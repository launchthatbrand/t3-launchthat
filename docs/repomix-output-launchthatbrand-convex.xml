This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    convex_rules.mdc
    convex-payloadcms.mdc
    cursor-rules-location.mdc
.generated/
  convexadmin.config.ts
  convexadmin.importMap.ts
app/
  (backend)/
    admin/
      [[...segments]]/
        not-found.tsx
        page.tsx
    layout.tsx
  (frontend)/
    [[...segments]]/
      not-found.tsx
      page.tsx
  server/
    inner.tsx
    page.tsx
  globals.css
  layout.tsx
components/
  frontend/
    views/
      GenericCollectionListPage.tsx
      PlaceholderView.tsx
    FrontendPuckEditor.tsx
  ConvexClientProvider.tsx
  FrontendRootPage.tsx
  Todo.tsx
convex/
  _generated/
    api.d.ts
    api.js
    dataModel.d.ts
    server.d.ts
    server.js
  auth.config.ts
  documents.ts
  myFunctions.ts
  plugins.ts
  posts.ts
  puckPages.ts
  README.md
  schema.ts
  todos.ts
  tsconfig.json
convexadmin/
  admin/
    src/
      collections/
        config/
          build.ts
          client.ts
          defaults.ts
          reservedFieldNames.spec.ts
          reservedFieldNames.ts
          sanitize.ts
          sanitizeCompoundIndexes.ts
          types.ts
          useAsTitle.spec.ts
          useAsTitle.ts
        endpoints/
          count.ts
          create.ts
          delete.ts
          deleteByID.ts
          docAccess.ts
          duplicate.ts
          find.ts
          findByID.ts
          findVersionByID.ts
          findVersions.ts
          index.ts
          preview.ts
          restoreVersion.ts
          update.ts
          updateByID.ts
        operations/
          local/
            count.ts
            countVersions.ts
            create.ts
            delete.ts
            duplicate.ts
            find.ts
            findByID.ts
            findVersionByID.ts
            findVersions.ts
            index.ts
            restoreVersion.ts
            update.ts
          utilities/
            update.ts
          count.ts
          countVersions.ts
          create.ts
          delete.ts
          deleteByID.ts
          docAccess.ts
          duplicate.ts
          find.ts
          findByID.ts
          findVersionByID.ts
          findVersions.ts
          restoreVersion.ts
          update.ts
          updateByID.ts
          utils.ts
        dataloader.ts
      components/
        data-table/
          data-table-column-header.tsx
          data-table-pagination.tsx
          data-table-row-actions.tsx
          data-table-view-options.tsx
        elements/
          RenderServerComponent.tsx
        puck/
          fields/
            ColumnConfigField.tsx
            SliderField.tsx
          HeadingBlock.tsx
          ItemLoop.tsx
        ui/
          accordion.tsx
          alert-dialog.tsx
          alert.tsx
          aspect-ratio.tsx
          avatar.tsx
          badge.tsx
          breadcrumb.tsx
          button.tsx
          calendar.tsx
          card.tsx
          carousel.tsx
          chart.tsx
          checkbox.tsx
          collapsible.tsx
          command.tsx
          context-menu.tsx
          dialog.tsx
          drawer.tsx
          dropdown-menu.tsx
          form.tsx
          hover-card.tsx
          input-otp.tsx
          input.tsx
          label.tsx
          menubar.tsx
          navigation-menu.tsx
          pagination.tsx
          popover.tsx
          progress.tsx
          radio-group.tsx
          resizable.tsx
          scroll-area.tsx
          select.tsx
          separator.tsx
          sheet.tsx
          sidebar.tsx
          skeleton.tsx
          slider.tsx
          sonner.tsx
          switch.tsx
          table.tsx
          tabs.tsx
          textarea.tsx
          toggle-group.tsx
          toggle.tsx
          tooltip.tsx
        views/
          CollectionSettingsPage.tsx
          DashboardView.tsx
          EditView.tsx
          ListView.tsx
          NotFoundView.tsx
        AdminProvider.tsx
        ConvexAdminProvider.tsx
        DebugPanel.tsx
        RootLayout.tsx
        RootPage.tsx
        TestGround.tsx
      fields/
        CheckboxField.tsx
        NumberField.tsx
        TextField.tsx
        UnknownField.tsx
      hooks/
        use-mobile.ts
      lib/
        formatDocTitle.ts
        getViewFromConfig.ts
        utils.ts
      preferences/
        operations/
          delete.ts
          findOne.ts
          update.ts
        requestHandlers/
          delete.ts
          findOne.ts
          update.ts
        config.ts
        deleteUserPreferences.ts
        types.ts
      templates/
        Default/
          NavHamburger/
            index.tsx
          Wrapper/
            index.tsx
          index.tsx
        MinimalTemplate.tsx
      utilities/
        formatAdminURL.ts
        getClientConfig.ts
        initPage.ts
  scripts/
    generate-admin.ts
  ui/
    src/
      elements/
        DocumentFields/
          index.scss
          index.tsx
        Gutter/
          index.tsx
        Nav/
          NavToggler/
            index.scss
            index.tsx
          context.tsx
        RenderIfInViewport/
          index.tsx
        AppSidebar.tsx
        version-switcher.tsx
      fields/
        Checkbox/
          index.tsx
        Number/
          index.tsx
        Select/
          index.tsx
        Text/
          index.tsx
      forms/
        fieldSchemasToFormState/
          calculateDefaultValues/
            index.ts
            iterateFields.ts
            promise.ts
          addFieldStatePromise.ts
          fieldSchemasToFormState.spec.js
          index.tsx
          iterateFields.ts
          renderField.tsx
          types.ts
        Form/
          context.ts
          createNestedClientFieldPath.ts
          errorMessages.ts
          fieldReducer.ts
          index.scss
          index.tsx
          initContextState.ts
          mergeErrorPaths.ts
          mergeServerFormState.ts
          reduceToSerializableFields.ts
          rowHelpers.ts
          rows.ts
          types.ts
        NullifyField/
          index.tsx
        RenderFields/
          index.scss
          index.tsx
          RenderField.tsx
          types.ts
        RowLabel/
          Context/
            index.tsx
          index.tsx
          types.ts
        Submit/
          index.scss
          index.tsx
        useField/
          index.tsx
          types.ts
        WatchChildErrors/
          buildPathSegments.ts
          index.tsx
        withCondition/
          index.tsx
          WatchCondition.tsx
      hooks/
        useIntersect.ts
      providers/
        Auth/
          index.tsx
        Config/
          index.tsx
        DocumentInfo/
          index.tsx
          types.ts
          useGetDocPermissions.ts
          useGetDocPermissions.tsx
        Locale/
          index.tsx
        Operation/
          index.tsx
        Preferences/
          index.tsx
        Translation/
          index.tsx
        UploadEdits/
          index.tsx
        NavProvider.tsx
      utilities/
        formatDocTitle/
          index.ts
        api.ts
        deepMerge.ts
        fieldIsHiddenOrDisabled.ts
        fieldIsSidebar.ts
        getFieldPaths.ts
        getFieldPermissions.ts
  constants.ts
  puck.config.tsx
  types.ts
docs/
  convex_native_payload_inspired.md
  repomix-output-payloadcms-payload.xml
  repomix-output-payloadcms-ui.xml
  repomix-output-t3-oss-create-t3-turbo.xml
lib/
  frontend/
    getFrontendViewComponent.ts
public/
  .generated/
    admin-config.json
  convex.svg
.gitignore
.prettierrc
components.json
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/convex_rules.mdc">
---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: **/*.{ts,tsx,js,jsx}
---

# Convex guidelines
## Function guidelines
### New function syntax
- ALWAYS use the new function syntax for Convex functions. For example:
      ```typescript
      import { query } from "./_generated/server";
      import { v } from "convex/values";
      export const f = query({
          args: {},
          returns: v.null(),
          handler: async (ctx, args) => {
          // Function body
          },
      });
      ```

### Http endpoint syntax
- HTTP endpoints are defined in `convex/http.ts` and require an `httpAction` decorator. For example:
      ```typescript
      import { httpRouter } from "convex/server";
      import { httpAction } from "./_generated/server";
      const http = httpRouter();
      http.route({
          path: "/echo",
          method: "POST",
          handler: httpAction(async (ctx, req) => {
          const body = await req.bytes();
          return new Response(body, { status: 200 });
          }),
      });
      ```
- HTTP endpoints are always registered at the exact path you specify in the `path` field. For example, if you specify `/api/someRoute`, the endpoint will be registered at `/api/someRoute`.

### Validators
- Below is an example of an array validator:
                            ```typescript
                            import { mutation } from "./_generated/server";
                            import { v } from "convex/values";

                            export default mutation({
                            args: {
                                simpleArray: v.array(v.union(v.string(), v.number())),
                            },
                            handler: async (ctx, args) => {
                                //...
                            },
                            });
                            ```
- Below is an example of a schema with validators that codify a discriminated union type:
                            ```typescript
                            import { defineSchema, defineTable } from "convex/server";
                            import { v } from "convex/values";

                            export default defineSchema({
                                results: defineTable(
                                    v.union(
                                        v.object({
                                            kind: v.literal("error"),
                                            errorMessage: v.string(),
                                        }),
                                        v.object({
                                            kind: v.literal("success"),
                                            value: v.number(),
                                        }),
                                    ),
                                )
                            });
                            ```
- Always use the `v.null()` validator when returning a null value. Below is an example query that returns a null value:
                                  ```typescript
                                  import { query } from "./_generated/server";
                                  import { v } from "convex/values";

                                  export const exampleQuery = query({
                                    args: {},
                                    returns: v.null(),
                                    handler: async (ctx, args) => {
                                        console.log("This query returns a null value");
                                        return null;
                                    },
                                  });
                                  ```

### Function registration
- Use `internalQuery`, `internalMutation`, and `internalAction` to register internal functions. These functions are private and aren't part of an app's API. They can only be called by other Convex functions. These functions are always imported from `./_generated/server`.
- Use `query`, `mutation`, and `action` to register public functions. These functions are part of the public API and are exposed to the public Internet. Do NOT use `query`, `mutation`, or `action` to register sensitive internal functions that should be kept private.
- You CANNOT register a function through the `api` or `internal` objects.
- ALWAYS include argument and return validators for all Convex functions. This includes all of `query`, `internalQuery`, `mutation`, `internalMutation`, `action`, and `internalAction`. If a function doesn't return anything, include `returns: v.null()` as its output validator.
- If the JavaScript implementation of a Convex function doesn't have a return value, it implicitly returns `null`.

### Function calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action.
- Use `ctx.runMutation` to call a mutation from a mutation or action.
- Use `ctx.runAction` to call an action from an action.
- ONLY call an action from another action if you need to cross runtimes (e.g. from V8 to Node). Otherwise, pull out the shared code into a helper async function and call that directly instead.
- Try to use as few calls from actions to queries and mutations as possible. Queries and mutations are transactions, so splitting logic up into multiple calls introduces the risk of race conditions.
- All of these calls take in a `FunctionReference`. Do NOT try to pass the callee function directly into one of these calls.
- When using `ctx.runQuery`, `ctx.runMutation`, or `ctx.runAction` to call a function in the same file, specify a type annotation on the return value to work around TypeScript circularity limitations. For example,
                            ```
                            export const f = query({
                              args: { name: v.string() },
                              returns: v.string(),
                              handler: async (ctx, args) => {
                                return "Hello " + args.name;
                              },
                            });

                            export const g = query({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                const result: string = await ctx.runQuery(api.example.f, { name: "Bob" });
                                return null;
                              },
                            });
                            ```

### Function references
- Function references are pointers to registered Convex functions.
- Use the `api` object defined by the framework in `convex/_generated/api.ts` to call public functions registered with `query`, `mutation`, or `action`.
- Use the `internal` object defined by the framework in `convex/_generated/api.ts` to call internal (or private) functions registered with `internalQuery`, `internalMutation`, or `internalAction`.
- Convex uses file-based routing, so a public function defined in `convex/example.ts` named `f` has a function reference of `api.example.f`.
- A private function defined in `convex/example.ts` named `g` has a function reference of `internal.example.g`.
- Functions can also registered within directories nested within the `convex/` folder. For example, a public function `h` defined in `convex/messages/access.ts` has a function reference of `api.messages.access.h`.

### Api design
- Convex uses file-based routing, so thoughtfully organize files with public query, mutation, or action functions within the `convex/` directory.
- Use `query`, `mutation`, and `action` to define public functions.
- Use `internalQuery`, `internalMutation`, and `internalAction` to define private, internal functions.

### Pagination
- Paginated queries are queries that return a list of results in incremental pages.
- You can define pagination using the following syntax:

                            ```ts
                            import { v } from "convex/values";
                            import { query, mutation } from "./_generated/server";
                            import { paginationOptsValidator } from "convex/server";
                            export const listWithExtraArg = query({
                                args: { paginationOpts: paginationOptsValidator, author: v.string() },
                                handler: async (ctx, args) => {
                                    return await ctx.db
                                    .query("messages")
                                    .filter((q) => q.eq(q.field("author"), args.author))
                                    .order("desc")
                                    .paginate(args.paginationOpts);
                                },
                            });
                            ```
- A query that ends in `.paginate()` returns an object that has the following properties:
                            - page (contains an array of documents that you fetches)
                            - isDone (a boolean that represents whether or not this is the last page of documents)
                            - continueCursor (a string that represents the cursor to use to fetch the next page of documents)


## Validator guidelines
- `v.bigint()` is deprecated for representing signed 64-bit integers. Use `v.int64()` instead.
- Use `v.record()` for defining a record type. `v.map()` and `v.set()` are not supported.

## Schema guidelines
- Always define your schema in `convex/schema.ts`.
- Always import the schema definition functions from `convex/server`:
- System fields are automatically added to all documents and are prefixed with an underscore.
- Always include all index fields in the index name. For example, if an index is defined as `["field1", "field2"]`, the index name should be "by_field1_and_field2".
- Index fields must be queried in the same order they are defined. If you want to be able to query by "field1" then "field2" and by "field2" then "field1", you must create separate indexes.

## Typescript guidelines
- You can use the helper typescript type `Id` imported from './_generated/dataModel' to get the type of the id for a given table. For example if there is a table called 'users' you can use `Id<'users'>` to get the type of the id for that table.
- If you need to define a `Record` make sure that you correctly provide the type of the key and value in the type. For example a validator `v.record(v.id('users'), v.string())` would have the type `Record<Id<'users'>, string>`. Below is an example of using `Record` with an `Id` type in a query:
                    ```ts
                    import { query } from "./_generated/server";
                    import { Doc, Id } from "./_generated/dataModel";

                    export const exampleQuery = query({
                        args: { userIds: v.array(v.id("users")) },
                        returns: v.record(v.id("users"), v.string()),
                        handler: async (ctx, args) => {
                            const idToUsername: Record<Id<"users">, string> = {};
                            for (const userId of args.userIds) {
                                const user = await ctx.db.get(userId);
                                if (user) {
                                    users[user._id] = user.username;
                                }
                            }

                            return idToUsername;
                        },
                    });
                    ```
- Be strict with types, particularly around id's of documents. For example, if a function takes in an id for a document in the 'users' table, take in `Id<'users'>` rather than `string`.
- Always use `as const` for string literals in discriminated union types.
- When using the `Array` type, make sure to always define your arrays as `const array: Array<T> = [...];`
- When using the `Record` type, make sure to always define your records as `const record: Record<KeyType, ValueType> = {...};`
- Always add `@types/node` to your `package.json` when using any Node.js built-in modules.

## Full text search guidelines
- A query for "10 messages in channel '#general' that best match the query 'hello hi' in their body" would look like:

const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general"),
  )
  .take(10);

## Query guidelines
- Do NOT use `filter` in queries. Instead, define an index in the schema and use `withIndex` instead.
- Convex queries do NOT support `.delete()`. Instead, `.collect()` the results, iterate over them, and call `ctx.db.delete(row._id)` on each result.
- Use `.unique()` to get a single document from a query. This method will throw an error if there are multiple documents that match the query.
- When using async iteration, don't use `.collect()` or `.take(n)` on the result of a query. Instead, use the `for await (const row of query)` syntax.
### Ordering
- By default Convex always returns documents in ascending `_creationTime` order.
- You can use `.order('asc')` or `.order('desc')` to pick whether a query is in ascending or descending order. If the order isn't specified, it defaults to ascending.
- Document queries that use indexes will be ordered based on the columns in the index and can avoid slow table scans.


## Mutation guidelines
- Use `ctx.db.replace` to fully replace an existing document. This method will throw an error if the document does not exist.
- Use `ctx.db.patch` to shallow merge updates into an existing document. This method will throw an error if the document does not exist.

## Action guidelines
- Always add `"use node";` to the top of files containing actions that use Node.js built-in modules.
- Never use `ctx.db` inside of an action. Actions don't have access to the database.
- Below is an example of the syntax for an action:
                    ```ts
                    import { action } from "./_generated/server";

                    export const exampleAction = action({
                        args: {},
                        returns: v.null(),
                        handler: async (ctx, args) => {
                            console.log("This action does not return anything");
                            return null;
                        },
                    });
                    ```

## Scheduling guidelines
### Cron guidelines
- Only use the `crons.interval` or `crons.cron` methods to schedule cron jobs. Do NOT use the `crons.hourly`, `crons.daily`, or `crons.weekly` helpers.
- Both cron methods take in a FunctionReference. Do NOT try to pass the function directly into one of these methods.
- Define crons by declaring the top-level `crons` object, calling some methods on it, and then exporting it as default. For example,
                            ```ts
                            import { cronJobs } from "convex/server";
                            import { internal } from "./_generated/api";
                            import { internalAction } from "./_generated/server";

                            const empty = internalAction({
                              args: {},
                              returns: v.null(),
                              handler: async (ctx, args) => {
                                console.log("empty");
                              },
                            });

                            const crons = cronJobs();

                            // Run `internal.crons.empty` every two hours.
                            crons.interval("delete inactive users", { hours: 2 }, internal.crons.empty, {});

                            export default crons;
                            ```
- You can register Convex functions within `crons.ts` just like any other file.
- If a cron calls an internal function, always import the `internal` object from '_generated/api`, even if the internal function is registered in the same file.


## File storage guidelines
- Convex includes file storage for large files like images, videos, and PDFs.
- The `ctx.storage.getUrl()` method returns a signed URL for a given file. It returns `null` if the file doesn't exist.
- Do NOT use the deprecated `ctx.storage.getMetadata` call for loading a file's metadata.

                    Instead, query the `_storage` system table. For example, you can use `ctx.db.system.get` to get an `Id<"_storage">`.
                    ```
                    import { query } from "./_generated/server";
                    import { Id } from "./_generated/dataModel";

                    type FileMetadata = {
                        _id: Id<"_storage">;
                        _creationTime: number;
                        contentType?: string;
                        sha256: string;
                        size: number;
                    }

                    export const exampleQuery = query({
                        args: { fileId: v.id("_storage") },
                        returns: v.null();
                        handler: async (ctx, args) => {
                            const metadata: FileMetadata | null = await ctx.db.system.get(args.fileId);
                            console.log(metadata);
                            return null;
                        },
                    });
                    ```
- Convex storage stores items as `Blob` objects. You must convert all items to/from a `Blob` when using Convex storage.


# Examples:
## Example: chat-app

### Task
```
Create a real-time chat application backend with AI responses. The app should:
- Allow creating users with names
- Support multiple chat channels
- Enable users to send messages to channels
- Automatically generate AI responses to user messages
- Show recent message history

The backend should provide APIs for:
1. User management (creation)
2. Channel management (creation)
3. Message operations (sending, listing)
4. AI response generation using OpenAI's GPT-4

Messages should be stored with their channel, author, and content. The system should maintain message order
and limit history display to the 10 most recent messages per channel.

```

### Analysis
1. Task Requirements Summary:
- Build a real-time chat backend with AI integration
- Support user creation
- Enable channel-based conversations
- Store and retrieve messages with proper ordering
- Generate AI responses automatically

2. Main Components Needed:
- Database tables: users, channels, messages
- Public APIs for user/channel management
- Message handling functions
- Internal AI response generation system
- Context loading for AI responses

3. Public API and Internal Functions Design:
Public Mutations:
- createUser:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({userId: v.id("users")})
  - purpose: Create a new user with a given name
- createChannel:
  - file path: convex/index.ts
  - arguments: {name: v.string()}
  - returns: v.object({channelId: v.id("channels")})
  - purpose: Create a new channel with a given name
- sendMessage:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), authorId: v.id("users"), content: v.string()}
  - returns: v.null()
  - purpose: Send a message to a channel and schedule a response from the AI

Public Queries:
- listMessages:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
    }))
  - purpose: List the 10 most recent messages from a channel in descending creation order

Internal Functions:
- generateResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.null()
  - purpose: Generate a response from the AI for a given channel
- loadContext:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels")}
  - returns: v.array(v.object({
    _id: v.id("messages"),
    _creationTime: v.number(),
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }))
- writeAgentResponse:
  - file path: convex/index.ts
  - arguments: {channelId: v.id("channels"), content: v.string()}
  - returns: v.null()
  - purpose: Write an AI response to a given channel

4. Schema Design:
- users
  - validator: { name: v.string() }
  - indexes: <none>
- channels
  - validator: { name: v.string() }
  - indexes: <none>
- messages
  - validator: { channelId: v.id("channels"), authorId: v.optional(v.id("users")), content: v.string() }
  - indexes
    - by_channel: ["channelId"]

5. Background Processing:
- AI response generation runs asynchronously after each user message
- Uses OpenAI's GPT-4 to generate contextual responses
- Maintains conversation context using recent message history


### Implementation

#### package.json
```typescript
{
  "name": "chat-app",
  "description": "This example shows how to build a chat app without authentication.",
  "version": "1.0.0",
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0"
  },
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}
```

#### tsconfig.json
```typescript
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "exclude": ["convex"],
  "include": ["**/src/**/*.tsx", "**/src/**/*.ts", "vite.config.ts"]
}
```

#### convex/index.ts
```typescript
import {
  query,
  mutation,
  internalQuery,
  internalMutation,
  internalAction,
} from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { internal } from "./_generated/api";

/**
 * Create a user with a given name.
 */
export const createUser = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("users", { name: args.name });
  },
});

/**
 * Create a channel with a given name.
 */
export const createChannel = mutation({
  args: {
    name: v.string(),
  },
  returns: v.id("channels"),
  handler: async (ctx, args) => {
    return await ctx.db.insert("channels", { name: args.name });
  },
});

/**
 * List the 10 most recent messages from a channel in descending creation order.
 */
export const listMessages = query({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      _id: v.id("messages"),
      _creationTime: v.number(),
      channelId: v.id("channels"),
      authorId: v.optional(v.id("users")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);
    return messages;
  },
});

/**
 * Send a message to a channel and schedule a response from the AI.
 */
export const sendMessage = mutation({
  args: {
    channelId: v.id("channels"),
    authorId: v.id("users"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const user = await ctx.db.get(args.authorId);
    if (!user) {
      throw new Error("User not found");
    }
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      authorId: args.authorId,
      content: args.content,
    });
    await ctx.scheduler.runAfter(0, internal.index.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

export const generateResponse = internalAction({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.index.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("No content in response");
    }
    await ctx.runMutation(internal.index.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = internalQuery({
  args: {
    channelId: v.id("channels"),
  },
  returns: v.array(
    v.object({
      role: v.union(v.literal("user"), v.literal("assistant")),
      content: v.string(),
    }),
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.db.get(args.channelId);
    if (!channel) {
      throw new Error("Channel not found");
    }
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_channel", (q) => q.eq("channelId", args.channelId))
      .order("desc")
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.db.get(message.authorId);
        if (!user) {
          throw new Error("User not found");
        }
        result.push({
          role: "user" as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: "assistant" as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = internalMutation({
  args: {
    channelId: v.id("channels"),
    content: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.insert("messages", {
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

#### convex/schema.ts
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  channels: defineTable({
    name: v.string(),
  }),

  users: defineTable({
    name: v.string(),
  }),

  messages: defineTable({
    channelId: v.id("channels"),
    authorId: v.optional(v.id("users")),
    content: v.string(),
  }).index("by_channel", ["channelId"]),
});
```

#### src/App.tsx
```typescript
export default function App() {
  return <div>Hello World</div>;
}
```
</file>

<file path=".cursor/rules/convex-payloadcms.mdc">
---
description: 
globs: 
alwaysApply: true
---
# ConvexAdmin Payload CMS Copy-Adapt Strategy

This rule guides the development of the `convexadmin` system by **copying relevant source files** from Payload CMS (`docs/payloadpackages/`) and **adapting them** to run natively on Convex, replacing Payload's backend dependencies with Convex features.

<rule>
  name: convexadmin_payload_copy_adapt
  description: Ensures development follows a copy-then-adapt pattern based on Payload CMS source code.

  metadata:
    version: 1.1
    priority: critical
    payload_source_reference: "docs/payloadpackages/" 

  guidelines:
    - section: "Core Principle: Copy, Then Adapt"
      description: |
        1.  **Identify:** Find the corresponding file(s) in `docs/payloadpackages/` (primarily `payload`, `ui`, `next`) that implement the desired functionality (e.g., `RootPage`, `ListView`, `TextField`).
        2.  **Copy:** Copy the identified file(s) into the analogous location within `convexadmin/` (e.g., `packages/next/src/views/Root/index.tsx` -> `convexadmin/components/RootPage.tsx`).
        3.  **Adapt:** Modify the copied file(s) according to the guidelines below.

    - section: "Adaptation Steps"
      description: |
        When adapting a copied Payload file:
        - **Imports:** Update import paths to match the `convexadmin` structure (`@/convexadmin/...`, relative paths). Remove imports related to Payload core (`payload`), internal utilities, or specific framework features not used (e.g., Payload's server functions if not applicable).
        - **Data Fetching:** Locate and REMOVE Payload's data fetching logic (e.g., usage of `initPageResult`, `req.payload.find`, `req.payload.update`). REPLACE with Convex hooks (`useQuery`, `useMutation`) calling functions defined in `convex/`. Data fetching MUST happen within client components (views, fields).
        - **Configuration:** Replace usage of Payload's dynamically processed `config` object with imports of our statically generated `config` from `@/generated/convexadmin.config`. Adjust logic to read from our simplified config structure.
        - **Component Mapping:** Replace Payload's dynamic component resolution via its internal `importMap` and helpers like `RenderServerComponent` or `getViewFromConfig` with our simplified versions: Use our `getViewFromConfig` (`convexadmin/lib/getViewFromConfig.ts`) which leverages our generated `importMap` (`@/generated/convexadmin.importMap.ts`) to select components from `convexadmin/components/views` and `convexadmin/components/fields`.
        - **Types:** Replace Payload-specific types (`SanitizedConfig`, `CollectionConfig`, `Field`, etc.) with our types from `convexadmin/types.ts` and Convex types (`Doc`, `Id`).
        - **Authentication/Access Control:** Remove Payload's built-in auth/access control checks tied to `req.user` or `req.payload.auth`. Implement checks using Convex `ctx.auth` within Convex functions or client-side checks based on `useConvexAuth()` or Clerk's hooks if applicable.
        - **UI/Styling:** Initially, retain the JSX structure. Adapt styling by replacing SCSS/CSS module patterns with Tailwind CSS classes. Remove Payload UI library components (`@payloadcms/ui`) that don't have direct `convexadmin` equivalents yet, potentially replacing them with Shadcn UI or simple elements.
        - **Server/Client Boundary:** Respect Next.js App Router conventions. Copied components might need explicit `"use client";` directives if they use hooks or event handlers. Server-only logic from Payload files needs to be moved to Convex functions or Next.js Server Components/Actions if appropriate.

    - section: "Payload Package Structure Analogy (Reference for Copying)"
      description: |
        Use this mapping to find source files in `docs/payloadpackages/`:
        1.  **Core Logic (`payload`):** Reference for understanding Payload's data structures, validation, hooks, but DO NOT copy backend logic files directly. Our backend is `convex/`.
        2.  **UI Components (`@payloadcms/ui`):** Copy candidates for `convexadmin/components/views/`, `convexadmin/components/fields/`, and shared UI elements. Requires significant adaptation for data fetching and styling.
        3.  **Next.js Integration (`@payloadcms/next`):** Copy candidates for `app/(backend)/admin/[[...segments]]/page.tsx`, `app/(backend)/layout.tsx`, `convexadmin/components/RootLayout.tsx`, `convexadmin/components/RootPage.tsx`, and potentially helpers like `getViewFromConfig`. Requires adapting routing, config/importMap usage, and data pre-fetching removal.

    - section: "ConvexAdmin Target Structure"
      description: |
        - **Config Generation:** `convexadmin/scripts/generate-admin.ts` -> `.generated/convexadmin.config.ts`, `.generated/convexadmin.importMap.ts`.
        - **Core Views/Layout:** `convexadmin/components/RootLayout.tsx`, `convexadmin/components/RootPage.tsx`.
        - **View Logic Helper:** `convexadmin/lib/getViewFromConfig.ts`.
        - **Generic Views:** `convexadmin/components/views/` (e.g., `ListView.tsx`, `EditView.tsx`).
        - **Generic Fields:** `convexadmin/components/fields/` (e.g., `TextField.tsx`, `CheckboxField.tsx`).
        - **Types:** `convexadmin/types.ts`.
        - **Constants:** `convexadmin/constants.ts`.
        - **Next.js Entry Points:** `app/(backend)/layout.tsx`, `app/(backend)/admin/[[...segments]]/page.tsx`.

    - section: "Key Differences - DO NOT COPY"
      description: |
        - Payload's internal API layer and data fetching utilities (`req.payload...`, `initPage`).
        - Payload's complex config processing logic.
        - Payload-specific React context providers (unless consciously replicated).
        - Server-side rendering logic deeply tied to Payload's backend.

</rule>
</file>

<file path=".cursor/rules/cursor-rules-location.mdc">
---
description: 
globs: 
alwaysApply: true
---
---
description: Cursor Rules Location
globs: *.mdc
---
# Cursor Rules Location

Rules for placing and organizing Cursor rule files in the repository.

<rule>
name: cursor_rules_location
description: Standards for placing Cursor rule files in the correct directory
filters:
  # Match any .mdc files
  - type: file_extension
    pattern: "\\.mdc$"
  # Match files that look like Cursor rules
  - type: content
    pattern: "(?s)<rule>.*?</rule>"
  # Match file creation events
  - type: event
    pattern: "file_create"

actions:
  - type: reject
    conditions:
      - pattern: "^(?!\\.\\/\\.cursor\\/rules\\/.*\\.mdc$)"
        message: "Cursor rule files (.mdc) must be placed in the .cursor/rules directory"

  - type: suggest
    message: |
      When creating Cursor rules:

      1. Always place rule files in PROJECT_ROOT/.cursor/rules/:
         ```
         .cursor/rules/
         ├── your-rule-name.mdc
         ├── another-rule.mdc
         └── ...
         ```

      2. Follow the naming convention:
         - Use kebab-case for filenames
         - Always use .mdc extension
         - Make names descriptive of the rule's purpose

      3. Directory structure:
         ```
         PROJECT_ROOT/
         ├── .cursor/
         │   └── rules/
         │       ├── your-rule-name.mdc
         │       └── ...
         └── ...
         ```

      4. Never place rule files:
         - In the project root
         - In subdirectories outside .cursor/rules
         - In any other location

examples:
  - input: |
      # Bad: Rule file in wrong location
      rules/my-rule.mdc
      my-rule.mdc
      .rules/my-rule.mdc

      # Good: Rule file in correct location
      .cursor/rules/my-rule.mdc
    output: "Correctly placed Cursor rule file"

metadata:
  priority: high
  version: 1.0
</rule>
</file>

<file path=".generated/convexadmin.config.ts">
// This file is generated automatically. Do not edit.
/* eslint-disable */
import type { AdminConfig } from "@/convexadmin/types";

export const config: AdminConfig = {
  collections: {
    todos: {
      label: "Todos",
      pluralLabel: "Todos",
      fields: {
        text: {
          label: "Text",
          type: "string",
        },
        isCompleted: {
          label: "Is Completed",
          type: "boolean",
        },
        createdAt: {
          label: "Created At",
          type: "number",
        },
        updatedAt: {
          label: "Updated At",
          type: "number",
        },
      },
    },
    posts: {
      label: "Posts",
      pluralLabel: "Posts",
      fields: {
        title: {
          label: "Title",
          type: "string",
        },
        description: {
          label: "Description",
          type: "string",
        },
      },
    },
    plugins: {
      label: "Plugins",
      pluralLabel: "Plugins",
      fields: {
        title: {
          label: "Title",
          type: "string",
        },
        description: {
          label: "Description",
          type: "string",
        },
      },
    },
    puckPages: {
      label: "Puck Pages",
      pluralLabel: "Puck Pages",
      fields: {
        identifier: {
          label: "Identifier",
          type: "string",
        },
        puckData: {
          label: "Puck Data",
          type: "unknown",
        },
      },
    },
  },
};
</file>

<file path=".generated/convexadmin.importMap.ts">
// This file is generated automatically. Do not edit.
/* eslint-disable */

import { CheckboxField } from "@/convexadmin/fields/CheckboxField";
import { CollectionSettingsPage } from "@/convexadmin/components/views/CollectionSettingsPage";
// View Imports
import { DashboardView } from "@/convexadmin/components/views/DashboardView";
import { EditView } from "@/convexadmin/components/views/EditView";
import { ListView } from "@/convexadmin/components/views/ListView";
import { NotFoundView } from "@/convexadmin/components/views/NotFoundView";
import { NumberField } from "@/convexadmin/fields/NumberField";
// Field Imports
import { TextField } from "@/convexadmin/fields/TextField";
import { UnknownField } from "@/convexadmin/fields/UnknownField";

export const importMap = {
  views: {
    Dashboard: DashboardView,
    CollectionList: ListView,
    CollectionEdit: EditView,
    CollectionCreate: EditView,
    CollectionSettings: CollectionSettingsPage,
    NotFound: NotFoundView,
  },
  fields: {
    string: TextField,
    boolean: CheckboxField,
    number: NumberField,
    unknown: UnknownField,
  },
};
</file>

<file path="app/(backend)/admin/[[...segments]]/not-found.tsx">
/* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
/* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
import React from "react";

// A simple Not Found component for the admin section
export default function AdminNotFound() {
  return (
    <div className="p-4 text-center">
      <h1 className="text-2xl font-bold mb-4">Not Found</h1>
      <p>The admin resource you requested could not be found.</p>
      {/* Optionally, add a link back to the admin dashboard */}
      {/* <Link href="/admin">Go to Admin Dashboard</Link> */}
    </div>
  );
}
</file>

<file path="app/(backend)/admin/[[...segments]]/page.tsx">
import type { AdminConfig } from "@/convexadmin/types"; // Use our types
import { RootPage } from "@/convexadmin/components/RootPage"; // Use our RootPage
import { config } from "@/.generated/convexadmin.config"; // Use generated config
import { importMap } from "@/.generated/convexadmin.importMap"; // Use generated importMap
/* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
/* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */


// Define Args based on Next.js App Router (params are resolved, not promises)
// Keep searchParams structure similar if needed
type Args = {
  params: Promise<{
    segments: string[];
  }>;
  searchParams: Promise<{
    [key: string]: string | string[];
  }>;
};

// Call our RootPage, passing adapted props
const Page = ({ params, searchParams }: Args) =>
  RootPage({ config, params, searchParams, importMap });

export default Page;
</file>

<file path="app/(backend)/layout.tsx">
import "../globals.css";

import type { AdminConfig } from "@/convexadmin/types"; // Import type
import React from "react";
import { RootLayout } from "@/convexadmin/components/RootLayout"; // Import the new layout
import { config } from "@/.generated/convexadmin.config"; // Use the correct alias path

type Args = {
  children: React.ReactNode;
};

// This layout specifically wraps the admin section
const BackendLayout = ({ children }: Args) => {
  return (
    // Render RootLayout, passing the imported config
    <RootLayout config={config as AdminConfig | null}>
      {/* You might want a basic HTML structure here if not using RootLayout from Payload */}
      <div className="admin-layout-container flex-1">
        {/* Example: <AdminSidebar /> */}
        <main className="admin-main-content">{children}</main>
      </div>
    </RootLayout>
  );
};

export default BackendLayout;
</file>

<file path="app/(frontend)/[[...segments]]/not-found.tsx">
/* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
/* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
import React from "react";

// A simple Not Found component for the admin section
export default function AdminNotFound() {
  return (
    <div className="p-4 text-center">
      <h1 className="text-2xl font-bold mb-4">Not Found</h1>
      <p>The admin resource you requested could not be found.</p>
      {/* Optionally, add a link back to the admin dashboard */}
      {/* <Link href="/admin">Go to Admin Dashboard</Link> */}
    </div>
  );
}
</file>

<file path="app/(frontend)/[[...segments]]/page.tsx">
import { FrontendRootPage } from "@/components/FrontendRootPage";
import { config } from "@/.generated/convexadmin.config";

/* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
/* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */

// Define Args based on Next.js App Router
type Args = {
  params: {
    segments?: string[];
  };
  searchParams?: {
    [key: string]: string | string[];
  };
};

// Make Page async to handle potential async nature of params/searchParams
const Page = async ({ params, searchParams }: Args) => {
  // Resolve segments before passing to client component
  const resolvedSegments = params.segments || [];
  // Extract editor flag specifically on the server
  const isEditorMode = searchParams?.editor === "true";

  // Pass resolved segments and the specific editor flag
  return (
    <FrontendRootPage
      config={config}
      segments={resolvedSegments}
      isEditorMode={isEditorMode}
    />
  );
};

export default Page;
</file>

<file path="app/server/inner.tsx">
"use client";

import { Preloaded, useMutation, usePreloadedQuery } from "convex/react";
import { api } from "../../convex/_generated/api";

export default function Home({
  preloaded,
}: {
  preloaded: Preloaded<typeof api.myFunctions.listNumbers>;
}) {
  const data = usePreloadedQuery(preloaded);
  const addNumber = useMutation(api.myFunctions.addNumber);
  return (
    <>
      <div className="flex flex-col gap-4 bg-slate-200 dark:bg-slate-800 p-4 rounded-md">
        <h2 className="text-xl font-bold">Reactive client-loaded data</h2>
        <code>
          <pre>{JSON.stringify(data, null, 2)}</pre>
        </code>
      </div>
      <button
        className="bg-foreground text-background px-4 py-2 rounded-md mx-auto"
        onClick={() => {
          void addNumber({ value: Math.floor(Math.random() * 10) });
        }}
      >
        Add a random number
      </button>
    </>
  );
}
</file>

<file path="app/server/page.tsx">
import Home from "./inner";
import { preloadQuery, preloadedQueryResult } from "convex/nextjs";
import { api } from "@/convex/_generated/api";

export default async function ServerPage() {
  const preloaded = await preloadQuery(api.myFunctions.listNumbers, {
    count: 3,
  });

  const data = preloadedQueryResult(preloaded);

  return (
    <main className="p-8 flex flex-col gap-4 mx-auto max-w-2xl">
      <h1 className="text-4xl font-bold text-center">Convex + Next.js</h1>
      <div className="flex flex-col gap-4 bg-slate-200 dark:bg-slate-800 p-4 rounded-md">
        <h2 className="text-xl font-bold">Non-reactive server-loaded data</h2>
        <code>
          <pre>{JSON.stringify(data, null, 2)}</pre>
        </code>
      </div>
      <Home preloaded={preloaded} />
    </main>
  );
}
</file>

<file path="app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }

  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="app/layout.tsx">
import "./globals.css";

import { Geist, Geist_Mono } from "next/font/google";

import { ClerkProvider } from "@clerk/nextjs";
import ConvexClientProvider from "@/components/ConvexClientProvider";
import type { Metadata } from "next";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
  icons: {
    icon: "/convex.svg",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ClerkProvider dynamic>
          <ConvexClientProvider>{children}</ConvexClientProvider>
        </ClerkProvider>
      </body>
    </html>
  );
}
</file>

<file path="components/frontend/views/GenericCollectionListPage.tsx">
"use client";

import type { AdminCollectionConfig } from "@/convexadmin/types"; // Import the type we need for props
import type { FunctionReference } from "convex/server";
// import type { AdminCollectionConfig } from "@/convexadmin/types"; // Unused
import type { Id } from "@/convex/_generated/dataModel";
import React from "react";
import { api } from "@/convex/_generated/api";
// import { useConvexAdmin } from "@/convexadmin/components/ConvexAdminProvider";
import { useQuery } from "convex/react";
// import type { Doc } from "@/convex/_generated/dataModel"; // Unused

// Define a generic document type constraint for props
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type GenericDoc = { _id: Id<any>; title?: string } & Record<string, any>;

// Helper to get the list query function reference (similar to admin)
const getListQueryRef = (
  slug: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
): FunctionReference<"query", "public", any, GenericDoc[]> | null => {
  switch (slug) {
    // Add known collection slugs and their corresponding query functions
    case "todos":
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return api.todos.getTodos as any; // Cast to expected type if needed
    case "posts":
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return api.posts.getPosts as any;
    case "plugins":
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return api.plugins.getPlugins as any;
    default:
      console.error(`(Frontend) No list query mapped for slug: ${slug}`);
      return null;
  }
};

interface GenericCollectionListPageProps {
  collectionSlug: string;
  collectionConfig: AdminCollectionConfig; // Add collectionConfig to props
}

export const GenericCollectionListPage: React.FC<
  GenericCollectionListPageProps
> = ({ collectionSlug, collectionConfig }) => {
  // Destructure collectionConfig from props
  // Remove context hook call
  // const { config } = useConvexAdmin();
  // const collectionConfig = config.collections[collectionSlug]; // Already have collectionConfig from props

  const listQueryRef = getListQueryRef(collectionSlug);

  const documents = useQuery(listQueryRef!, listQueryRef ? {} : "skip");

  // This check might now be redundant if getFrontendViewComponent guarantees config exists,
  // but keeping it doesn't hurt.
  if (!collectionConfig) {
    return (
      <div>
        Error: Configuration not found for collection `{collectionSlug}`.
      </div>
    );
  }

  if (!listQueryRef) {
    return (
      <div>Error: List view query not configured for `{collectionSlug}`.</div>
    );
  }

  const titleField = "title"; // Assume a 'title' field for simplicity
  const descriptionField = "description"; // Assume a 'description' field

  return (
    <div>
      <h1 className="text-3xl font-bold mb-4">
        {collectionConfig.pluralLabel || collectionSlug} (Frontend)
      </h1>
      {documents === undefined && (
        <div>Loading {collectionConfig.pluralLabel}...</div>
      )}
      {documents && documents.length === 0 && (
        <div>No {collectionConfig.pluralLabel} found.</div>
      )}
      {documents && documents.length > 0 && (
        <ul className="list-disc pl-5 space-y-3">
          {documents.map((doc: GenericDoc) => (
            <li key={doc._id}>
              {/* Attempt to display title, fallback to ID */}
              <h2 className="text-xl font-semibold">
                {doc[titleField] ? String(doc[titleField]) : doc._id}
              </h2>
              {/* Display description if it exists */}
              {doc[descriptionField] && <p>{String(doc[descriptionField])}</p>}
              {/* TODO: Link to detail page? */}
              {/* <Link href={`/${collectionSlug}/${doc._id}`}>View</Link> */}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
</file>

<file path="components/frontend/views/PlaceholderView.tsx">
import React from "react";

// Simple placeholder view for frontend routes
interface PlaceholderViewProps {
  segments?: string[];
  searchParams?: { [key: string]: string | string[] };
  message?: string;
}

export const PlaceholderView: React.FC<PlaceholderViewProps> = ({
  segments,
  searchParams,
  message = "Placeholder View",
}) => {
  return (
    <div
      style={{
        border: "2px dashed #ccc",
        padding: "2rem",
        borderRadius: "8px",
        backgroundColor: "#f9f9f9",
      }}
    >
      <h2>{message}</h2>
      <pre>Segments: {JSON.stringify(segments, null, 2)}</pre>
      <pre>Search Params: {JSON.stringify(searchParams, null, 2)}</pre>
    </div>
  );
};
</file>

<file path="components/frontend/FrontendPuckEditor.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { Puck, type Data } from "@measured/puck";
import { puckConfig } from "@/convexadmin/puck.config"; // Use the same config for now
import { DocumentInfoProvider } from "@/convexui/src/providers/DocumentInfo"; // Import the provider
import { useMutation, useQuery } from "convex/react"; // Import useMutation and useQuery
import { api } from "@/convex/_generated/api"; // Import api
import "@measured/puck/puck.css";

// Actual frontend Puck editor wrapper
interface FrontendPuckEditorProps {
  collectionSlug: string;
  // Add other props later, like the initial data source ID
  // initialData?: Data | null;
}

const defaultPuckData: Data = { content: [], root: {} };

export const FrontendPuckEditor: React.FC<FrontendPuckEditorProps> = ({
  collectionSlug,
  // initialData: initialDataProp // Receive initial data if passed
}) => {
  // Fetch existing Puck data for this identifier
  const existingPuckData = useQuery(
    api.puckPages.getPuckPage,
    collectionSlug ? { identifier: collectionSlug } : "skip",
  );

  // State for the editor's data, initialized empty
  const [initialData, setInitialData] = useState<Data>(defaultPuckData);
  const [isLoading, setIsLoading] = useState<boolean>(true); // Add loading state

  // Effect to update initialData once the query resolves
  useEffect(() => {
    if (existingPuckData !== undefined) {
      // Query has finished
      if (existingPuckData && existingPuckData.puckData) {
        // Found existing data, use it
        // We need to assert the type here as well
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setInitialData(existingPuckData.puckData as any);
      } else {
        // No existing data found, use default empty state
        setInitialData(defaultPuckData);
      }
      setIsLoading(false); // Set loading to false
    }
    // Dependency array includes the query result
  }, [existingPuckData]);

  // Get the mutation function
  const savePuckPage = useMutation(api.puckPages.savePuckPage);

  // Define the publish handler using the mutation
  const handlePublish = React.useCallback(
    async (data: Data) => {
      console.log(
        `Publishing Puck data for identifier: ${collectionSlug}`,
        JSON.stringify(data, null, 2),
      );
      try {
        await savePuckPage({ identifier: collectionSlug, puckData: data });
        alert(`Saved page structure for ${collectionSlug}.`);
        // Update local state immediately on successful save
        setInitialData(data);
      } catch (error) {
        console.error("Failed to save Puck page:", error);
        const message =
          error instanceof Error ? error.message : "Unknown error";
        alert(`Error saving page structure: ${message}`);
      }
    },
    [collectionSlug, savePuckPage],
  );

  // Show loading indicator while fetching data
  if (isLoading) {
    return <div className="p-8 text-center">Loading editor content...</div>;
  }

  // Render the Puck editor, wrapped in the provider
  return (
    <DocumentInfoProvider collectionSlug={collectionSlug}>
      <Puck
        config={puckConfig}
        data={initialData} // Use state for data
        onPublish={handlePublish} // Use the mutation handler
        // You might want to customize the header/UI further later
        // headerPath={`/${collectionSlug}`}
        // renderHeader={...}
      />
    </DocumentInfoProvider>
  );
};
</file>

<file path="components/ConvexClientProvider.tsx">
"use client";

import { ReactNode } from "react";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { useAuth } from "@clerk/nextjs";
const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export default function ConvexClientProvider({
  children,
}: {
  children: ReactNode;
}) {
  return (
    <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
      {children}
    </ConvexProviderWithClerk>
  );
}
</file>

<file path="components/FrontendRootPage.tsx">
"use client"; // Likely needs to be a client component for hooks

import { Pencil, Settings } from "lucide-react"; // Added Pencil icon

import type { AdminConfig } from "@/convexadmin/types";
import { DocumentInfoProvider } from "@/convexui/src/providers/DocumentInfo"; // Import the provider
// Import a placeholder/wrapper for the frontend Puck editor
import { FrontendPuckEditor } from "@/components/frontend/FrontendPuckEditor";
import Link from "next/link"; // Import Link
import React from "react";
import { Render } from "@measured/puck"; // Import Puck Render
import { api } from "@/convex/_generated/api"; // Import api
import { getFrontendViewComponent } from "@/lib/frontend/getFrontendViewComponent"; // New helper
import { puckConfig } from "@/convexadmin/puck.config"; // Import shared Puck config
import { useQuery } from "convex/react"; // Import useQuery

// TODO: Define actual frontend layout components (Header, Footer, etc.)
// import { FrontendHeader } from "./frontend/layout/FrontendHeader";
// import { FrontendFooter } from "./frontend/layout/FrontendFooter";

interface FrontendRootPageProps {
  config: AdminConfig;
  segments: string[];
  isEditorMode: boolean; // Add the new prop
  // searchParams is no longer directly needed here
  // searchParams: {
  //   [key: string]: string | string[];
  // };
}

export const FrontendRootPage = ({
  config,
  segments,
  isEditorMode, // Use the direct prop
  // searchParams, // No longer destructuring searchParams here
}: FrontendRootPageProps) => {
  console.log("FrontendRootPage received segments:", segments);
  console.log("FrontendRootPage received isEditorMode:", isEditorMode); // Log the boolean

  // Check if editor mode is requested
  // const isEditorMode = searchParams?.editor === "true"; // Remove this check

  // Determine the collectionSlug based on segments
  const collectionSlug =
    segments.length === 1 && config.collections[segments[0]]
      ? segments[0]
      : null;

  // Fetch Puck page data IF we are NOT in editor mode AND have a collectionSlug
  const identifier = collectionSlug;
  const puckPageData = useQuery(
    api.puckPages.getPuckPage,
    !isEditorMode && identifier ? { identifier } : "skip",
  );

  // Determine the Fallback View Component
  const { ViewComponent: FallbackViewComponent, props: fallbackViewProps } =
    getFrontendViewComponent({
      config,
      segments,
      searchParams: {}, // Pass empty or use useSearchParams if needed
    });

  // --- Admin Bar Logic --- //
  const currentPath = `/${segments.join("/")}`; // Use resolved segments
  const editorLinkHref = `${currentPath}?editor=true`;
  const adminSettingsLinkHref = collectionSlug
    ? `/admin/collections/${collectionSlug}/settings/frontend`
    : "#"; // Fallback href if not a collection page

  // Calculate padding for main content based on whether the admin bar is shown
  const mainPaddingTop = collectionSlug ? "pt-16" : "pt-4"; // Adjust 'pt-16' based on final bar height

  // --- Determine Content to Render --- //
  let content: React.ReactNode;

  if (isEditorMode && collectionSlug) {
    // Render the Editor
    content = <FrontendPuckEditor collectionSlug={collectionSlug} />;
  } else if (puckPageData === undefined && identifier) {
    // Loading state while fetching Puck data
    content = <div className="p-8 text-center">Loading page layout...</div>;
  } else if (puckPageData && puckPageData.puckData && identifier) {
    // Render the page using Puck data, wrapped in the provider
    // We need to assert the type of puckPageData.puckData here
    content = (
      <DocumentInfoProvider collectionSlug={identifier}>
        {/* eslint-disable-next-line @typescript-eslint/no-explicit-any */}
        <Render config={puckConfig} data={puckPageData.puckData as any} />
      </DocumentInfoProvider>
    );
  } else {
    // Render the Fallback View Component
    content = <FallbackViewComponent {...fallbackViewProps} />;
  }

  return (
    <div className="frontend-root relative min-h-screen">
      {/* Conditionally render Admin Bar */}
      {collectionSlug && (
        <div className="admin-bar fixed top-0 left-0 right-0 z-50 bg-gray-900 text-white shadow-md">
          <div className="container mx-auto px-4 py-2 flex justify-between items-center">
            {/* Left side: Collection Info */}
            <span className="text-sm">
              Viewing Frontend:{" "}
              {config.collections[collectionSlug]?.pluralLabel ||
                collectionSlug}
            </span>
            {/* Right side: Action Links */}
            <div className="flex items-center space-x-4">
              {!isEditorMode && ( // Use the prop directly
                <Link
                  href={editorLinkHref}
                  className="text-sm flex items-center space-x-1 hover:text-gray-300 transition-colors"
                  title="Open page builder"
                >
                  <Pencil className="h-4 w-4" />
                  <span>Open In Editor</span>
                </Link>
              )}
              <Link
                href={adminSettingsLinkHref}
                className="text-sm flex items-center space-x-1 hover:text-gray-300 transition-colors"
                title={`Admin Settings for ${collectionSlug}`}
                target="_blank"
                rel="noopener noreferrer"
              >
                <Settings className="h-4 w-4" />
                <span>Admin Settings</span>
              </Link>
            </div>
          </div>
        </div>
      )}

      {/* <FrontendHeader /> */}
      {/* Apply dynamic padding to main */}
      <main className={`frontend-main p-4 md:p-6 ${mainPaddingTop}`}>
        {content}
      </main>
      {/* <FrontendFooter /> */}
    </div>
  );
};
</file>

<file path="components/Todo.tsx">
"use client";

import { SignInButton, SignedIn, SignedOut, UserButton } from "@clerk/nextjs";
import { useMutation, useQuery } from "convex/react";

import { Doc } from "../convex/_generated/dataModel";
import { api } from "../convex/_generated/api";
import { useState } from "react";

export default function Todo() {
  const [newTodoText, setNewTodoText] = useState("");
  const [searchQuery, setSearchQuery] = useState("");

  const todos = useQuery(api.todos.getTodos);
  const searchResults = useQuery(api.todos.searchTodos, { searchQuery });
  const createTodo = useMutation(api.todos.createTodo);
  const updateTodo = useMutation(api.todos.updateTodo);
  const deleteTodo = useMutation(api.todos.deleteTodo);

  const handleCreateTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newTodoText.trim()) return;

    await createTodo({ text: newTodoText });
    setNewTodoText("");
  };

  const handleToggleTodo = async (todo: Doc<"todos">) => {
    await updateTodo({
      id: todo._id,
      isCompleted: !todo.isCompleted,
    });
  };

  const handleDeleteTodo = async (todoId: Doc<"todos">["_id"]) => {
    await deleteTodo({ id: todoId });
  };

  const displayedTodos = searchQuery ? searchResults : todos;

  return (
    <div className="max-w-4xl mx-auto p-4 space-y-8">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Todo App</h1>
        <UserButton afterSignOutUrl="/" />
      </div>

      <SignedIn>
        <div className="space-y-4">
          {/* Search Input */}
          <div className="flex gap-4">
            <input
              type="text"
              placeholder="Search todos..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="flex-1 px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {/* Create Todo Form */}
          <form onSubmit={handleCreateTodo} className="flex gap-4">
            <input
              type="text"
              placeholder="Add a new todo..."
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              className="flex-1 px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <button
              type="submit"
              className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              Add
            </button>
          </form>

          {/* Todo List */}
          <div className="space-y-4">
            {displayedTodos?.map((todo) => (
              <div
                key={todo._id}
                className="flex items-center gap-4 p-4 bg-white rounded-lg shadow"
              >
                <input
                  type="checkbox"
                  checked={todo.isCompleted}
                  onChange={() => handleToggleTodo(todo)}
                  className="h-5 w-5 rounded border-gray-300 focus:ring-blue-500"
                />
                <span
                  className={`flex-1 ${
                    todo.isCompleted ? "line-through text-gray-500" : ""
                  }`}
                >
                  {todo.text}
                </span>
                <button
                  onClick={() => handleDeleteTodo(todo._id)}
                  className="p-2 text-red-500 hover:text-red-600 focus:outline-none"
                >
                  Delete
                </button>
              </div>
            ))}

            {displayedTodos?.length === 0 && (
              <p className="text-center text-gray-500">No todos found</p>
            )}
          </div>
        </div>
      </SignedIn>

      <SignedOut>
        <div className="text-center space-y-4">
          <p className="text-gray-600">Please sign in to manage your todos</p>
          <SignInButton mode="modal">
            <button className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
              Sign In
            </button>
          </SignInButton>
        </div>
      </SignedOut>
    </div>
  );
}
</file>

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as documents from "../documents.js";
import type * as plugins from "../plugins.js";
import type * as posts from "../posts.js";
import type * as puckPages from "../puckPages.js";
import type * as todos from "../todos.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  documents: typeof documents;
  plugins: typeof plugins;
  posts: typeof posts;
  puckPages: typeof puckPages;
  todos: typeof todos;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/auth.config.ts">
const authConfig = {
  providers: [
    // Uncomment this once you have set up a Clerk app
    {
      // Replace with your own Clerk Issuer URL from your "convex" JWT template
      // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`
      // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
      // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
      domain: "https://obliging-cowbird-14.clerk.accounts.dev",
      applicationID: "convex",
    },
  ],
};

export default authConfig;
</file>

<file path="convex/documents.ts">
import { query } from "./_generated/server";
import { v } from "convex/values";

// Define a type for valid table names based on the schema
const validTableNames = v.union(
  v.literal("todos"),
  v.literal("posts"),
  v.literal("plugins"),
  v.literal("puckPages"),
  // Add other table names here if needed
);

export const listDocuments = query({
  args: {
    tableName: validTableNames,
  },
  handler: async (ctx, args) => {
    // Use the validated tableName directly. Convex infers the type correctly here.
    // No explicit cast needed if args are validated properly.
    const documents = await ctx.db.query(args.tableName).collect();
    return documents;
  },
});

// New query to get keys from the first document in a table
export const getDocumentKeys = query({
  args: {
    tableName: validTableNames,
  },
  handler: async (ctx, args) => {
    // Fetch only the first document to get its keys
    const firstDoc = await ctx.db.query(args.tableName).first();
    if (!firstDoc) {
      return []; // Return empty array if table is empty
    }
    // Return the keys of the first document
    return Object.keys(firstDoc);
  },
});
</file>

<file path="convex/myFunctions.ts">
// This file can be safely deleted since we've implemented our todo functionality in todos.ts
</file>

<file path="convex/plugins.ts">
import { query } from "./_generated/server";

// Basic query to fetch all plugins
export const getPlugins = query({
  args: {}, // No arguments for now
  handler: async (ctx) => {
    return await ctx.db.query("plugins").collect();
  },
});
</file>

<file path="convex/posts.ts">
import { query } from "./_generated/server";

// Basic query to fetch all posts
export const getPosts = query({
  args: {}, // No arguments for now
  handler: async (ctx) => {
    return await ctx.db.query("posts").collect();
  },
});
</file>

<file path="convex/puckPages.ts">
import { mutation, query } from "./_generated/server";

import { v } from "convex/values";

// Mutation to save or update Puck page data
export const savePuckPage = mutation({
  args: {
    identifier: v.string(),
    puckData: v.any(), // Matches schema type
  },
  handler: async (ctx, args) => {
    // ///////////////////////////////////////////////
    // ///           SECURITY WARNING            ///
    // ///////////////////////////////////////////////
    // You MUST add authentication and authorization checks here.
    // Who is allowed to save page structures for which identifier?
    // const identity = await ctx.auth.getUserIdentity();
    // if (!identity) {
    //   throw new Error("User must be authenticated to save page structure.");
    // }
    // // Add checks based on user roles or ownership of the identifier...
    // ///////////////////////////////////////////////

    // Check if a page with this identifier already exists
    const existingPage = await ctx.db
      .query("puckPages")
      .withIndex("by_identifier", (q) => q.eq("identifier", args.identifier))
      .unique();

    if (existingPage) {
      // Update existing page
      await ctx.db.patch(existingPage._id, { puckData: args.puckData });
      console.log(
        `Updated Puck page structure for identifier: ${args.identifier}`,
      );
      return existingPage._id;
    } else {
      // Create new page
      const pageId = await ctx.db.insert("puckPages", {
        identifier: args.identifier,
        puckData: args.puckData,
      });
      console.log(
        `Created new Puck page structure for identifier: ${args.identifier}`,
      );
      return pageId;
    }
  },
});

// Query to retrieve Puck page data by identifier
export const getPuckPage = query({
  args: { identifier: v.string() },
  handler: async (ctx, args) => {
    // ///////////////////////////////////////////////
    // ///           SECURITY WARNING            ///
    // ///////////////////////////////////////////////
    // Add authentication/authorization if needed.
    // Is this page data public, or should only specific users see it?
    // Consider if draft/published versions are needed.
    // ///////////////////////////////////////////////

    const page = await ctx.db
      .query("puckPages")
      .withIndex("by_identifier", (q) => q.eq("identifier", args.identifier))
      .unique();

    return page; // Returns the document or null if not found
  },
});
</file>

<file path="convex/README.md">
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.
</file>

<file path="convex/schema.ts">
import { defineSchema, defineTable } from "convex/server";

import { v } from "convex/values";

// The schema is entirely optional.
// You can delete this file (schema.ts) and the
// app will continue to work.
// The schema provides more precise TypeScript types.
export default defineSchema({
  todos: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_createdAt", ["createdAt"])
    .searchIndex("search_text", {
      searchField: "text",
      filterFields: ["isCompleted"],
    }),

  // New Posts table
  posts: defineTable({
    title: v.string(),
    description: v.string(),
  }),

  // New Plugins table
  plugins: defineTable({
    title: v.string(),
    description: v.string(),
  }),

  // Add the new table for Puck page structures
  puckPages: defineTable({
    identifier: v.string(), // e.g., collectionSlug or route path
    puckData: v.any(), // Store the Puck Data object (consider v.object for stricter typing later)
  }).index("by_identifier", ["identifier"]), // Index for fast lookups
});
</file>

<file path="convex/todos.ts">
import { mutation, query } from "./_generated/server";

import { v } from "convex/values";

// Get all todos
export const getTodos = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    const todos = await ctx.db
      .query("todos")
      .withIndex("by_createdAt")
      .order("desc")
      .collect();
    return todos;
  },
});

// Get a single todo by ID
export const getTodoById = query({
  args: { id: v.id("todos") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return null;
    }
    const todo = await ctx.db.get(args.id);
    return todo;
  },
});

// Create a new todo
export const createTodo = mutation({
  args: {
    text: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const todo = await ctx.db.insert("todos", {
      text: args.text,
      isCompleted: false,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
    return todo;
  },
});

// Update a todo
export const updateTodo = mutation({
  args: {
    id: v.id("todos"),
    data: v.any(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const { id, data } = args;

    const existingTodo = await ctx.db.get(id);
    if (!existingTodo) {
      throw new Error("Todo not found");
    }

    await ctx.db.patch(id, {
      ...data,
      updatedAt: Date.now(),
    });

    return null;
  },
});

// Delete a todo
export const deleteTodo = mutation({
  args: {
    id: v.id("todos"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const { id } = args;
    await ctx.db.delete(id);
    return null;
  },
});

// Search todos
export const searchTodos = query({
  args: {
    searchQuery: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    const todos = await ctx.db
      .query("todos")
      .withSearchIndex("search_text", (q) => q.search("text", args.searchQuery))
      .collect();
    return todos;
  },
});
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
</file>

<file path="convexadmin/admin/src/collections/config/build.ts">
import type { CollectionConfig } from './types.js'

const buildCollection = (collection: CollectionConfig): CollectionConfig => collection

export default buildCollection
</file>

<file path="convexadmin/admin/src/collections/config/client.ts">
// @ts-strict-ignore
import type { I18nClient } from '@convexcms/translations'

import type { StaticDescription } from '../../admin/types.js'
import type { ImportMap } from '../../bin/generateImportMap/index.js'
import type {
  LivePreviewConfig,
  ServerOnlyLivePreviewProperties,
  StaticLabel,
} from '../../config/types.js'
import type { ClientField } from '../../fields/config/client.js'
import type { Payload } from '../../types/index.js'
import type { SanitizedUploadConfig } from '../../uploads/types.js'
import type { SanitizedCollectionConfig } from './types.js'

import { createClientFields } from '../../fields/config/client.js'

export type ServerOnlyCollectionProperties = keyof Pick<
  SanitizedCollectionConfig,
  | 'access'
  | 'custom'
  | 'endpoints'
  | 'flattenedFields'
  | 'hooks'
  | 'indexes'
  | 'joins'
  | 'polymorphicJoins'
  | 'sanitizedIndexes'
>

export type ServerOnlyCollectionAdminProperties = keyof Pick<
  SanitizedCollectionConfig['admin'],
  'baseListFilter' | 'components' | 'hidden'
>

export type ServerOnlyUploadProperties = keyof Pick<
  SanitizedCollectionConfig['upload'],
  | 'adminThumbnail'
  | 'externalFileHeaderFilter'
  | 'handlers'
  | 'modifyResponseHeaders'
  | 'withMetadata'
>

export type ClientCollectionConfig = {
  admin: {
    description?: StaticDescription
    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>
    preview?: boolean
  } & Omit<
    SanitizedCollectionConfig['admin'],
    | 'components'
    | 'description'
    | 'joins'
    | 'livePreview'
    | 'preview'
    | ServerOnlyCollectionAdminProperties
  >
  auth?: { verify?: true } & Omit<
    SanitizedCollectionConfig['auth'],
    'forgotPassword' | 'strategies' | 'verify'
  >
  fields: ClientField[]
  labels: {
    plural: StaticLabel
    singular: StaticLabel
  }
} & Omit<
  SanitizedCollectionConfig,
  'admin' | 'auth' | 'fields' | 'labels' | ServerOnlyCollectionProperties
>

const serverOnlyCollectionProperties: Partial<ServerOnlyCollectionProperties>[] = [
  'hooks',
  'access',
  'endpoints',
  'custom',
  'joins',
  'polymorphicJoins',
  'flattenedFields',
  'indexes',
  'sanitizedIndexes',
  // `upload`
  // `admin`
  // are all handled separately
]

const serverOnlyUploadProperties: Partial<ServerOnlyUploadProperties>[] = [
  'adminThumbnail',
  'externalFileHeaderFilter',
  'handlers',
  'modifyResponseHeaders',
  'withMetadata',
]

const serverOnlyCollectionAdminProperties: Partial<ServerOnlyCollectionAdminProperties>[] = [
  'hidden',
  'baseListFilter',
  'components',
  // 'preview' is handled separately
  // `livePreview` is handled separately
]

export const createClientCollectionConfig = ({
  collection,
  defaultIDType,
  i18n,
  importMap,
}: {
  collection: SanitizedCollectionConfig
  defaultIDType: Payload['config']['db']['defaultIDType']
  i18n: I18nClient
  importMap: ImportMap
}): ClientCollectionConfig => {
  const clientCollection = {} as Partial<ClientCollectionConfig>

  for (const key in collection) {
    if (serverOnlyCollectionProperties.includes(key as any)) {
      continue
    }
    switch (key) {
      case 'admin':
        if (!collection.admin) {
          break
        }
        clientCollection.admin = {} as ClientCollectionConfig['admin']
        for (const adminKey in collection.admin) {
          if (serverOnlyCollectionAdminProperties.includes(adminKey as any)) {
            continue
          }

          switch (adminKey) {
            case 'description':
              if (
                typeof collection.admin.description === 'string' ||
                typeof collection.admin.description === 'object'
              ) {
                if (collection.admin.description) {
                  clientCollection.admin.description = collection.admin.description
                }
              } else if (typeof collection.admin.description === 'function') {
                const description = collection.admin.description({ t: i18n.t })
                if (description) {
                  clientCollection.admin.description = description
                }
              }
              break
            case 'livePreview':
              clientCollection.admin.livePreview =
                {} as ClientCollectionConfig['admin']['livePreview']
              if (collection.admin.livePreview.breakpoints) {
                clientCollection.admin.livePreview.breakpoints =
                  collection.admin.livePreview.breakpoints
              }
              break
            case 'preview':
              if (collection.admin.preview) {
                clientCollection.admin.preview = true
              }
              break
            default:
              clientCollection.admin[adminKey] = collection.admin[adminKey]
          }
        }
        break
      case 'auth':
        if (!collection.auth) {
          break
        }
        clientCollection.auth = {} as { verify?: true } & SanitizedCollectionConfig['auth']
        if (collection.auth.cookies) {
          clientCollection.auth.cookies = collection.auth.cookies
        }
        if (collection.auth.depth !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.depth = collection.auth.depth
        }
        if (collection.auth.disableLocalStrategy) {
          clientCollection.auth.disableLocalStrategy = collection.auth.disableLocalStrategy
        }
        if (collection.auth.lockTime !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.lockTime = collection.auth.lockTime
        }
        if (collection.auth.loginWithUsername) {
          clientCollection.auth.loginWithUsername = collection.auth.loginWithUsername
        }
        if (collection.auth.maxLoginAttempts !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.maxLoginAttempts = collection.auth.maxLoginAttempts
        }
        if (collection.auth.removeTokenFromResponses) {
          clientCollection.auth.removeTokenFromResponses = collection.auth.removeTokenFromResponses
        }

        if (collection.auth.useAPIKey) {
          clientCollection.auth.useAPIKey = collection.auth.useAPIKey
        }
        if (collection.auth.tokenExpiration) {
          clientCollection.auth.tokenExpiration = collection.auth.tokenExpiration
        }
        if (collection.auth.verify) {
          clientCollection.auth.verify = true
        }
        break
      case 'fields':
        clientCollection.fields = createClientFields({
          defaultIDType,
          fields: collection.fields,
          i18n,
          importMap,
        })
        break
      case 'labels':
        clientCollection.labels = {
          plural:
            typeof collection.labels.plural === 'function'
              ? collection.labels.plural({ i18n, t: i18n.t })
              : collection.labels.plural,
          singular:
            typeof collection.labels.singular === 'function'
              ? collection.labels.singular({ i18n, t: i18n.t })
              : collection.labels.singular,
        }
        break
      case 'upload':
        if (!collection.upload) {
          break
        }
        clientCollection.upload = {} as SanitizedUploadConfig
        for (const uploadKey in collection.upload) {
          if (serverOnlyUploadProperties.includes(uploadKey as any)) {
            continue
          }
          if (uploadKey === 'imageSizes') {
            clientCollection.upload.imageSizes = collection.upload.imageSizes.map((size) => {
              const sanitizedSize = { ...size }
              if ('generateImageName' in sanitizedSize) {
                delete sanitizedSize.generateImageName
              }
              return sanitizedSize
            })
          } else {
            clientCollection.upload[uploadKey] = collection.upload[uploadKey]
          }
        }
        break

      default:
        clientCollection[key] = collection[key]
    }
  }

  return clientCollection as ClientCollectionConfig
}

export const createClientCollectionConfigs = ({
  collections,
  defaultIDType,
  i18n,
  importMap,
}: {
  collections: SanitizedCollectionConfig[]
  defaultIDType: Payload['config']['db']['defaultIDType']
  i18n: I18nClient
  importMap: ImportMap
}): ClientCollectionConfig[] => {
  const clientCollections = new Array(collections.length)

  for (let i = 0; i < collections.length; i++) {
    const collection = collections[i]

    clientCollections[i] = createClientCollectionConfig({
      collection,
      defaultIDType,
      i18n,
      importMap,
    })
  }

  return clientCollections
}
</file>

<file path="convexadmin/admin/src/collections/config/defaults.ts">
import type { IncomingAuthType, LoginWithUsernameOptions } from '../../auth/types.js'
import type { CollectionConfig } from './types.js'

import defaultAccess from '../../auth/defaultAccess.js'

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const defaults: Partial<CollectionConfig> = {
  access: {
    create: defaultAccess,
    delete: defaultAccess,
    read: defaultAccess,
    unlock: defaultAccess,
    update: defaultAccess,
  },
  admin: {
    components: {},
    custom: {},
    enableRichTextLink: true,
    enableRichTextRelationship: true,
    pagination: {
      defaultLimit: 10,
      limits: [5, 10, 25, 50, 100],
    },
    useAsTitle: 'id',
  },
  auth: false,
  custom: {},
  endpoints: [],
  fields: [],
  hooks: {
    afterChange: [],
    afterDelete: [],
    afterForgotPassword: [],
    afterLogin: [],
    afterLogout: [],
    afterMe: [],
    afterOperation: [],
    afterRead: [],
    afterRefresh: [],
    beforeChange: [],
    beforeDelete: [],
    beforeLogin: [],
    beforeOperation: [],
    beforeRead: [],
    beforeValidate: [],
    me: [],
    refresh: [],
  },
  indexes: [],
  timestamps: true,
  upload: false,
  versions: false,
}

export const addDefaultsToCollectionConfig = (collection: CollectionConfig): CollectionConfig => {
  collection.access = {
    create: defaultAccess,
    delete: defaultAccess,
    read: defaultAccess,
    unlock: defaultAccess,
    update: defaultAccess,
    ...(collection.access || {}),
  }

  collection.admin = {
    components: {},
    custom: {},
    enableRichTextLink: true,
    enableRichTextRelationship: true,
    useAsTitle: 'id',
    ...(collection.admin || {}),
    pagination: {
      defaultLimit: 10,
      limits: [5, 10, 25, 50, 100],
      ...(collection.admin?.pagination || {}),
    },
  }

  collection.auth = collection.auth ?? false
  collection.custom = collection.custom ?? {}
  collection.endpoints = collection.endpoints ?? []
  collection.fields = collection.fields ?? []

  collection.hooks = {
    afterChange: [],
    afterDelete: [],
    afterForgotPassword: [],
    afterLogin: [],
    afterLogout: [],
    afterMe: [],
    afterOperation: [],
    afterRead: [],
    afterRefresh: [],
    beforeChange: [],
    beforeDelete: [],
    beforeLogin: [],
    beforeOperation: [],
    beforeRead: [],
    beforeValidate: [],
    me: [],
    refresh: [],
    ...(collection.hooks || {}),
  }

  collection.timestamps = collection.timestamps ?? true
  collection.upload = collection.upload ?? false
  collection.versions = collection.versions ?? false

  collection.indexes = collection.indexes ?? []

  return collection
}

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const authDefaults: IncomingAuthType = {
  cookies: {
    sameSite: 'Lax',
    secure: false,
  },
  forgotPassword: {},
  lockTime: 600000, // 10 minutes
  loginWithUsername: false,
  maxLoginAttempts: 5,
  tokenExpiration: 7200,
  verify: false,
}

export const addDefaultsToAuthConfig = (auth: IncomingAuthType): IncomingAuthType => {
  auth.cookies = {
    sameSite: 'Lax',
    secure: false,
    ...(auth.cookies || {}),
  }

  auth.forgotPassword = auth.forgotPassword ?? {}
  auth.lockTime = auth.lockTime ?? 600000 // 10 minutes
  auth.loginWithUsername = auth.loginWithUsername ?? false
  auth.maxLoginAttempts = auth.maxLoginAttempts ?? 5
  auth.tokenExpiration = auth.tokenExpiration ?? 7200
  auth.verify = auth.verify ?? false
  auth.strategies = auth.strategies ?? []

  if (!auth.disableLocalStrategy && auth.verify === true) {
    auth.verify = {}
  }

  return auth
}

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const loginWithUsernameDefaults: LoginWithUsernameOptions = {
  allowEmailLogin: false,
  requireEmail: false,
  requireUsername: true,
}

export const addDefaultsToLoginWithUsernameConfig = (
  loginWithUsername: LoginWithUsernameOptions,
): LoginWithUsernameOptions =>
  ({
    allowEmailLogin: false,
    requireEmail: false,
    requireUsername: true,
    ...(loginWithUsername || {}),
  }) as LoginWithUsernameOptions
</file>

<file path="convexadmin/admin/src/collections/config/reservedFieldNames.spec.ts">
import type { Config } from '../../config/types.js'
import type { CollectionConfig, Field } from '../../index.js'

import { ReservedFieldName } from '../../errors/index.js'
import { sanitizeCollection } from './sanitize.js'

describe('reservedFieldNames - collections -', () => {
  const config = {
    collections: [],
    globals: [],
  } as Partial<Config>

  describe('uploads -', () => {
    const collectionWithUploads: CollectionConfig = {
      slug: 'collection-with-uploads',
      fields: [],
      upload: true,
    }

    it('should throw on file', async () => {
      const fields: Field[] = [
        {
          name: 'file',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithUploads,
                fields,
              },
            ],
          },
          {
            ...collectionWithUploads,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should not throw on a custom field', async () => {
      const fields: Field[] = [
        {
          name: 'customField',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithUploads,
                fields,
              },
            ],
          },
          {
            ...collectionWithUploads,
            fields,
          },
        )
      }).not.toThrow()
    })
  })

  describe('auth -', () => {
    const collectionWithAuth: CollectionConfig = {
      slug: 'collection-with-auth',
      auth: {
        loginWithUsername: true,
        useAPIKey: true,
        verify: true,
      },
      fields: [],
    }

    it('should throw on hash', async () => {
      const fields: Field[] = [
        {
          name: 'hash',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should throw on salt', async () => {
      const fields: Field[] = [
        {
          name: 'salt',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should not throw on a custom field', async () => {
      const fields: Field[] = [
        {
          name: 'customField',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).not.toThrow()
    })
  })
})
</file>

<file path="convexadmin/admin/src/collections/config/reservedFieldNames.ts">
// @ts-strict-ignore
import type { Field } from '../../fields/config/types.js'
import type { CollectionConfig } from '../../index.js'

import { ReservedFieldName } from '../../errors/ReservedFieldName.js'
import { fieldAffectsData } from '../../fields/config/types.js'

// Note for future reference: We've slimmed down the reserved field names but left them in here for reference in case it's needed in the future.

/**
 * Reserved field names for collections with auth config enabled
 */
const reservedBaseAuthFieldNames = [
  /* 'email',
  'resetPasswordToken',
  'resetPasswordExpiration', */
  'salt',
  'hash',
]
/**
 * Reserved field names for auth collections with verify: true
 */
const reservedVerifyFieldNames = [
  /* '_verified', '_verificationToken' */
]
/**
 * Reserved field names for auth collections with useApiKey: true
 */
const reservedAPIKeyFieldNames = [
  /* 'enableAPIKey', 'apiKeyIndex', 'apiKey' */
]

/**
 * Reserved field names for collections with upload config enabled
 */
const reservedBaseUploadFieldNames = [
  'file',
  /* 'mimeType',
  'thumbnailURL',
  'width',
  'height',
  'filesize',
  'filename',
  'url',
  'focalX',
  'focalY',
  'sizes', */
]

/**
 * Reserved field names for collections with versions enabled
 */
const reservedVersionsFieldNames = [
  /* '__v', '_status' */
]

/**
 * Sanitize fields for collections with auth config enabled.
 *
 * Should run on top level fields only.
 */
export const sanitizeAuthFields = (fields: Field[], config: CollectionConfig) => {
  for (let i = 0; i < fields.length; i++) {
    const field = fields[i]

    if (fieldAffectsData(field) && field.name) {
      if (config.auth && typeof config.auth === 'object' && !config.auth.disableLocalStrategy) {
        const auth = config.auth

        if (reservedBaseAuthFieldNames.includes(field.name)) {
          throw new ReservedFieldName(field, field.name)
        }

        if (auth.verify) {
          if (reservedAPIKeyFieldNames.includes(field.name)) {
            throw new ReservedFieldName(field, field.name)
          }
        }

        /* if (auth.maxLoginAttempts) {
          if (field.name === 'loginAttempts' || field.name === 'lockUntil') {
            throw new ReservedFieldName(field, field.name)
          }
        } */

        /* if (auth.loginWithUsername) {
          if (field.name === 'username') {
            throw new ReservedFieldName(field, field.name)
          }
        } */

        if (auth.verify) {
          if (reservedVerifyFieldNames.includes(field.name)) {
            throw new ReservedFieldName(field, field.name)
          }
        }
      }
    }

    // Handle tabs without a name
    if (field.type === 'tabs') {
      for (let j = 0; j < field.tabs.length; j++) {
        const tab = field.tabs[j]

        if (!('name' in tab)) {
          sanitizeAuthFields(tab.fields, config)
        }
      }
    }

    // Handle presentational fields like rows and collapsibles
    if (!fieldAffectsData(field) && 'fields' in field && field.fields) {
      sanitizeAuthFields(field.fields, config)
    }
  }
}

/**
 * Sanitize fields for collections with upload config enabled.
 *
 * Should run on top level fields only.
 */
export const sanitizeUploadFields = (fields: Field[], config: CollectionConfig) => {
  if (config.upload && typeof config.upload === 'object') {
    for (let i = 0; i < fields.length; i++) {
      const field = fields[i]

      if (fieldAffectsData(field) && field.name) {
        if (reservedBaseUploadFieldNames.includes(field.name)) {
          throw new ReservedFieldName(field, field.name)
        }
      }

      // Handle tabs without a name
      if (field.type === 'tabs') {
        for (let j = 0; j < field.tabs.length; j++) {
          const tab = field.tabs[j]

          if (!('name' in tab)) {
            sanitizeUploadFields(tab.fields, config)
          }
        }
      }

      // Handle presentational fields like rows and collapsibles
      if (!fieldAffectsData(field) && 'fields' in field && field.fields) {
        sanitizeUploadFields(field.fields, config)
      }
    }
  }
}
</file>

<file path="convexadmin/admin/src/collections/config/sanitize.ts">
// @ts-strict-ignore

import type { Config, SanitizedConfig } from '../../config/types.js'
import type {
  CollectionConfig,
  SanitizedCollectionConfig,
  SanitizedJoin,
  SanitizedJoins,
} from './types.js'

import { authCollectionEndpoints } from '../../auth/endpoints/index.js'
import { getBaseAuthFields } from '../../auth/getAuthFields.js'
import { TimestampsRequired } from '../../errors/TimestampsRequired.js'
import { sanitizeFields } from '../../fields/config/sanitize.js'
import { fieldAffectsData } from '../../fields/config/types.js'
import mergeBaseFields from '../../fields/mergeBaseFields.js'
import { uploadCollectionEndpoints } from '../../uploads/endpoints/index.js'
import { getBaseUploadFields } from '../../uploads/getBaseFields.js'
import { flattenAllFields } from '../../utilities/flattenAllFields.js'
import { formatLabels } from '../../utilities/formatLabels.js'
import baseVersionFields from '../../versions/baseFields.js'
import { versionDefaults } from '../../versions/defaults.js'
import { defaultCollectionEndpoints } from '../endpoints/index.js'
import {
  addDefaultsToAuthConfig,
  addDefaultsToCollectionConfig,
  addDefaultsToLoginWithUsernameConfig,
} from './defaults.js'
import { sanitizeAuthFields, sanitizeUploadFields } from './reservedFieldNames.js'
import { sanitizeCompoundIndexes } from './sanitizeCompoundIndexes.js'
import { validateUseAsTitle } from './useAsTitle.js'

export const sanitizeCollection = async (
  config: Config,
  collection: CollectionConfig,
  /**
   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises
   * so that you can sanitize them together, after the config has been sanitized.
   */
  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,
  _validRelationships?: string[],
): Promise<SanitizedCollectionConfig> => {
  if (collection._sanitized) {
    return collection as SanitizedCollectionConfig
  }
  collection._sanitized = true
  // /////////////////////////////////
  // Make copy of collection config
  // /////////////////////////////////

  const sanitized: CollectionConfig = addDefaultsToCollectionConfig(collection)

  // /////////////////////////////////
  // Sanitize fields
  // /////////////////////////////////

  const validRelationships = _validRelationships ?? config.collections.map((c) => c.slug) ?? []

  const joins: SanitizedJoins = {}
  const polymorphicJoins: SanitizedJoin[] = []
  sanitized.fields = await sanitizeFields({
    collectionConfig: sanitized,
    config,
    fields: sanitized.fields,
    joinPath: '',
    joins,
    parentIsLocalized: false,
    polymorphicJoins,
    richTextSanitizationPromises,
    validRelationships,
  })

  if (sanitized.endpoints !== false) {
    if (!sanitized.endpoints) {
      sanitized.endpoints = []
    }

    if (sanitized.auth) {
      for (const endpoint of authCollectionEndpoints) {
        sanitized.endpoints.push(endpoint)
      }
    }

    if (sanitized.upload) {
      for (const endpoint of uploadCollectionEndpoints) {
        sanitized.endpoints.push(endpoint)
      }
    }

    for (const endpoint of defaultCollectionEndpoints) {
      sanitized.endpoints.push(endpoint)
    }
  }

  if (sanitized.timestamps !== false) {
    // add default timestamps fields only as needed
    let hasUpdatedAt: boolean | null = null
    let hasCreatedAt: boolean | null = null
    sanitized.fields.some((field) => {
      if (fieldAffectsData(field)) {
        if (field.name === 'updatedAt') {
          hasUpdatedAt = true
        }
        if (field.name === 'createdAt') {
          hasCreatedAt = true
        }
      }
      return hasCreatedAt && hasUpdatedAt
    })
    if (!hasUpdatedAt) {
      sanitized.fields.push({
        name: 'updatedAt',
        type: 'date',
        admin: {
          disableBulkEdit: true,
          hidden: true,
        },
        index: true,
        label: ({ t }) => t('general:updatedAt'),
      })
    }
    if (!hasCreatedAt) {
      sanitized.fields.push({
        name: 'createdAt',
        admin: {
          disableBulkEdit: true,
          hidden: true,
        },
        // The default sort for list view is createdAt. Thus, enabling indexing by default, is a major performance improvement, especially for large or a large amount of collections.
        type: 'date',
        index: true,
        label: ({ t }) => t('general:createdAt'),
      })
    }
  }

  sanitized.labels = sanitized.labels || formatLabels(sanitized.slug)

  if (sanitized.versions) {
    if (sanitized.versions === true) {
      sanitized.versions = { drafts: false, maxPerDoc: 100 }
    }

    if (sanitized.timestamps === false) {
      throw new TimestampsRequired(collection)
    }

    sanitized.versions.maxPerDoc =
      typeof sanitized.versions.maxPerDoc === 'number' ? sanitized.versions.maxPerDoc : 100

    if (sanitized.versions.drafts) {
      if (sanitized.versions.drafts === true) {
        sanitized.versions.drafts = {
          autosave: false,
          validate: false,
        }
      }

      if (sanitized.versions.drafts.autosave === true) {
        sanitized.versions.drafts.autosave = {
          interval: versionDefaults.autosaveInterval,
        }
      }

      if (sanitized.versions.drafts.validate === undefined) {
        sanitized.versions.drafts.validate = false
      }

      sanitized.fields = mergeBaseFields(sanitized.fields, baseVersionFields)
    }
  }

  if (sanitized.upload) {
    if (sanitized.upload === true) {
      sanitized.upload = {}
    }

    // sanitize fields for reserved names
    sanitizeUploadFields(sanitized.fields, sanitized)

    sanitized.upload.cacheTags = sanitized.upload?.cacheTags ?? true
    sanitized.upload.bulkUpload = sanitized.upload?.bulkUpload ?? true
    sanitized.upload.staticDir = sanitized.upload.staticDir || sanitized.slug
    sanitized.admin.useAsTitle =
      sanitized.admin?.useAsTitle && sanitized.admin.useAsTitle !== 'id'
        ? sanitized.admin.useAsTitle
        : 'filename'

    const uploadFields = getBaseUploadFields({
      collection: sanitized,
      config,
    })

    sanitized.fields = mergeBaseFields(sanitized.fields, uploadFields)
  }

  if (sanitized.auth) {
    // sanitize fields for reserved names
    sanitizeAuthFields(sanitized.fields, sanitized)

    sanitized.auth = addDefaultsToAuthConfig(
      typeof sanitized.auth === 'boolean' ? {} : sanitized.auth,
    )

    // disable duplicate for auth enabled collections by default
    sanitized.disableDuplicate = sanitized.disableDuplicate ?? true

    if (sanitized.auth.loginWithUsername) {
      if (sanitized.auth.loginWithUsername === true) {
        sanitized.auth.loginWithUsername = addDefaultsToLoginWithUsernameConfig({})
      } else {
        const loginWithUsernameWithDefaults = addDefaultsToLoginWithUsernameConfig(
          sanitized.auth.loginWithUsername,
        )

        // if allowEmailLogin is false, requireUsername must be true
        if (loginWithUsernameWithDefaults.allowEmailLogin === false) {
          loginWithUsernameWithDefaults.requireUsername = true
        }
        sanitized.auth.loginWithUsername = loginWithUsernameWithDefaults
      }
    } else {
      sanitized.auth.loginWithUsername = false
    }

    if (!collection?.admin?.useAsTitle) {
      sanitized.admin.useAsTitle = sanitized.auth.loginWithUsername ? 'username' : 'email'
    }

    sanitized.fields = mergeBaseFields(sanitized.fields, getBaseAuthFields(sanitized.auth))
  }

  if (collection?.admin?.pagination?.limits?.length) {
    sanitized.admin.pagination.limits = collection.admin.pagination.limits
  }

  validateUseAsTitle(sanitized)

  const sanitizedConfig = sanitized as SanitizedCollectionConfig

  sanitizedConfig.joins = joins
  sanitizedConfig.polymorphicJoins = polymorphicJoins

  sanitizedConfig.flattenedFields = flattenAllFields({ fields: sanitizedConfig.fields })

  sanitizedConfig.sanitizedIndexes = sanitizeCompoundIndexes({
    fields: sanitizedConfig.flattenedFields,
    indexes: sanitizedConfig.indexes,
  })

  return sanitizedConfig
}
</file>

<file path="convexadmin/admin/src/collections/config/sanitizeCompoundIndexes.ts">
import type { FlattenedField } from '../../fields/config/types.js'
import type { CompoundIndex, SanitizedCompoundIndex } from './types.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { getFieldByPath } from '../../utilities/getFieldByPath.js'

export const sanitizeCompoundIndexes = ({
  fields,
  indexes,
}: {
  fields: FlattenedField[]
  indexes: CompoundIndex[]
}): SanitizedCompoundIndex[] => {
  const sanitizedCompoundIndexes: SanitizedCompoundIndex[] = []

  for (const index of indexes) {
    const sanitized: SanitizedCompoundIndex = { fields: [], unique: index.unique ?? false }
    for (const path of index.fields) {
      const result = getFieldByPath({ fields, path })

      if (!result) {
        throw new InvalidConfiguration(`Field ${path} was not found`)
      }

      const { field, localizedPath, pathHasLocalized } = result

      if (['array', 'blocks', 'group', 'tab'].includes(field.type)) {
        throw new InvalidConfiguration(
          `Compound index on ${field.type} cannot be set. Path: ${localizedPath}`,
        )
      }

      sanitized.fields.push({ field, localizedPath, path, pathHasLocalized })
    }

    sanitizedCompoundIndexes.push(sanitized)
  }

  return sanitizedCompoundIndexes
}
</file>

<file path="convexadmin/admin/src/collections/config/types.ts">
import type { GraphQLInputObjectType, GraphQLNonNull, GraphQLObjectType } from 'graphql'
import type { DeepRequired, IsAny, MarkOptional } from 'ts-essentials'

import type { CustomUpload } from '../../admin/types.js'
import type { Arguments as MeArguments } from '../../auth/operations/me.js'
import type {
  Arguments as RefreshArguments,
  Result as RefreshResult,
} from '../../auth/operations/refresh.js'
import type { Auth, ClientUser, IncomingAuthType } from '../../auth/types.js'
import type {
  Access,
  AfterErrorHookArgs,
  AfterErrorResult,
  CustomComponent,
  EditConfig,
  Endpoint,
  EntityDescription,
  EntityDescriptionComponent,
  GeneratePreviewURL,
  LabelFunction,
  LivePreviewConfig,
  MetaConfig,
  PayloadComponent,
  StaticLabel,
} from '../../config/types.js'
import type { DBIdentifierName } from '../../database/types.js'
import type {
  Field,
  FlattenedField,
  JoinField,
  RelationshipField,
  UploadField,
} from '../../fields/config/types.js'
import type {
  CollectionSlug,
  JsonObject,
  RequestContext,
  TypedAuthOperations,
  TypedCollection,
  TypedCollectionSelect,
  TypedLocale,
} from '../../index.js'
import type {
  PayloadRequest,
  SelectIncludeType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../types/index.js'
import type { SanitizedUploadConfig, UploadConfig } from '../../uploads/types.js'
import type {
  IncomingCollectionVersions,
  SanitizedCollectionVersions,
} from '../../versions/types.js'
import type { AfterOperationArg, AfterOperationMap } from '../operations/utils.js'

export type DataFromCollectionSlug<TSlug extends CollectionSlug> = TypedCollection[TSlug]

export type SelectFromCollectionSlug<TSlug extends CollectionSlug> = TypedCollectionSelect[TSlug]

export type AuthOperationsFromCollectionSlug<TSlug extends CollectionSlug> =
  TypedAuthOperations[TSlug]

export type RequiredDataFromCollection<TData extends JsonObject> = MarkOptional<
  TData,
  'createdAt' | 'id' | 'sizes' | 'updatedAt'
>

export type RequiredDataFromCollectionSlug<TSlug extends CollectionSlug> =
  RequiredDataFromCollection<DataFromCollectionSlug<TSlug>>

export type HookOperationType =
  | 'autosave'
  | 'count'
  | 'countVersions'
  | 'create'
  | 'delete'
  | 'forgotPassword'
  | 'login'
  | 'read'
  | 'refresh'
  | 'update'

type CreateOrUpdateOperation = Extract<HookOperationType, 'create' | 'update'>

export type BeforeOperationHook = (args: {
  args?: any
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  /**
   * Hook operation being performed
   */
  operation: HookOperationType
  req: PayloadRequest
}) => any

export type BeforeValidateHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  data?: Partial<T>
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  /**
   * Original document before change
   *
   * `undefined` on 'create' operation
   */
  originalDoc?: T
  req: PayloadRequest
}) => any

export type BeforeChangeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  data: Partial<T>
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  /**
   * Original document before change
   *
   * `undefined` on 'create' operation
   */
  originalDoc?: T
  req: PayloadRequest
}) => any

export type AfterChangeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  previousDoc: T
  req: PayloadRequest
}) => any

export type BeforeReadHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  query: { [key: string]: any }
  req: PayloadRequest
}) => any

export type AfterReadHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  findMany?: boolean
  query?: { [key: string]: any }
  req: PayloadRequest
}) => any

export type BeforeDeleteHook = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  id: number | string
  req: PayloadRequest
}) => any

export type AfterDeleteHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  id: number | string
  req: PayloadRequest
}) => any

export type AfterOperationHook<TOperationGeneric extends CollectionSlug = string> = (
  arg: AfterOperationArg<TOperationGeneric>,
) =>
  | Awaited<
      ReturnType<AfterOperationMap<TOperationGeneric>[keyof AfterOperationMap<TOperationGeneric>]>
    >
  | Promise<
      Awaited<
        ReturnType<AfterOperationMap<TOperationGeneric>[keyof AfterOperationMap<TOperationGeneric>]>
      >
    >

export type BeforeLoginHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  user: T
}) => any

export type AfterLoginHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  token: string
  user: T
}) => any

export type AfterLogoutHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
}) => any

export type AfterMeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  response: unknown
}) => any

export type RefreshHook<T extends TypeWithID = any> = (args: {
  args: RefreshArguments
  user: T
}) => Promise<RefreshResult | void> | (RefreshResult | void)

export type MeHook<T extends TypeWithID = any> = (args: {
  args: MeArguments
  user: T
}) => ({ exp: number; user: T } | void) | Promise<{ exp: number; user: T } | void>

export type AfterRefreshHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  exp: number
  req: PayloadRequest
  token: string
}) => any

export type AfterErrorHook = (
  args: { collection: SanitizedCollectionConfig } & AfterErrorHookArgs,
) => AfterErrorResult | Promise<AfterErrorResult>

export type AfterForgotPasswordHook = (args: {
  args?: any
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
}) => any

export type BaseListFilter = (args: {
  limit: number
  locale?: TypedLocale
  page: number
  req: PayloadRequest
  sort: string
}) => null | Promise<null | Where> | Where

export type CollectionAdminOptions = {
  baseListFilter?: BaseListFilter
  /**
   * Custom admin components
   */
  components?: {
    afterList?: CustomComponent[]
    afterListTable?: CustomComponent[]
    beforeList?: CustomComponent[]
    beforeListTable?: CustomComponent[]
    Description?: EntityDescriptionComponent
    /**
     * Components within the edit view
     */
    edit?: {
      /**
       * Replaces the "Preview" button
       */
      PreviewButton?: CustomComponent
      /**
       * Replaces the "Publish" button
       * + drafts must be enabled
       */
      PublishButton?: CustomComponent
      /**
       * Replaces the "Save" button
       * + drafts must be disabled
       */
      SaveButton?: CustomComponent
      /**
       * Replaces the "Save Draft" button
       * + drafts must be enabled
       * + autosave must be disabled
       */
      SaveDraftButton?: CustomComponent
      /**
       * Replaces the "Upload" section
       * + upload must be enabled
       */
      Upload?: CustomUpload
    }
    listMenuItems?: CustomComponent[]
    views?: {
      /**
       * Set to a React component to replace the entire Edit View, including all nested routes.
       * Set to an object to replace or modify individual nested routes, or to add new ones.
       */
      edit?: EditConfig
      list?: {
        actions?: CustomComponent[]
        Component?: PayloadComponent
      }
    }
  }
  /** Extension point to add your custom data. Available in server and client. */
  custom?: Record<string, any>
  /**
   * Default columns to show in list view
   */
  defaultColumns?: string[]
  /**
   * Custom description for collection. This will also be used as JSDoc for the generated types
   */
  description?: EntityDescription
  /**
   * Disable the Copy To Locale button in the edit document view
   * @default false
   */
  disableCopyToLocale?: boolean
  enableRichTextLink?: boolean
  enableRichTextRelationship?: boolean
  /**
   * Specify a navigational group for collections in the admin sidebar.
   * - Provide a string to place the entity in a custom group.
   * - Provide a record to define localized group names.
   * - Set to `false` to exclude the entity from the sidebar / dashboard without disabling its routes.
   */
  group?: false | Record<string, string> | string
  /**
   * Exclude the collection from the admin nav and routes
   */
  hidden?: ((args: { user: ClientUser }) => boolean) | boolean
  /**
   * Hide the API URL within the Edit view
   */
  hideAPIURL?: boolean
  /**
   * Additional fields to be searched via the full text search
   */
  listSearchableFields?: string[]
  /**
   * Live preview options
   */
  livePreview?: LivePreviewConfig
  meta?: MetaConfig
  pagination?: {
    defaultLimit?: number
    limits?: number[]
  }
  /**
   * Function to generate custom preview URL
   */
  preview?: GeneratePreviewURL
  /**
   * Field to use as title in Edit View and first column in List view
   */
  useAsTitle?: string
}

/** Manage all aspects of a data collection */
export type CollectionConfig<TSlug extends CollectionSlug = any> = {
  /**
   * Do not set this property manually. This is set to true during sanitization, to avoid
   * sanitizing the same collection multiple times.
   */
  _sanitized?: boolean
  /**
   * Access control
   */
  access?: {
    admin?: ({ req }: { req: PayloadRequest }) => boolean | Promise<boolean>
    create?: Access
    delete?: Access
    read?: Access
    readVersions?: Access
    unlock?: Access
    update?: Access
  }
  /**
   * Collection admin options
   */
  admin?: CollectionAdminOptions
  /**
   * Collection login options
   *
   * Use `true` to enable with default options
   */
  auth?: boolean | IncomingAuthType
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  /**
   * Used to override the default naming of the database table or collection with your using a function or string
   * @WARNING: If you change this property with existing data, you will need to handle the renaming of the table in your database or by using migrations
   */
  dbName?: DBIdentifierName
  defaultPopulate?: IsAny<SelectFromCollectionSlug<TSlug>> extends true
    ? SelectType
    : SelectFromCollectionSlug<TSlug>
  /**
   * Default field to sort by in collection list view
   */
  defaultSort?: Sort
  /**
   * When true, do not show the "Duplicate" button while editing documents within this collection and prevent `duplicate` from all APIs
   */
  disableDuplicate?: boolean
  /**
   * Opt-in to enable query presets for this collection.
   * @see https://payloadcms.com/docs/query-presets/overview
   */
  enableQueryPresets?: boolean
  /**
   * Custom rest api endpoints, set false to disable all rest endpoints for this collection.
   */
  endpoints?: false | Omit<Endpoint, 'root'>[]
  fields: Field[]
  /**
   * Specify which fields should be selected always, regardless of the `select` query which can be useful that the field exists for access control / hooks
   */
  forceSelect?: IsAny<SelectFromCollectionSlug<TSlug>> extends true
    ? SelectIncludeType
    : SelectFromCollectionSlug<TSlug>
  /**
   * GraphQL configuration
   */
  graphQL?:
    | {
        disableMutations?: true
        disableQueries?: true
        pluralName?: string
        singularName?: string
      }
    | false
  /**
   * Hooks to modify Payload functionality
   */
  hooks?: {
    afterChange?: AfterChangeHook[]
    afterDelete?: AfterDeleteHook[]
    afterError?: AfterErrorHook[]
    afterForgotPassword?: AfterForgotPasswordHook[]
    afterLogin?: AfterLoginHook[]
    afterLogout?: AfterLogoutHook[]
    afterMe?: AfterMeHook[]
    afterOperation?: AfterOperationHook<TSlug>[]
    afterRead?: AfterReadHook[]
    afterRefresh?: AfterRefreshHook[]
    beforeChange?: BeforeChangeHook[]
    beforeDelete?: BeforeDeleteHook[]
    beforeLogin?: BeforeLoginHook[]
    beforeOperation?: BeforeOperationHook[]
    beforeRead?: BeforeReadHook[]
    beforeValidate?: BeforeValidateHook[]
    /**
    /**
     * Use the `me` hook to control the `me` operation.
     * Here, you can optionally instruct the me operation to return early,
     * and skip its default logic.
     */
    me?: MeHook[]
    /**
     * Use the `refresh` hook to control the refresh operation.
     * Here, you can optionally instruct the refresh operation to return early,
     * and skip its default logic.
     */
    refresh?: RefreshHook[]
  }
  /**
   * Define compound indexes for this collection.
   * This can be used to either speed up querying/sorting by 2 or more fields at the same time or
   * to ensure uniqueness between several fields.
   * Specify field paths
   * @example
   * [{ unique: true, fields: ['title', 'group.name'] }]
   * @default []
   */
  indexes?: CompoundIndex[]
  /**
   * Label configuration
   */
  labels?: {
    plural?: LabelFunction | StaticLabel
    singular?: LabelFunction | StaticLabel
  }
  /**
   * Enables / Disables the ability to lock documents while editing
   * @default true
   */
  lockDocuments?:
    | {
        duration: number
      }
    | false
  /**
   * If true, enables custom ordering for the collection, and documents in the listView can be reordered via drag and drop.
   * New documents are inserted at the end of the list according to this parameter.
   *
   * Under the hood, a field with {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing|fractional indexing} is used to optimize inserts and reorderings.
   *
   * @default false
   *
   * @experimental There may be frequent breaking changes to this API
   */
  orderable?: boolean
  slug: string
  /**
   * Add `createdAt` and `updatedAt` fields
   *
   * @default true
   */
  timestamps?: boolean
  /**
   * Options used in typescript generation
   */
  typescript?: {
    /**
     * Typescript generation name given to the interface type
     */
    interface?: string
  }
  /**
   * Customize the handling of incoming file uploads
   *
   * @default false // disable uploads
   */
  upload?: boolean | UploadConfig
  /**
   * Enable versioning. Set it to true to enable default versions settings,
   * or customize versions options by setting the property equal to an object
   * containing the version options.
   *
   * @default false // disable versioning
   */
  versions?: boolean | IncomingCollectionVersions
}

export type SanitizedJoin = {
  /**
   * The field configuration defining the join
   */
  field: JoinField
  getForeignPath?(args: { locale?: TypedLocale }): string
  /**
   * The path of the join field in dot notation
   */
  joinPath: string
  /**
   * `parentIsLocalized` is true if any parent field of the
   * field configuration defining the join is localized
   */
  parentIsLocalized: boolean
  targetField: RelationshipField | UploadField
}

export type SanitizedJoins = {
  [collectionSlug: string]: SanitizedJoin[]
}

/**
 * @todo remove the `DeepRequired` in v4.
 * We don't actually guarantee that all properties are set when sanitizing configs.
 */
export interface SanitizedCollectionConfig
  extends Omit<
    DeepRequired<CollectionConfig>,
    'auth' | 'endpoints' | 'fields' | 'slug' | 'upload' | 'versions'
  > {
  auth: Auth
  endpoints: Endpoint[] | false
  fields: Field[]
  /**
   * Fields in the database schema structure
   * Rows / collapsible / tabs w/o name `fields` merged to top, UIs are excluded
   */
  flattenedFields: FlattenedField[]
  /**
   * Object of collections to join 'Join Fields object keyed by collection
   */
  joins: SanitizedJoins

  /**
   * List of all polymorphic join fields
   */
  polymorphicJoins: SanitizedJoin[]

  sanitizedIndexes: SanitizedCompoundIndex[]

  slug: CollectionSlug
  upload: SanitizedUploadConfig
  versions: SanitizedCollectionVersions
}

export type Collection = {
  config: SanitizedCollectionConfig
  customIDType?: 'number' | 'text'
  graphQL?: {
    countType: GraphQLObjectType
    JWT: GraphQLObjectType
    mutationInputType: GraphQLNonNull<any>
    paginatedType: GraphQLObjectType
    type: GraphQLObjectType
    updateMutationInputType: GraphQLNonNull<any>
    versionType: GraphQLObjectType
    whereInputType: GraphQLInputObjectType
  }
}

export type BulkOperationResult<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  docs: TransformCollectionWithSelect<TSlug, TSelect>[]
  errors: {
    id: DataFromCollectionSlug<TSlug>['id']
    message: string
  }[]
}

export type AuthCollection = {
  config: SanitizedCollectionConfig
}

export type TypeWithID = {
  docId?: any
  id: number | string
}

export type TypeWithTimestamps = {
  [key: string]: unknown
  createdAt: string
  id: number | string
  updatedAt: string
}

export type CompoundIndex = {
  fields: string[]
  unique?: boolean
}

export type SanitizedCompoundIndex = {
  fields: {
    field: FlattenedField
    localizedPath: string
    path: string
    pathHasLocalized: boolean
  }[]
  unique: boolean
}
</file>

<file path="convexadmin/admin/src/collections/config/useAsTitle.spec.ts">
import type { Config } from '../../config/types.js'
import type { CollectionConfig } from '../../index.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { sanitizeCollection } from './sanitize.js'

describe('sanitize - collections -', () => {
  const config = {
    collections: [],
    globals: [],
  } as Partial<Config>

  describe('validate useAsTitle -', () => {
    const defaultCollection: CollectionConfig = {
      slug: 'collection-with-defaults',
      fields: [
        {
          name: 'title',
          type: 'text',
        },
      ],
    }

    it('should throw on invalid field', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'invalidField',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })

    it('should not throw on valid field', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on valid field inside tabs', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
        fields: [
          {
            type: 'tabs',
            tabs: [
              {
                label: 'General',
                fields: [
                  {
                    name: 'title',
                    type: 'text',
                  },
                ],
              },
            ],
          },
        ],
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on valid field inside collapsibles', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
        fields: [
          {
            type: 'collapsible',
            label: 'Collapsible',
            fields: [
              {
                name: 'title',
                type: 'text',
              },
            ],
          },
        ],
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should throw on nested useAsTitle', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'content.title',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })

    it('should not throw on default field: id', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'id',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on default field: email if auth is enabled', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        auth: true,
        admin: {
          useAsTitle: 'email',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })
    it('should throw on default field: email if auth is not enabled', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'email',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })
  })
})
</file>

<file path="convexadmin/admin/src/collections/config/useAsTitle.ts">
import type { CollectionConfig } from '../../index.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'
import flattenFields from '../../utilities/flattenTopLevelFields.js'

/**
 * Validate useAsTitle for collections.
 */
export const validateUseAsTitle = (config: CollectionConfig) => {
  if (config.admin?.useAsTitle?.includes('.')) {
    throw new InvalidConfiguration(
      `"useAsTitle" cannot be a nested field. Please specify a top-level field in the collection "${config.slug}"`,
    )
  }

  if (config?.admin && config.admin?.useAsTitle && config.admin.useAsTitle !== 'id') {
    const fields = flattenFields(config.fields)
    const useAsTitleField = fields.find((field) => {
      if (fieldAffectsData(field) && config.admin) {
        return field.name === config.admin.useAsTitle
      }
      return false
    })

    // If auth is enabled then we don't need to
    if (config.auth) {
      if (config.admin.useAsTitle !== 'email') {
        if (!useAsTitleField) {
          throw new InvalidConfiguration(
            `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" does not exist in the collection "${config.slug}"`,
          )
        }
      }
    } else {
      if (useAsTitleField && fieldIsVirtual(useAsTitleField)) {
        throw new InvalidConfiguration(
          `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" in the collection "${config.slug}" is virtual. A virtual field cannot be used as the title.`,
        )
      }
      if (!useAsTitleField) {
        throw new InvalidConfiguration(
          `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" does not exist in the collection "${config.slug}"`,
        )
      }
    }
  }
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/count.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { countOperation } from '../operations/count.js'

export const countHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { where } = req.query as {
    where?: Where
  }

  const result = await countOperation({
    collection,
    req,
    where,
  })

  return Response.json(result, {
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/create.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { createOperation } from '../operations/create.js'

export const createHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { searchParams } = req
  const autosave = searchParams.get('autosave') === 'true'
  const draft = searchParams.get('draft') === 'true'
  const depth = searchParams.get('depth')

  const doc = await createOperation({
    autosave,
    collection,
    data: req.data,
    depth: isNumber(depth) ? depth : undefined,
    draft,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(
    {
      doc,
      message: req.t('general:successfullyCreated', {
        label: getTranslation(collection.config.labels.singular, req.i18n),
      }),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.CREATED,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/delete.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { deleteOperation } from '../operations/delete.js'

export const deleteHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, overrideLock, populate, select, where } = req.query as {
    depth?: string
    overrideLock?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    where?: Where
  }

  const result = await deleteOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    where,
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (result.errors.length === 0) {
    const message = req.t('general:deletedCountSuccessfully', {
      count: result.docs.length,
      label: getTranslation(
        collection.config.labels[result.docs.length === 1 ? 'singular' : 'plural'],
        req.i18n,
      ),
    })

    return Response.json(
      {
        ...result,
        message,
      },
      {
        headers,
        status: httpStatus.OK,
      },
    )
  }

  const total = result.docs.length + result.errors.length

  const message = req.t('error:unableToDeleteCount', {
    count: result.errors.length,
    label: getTranslation(collection.config.labels[total === 1 ? 'singular' : 'plural'], req.i18n),
    total,
  })

  return Response.json(
    {
      ...result,
      message,
    },
    {
      headers,
      status: httpStatus.BAD_REQUEST,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/deleteByID.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { deleteByIDOperation } from '../operations/deleteByID.js'

export const deleteByIDHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const overrideLock = searchParams.get('overrideLock')

  const doc = await deleteByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? depth : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (!doc) {
    return Response.json(
      {
        message: req.t('general:notFound'),
      },
      {
        headers,
        status: httpStatus.NOT_FOUND,
      },
    )
  }

  return Response.json(
    {
      doc,
      message: req.t('general:deletedSuccessfully'),
    },
    {
      headers,
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/docAccess.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { docAccessOperation } from '../operations/docAccess.js'

export const docAccessHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req, { optionalID: true })
  const result = await docAccessOperation({
    id,
    collection,
    req,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/duplicate.ts">
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { duplicateOperation } from '../operations/duplicate.js'

export const duplicateHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  // draft defaults to true, unless explicitly set requested as false to prevent the newly duplicated document from being published
  const draft = searchParams.get('draft') !== 'false'

  const doc = await duplicateOperation({
    id,
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  const message = req.t('general:successfullyDuplicated', {
    label: getTranslation(collection.config.labels.singular, req.i18n),
  })

  return Response.json(
    {
      doc,
      message,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/find.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { JoinQuery, Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizeJoinParams } from '../../utilities/sanitizeJoinParams.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findOperation } from '../operations/find.js'

export const findHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, draft, joins, limit, page, pagination, populate, select, sort, where } =
    req.query as {
      depth?: string
      draft?: string
      joins?: JoinQuery
      limit?: string
      page?: string
      pagination?: string
      populate?: Record<string, unknown>
      select?: Record<string, unknown>
      sort?: string
      where?: Where
    }

  const result = await findOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true',
    joins: sanitizeJoinParams(joins),
    limit: isNumber(limit) ? Number(limit) : undefined,
    page: isNumber(page) ? Number(page) : undefined,
    pagination: pagination === 'false' ? false : undefined,
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/findByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { JoinQuery } from '../../types/index.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizeJoinParams } from '../../utilities/sanitizeJoinParams.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findByIDOperation } from '../operations/findByID.js'

export const findByIDHandler: PayloadHandler = async (req) => {
  const { searchParams } = req
  const { id, collection } = getRequestCollectionWithID(req)
  const depth = searchParams.get('depth')

  const result = await findByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    joins: sanitizeJoinParams(req.query.joins as JoinQuery),
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/findVersionByID.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionByIDOperation } from '../operations/findVersionByID.js'

export const findVersionByIDHandler: PayloadHandler = async (req) => {
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const { id, collection } = getRequestCollectionWithID(req)

  const result = await findVersionByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/findVersions.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionsOperation } from '../operations/findVersions.js'

export const findVersionsHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, limit, page, pagination, populate, select, sort, where } = req.query as {
    depth?: string
    limit?: string
    page?: string
    pagination?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    sort?: string
    where?: Where
  }

  const result = await findVersionsOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    limit: isNumber(limit) ? Number(limit) : undefined,
    page: isNumber(page) ? Number(page) : undefined,
    pagination: pagination === 'false' ? false : undefined,
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/index.ts">
import type { Endpoint } from '../../config/types.js'

import { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'
import { countHandler } from './count.js'
import { createHandler } from './create.js'
import { deleteHandler } from './delete.js'
import { deleteByIDHandler } from './deleteByID.js'
import { docAccessHandler } from './docAccess.js'
import { duplicateHandler } from './duplicate.js'
import { findHandler } from './find.js'
import { findByIDHandler } from './findByID.js'
import { findVersionByIDHandler } from './findVersionByID.js'
import { findVersionsHandler } from './findVersions.js'
import { previewHandler } from './preview.js'
import { restoreVersionHandler } from './restoreVersion.js'
import { updateHandler } from './update.js'
import { updateByIDHandler } from './updateByID.js'

export const defaultCollectionEndpoints: Endpoint[] = [
  ...wrapInternalEndpoints([
    {
      handler: countHandler,
      method: 'get',
      path: '/count',
    },
    {
      handler: createHandler,
      method: 'post',
      path: '/',
    },
    {
      handler: deleteHandler,
      method: 'delete',
      path: '/',
    },
    {
      handler: deleteByIDHandler,
      method: 'delete',
      path: '/:id',
    },
    {
      handler: docAccessHandler,
      method: 'post',
      path: '/access/:id?',
    },
    {
      handler: findVersionsHandler,
      method: 'get',
      path: '/versions',
    },
    {
      handler: duplicateHandler,
      method: 'post',
      path: '/:id/duplicate',
    },
    {
      handler: findHandler,
      method: 'get',
      path: '/',
    },
    {
      handler: findByIDHandler,
      method: 'get',
      path: '/:id',
    },
    {
      handler: findVersionByIDHandler,
      method: 'get',
      path: '/versions/:id',
    },
    {
      handler: previewHandler,
      method: 'get',
      path: '/:id/preview',
    },
    {
      handler: restoreVersionHandler,
      method: 'post',
      path: '/versions/:id',
    },
    {
      handler: updateHandler,
      method: 'patch',
      path: '/',
    },
    {
      handler: updateByIDHandler,
      method: 'patch',
      path: '/:id',
    },
  ]),
]
</file>

<file path="convexadmin/admin/src/collections/endpoints/preview.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { extractJWT } from '../../auth/extractJWT.js'
import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { findByIDOperation } from '../operations/findByID.js'

export const previewHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const doc = await findByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    req,
  })

  let previewURL: string

  const generatePreviewURL =
    req.payload?.collections?.[collection.config.slug]?.config?.admin?.preview

  const token = extractJWT(req)

  if (typeof generatePreviewURL === 'function') {
    previewURL = await generatePreviewURL(doc, {
      locale: req.locale,
      req,
      token,
    })
  }

  return Response.json(previewURL, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/restoreVersion.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { restoreVersionOperation } from '../operations/restoreVersion.js'

export const restoreVersionHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const draft = searchParams.get('draft')

  const result = await restoreVersionOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true' ? true : undefined,
    populate: sanitizePopulateParam(req.query.populate),
    req,
  })

  return Response.json(
    {
      ...result,
      message: req.t('version:restoredSuccessfully'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/update.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { updateOperation } from '../operations/update.js'

export const updateHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, draft, limit, overrideLock, populate, select, sort, where } = req.query as {
    depth?: string
    draft?: string
    limit?: string
    overrideLock?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    sort?: string
    where?: Where
  }

  const result = await updateOperation({
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true',
    limit: isNumber(limit) ? Number(limit) : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (result.errors.length === 0) {
    const message = req.t('general:updatedCountSuccessfully', {
      count: result.docs.length,
      label: getTranslation(
        collection.config.labels[result.docs.length === 1 ? 'singular' : 'plural'],
        req.i18n,
      ),
    })

    return Response.json(
      {
        ...result,
        message,
      },
      {
        headers,
        status: httpStatus.OK,
      },
    )
  }

  const total = result.docs.length + result.errors.length
  const message = req.t('error:unableToUpdateCount', {
    count: result.errors.length,
    label: getTranslation(collection.config.labels[total === 1 ? 'singular' : 'plural'], req.i18n),
    total,
  })

  return Response.json(
    {
      ...result,
      message,
    },
    {
      headers,
      status: httpStatus.BAD_REQUEST,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/endpoints/updateByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { updateByIDOperation } from '../operations/updateByID.js'

export const updateByIDHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const autosave = searchParams.get('autosave') === 'true'
  const draft = searchParams.get('draft') === 'true'
  const overrideLock = searchParams.get('overrideLock')
  const publishSpecificLocale = req.query.publishSpecificLocale as string | undefined

  const doc = await updateByIDOperation({
    id,
    autosave,
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(req.query.populate),
    publishSpecificLocale,
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  let message = req.t('general:updatedSuccessfully')

  if (draft) {
    message = req.t('version:draftSavedSuccessfully')
  }
  if (autosave) {
    message = req.t('version:autosavedSuccessfully')
  }

  return Response.json(
    {
      doc,
      message,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/count.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, Where } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { countOperation } from '../count.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   *  Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

// eslint-disable-next-line no-restricted-exports
export default async function countLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<{ totalDocs: number }> {
  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Count Operation.`,
    )
  }

  return countOperation<TSlug>({
    collection,
    disableErrors,
    overrideAccess,
    req: await createLocalReq(options, payload),
    where,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/countVersions.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, Where } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { countVersionsOperation } from '../countVersions.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

// eslint-disable-next-line no-restricted-exports
export default async function countVersionsLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<{ totalDocs: number }> {
  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Count Versions Operation.`,
    )
  }

  return countVersionsOperation<TSlug>({
    collection,
    disableErrors,
    overrideAccess,
    req: await createLocalReq(options, payload),
    where,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/create.ts">
// @ts-strict-ignore
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type { File } from '../../../uploads/types.js'
import type {
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import {
  type CollectionSlug,
  deepCopyObjectSimple,
  type Payload,
  type RequestContext,
  type TypedLocale,
} from '../../../index.js'
import { getFileByPath } from '../../../uploads/getFileByPath.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { createOperation } from '../create.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The data for the document to create.
   */
  data: RequiredDataFromCollectionSlug<TSlug>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * If creating verification-enabled auth doc,
   * you can disable the email that is auto-sent
   */
  disableVerificationEmail?: boolean
  /**
   * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * If you want to create a document that is a duplicate of another document
   */
  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * A `File` object when creating a collection with `upload: true`.
   */
  file?: File
  /**
   * A file path when creating a collection with `upload: true`.
   */
  filePath?: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * If you are uploading a file and would like to replace
   * the existing file instead of generating a new filename,
   * you can set the following property to `true`
   */
  overwriteExistingFiles?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

// eslint-disable-next-line no-restricted-exports
export default async function createLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    disableVerificationEmail,
    draft,
    duplicateFromID,
    file,
    filePath,
    overrideAccess = true,
    overwriteExistingFiles = false,
    populate,
    select,
    showHiddenFields,
  } = options
  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Create Operation.`,
    )
  }

  const req = await createLocalReq(options, payload)
  req.file = file ?? (await getFileByPath(filePath))

  return createOperation<TSlug, TSelect>({
    collection,
    data: deepCopyObjectSimple(data), // Ensure mutation of data in create operation hooks doesn't affect the original data
    depth,
    disableTransaction,
    disableVerificationEmail,
    draft,
    duplicateFromID,
    overrideAccess,
    overwriteExistingFiles,
    populate,
    req,
    select,
    showHiddenFields,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/delete.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { BulkOperationResult, SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { deleteOperation } from '../delete.js'
import { deleteByIDOperation } from '../deleteByID.js'

export type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).
   * @default true
   */
  overrideLock?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export type ByIDOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to delete.
   */
  id: number | string
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: never
} & BaseOptions<TSlug, TSelect>

export type ManyOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to delete.
   */
  id?: never
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where: Where
} & BaseOptions<TSlug, TSelect>

export type Options<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>

async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ByIDOptions<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ManyOptions<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    disableTransaction,
    overrideAccess = true,
    overrideLock,
    populate,
    select,
    showHiddenFields,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Delete Operation.`,
    )
  }

  const args = {
    id,
    collection,
    depth,
    disableTransaction,
    overrideAccess,
    overrideLock,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    where,
  }

  if (options.id) {
    return deleteByIDOperation<TSlug, TSelect>(args)
  }
  return deleteOperation<TSlug, TSelect>(args)
}

export default deleteLocal
</file>

<file path="convexadmin/admin/src/collections/operations/local/duplicate.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug, TypedLocale } from '../../..//index.js'
import type { Payload, RequestContext } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type {
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { duplicateOperation } from '../duplicate.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * Override the data for the document to duplicate.
   */
  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the document to duplicate from.
   */
  id: number | string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export async function duplicate<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    draft,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options
  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Duplicate Operation.`,
    )
  }

  if (collection.config.disableDuplicate === true) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} cannot be duplicated.`,
      400,
    )
  }

  const req = await createLocalReq(options, payload)

  return duplicateOperation<TSlug, TSelect>({
    id,
    collection,
    data,
    depth,
    disableTransaction,
    draft,
    overrideAccess,
    populate,
    req,
    select,
    showHiddenFields,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/find.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../../database/types.js'
import type {
  CollectionSlug,
  JoinQuery,
  Payload,
  RequestContext,
  TypedLocale,
} from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findOperation } from '../find.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The current population depth, used internally for relationships population.
   * @internal
   */
  currentDepth?: number
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   * Whether the documents should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Include info about the lock status to the result into all documents with fields: `_isLocked` and `_userEditing`
   */
  includeLockStatus?: boolean
  /**
   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).
   * Pass `false` to disable all join fields from the result.
   */
  joins?: JoinQuery<TSlug>
  /**
   * The maximum related documents to be returned.
   * Defaults unless `defaultLimit` is specified for the collection config
   * @default 10
   */
  limit?: number
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Get a specific page number
   * @default 1
   */
  page?: number
  /**
   * Set to `false` to return all documents and avoid querying for document counts which introduces some overhead.
   * You can also combine that property with a specified `limit` to limit documents but avoid the count query.
   */
  pagination?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

export async function findLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> {
  const {
    collection: collectionSlug,
    currentDepth,
    depth,
    disableErrors,
    draft = false,
    includeLockStatus,
    joins,
    limit,
    overrideAccess = true,
    page,
    pagination = true,
    populate,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find Operation.`,
    )
  }

  return findOperation<TSlug, TSelect>({
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    limit,
    overrideAccess,
    page,
    pagination,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    sort,
    where,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/findByID.ts">
// @ts-strict-ignore
/* eslint-disable no-restricted-exports */
import type {
  CollectionSlug,
  JoinQuery,
  Payload,
  RequestContext,
  SelectType,
  TypedLocale,
} from '../../../index.js'
import type {
  ApplyDisableErrors,
  Document,
  PayloadRequest,
  PopulateType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type { SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findByIDOperation } from '../findByID.js'

export type Options<
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectType,
> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The current population depth, used internally for relationships population.
   * @internal
   */
  currentDepth?: number
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   * `null` will be returned instead, if the document on this ID was not found.
   */
  disableErrors?: TDisableErrors
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the document to find.
   */
  id: number | string
  /**
   * Include info about the lock status to the result with fields: `_isLocked` and `_userEditing`
   */
  includeLockStatus?: boolean
  /**
   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).
   * Pass `false` to disable all join fields from the result.
   */
  joins?: JoinQuery<TSlug>
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function findByIDLocal<
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TDisableErrors, TSelect>,
): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> {
  const {
    id,
    collection: collectionSlug,
    currentDepth,
    depth,
    disableErrors = false,
    draft = false,
    includeLockStatus,
    joins,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find By ID Operation.`,
    )
  }

  return findByIDOperation<TSlug, TDisableErrors, TSelect>({
    id,
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/findVersionByID.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionByIDOperation } from '../findVersionByID.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   * `null` will be returned instead, if the document on this ID was not found.
   */
  disableErrors?: boolean
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to find.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function findVersionByIDLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    disableErrors = false,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Find Version By ID Operation.`,
    )
  }

  return findVersionByIDOperation({
    id,
    collection,
    depth,
    disableErrors,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/findVersions.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../../database/types.js'
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  Where,
} from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionsOperation } from '../findVersions.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Whether the documents should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The maximum related documents to be returned.
   * Defaults unless `defaultLimit` is specified for the collection config
   * @default 10
   */
  limit?: number
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Get a specific page number
   * @default 1
   */
  page?: number
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-version.createdAt' // Sort DESC by createdAt
   * @example ['version.group', '-version.createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

export default async function findVersionsLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> {
  const {
    collection: collectionSlug,
    depth,
    limit,
    overrideAccess = true,
    page,
    populate,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find Versions Operation.`,
    )
  }

  return findVersionsOperation({
    collection,
    depth,
    limit,
    overrideAccess,
    page,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    sort,
    where,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/index.ts">
/* eslint-disable no-restricted-exports */
import * as auth from '../../../auth/operations/local/index.js'
import count from './count.js'
import countVersions from './countVersions.js'
import create from './create.js'
import deleteLocal from './delete.js'
import { duplicate } from './duplicate.js'
import { findLocal } from './find.js'
import findByID from './findByID.js'
import findVersionByID from './findVersionByID.js'
import findVersions from './findVersions.js'
import restoreVersion from './restoreVersion.js'
import update from './update.js'

export default {
  auth,
  count,
  countVersions,
  create,
  deleteLocal,
  duplicate,
  find: findLocal,
  findByID,
  findVersionByID,
  findVersions,
  restoreVersion,
  update,
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/restoreVersion.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { restoreVersionOperation } from '../restoreVersion.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to restore.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function restoreVersionLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<DataFromCollectionSlug<TSlug>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Restore Version Operation.`,
    )
  }

  const args = {
    id,
    collection,
    depth,
    overrideAccess,
    payload,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  }

  return restoreVersionOperation(args)
}
</file>

<file path="convexadmin/admin/src/collections/operations/local/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { File } from '../../../uploads/types.js'
import type {
  BulkOperationResult,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { getFileByPath } from '../../../uploads/getFileByPath.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { updateOperation } from '../update.js'
import { updateByIDOperation } from '../updateByID.js'

export type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * Whether the current update should be marked as from autosave.
   * `versions.drafts.autosave` should be specified.
   */
  autosave?: boolean
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The document / documents data to update.
   */
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Update documents to a draft.
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * A `File` object when updating a collection with `upload: true`.
   */
  file?: File
  /**
   * A file path when creating a collection with `upload: true`.
   */
  filePath?: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).
   * @default true
   */
  overrideLock?: boolean
  /**
   * If you are uploading a file and would like to replace
   * the existing file instead of generating a new filename,
   * you can set the following property to `true`
   */
  overwriteExistingFiles?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * Publish the document / documents with a specific locale.
   */
  publishSpecificLocale?: string
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export type ByIDOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to update.
   */
  id: number | string
  /**
   * Limit documents to update
   */
  limit?: never
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: never
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: never
} & BaseOptions<TSlug, TSelect>

export type ManyOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to update.
   */
  id?: never
  /**
   * Limit documents to update
   */
  limit?: number
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where: Where
} & BaseOptions<TSlug, TSelect>

export type Options<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>

async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ByIDOptions<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ManyOptions<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    autosave,
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    draft,
    file,
    filePath,
    limit,
    overrideAccess = true,
    overrideLock,
    overwriteExistingFiles = false,
    populate,
    publishSpecificLocale,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Update Operation.`,
    )
  }

  const req = await createLocalReq(options, payload)
  req.file = file ?? (await getFileByPath(filePath))

  const args = {
    id,
    autosave,
    collection,
    data,
    depth,
    disableTransaction,
    draft,
    limit,
    overrideAccess,
    overrideLock,
    overwriteExistingFiles,
    payload,
    populate,
    publishSpecificLocale,
    req,
    select,
    showHiddenFields,
    sort,
    where,
  }

  if (options.id) {
    return updateByIDOperation<TSlug, TSelect>(args)
  }
  return updateOperation<TSlug, TSelect>(args)
}

export default updateLocal
</file>

<file path="convexadmin/admin/src/collections/operations/utilities/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { Args } from '../../../fields/hooks/beforeChange/index.js'
import type {
  Payload,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type {
  DataFromCollectionSlug,
  SanitizedCollectionConfig,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { ensureUsernameOrEmail } from '../../../auth/ensureUsernameOrEmail.js'
import { generatePasswordSaltHash } from '../../../auth/strategies/local/generatePasswordSaltHash.js'
import { combineQueries } from '../../../database/combineQueries.js'
import { afterChange } from '../../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../../fields/hooks/afterRead/index.js'
import { beforeChange } from '../../../fields/hooks/beforeChange/index.js'
import { beforeValidate } from '../../../fields/hooks/beforeValidate/index.js'
import {
  type AccessResult,
  type CollectionSlug,
  deepCopyObjectSimple,
  type FileToSave,
  type SanitizedConfig,
} from '../../../index.js'
import { deleteAssociatedFiles } from '../../../uploads/deleteAssociatedFiles.js'
import { uploadFiles } from '../../../uploads/uploadFiles.js'
import { checkDocumentLockStatus } from '../../../utilities/checkDocumentLockStatus.js'
import { getLatestCollectionVersion } from '../../../versions/getLatestCollectionVersion.js'
import { saveVersion } from '../../../versions/saveVersion.js'

export type SharedUpdateDocumentArgs<TSlug extends CollectionSlug> = {
  accessResults: AccessResult
  autosave: boolean
  collectionConfig: SanitizedCollectionConfig
  config: SanitizedConfig
  data: DeepPartial<DataFromCollectionSlug<TSlug>>
  depth: number
  docWithLocales: any
  draftArg: boolean
  fallbackLocale: string
  filesToUpload: FileToSave[]
  id: number | string
  locale: string
  overrideAccess: boolean
  overrideLock: boolean
  payload: Payload
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select: SelectType
  showHiddenFields: boolean
}

/**
 * This function is used to update a document in the DB and return the result.
 *
 * It runs the following hooks in order:
 * - beforeValidate - Fields
 * - beforeValidate - Collection
 * - beforeChange - Collection
 * - beforeChange - Fields
 * - afterRead - Fields
 * - afterRead - Collection
 * - afterChange - Fields
 * - afterChange - Collection
 */
export const updateDocument = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,
>({
  id,
  accessResults,
  autosave,
  collectionConfig,
  config,
  data,
  depth,
  docWithLocales,
  draftArg,
  fallbackLocale,
  filesToUpload,
  locale,
  overrideAccess,
  overrideLock,
  payload,
  populate,
  publishSpecificLocale,
  req,
  select,
  showHiddenFields,
}: SharedUpdateDocumentArgs<TSlug>): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  const password = data?.password
  const shouldSaveDraft =
    Boolean(draftArg && collectionConfig.versions.drafts) && data._status !== 'published'
  const shouldSavePassword = Boolean(
    password &&
      collectionConfig.auth &&
      (!collectionConfig.auth.disableLocalStrategy ||
        (typeof collectionConfig.auth.disableLocalStrategy === 'object' &&
          collectionConfig.auth.disableLocalStrategy.enableFields)) &&
      !shouldSaveDraft,
  )

  // /////////////////////////////////////
  // Handle potentially locked documents
  // /////////////////////////////////////

  await checkDocumentLockStatus({
    id,
    collectionSlug: collectionConfig.slug,
    lockErrorMessage: `Document with ID ${id} is currently locked by another user and cannot be updated.`,
    overrideLock,
    req,
  })

  const originalDoc = await afterRead({
    collection: collectionConfig,
    context: req.context,
    depth: 0,
    doc: deepCopyObjectSimple(docWithLocales),
    draft: draftArg,
    fallbackLocale: id ? null : fallbackLocale,
    global: null,
    locale,
    overrideAccess: true,
    req,
    showHiddenFields: true,
  })

  if (collectionConfig.auth) {
    ensureUsernameOrEmail<TSlug>({
      authOptions: collectionConfig.auth,
      collectionSlug: collectionConfig.slug,
      data,
      operation: 'update',
      originalDoc,
      req,
    })
  }

  // /////////////////////////////////////
  // Delete any associated files
  // /////////////////////////////////////

  await deleteAssociatedFiles({
    collectionConfig,
    config,
    doc: docWithLocales,
    files: filesToUpload,
    overrideDelete: false,
    req,
  })

  // /////////////////////////////////////
  // beforeValidate - Fields
  // /////////////////////////////////////

  data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({
    id,
    collection: collectionConfig,
    context: req.context,
    data,
    doc: originalDoc,
    global: null,
    operation: 'update',
    overrideAccess,
    req,
  })

  // /////////////////////////////////////
  // beforeValidate - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.beforeValidate?.length) {
    for (const hook of collectionConfig.hooks.beforeValidate) {
      data =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          data,
          operation: 'update',
          originalDoc,
          req,
        })) || data
    }
  }

  // /////////////////////////////////////
  // Write files to local storage
  // /////////////////////////////////////

  if (!collectionConfig.upload.disableLocalStorage) {
    await uploadFiles(payload, filesToUpload, req)
  }

  // /////////////////////////////////////
  // beforeChange - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.beforeChange?.length) {
    for (const hook of collectionConfig.hooks.beforeChange) {
      data =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          data,
          operation: 'update',
          originalDoc,
          req,
        })) || data
    }
  }

  // /////////////////////////////////////
  // beforeChange - Fields
  // /////////////////////////////////////

  let publishedDocWithLocales = docWithLocales
  let versionSnapshotResult

  const beforeChangeArgs: Args<DataFromCollectionSlug<TSlug>> = {
    id,
    collection: collectionConfig,
    context: req.context,
    data: { ...data, id },
    doc: originalDoc,
    docWithLocales: undefined,
    global: null,
    operation: 'update',
    req,
    skipValidation:
      shouldSaveDraft &&
      collectionConfig.versions.drafts &&
      !collectionConfig.versions.drafts.validate,
  }

  if (publishSpecificLocale) {
    versionSnapshotResult = await beforeChange({
      ...beforeChangeArgs,
      docWithLocales,
    })

    const lastPublished = await getLatestCollectionVersion({
      id,
      config: collectionConfig,
      payload,
      published: true,
      query: {
        collection: collectionConfig.slug,
        locale,
        req,
        where: combineQueries({ id: { equals: id } }, accessResults),
      },
      req,
    })

    publishedDocWithLocales = lastPublished ? lastPublished : {}
  }

  let result = await beforeChange({
    ...beforeChangeArgs,
    docWithLocales: publishedDocWithLocales,
  })

  // /////////////////////////////////////
  // Handle potential password update
  // /////////////////////////////////////

  const dataToUpdate: Record<string, unknown> = { ...result }

  if (shouldSavePassword && typeof password === 'string') {
    const { hash, salt } = await generatePasswordSaltHash({
      collection: collectionConfig,
      password,
      req,
    })
    dataToUpdate.salt = salt
    dataToUpdate.hash = hash
    delete dataToUpdate.password
    delete data.password
  }

  // /////////////////////////////////////
  // Update
  // /////////////////////////////////////

  if (!shouldSaveDraft) {
    result = await req.payload.db.updateOne({
      id,
      collection: collectionConfig.slug,
      data: dataToUpdate,
      locale,
      req,
      select,
    })
  }

  // /////////////////////////////////////
  // Create version
  // /////////////////////////////////////

  if (collectionConfig.versions) {
    result = await saveVersion({
      id,
      autosave,
      collection: collectionConfig,
      docWithLocales: result,
      draft: shouldSaveDraft,
      payload,
      publishSpecificLocale,
      req,
      select,
      snapshot: versionSnapshotResult,
    })
  }

  // /////////////////////////////////////
  // afterRead - Fields
  // /////////////////////////////////////

  result = await afterRead({
    collection: collectionConfig,
    context: req.context,
    depth,
    doc: result,
    draft: draftArg,
    fallbackLocale,
    global: null,
    locale,
    overrideAccess,
    populate,
    req,
    select,
    showHiddenFields,
  })

  // /////////////////////////////////////
  // afterRead - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.afterRead?.length) {
    for (const hook of collectionConfig.hooks.afterRead) {
      result =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          doc: result,
          req,
        })) || result
    }
  }

  // /////////////////////////////////////
  // afterChange - Fields
  // /////////////////////////////////////

  result = await afterChange({
    collection: collectionConfig,
    context: req.context,
    data,
    doc: result,
    global: null,
    operation: 'update',
    previousDoc: originalDoc,
    req,
  })

  // /////////////////////////////////////
  // afterChange - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.afterChange?.length) {
    for (const hook of collectionConfig.hooks.afterChange) {
      result =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          doc: result,
          operation: 'update',
          previousDoc: originalDoc,
          req,
        })) || result
    }
  }

  return result as TransformCollectionWithSelect<TSlug, TSelect>
}
</file>

<file path="convexadmin/admin/src/collections/operations/count.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, Where } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  disableErrors?: boolean
  overrideAccess?: boolean
  req?: PayloadRequest
  where?: Where
}

export const countOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments,
): Promise<{ totalDocs: number }> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'count',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      disableErrors,
      overrideAccess,
      req: { payload },
      req,
      where,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          totalDocs: 0,
        }
      }
    }

    let result: { totalDocs: number }

    const fullWhere = combineQueries(where, accessResult)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    result = await payload.db.count({
      collection: collectionConfig.slug,
      req,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'count',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/countVersions.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, Where } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { buildVersionCollectionFields, type CollectionSlug } from '../../index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  disableErrors?: boolean
  overrideAccess?: boolean
  req?: PayloadRequest
  where?: Where
}

export const countVersionsOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments,
): Promise<{ totalDocs: number }> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'countVersions',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      disableErrors,
      overrideAccess,
      req: { payload },
      req,
      where,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess(
        { disableErrors, req },
        collectionConfig.access.readVersions,
      )

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          totalDocs: 0,
        }
      }
    }

    let result: { totalDocs: number }

    const fullWhere = combineQueries(where, accessResult)

    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    result = await payload.db.countVersions({
      collection: collectionConfig.slug,
      req,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'countVersions',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/create.ts">
// @ts-strict-ignore
import crypto from 'crypto'

import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  AfterChangeHook,
  BeforeOperationHook,
  BeforeValidateHook,
  Collection,
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'
import executeAccess from '../../auth/executeAccess.js'
import { sendVerificationEmail } from '../../auth/sendVerificationEmail.js'
import { registerLocalStrategy } from '../../auth/strategies/local/register.js'
import { getDuplicateDocumentData } from '../../duplicateDocument/index.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { beforeChange } from '../../fields/hooks/beforeChange/index.js'
import { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'
import { type CollectionSlug, type JsonObject } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { uploadFiles } from '../../uploads/uploadFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { saveVersion } from '../../versions/saveVersion.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  autosave?: boolean
  collection: Collection
  data: RequiredDataFromCollectionSlug<TSlug>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']
  overrideAccess?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const createOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    ensureUsernameOrEmail<TSlug>({
      authOptions: args.collection.config.auth,
      collectionSlug: args.collection.config.slug,
      data: args.data,
      operation: 'create',
      req: args.req,
    })

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'create',
            req: args.req,
          })) || args
      }
    }

    const {
      autosave = false,
      collection: { config: collectionConfig },
      collection,
      depth,
      disableVerificationEmail,
      draft = false,
      duplicateFromID,
      overrideAccess,
      overwriteExistingFiles = false,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload,
        payload: { config },
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    let { data } = args

    const shouldSaveDraft = Boolean(draft && collectionConfig.versions.drafts)

    let duplicatedFromDocWithLocales: JsonObject = {}
    let duplicatedFromDoc: JsonObject = {}

    if (duplicateFromID) {
      const duplicateResult = await getDuplicateDocumentData({
        id: duplicateFromID,
        collectionConfig,
        draftArg: shouldSaveDraft,
        overrideAccess,
        req,
        shouldSaveDraft,
      })

      duplicatedFromDoc = duplicateResult.duplicatedFromDoc
      duplicatedFromDocWithLocales = duplicateResult.duplicatedFromDocWithLocales
    }

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    if (!overrideAccess) {
      await executeAccess({ data, req }, collectionConfig.access.create)
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data: newFileData, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data,
      isDuplicating: Boolean(duplicateFromID),
      operation: 'create',
      originalDoc: duplicatedFromDoc,
      overwriteExistingFiles,
      req,
      throwOnMissingFile:
        !shouldSaveDraft && collection.config.upload.filesRequiredOnCreate !== false,
    })

    data = newFileData

    // /////////////////////////////////////
    // beforeValidate - Fields
    // /////////////////////////////////////

    data = await beforeValidate({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: duplicatedFromDoc,
      global: null,
      operation: 'create',
      overrideAccess,
      req,
    })

    // /////////////////////////////////////
    // beforeValidate - Collections
    // /////////////////////////////////////

    if (collectionConfig.hooks.beforeValidate?.length) {
      for (const hook of collectionConfig.hooks.beforeValidate) {
        data =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            data,
            operation: 'create',
            originalDoc: duplicatedFromDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeChange?.length) {
      for (const hook of collectionConfig.hooks.beforeChange) {
        data =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            data,
            operation: 'create',
            originalDoc: duplicatedFromDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Fields
    // /////////////////////////////////////

    const resultWithLocales = await beforeChange<JsonObject>({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: duplicatedFromDoc,
      docWithLocales: duplicatedFromDocWithLocales,
      global: null,
      operation: 'create',
      req,
      skipValidation:
        shouldSaveDraft &&
        collectionConfig.versions.drafts &&
        !collectionConfig.versions.drafts.validate,
    })

    // /////////////////////////////////////
    // Write files to local storage
    // /////////////////////////////////////

    if (!collectionConfig.upload.disableLocalStorage) {
      await uploadFiles(payload, filesToUpload, req)
    }

    // /////////////////////////////////////
    // Create
    // /////////////////////////////////////

    let doc

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    if (collectionConfig.auth && !collectionConfig.auth.disableLocalStrategy) {
      if (collectionConfig.auth.verify) {
        resultWithLocales._verified = Boolean(resultWithLocales._verified) || false
        resultWithLocales._verificationToken = crypto.randomBytes(20).toString('hex')
      }

      doc = await registerLocalStrategy({
        collection: collectionConfig,
        doc: resultWithLocales,
        password: data.password as string,
        payload: req.payload,
        req,
        select,
      })
    } else {
      doc = await payload.db.create({
        collection: collectionConfig.slug,
        data: resultWithLocales,
        req,
        select,
      })
    }

    const verificationToken = doc._verificationToken
    let result: Document = sanitizeInternalFields(doc)

    // /////////////////////////////////////
    // Create version
    // /////////////////////////////////////

    if (collectionConfig.versions) {
      await saveVersion({
        id: result.id,
        autosave,
        collection: collectionConfig,
        docWithLocales: result,
        payload,
        req,
      })
    }

    // /////////////////////////////////////
    // Send verification email if applicable
    // /////////////////////////////////////

    if (collectionConfig.auth && collectionConfig.auth.verify && result.email) {
      await sendVerificationEmail({
        collection: { config: collectionConfig },
        config: payload.config,
        disableEmail: disableVerificationEmail,
        email: payload.email,
        req,
        token: verificationToken,
        user: result,
      })
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: result,
      global: null,
      operation: 'create',
      previousDoc: {},
      req,
    })

    // /////////////////////////////////////
    // afterChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterChange?.length) {
      for (const hook of collectionConfig.hooks.afterChange) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            operation: 'create',
            previousDoc: {},
            req: args.req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation<TSlug>({
      args,
      collection: collectionConfig,
      operation: 'create',
      result,
    })

    await unlinkTempFiles({ collectionConfig, config, req })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/delete.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { AccessResult } from '../../config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, PopulateType, SelectType, Where } from '../../types/index.js'
import type {
  BeforeOperationHook,
  BulkOperationResult,
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { APIError } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'
import { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'
import { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'
import { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  depth?: number
  disableTransaction?: boolean
  overrideAccess?: boolean
  overrideLock?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  where: Where
}

export const deleteOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<BulkOperationResult<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'delete',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      depth,
      overrideAccess,
      overrideLock,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
      where,
    } = args

    if (!where) {
      throw new APIError("Missing 'where' query of documents to delete.", httpStatus.BAD_REQUEST)
    }

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ req }, collectionConfig.access.delete)
    }

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    const fullWhere = combineQueries(where, accessResult)

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Retrieve documents
    // /////////////////////////////////////

    const { docs } = await payload.db.find<DataFromCollectionSlug<TSlug>>({
      collection: collectionConfig.slug,
      locale,
      req,
      select,
      where: fullWhere,
    })

    const errors = []

    const promises = docs.map(async (doc) => {
      let result

      const { id } = doc

      try {
        // /////////////////////////////////////
        // Handle potentially locked documents
        // /////////////////////////////////////

        await checkDocumentLockStatus({
          id,
          collectionSlug: collectionConfig.slug,
          lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,
          overrideLock,
          req,
        })

        // /////////////////////////////////////
        // beforeDelete - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.beforeDelete?.length) {
          for (const hook of collectionConfig.hooks.beforeDelete) {
            await hook({
              id,
              collection: collectionConfig,
              context: req.context,
              req,
            })
          }
        }

        await deleteAssociatedFiles({
          collectionConfig,
          config,
          doc,
          overrideDelete: true,
          req,
        })

        // /////////////////////////////////////
        // Delete versions
        // /////////////////////////////////////

        if (collectionConfig.versions) {
          await deleteCollectionVersions({
            id,
            slug: collectionConfig.slug,
            payload,
            req,
          })
        }

        // /////////////////////////////////////
        // Delete scheduled posts
        // /////////////////////////////////////
        if (collectionConfig.versions?.drafts && collectionConfig.versions.drafts.schedulePublish) {
          await deleteScheduledPublishJobs({
            id,
            slug: collectionConfig.slug,
            payload,
            req,
          })
        }

        // /////////////////////////////////////
        // Delete document
        // /////////////////////////////////////

        await payload.db.deleteOne({
          collection: collectionConfig.slug,
          req,
          returning: false,
          where: {
            id: {
              equals: id,
            },
          },
        })

        // /////////////////////////////////////
        // afterRead - Fields
        // /////////////////////////////////////

        result = await afterRead({
          collection: collectionConfig,
          context: req.context,
          depth,
          doc: result || doc,
          draft: undefined,
          fallbackLocale,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select,
          showHiddenFields,
        })

        // /////////////////////////////////////
        // afterRead - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.afterRead?.length) {
          for (const hook of collectionConfig.hooks.afterRead) {
            result =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: result || doc,
                req,
              })) || result
          }
        }

        // /////////////////////////////////////
        // afterDelete - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.afterDelete?.length) {
          for (const hook of collectionConfig.hooks.afterDelete) {
            result =
              (await hook({
                id,
                collection: collectionConfig,
                context: req.context,
                doc: result,
                req,
              })) || result
          }
        }

        // /////////////////////////////////////
        // 8. Return results
        // /////////////////////////////////////

        return result
      } catch (error) {
        errors.push({
          id: doc.id,
          message: error.message,
        })
      }
      return null
    })

    const awaitedDocs = await Promise.all(promises)

    // /////////////////////////////////////
    // Delete Preferences
    // /////////////////////////////////////

    await deleteUserPreferences({
      collectionConfig,
      ids: docs.map(({ id }) => id),
      payload,
      req,
    })

    let result = {
      docs: awaitedDocs.filter(Boolean),
      errors,
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'delete',
      result,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/deleteByID.ts">
// @ts-strict-ignore
import type { CollectionSlug } from '../../index.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type { BeforeOperationHook, Collection, DataFromCollectionSlug } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { Forbidden, NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'
import { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'
import { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'
import { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  depth?: number
  disableTransaction?: boolean
  id: number | string
  overrideAccess?: boolean
  overrideLock?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const deleteByIDOperation = async <TSlug extends CollectionSlug, TSelect extends SelectType>(
  incomingArgs: Arguments,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'delete',
            req: args.req,
          })) || args
      }
    }

    const {
      id,
      collection: { config: collectionConfig },
      depth,
      overrideAccess,
      overrideLock,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, req }, collectionConfig.access.delete)
      : true
    const hasWhereAccess = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // beforeDelete - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeDelete?.length) {
      for (const hook of collectionConfig.hooks.beforeDelete) {
        await hook({
          id,
          collection: collectionConfig,
          context: req.context,
          req,
        })
      }
    }

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const docToDelete = await req.payload.db.findOne({
      collection: collectionConfig.slug,
      locale: req.locale,
      req,
      where: combineQueries({ id: { equals: id } }, accessResults),
    })

    if (!docToDelete && !hasWhereAccess) {
      throw new NotFound(req.t)
    }
    if (!docToDelete && hasWhereAccess) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // Handle potentially locked documents
    // /////////////////////////////////////

    await checkDocumentLockStatus({
      id,
      collectionSlug: collectionConfig.slug,
      lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,
      overrideLock,
      req,
    })

    await deleteAssociatedFiles({
      collectionConfig,
      config,
      doc: docToDelete,
      overrideDelete: true,
      req,
    })

    // /////////////////////////////////////
    // Delete versions
    // /////////////////////////////////////

    if (collectionConfig.versions) {
      await deleteCollectionVersions({
        id,
        slug: collectionConfig.slug,
        payload,
        req,
      })
    }

    // /////////////////////////////////////
    // Delete scheduled posts
    // /////////////////////////////////////
    if (collectionConfig.versions?.drafts && collectionConfig.versions.drafts.schedulePublish) {
      await deleteScheduledPublishJobs({
        id,
        slug: collectionConfig.slug,
        payload,
        req,
      })
    }

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Delete document
    // /////////////////////////////////////

    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.deleteOne({
      collection: collectionConfig.slug,
      req,
      select,
      where: { id: { equals: id } },
    })

    // /////////////////////////////////////
    // Delete Preferences
    // /////////////////////////////////////

    await deleteUserPreferences({
      collectionConfig,
      ids: [id],
      payload,
      req,
    })

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterDelete - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterDelete?.length) {
      for (const hook of collectionConfig.hooks.afterDelete) {
        result =
          (await hook({
            id,
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'deleteByID',
      result,
    })

    // /////////////////////////////////////
    // 8. Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result as TransformCollectionWithSelect<TSlug, TSelect>
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/docAccess.ts">
// @ts-strict-ignore
import type { SanitizedCollectionPermission } from '../../auth/index.js'
import type { AllOperations, PayloadRequest } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import { getEntityPolicies } from '../../utilities/getEntityPolicies.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizePermissions } from '../../utilities/sanitizePermissions.js'

const allOperations: AllOperations[] = ['create', 'read', 'update', 'delete']

type Arguments = {
  collection: Collection
  id: number | string
  req: PayloadRequest
}

export async function docAccessOperation(args: Arguments): Promise<SanitizedCollectionPermission> {
  const {
    id,
    collection: { config },
    req,
  } = args

  const collectionOperations = [...allOperations]

  if (
    config.auth &&
    typeof config.auth.maxLoginAttempts !== 'undefined' &&
    config.auth.maxLoginAttempts !== 0
  ) {
    collectionOperations.push('unlock')
  }

  if (config.versions) {
    collectionOperations.push('readVersions')
  }

  try {
    const result = await getEntityPolicies({
      id,
      type: 'collection',
      blockPolicies: {},
      entity: config,
      operations: collectionOperations,
      req,
    })

    const sanitizedPermissions = sanitizePermissions({
      collections: {
        [config.slug]: result,
      },
    })

    return sanitizedPermissions?.collections?.[config.slug]
  } catch (e: unknown) {
    await killTransaction(req)
    throw e
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/duplicate.ts">
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug } from '../../index.js'
import type { TransformCollectionWithSelect } from '../../types/index.js'
import type { RequiredDataFromCollectionSlug, SelectFromCollectionSlug } from '../config/types.js'

import { type Arguments as CreateArguments, createOperation } from './create.js'

export type Arguments<TSlug extends CollectionSlug> = {
  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  id: number | string
} & Omit<CreateArguments<TSlug>, 'data' | 'duplicateFromID'>

export const duplicateOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  const { id, ...args } = incomingArgs
  return createOperation({
    ...args,
    data: incomingArgs?.data || {},
    duplicateFromID: id,
  })
}
</file>

<file path="convexadmin/admin/src/collections/operations/find.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PaginatedDocs } from '../../database/types.js'
import type { CollectionSlug, JoinQuery } from '../../index.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../types/index.js'
import type {
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'
import { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  includeLockStatus?: boolean
  joins?: JoinQuery
  limit?: number
  overrideAccess?: boolean
  page?: number
  pagination?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  sort?: Sort
  where?: Where
}

const lockDurationDefault = 300 // Default 5 minutes in seconds

export const findOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'read',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      collection,
      currentDepth,
      depth,
      disableErrors,
      draft: draftsEnabled,
      includeLockStatus,
      joins,
      limit,
      overrideAccess,
      page,
      pagination = true,
      populate,
      req: { fallbackLocale, locale, payload },
      req,
      select: incomingSelect,
      showHiddenFields,
      sort,
      where,
    } = args

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          docs: [],
          hasNextPage: false,
          hasPrevPage: false,
          limit,
          nextPage: null,
          page: 1,
          pagingCounter: 1,
          prevPage: null,
          totalDocs: 0,
          totalPages: 1,
        }
      }
    }

    // /////////////////////////////////////
    // Find
    // /////////////////////////////////////

    const usePagination = pagination && limit !== 0
    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)
    const sanitizedPage = page || 1

    let result: PaginatedDocs<DataFromCollectionSlug<TSlug>>

    let fullWhere = combineQueries(where, accessResult)

    const sanitizedJoins = await sanitizeJoinQuery({
      collectionConfig,
      joins,
      overrideAccess,
      req,
    })

    if (collectionConfig.versions?.drafts && draftsEnabled) {
      fullWhere = appendVersionToQueryKey(fullWhere)

      await validateQueryPaths({
        collectionConfig: collection.config,
        overrideAccess,
        req,
        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),
        where: appendVersionToQueryKey(where),
      })

      result = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
        limit: sanitizedLimit,
        locale,
        page: sanitizedPage,
        pagination: usePagination,
        req,
        select: getQueryDraftsSelect({ select }),
        sort: getQueryDraftsSort({ collectionConfig, sort }),
        where: fullWhere,
      })
    } else {
      await validateQueryPaths({
        collectionConfig,
        overrideAccess,
        req,
        where,
      })

      result = await payload.db.find<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        draftsEnabled,
        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
        limit: sanitizedLimit,
        locale,
        page: sanitizedPage,
        pagination,
        req,
        select,
        sort,
        where: fullWhere,
      })
    }

    if (includeLockStatus) {
      try {
        const lockDocumentsProp = collectionConfig?.lockDocuments

        const lockDuration =
          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault
        const lockDurationInMilliseconds = lockDuration * 1000

        const now = new Date().getTime()

        const lockedDocuments = await payload.find({
          collection: lockedDocumentsCollectionSlug,
          depth: 1,
          limit: sanitizedLimit,
          overrideAccess: false,
          pagination: false,
          req,
          where: {
            and: [
              {
                'document.relationTo': {
                  equals: collectionConfig.slug,
                },
              },
              {
                'document.value': {
                  in: result.docs.map((doc) => doc.id),
                },
              },
              // Query where the lock is newer than the current time minus lock time
              {
                updatedAt: {
                  greater_than: new Date(now - lockDurationInMilliseconds),
                },
              },
            ],
          },
        })

        const lockedDocs = Array.isArray(lockedDocuments?.docs) ? lockedDocuments.docs : []

        // Filter out stale locks
        const validLockedDocs = lockedDocs.filter((lock) => {
          const lastEditedAt = new Date(lock?.updatedAt).getTime()
          return lastEditedAt + lockDurationInMilliseconds > now
        })

        for (const doc of result.docs) {
          const lockedDoc = validLockedDocs.find((lock) => lock?.document?.value === doc.id)
          doc._isLocked = !!lockedDoc
          doc._userEditing = lockedDoc ? lockedDoc?.user?.value : null
        }
      } catch (_err) {
        for (const doc of result.docs) {
          doc._isLocked = false
          doc._userEditing = null
        }
      }
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig?.hooks?.beforeRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          let docRef = doc

          for (const hook of collectionConfig.hooks.beforeRead) {
            docRef =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef,
                query: fullWhere,
                req,
              })) || docRef
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.docs = await Promise.all(
      result.docs.map(async (doc) =>
        afterRead<DataFromCollectionSlug<TSlug>>({
          collection: collectionConfig,
          context: req.context,
          currentDepth,
          depth,
          doc,
          draft: draftsEnabled,
          fallbackLocale,
          findMany: true,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select,
          showHiddenFields,
        }),
      ),
    )

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig?.hooks?.afterRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          let docRef = doc

          for (const hook of collectionConfig.hooks.afterRead) {
            docRef =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef,
                findMany: true,
                query: fullWhere,
                req,
              })) || doc
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'find',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result as PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/findByID.ts">
// @ts-strict-ignore
import type { FindOneArgs } from '../../database/types.js'
import type { CollectionSlug, JoinQuery } from '../../index.js'
import type {
  ApplyDisableErrors,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'
import { NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { validateQueryPaths } from '../../index.js'
import { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import replaceWithDraftIfAvailable from '../../versions/drafts/replaceWithDraftIfAvailable.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  id: number | string
  includeLockStatus?: boolean
  joins?: JoinQuery
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const findByIDOperation = async <
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'read',
            req: args.req,
          })) || args
      }
    }

    const {
      id,
      collection: { config: collectionConfig },
      currentDepth,
      depth,
      disableErrors,
      draft: draftEnabled = false,
      includeLockStatus,
      joins,
      overrideAccess = false,
      populate,
      req: { fallbackLocale, locale, t },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResult = !overrideAccess
      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.read)
      : true

    // If errors are disabled, and access returns false, return null
    if (accessResult === false) {
      return null
    }

    const where = { id: { equals: id } }

    const fullWhere = combineQueries(where, accessResult)

    const sanitizedJoins = await sanitizeJoinQuery({
      collectionConfig,
      joins,
      overrideAccess,
      req,
    })

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      draftsEnabled: draftEnabled,
      joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
      locale,
      req: {
        transactionID: req.transactionID,
      } as PayloadRequest,
      select,
      where: fullWhere,
    }

    // execute only if there's a custom ID and potentially overwriten access on id
    if (req.payload.collections[collectionConfig.slug].customIDType) {
      await validateQueryPaths({
        collectionConfig,
        overrideAccess,
        req,
        where,
      })
    }
    // /////////////////////////////////////
    // Find by ID
    // /////////////////////////////////////

    if (!findOneArgs.where.and[0].id) {
      throw new NotFound(t)
    }

    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.findOne(findOneArgs)

    if (!result) {
      if (!disableErrors) {
        throw new NotFound(req.t)
      }

      return null
    }

    // /////////////////////////////////////
    // Include Lock Status if required
    // /////////////////////////////////////

    if (includeLockStatus && id) {
      let lockStatus = null

      try {
        const lockDocumentsProp = collectionConfig?.lockDocuments

        const lockDurationDefault = 300 // Default 5 minutes in seconds
        const lockDuration =
          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault
        const lockDurationInMilliseconds = lockDuration * 1000

        const lockedDocument = await req.payload.find({
          collection: lockedDocumentsCollectionSlug,
          depth: 1,
          limit: 1,
          overrideAccess: false,
          pagination: false,
          req,
          where: {
            and: [
              {
                'document.relationTo': {
                  equals: collectionConfig.slug,
                },
              },
              {
                'document.value': {
                  equals: id,
                },
              },
              // Query where the lock is newer than the current time minus lock time
              {
                updatedAt: {
                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),
                },
              },
            ],
          },
        })

        if (lockedDocument && lockedDocument.docs.length > 0) {
          lockStatus = lockedDocument.docs[0]
        }
      } catch {
        // swallow error
      }

      result._isLocked = !!lockStatus
      result._userEditing = lockStatus?.user?.value ?? null
    }

    // /////////////////////////////////////
    // Replace document with draft if available
    // /////////////////////////////////////

    if (collectionConfig.versions?.drafts && draftEnabled) {
      result = await replaceWithDraftIfAvailable({
        accessResult,
        doc: result,
        entity: collectionConfig,
        entityType: 'collection',
        overrideAccess,
        req,
        select,
      })
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeRead?.length) {
      for (const hook of collectionConfig.hooks.beforeRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            query: findOneArgs.where,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      currentDepth,
      depth,
      doc: result,
      draft: draftEnabled,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            query: findOneArgs.where,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'findByID',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result as ApplyDisableErrors<
      TransformCollectionWithSelect<TSlug, TSelect>,
      TDisableErrors
    >
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/findVersionByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { Collection, TypeWithID } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const findVersionByIDOperation = async <TData extends TypeWithID = any>(
  args: Arguments,
): Promise<TypeWithVersion<TData>> => {
  const {
    id,
    collection: { config: collectionConfig },
    currentDepth,
    depth,
    disableErrors,
    overrideAccess,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
  } = args

  if (!id) {
    throw new APIError('Missing ID of version.', httpStatus.BAD_REQUEST)
  }

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.readVersions)
      : true

    // If errors are disabled, and access returns false, return null
    if (accessResults === false) {
      return null
    }

    const hasWhereAccess = typeof accessResults === 'object'

    const fullWhere = combineQueries({ id: { equals: id } }, accessResults)

    // /////////////////////////////////////
    // Find by ID
    // /////////////////////////////////////

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),
      select: incomingSelect,
    })

    const versionsQuery = await payload.db.findVersions<TData>({
      collection: collectionConfig.slug,
      limit: 1,
      locale,
      pagination: false,
      req,
      select,
      where: fullWhere,
    })

    const result = versionsQuery.docs[0]

    if (!result) {
      if (!disableErrors) {
        if (!hasWhereAccess) {
          throw new NotFound(req.t)
        }
        if (hasWhereAccess) {
          throw new Forbidden(req.t)
        }
      }

      return null
    }

    if (!result.version) {
      // Fallback if not selected
      ;(result as any).version = {}
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeRead?.length) {
      for (const hook of collectionConfig.hooks.beforeRead) {
        result.version =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result.version,
            query: fullWhere,
            req,
          })) || result.version
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.version = await afterRead({
      collection: collectionConfig,
      context: req.context,
      currentDepth,
      depth,
      doc: result.version,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select: typeof select?.version === 'object' ? select.version : undefined,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result.version =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result.version,
            query: fullWhere,
            req,
          })) || result.version
      }
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/findVersions.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  collection: Collection
  depth?: number
  limit?: number
  overrideAccess?: boolean
  page?: number
  pagination?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  sort?: Sort
  where?: Where
}

export const findVersionsOperation = async <TData extends TypeWithVersion<TData>>(
  args: Arguments,
): Promise<PaginatedDocs<TData>> => {
  const {
    collection: { config: collectionConfig },
    depth,
    limit,
    overrideAccess,
    page,
    pagination = true,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
    sort,
    where,
  } = args

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResults

    if (!overrideAccess) {
      accessResults = await executeAccess({ req }, collectionConfig.access.readVersions)
    }

    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    const fullWhere = combineQueries(where, accessResults)

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Find
    // /////////////////////////////////////

    const paginatedDocs = await payload.db.findVersions<TData>({
      collection: collectionConfig.slug,
      limit: limit ?? 10,
      locale,
      page: page || 1,
      pagination,
      req,
      select,
      sort,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////
    const result: PaginatedDocs<TData> = paginatedDocs as unknown as PaginatedDocs<TData>
    result.docs = (await Promise.all(
      paginatedDocs.docs.map(async (doc) => {
        const docRef = doc
        // Fallback if not selected
        if (!docRef.version) {
          ;(docRef as any).version = {}
        }

        if (collectionConfig.hooks?.beforeRead?.length) {
          for (const hook of collectionConfig.hooks.beforeRead) {
            docRef.version =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef.version,
                query: fullWhere,
                req,
              })) || docRef.version
          }
        }

        return docRef
      }),
    )) as TData[]
    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.docs = await Promise.all(
      result.docs.map(async (data) => {
        data.version = await afterRead({
          collection: collectionConfig,
          context: req.context,
          depth,
          doc: data.version,
          draft: undefined,
          fallbackLocale,
          findMany: true,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select: typeof select?.version === 'object' ? select.version : undefined,
          showHiddenFields,
        })
        return data
      }),
    )

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks.afterRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          const docRef = doc

          for (const hook of collectionConfig.hooks.afterRead) {
            docRef.version =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: doc.version,
                findMany: true,
                query: fullWhere,
                req,
              })) || doc.version
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////
    result.docs = result.docs.map((doc) => sanitizeInternalFields<TData>(doc))

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/restoreVersion.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { FindOneArgs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'
import type { Collection, TypeWithID } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const restoreVersionOperation = async <TData extends TypeWithID = any>(
  args: Arguments,
): Promise<TData> => {
  const {
    id,
    collection: { config: collectionConfig },
    depth,
    draft,
    overrideAccess = false,
    populate,
    req,
    req: { fallbackLocale, locale, payload },
    select: incomingSelect,
    showHiddenFields,
  } = args

  try {
    if (!id) {
      throw new APIError('Missing ID of version to restore.', httpStatus.BAD_REQUEST)
    }

    // /////////////////////////////////////
    // Retrieve original raw version
    // /////////////////////////////////////

    const { docs: versionDocs } = await req.payload.db.findVersions({
      collection: collectionConfig.slug,
      limit: 1,
      locale,
      pagination: false,
      req,
      where: { id: { equals: id } },
    })

    const [rawVersion] = versionDocs

    if (!rawVersion) {
      throw new NotFound(req.t)
    }

    const parentDocID = rawVersion.parent

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id: parentDocID, req }, collectionConfig.access.update)
      : true
    const hasWherePolicy = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      locale,
      req,
      where: combineQueries({ id: { equals: parentDocID } }, accessResults),
    }

    const doc = await req.payload.db.findOne(findOneArgs)

    if (!doc && !hasWherePolicy) {
      throw new NotFound(req.t)
    }
    if (!doc && hasWherePolicy) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // fetch previousDoc
    // /////////////////////////////////////

    const prevDocWithLocales = await getLatestCollectionVersion({
      id: parentDocID,
      config: collectionConfig,
      payload,
      query: findOneArgs,
      req,
    })

    // /////////////////////////////////////
    // Update
    // /////////////////////////////////////

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    let result = await req.payload.db.updateOne({
      id: parentDocID,
      collection: collectionConfig.slug,
      data: rawVersion.version,
      req,
      select,
    })

    // /////////////////////////////////////
    // Save `previousDoc` as a version after restoring
    // /////////////////////////////////////

    const prevVersion = { ...prevDocWithLocales }

    delete prevVersion.id

    await payload.db.createVersion({
      autosave: false,
      collectionSlug: collectionConfig.slug,
      createdAt: prevVersion.createdAt,
      parent: parentDocID,
      req,
      updatedAt: new Date().toISOString(),
      versionData: draft ? { ...rawVersion.version, _status: 'draft' } : rawVersion.version,
    })

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: collectionConfig,
      context: req.context,
      data: result,
      doc: result,
      global: null,
      operation: 'update',
      previousDoc: prevDocWithLocales,
      req,
    })

    // /////////////////////////////////////
    // afterChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterChange?.length) {
      for (const hook of collectionConfig.hooks.afterChange) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            operation: 'update',
            previousDoc: prevDocWithLocales,
            req,
          })) || result
      }
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import { status as httpStatus } from 'http-status'

import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'
import type {
  BulkOperationResult,
  Collection,
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { APIError } from '../../errors/index.js'
import { type CollectionSlug, deepCopyObjectSimple } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'
import { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'
import { updateDocument } from './utilities/update.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  limit?: number
  overrideAccess?: boolean
  overrideLock?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  where: Where
}

export const updateOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<BulkOperationResult<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'update',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      collection,
      depth,
      draft: draftArg = false,
      limit = 0,
      overrideAccess,
      overrideLock,
      overwriteExistingFiles = false,
      populate,
      publishSpecificLocale,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
      sort,
      where,
    } = args

    if (!where) {
      throw new APIError("Missing 'where' query of documents to update.", httpStatus.BAD_REQUEST)
    }

    const { data: bulkUpdateData } = args
    const shouldSaveDraft = Boolean(draftArg && collectionConfig.versions.drafts)

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult
    if (!overrideAccess) {
      accessResult = await executeAccess({ req }, collectionConfig.access.update)
    }

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    // /////////////////////////////////////
    // Retrieve documents
    // /////////////////////////////////////

    const fullWhere = combineQueries(where, accessResult)

    let docs

    if (collectionConfig.versions?.drafts && shouldSaveDraft) {
      const versionsWhere = appendVersionToQueryKey(fullWhere)

      await validateQueryPaths({
        collectionConfig: collection.config,
        overrideAccess,
        req,
        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),
        where: appendVersionToQueryKey(where),
      })

      const query = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        limit,
        locale,
        pagination: false,
        req,
        sort: getQueryDraftsSort({ collectionConfig, sort }),
        where: versionsWhere,
      })

      docs = query.docs
    } else {
      const query = await payload.db.find({
        collection: collectionConfig.slug,
        limit,
        locale,
        pagination: false,
        req,
        sort,
        where: fullWhere,
      })

      docs = query.docs
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data: bulkUpdateData,
      operation: 'update',
      overwriteExistingFiles,
      req,
      throwOnMissingFile: false,
    })

    const errors = []

    const promises = docs.map(async (docWithLocales) => {
      const { id } = docWithLocales

      try {
        const select = sanitizeSelect({
          forceSelect: collectionConfig.forceSelect,
          select: incomingSelect,
        })

        // ///////////////////////////////////////////////
        // Update document, runs all document level hooks
        // ///////////////////////////////////////////////
        const updatedDoc = await updateDocument({
          id,
          accessResults: accessResult,
          autosave: false,
          collectionConfig,
          config,
          data: deepCopyObjectSimple(data),
          depth,
          docWithLocales,
          draftArg,
          fallbackLocale,
          filesToUpload,
          locale,
          overrideAccess,
          overrideLock,
          payload,
          populate,
          publishSpecificLocale,
          req,
          select,
          showHiddenFields,
        })

        return updatedDoc
      } catch (error) {
        errors.push({
          id,
          message: error.message,
        })
      }
      return null
    })

    await unlinkTempFiles({
      collectionConfig,
      config,
      req,
    })

    const awaitedDocs = await Promise.all(promises)

    let result = {
      docs: awaitedDocs.filter(Boolean),
      errors,
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'update',
      result,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/updateByID.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import { status as httpStatus } from 'http-status'

import type { FindOneArgs } from '../../database/types.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  Collection,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { type CollectionSlug, deepCopyObjectSimple } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'
import { updateDocument } from './utilities/update.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  autosave?: boolean
  collection: Collection
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  id: number | string
  overrideAccess?: boolean
  overrideLock?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const updateByIDOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'update',
            req: args.req,
          })) || args
      }
    }

    if (args.publishSpecificLocale) {
      args.req.locale = args.publishSpecificLocale
    }

    const {
      id,
      autosave = false,
      collection: { config: collectionConfig },
      collection,
      depth,
      draft: draftArg = false,
      overrideAccess,
      overrideLock,
      overwriteExistingFiles = false,
      populate,
      publishSpecificLocale,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    if (!id) {
      throw new APIError('Missing ID of document to update.', httpStatus.BAD_REQUEST)
    }

    const { data } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, data, req }, collectionConfig.access.update)
      : true
    const hasWherePolicy = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      locale,
      req,
      where: combineQueries({ id: { equals: id } }, accessResults),
    }

    const docWithLocales = await getLatestCollectionVersion({
      id,
      config: collectionConfig,
      payload,
      query: findOneArgs,
      req,
    })

    if (!docWithLocales && !hasWherePolicy) {
      throw new NotFound(req.t)
    }
    if (!docWithLocales && hasWherePolicy) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data: newFileData, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data,
      operation: 'update',
      overwriteExistingFiles,
      req,
      throwOnMissingFile: false,
    })

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // ///////////////////////////////////////////////
    // Update document, runs all document level hooks
    // ///////////////////////////////////////////////

    let result = await updateDocument<TSlug, TSelect>({
      id,
      accessResults,
      autosave,
      collectionConfig,
      config,
      data: deepCopyObjectSimple(newFileData),
      depth,
      docWithLocales,
      draftArg,
      fallbackLocale,
      filesToUpload,
      locale,
      overrideAccess,
      overrideLock,
      payload,
      populate,
      publishSpecificLocale,
      req,
      select,
      showHiddenFields,
    })

    await unlinkTempFiles({
      collectionConfig,
      config,
      req,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = (await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'updateByID',
      result,
    })) as TransformCollectionWithSelect<TSlug, TSelect>

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="convexadmin/admin/src/collections/operations/utils.ts">
import type { forgotPasswordOperation } from '../../auth/operations/forgotPassword.js'
import type { loginOperation } from '../../auth/operations/login.js'
import type { refreshOperation } from '../../auth/operations/refresh.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest } from '../../types/index.js'
import type {
  AfterOperationHook,
  SanitizedCollectionConfig,
  SelectFromCollectionSlug,
} from '../config/types.js'
import type { countOperation } from './count.js'
import type { countVersionsOperation } from './countVersions.js'
import type { createOperation } from './create.js'
import type { deleteOperation } from './delete.js'
import type { deleteByIDOperation } from './deleteByID.js'
import type { findOperation } from './find.js'
import type { findByIDOperation } from './findByID.js'
import type { updateOperation } from './update.js'
import type { updateByIDOperation } from './updateByID.js'

export type AfterOperationMap<TOperationGeneric extends CollectionSlug> = {
  count: typeof countOperation<TOperationGeneric>
  countVersions: typeof countVersionsOperation<TOperationGeneric>
  create: typeof createOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  delete: typeof deleteOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  deleteByID: typeof deleteByIDOperation<
    TOperationGeneric,
    SelectFromCollectionSlug<TOperationGeneric>
  >
  find: typeof findOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  findByID: typeof findByIDOperation<
    TOperationGeneric,
    boolean,
    SelectFromCollectionSlug<TOperationGeneric>
  >
  forgotPassword: typeof forgotPasswordOperation
  login: typeof loginOperation<TOperationGeneric>
  refresh: typeof refreshOperation
  update: typeof updateOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  updateByID: typeof updateByIDOperation<
    TOperationGeneric,
    SelectFromCollectionSlug<TOperationGeneric>
  >
}

export type AfterOperationArg<TOperationGeneric extends CollectionSlug> = {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  req: PayloadRequest
} & (
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['count']>[0]
      operation: 'count'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['count']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['countVersions']>[0]
      operation: 'countVersions'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['countVersions']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['create']>[0]
      operation: 'create'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['create']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['delete']>[0]
      operation: 'delete'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['delete']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['deleteByID']>[0]
      operation: 'deleteByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['deleteByID']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['find']>[0]
      operation: 'find'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['find']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['findByID']>[0]
      operation: 'findByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['findByID']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['forgotPassword']>[0]
      operation: 'forgotPassword'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['forgotPassword']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['login']>[0]
      operation: 'login'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['login']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['refresh']>[0]
      operation: 'refresh'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['refresh']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['update']>[0]
      operation: 'update'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['update']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['updateByID']>[0]
      operation: 'updateByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['updateByID']>>
    }
)

type OperationResult<
  TOperationGeneric extends CollectionSlug,
  O extends keyof AfterOperationMap<TOperationGeneric>,
> = Awaited<ReturnType<AfterOperationMap<TOperationGeneric>[O]>>

export const buildAfterOperation = async <
  TOperationGeneric extends CollectionSlug,
  O extends keyof AfterOperationMap<TOperationGeneric> = keyof AfterOperationMap<TOperationGeneric>,
>(
  operationArgs: { operation: O } & Omit<AfterOperationArg<TOperationGeneric>, 'req'>,
): Promise<any | OperationResult<TOperationGeneric, O>> => {
  const { args, collection, operation, result } = operationArgs

  let newResult = result as OperationResult<TOperationGeneric, O>

  if (args.collection.config.hooks?.afterOperation?.length) {
    for (const hook of args.collection.config.hooks.afterOperation) {
      const hookResult = await hook({
        args,
        collection,
        operation,
        req: args.req,
        result: newResult,
      } as AfterOperationArg<TOperationGeneric>)

      if (hookResult !== undefined) {
        newResult = hookResult as OperationResult<TOperationGeneric, O>
      }
    }
  }

  return newResult
}
</file>

<file path="convexadmin/admin/src/collections/dataloader.ts">
// @ts-strict-ignore
import type { BatchLoadFn } from 'dataloader'

import DataLoader from 'dataloader'

import type { FindArgs } from '../database/types.js'
import type { PayloadRequest, PopulateType, SelectType } from '../types/index.js'
import type { TypeWithID } from './config/types.js'
import type { Options } from './operations/local/find.js'

import { isValidID } from '../utilities/isValidID.js'

// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.

// We keep a list of all documents requested to be populated for any given request
// and then batch together documents within the same collection,
// making only 1 find per each collection, rather than `findByID` per each requested doc.

// This dramatically improves performance for REST and Local API `depth` populations,
// and also ensures complex GraphQL queries perform lightning-fast.

const batchAndLoadDocs =
  (req: PayloadRequest): BatchLoadFn<string, TypeWithID> =>
  async (keys: string[]): Promise<TypeWithID[]> => {
    const { payload } = req

    // Create docs array of same length as keys, using null as value
    // We will replace nulls with injected docs as they are retrieved
    const docs: (null | TypeWithID)[] = keys.map(() => null)

    /**
    * Batch IDs by their `find` args
    * so we can make one find query per combination of collection, depth, locale, and fallbackLocale.
    *
    * Resulting shape will be as follows:
      {
        // key is stringified set of find args
        '[null,"pages",2,0,"es","en",false,false]': [
          // value is array of IDs to find with these args
          'q34tl23462346234524',
          '435523540194324280',
          '2346245j35l3j5234532li',
        ],
        // etc
      };
    *
    **/

    const batchByFindArgs = {}

    for (const key of keys) {
      const [
        transactionID,
        collection,
        id,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ] = JSON.parse(key)

      const batchKeyArray = [
        transactionID,
        collection,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ]

      const batchKey = JSON.stringify(batchKeyArray)

      const idType = payload.collections?.[collection].customIDType || payload.db.defaultIDType
      const sanitizedID = idType === 'number' ? parseFloat(id) : id

      if (isValidID(sanitizedID, idType)) {
        batchByFindArgs[batchKey] = [...(batchByFindArgs[batchKey] || []), sanitizedID]
      }
    }

    // Run find requests one after another, so as to not hang transactions

    for (const [batchKey, ids] of Object.entries(batchByFindArgs)) {
      const [
        transactionID,
        collection,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ] = JSON.parse(batchKey)

      req.transactionID = transactionID

      const result = await payload.find({
        collection,
        currentDepth,
        depth,
        disableErrors: true,
        draft,
        fallbackLocale,
        locale,
        overrideAccess: Boolean(overrideAccess),
        pagination: false,
        populate,
        req,
        select,
        showHiddenFields: Boolean(showHiddenFields),
        where: {
          id: {
            in: ids,
          },
        },
      })

      // For each returned doc, find index in original keys
      // Inject doc within docs array if index exists
      for (const doc of result.docs) {
        const docKey = createDataloaderCacheKey({
          collectionSlug: collection,
          currentDepth,
          depth,
          docID: doc.id,
          draft,
          fallbackLocale,
          locale,
          overrideAccess,
          populate,
          select,
          showHiddenFields,
          transactionID: req.transactionID,
        })
        const docsIndex = keys.findIndex((key) => key === docKey)

        if (docsIndex > -1) {
          docs[docsIndex] = doc
        }
      }
    }

    // Return docs array,
    // which has now been injected with all fetched docs
    // and should match the length of the incoming keys arg
    return docs
  }

export const getDataLoader = (req: PayloadRequest) => {
  const findQueries = new Map()
  const dataLoader = new DataLoader(batchAndLoadDocs(req)) as PayloadRequest['payloadDataLoader']

  dataLoader.find = (args: FindArgs) => {
    const key = createFindDataloaderCacheKey(args)
    const cached = findQueries.get(key)
    if (cached) {
      return cached
    }
    const request = req.payload.find(args)
    findQueries.set(key, request)
    return request
  }

  return dataLoader
}

const createFindDataloaderCacheKey = ({
  collection,
  currentDepth,
  depth,
  disableErrors,
  draft,
  includeLockStatus,
  joins,
  limit,
  overrideAccess,
  page,
  pagination,
  populate,
  req,
  select,
  showHiddenFields,
  sort,
  where,
}: Options<string, SelectType>): string =>
  JSON.stringify([
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    limit,
    overrideAccess,
    page,
    pagination,
    populate,
    req?.locale,
    req?.fallbackLocale,
    req?.user?.id,
    req?.transactionID,
    select,
    showHiddenFields,
    sort,
    where,
  ])

type CreateCacheKeyArgs = {
  collectionSlug: string
  currentDepth: number
  depth: number
  docID: number | string
  draft: boolean
  fallbackLocale: string
  locale: string
  overrideAccess: boolean
  populate?: PopulateType
  select?: SelectType
  showHiddenFields: boolean
  transactionID: number | Promise<number | string> | string
}
export const createDataloaderCacheKey = ({
  collectionSlug,
  currentDepth,
  depth,
  docID,
  draft,
  fallbackLocale,
  locale,
  overrideAccess,
  populate,
  select,
  showHiddenFields,
  transactionID,
}: CreateCacheKeyArgs): string =>
  JSON.stringify([
    transactionID,
    collectionSlug,
    docID,
    depth,
    currentDepth,
    locale,
    fallbackLocale,
    overrideAccess,
    showHiddenFields,
    draft,
    select,
    populate,
  ])
</file>

<file path="convexadmin/admin/src/components/data-table/data-table-column-header.tsx">
"use client";

import { ArrowDown, ArrowUp, ChevronsUpDown, EyeOff } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/convexadmin/components/ui/dropdown-menu";

import { Button } from "@/convexadmin/components/ui/button";
import { Column } from "@tanstack/react-table";
import { cn } from "@/convexadmin/lib/utils";

interface DataTableColumnHeaderProps<TData, TValue>
  extends React.HTMLAttributes<HTMLDivElement> {
  column: Column<TData, TValue>;
  title: string;
}

export function DataTableColumnHeader<TData, TValue>({
  column,
  title,
  className,
}: DataTableColumnHeaderProps<TData, TValue>) {
  if (!column.getCanSort()) {
    return <div className={cn(className)}>{title}</div>;
  }

  return (
    <div className={cn("flex items-center space-x-2", className)}>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            size="sm"
            className="-ml-3 h-8 data-[state=open]:bg-accent"
          >
            <span>{title}</span>
            {column.getIsSorted() === "desc" ? (
              <ArrowDown className="ml-2 h-4 w-4" />
            ) : column.getIsSorted() === "asc" ? (
              <ArrowUp className="ml-2 h-4 w-4" />
            ) : (
              <ChevronsUpDown className="ml-2 h-4 w-4" />
            )}
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="start">
          <DropdownMenuItem onClick={() => column.toggleSorting(false)}>
            <ArrowUp className="mr-2 h-3.5 w-3.5 text-muted-foreground/70" />
            Asc
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => column.toggleSorting(true)}>
            <ArrowDown className="mr-2 h-3.5 w-3.5 text-muted-foreground/70" />
            Desc
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem onClick={() => column.toggleVisibility(false)}>
            <EyeOff className="mr-2 h-3.5 w-3.5 text-muted-foreground/70" />
            Hide
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
</file>

<file path="convexadmin/admin/src/components/data-table/data-table-pagination.tsx">
"use client";

import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/convexadmin/components/ui/select";

import { Button } from "@/convexadmin/components/ui/button";
import { Table } from "@tanstack/react-table";

interface DataTablePaginationProps<TData> {
  table: Table<TData>;
}

export function DataTablePagination<TData>({
  table,
}: DataTablePaginationProps<TData>) {
  return (
    <div className="flex items-center justify-between px-2 py-4">
      <div className="flex-1 text-sm text-muted-foreground">
        {table.getFilteredSelectedRowModel().rows.length} of{" "}
        {table.getFilteredRowModel().rows.length} row(s) selected.
      </div>
      <div className="flex items-center space-x-6 lg:space-x-8">
        <div className="flex items-center space-x-2">
          <p className="text-sm font-medium">Rows per page</p>
          <Select
            value={`${table.getState().pagination.pageSize}`}
            onValueChange={(value) => {
              table.setPageSize(Number(value));
            }}
          >
            <SelectTrigger className="h-8 w-[70px]">
              <SelectValue placeholder={table.getState().pagination.pageSize} />
            </SelectTrigger>
            <SelectContent side="top">
              {[10, 20, 30, 40, 50].map((pageSize) => (
                <SelectItem key={pageSize} value={`${pageSize}`}>
                  {pageSize}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="flex w-[100px] items-center justify-center text-sm font-medium">
          Page {table.getState().pagination.pageIndex + 1} of{" "}
          {table.getPageCount()}
        </div>
        <div className="flex items-center space-x-2">
          <Button
            variant="outline"
            className="hidden h-8 w-8 p-0 lg:flex"
            onClick={() => table.setPageIndex(0)}
            disabled={!table.getCanPreviousPage()}
          >
            <span className="sr-only">Go to first page</span>
            <ChevronsLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="h-8 w-8 p-0"
            onClick={() => table.previousPage()}
            disabled={!table.getCanPreviousPage()}
          >
            <span className="sr-only">Go to previous page</span>
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="h-8 w-8 p-0"
            onClick={() => table.nextPage()}
            disabled={!table.getCanNextPage()}
          >
            <span className="sr-only">Go to next page</span>
            <ChevronRight className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            className="hidden h-8 w-8 p-0 lg:flex"
            onClick={() => table.setPageIndex(table.getPageCount() - 1)}
            disabled={!table.getCanNextPage()}
          >
            <span className="sr-only">Go to last page</span>
            <ChevronsRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="convexadmin/admin/src/components/data-table/data-table-row-actions.tsx">
"use client";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/convexadmin/components/ui/dropdown-menu";

import { Button } from "@/convexadmin/components/ui/button";
import Link from "next/link";
import { MoreHorizontal } from "lucide-react";
import { Row } from "@tanstack/react-table";

// We need the collection slug to build the correct links
interface DataTableRowActionsProps<TData extends { _id: string }> {
  row: Row<TData>;
  collectionSlug: string;
}

export function DataTableRowActions<TData extends { _id: string }>({
  row,
  collectionSlug,
}: DataTableRowActionsProps<TData>) {
  const docId = row.original._id;

  const handleDelete = () => {
    // TODO: Implement delete mutation
    console.warn(
      `Delete action clicked for doc: ${docId}, collection: ${collectionSlug}`,
    );
    alert(`Delete action triggered for ${docId}. Implement mutation.`);
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          className="flex h-8 w-8 p-0 data-[state=open]:bg-muted"
        >
          <MoreHorizontal className="h-4 w-4" />
          <span className="sr-only">Open menu</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[160px]">
        <DropdownMenuItem asChild>
          <Link href={`/admin/collections/${collectionSlug}/${docId}`}>
            View
          </Link>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={handleDelete} className="text-red-600">
          Delete
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="convexadmin/admin/src/components/data-table/data-table-view-options.tsx">
"use client";

import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
} from "@/convexadmin/components/ui/dropdown-menu";

import { Button } from "@/convexadmin/components/ui/button";
import { DropdownMenuTrigger } from "@radix-ui/react-dropdown-menu";
import { Settings2 } from "lucide-react";
import { Table } from "@tanstack/react-table";

interface DataTableViewOptionsProps<TData> {
  table: Table<TData>;
}

export function DataTableViewOptions<TData>({
  table,
}: DataTableViewOptionsProps<TData>) {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className="ml-auto hidden h-8 lg:flex"
        >
          <Settings2 className="mr-2 h-4 w-4" />
          View
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[150px]">
        <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
        <DropdownMenuSeparator />
        {table
          .getAllColumns()
          .filter(
            (column) =>
              typeof column.accessorFn !== "undefined" && column.getCanHide(),
          )
          .map((column) => {
            return (
              <DropdownMenuCheckboxItem
                key={column.id}
                className="capitalize"
                checked={column.getIsVisible()}
                onCheckedChange={(value) => column.toggleVisibility(!!value)}
              >
                {(column.columnDef.header as string) || column.id}
              </DropdownMenuCheckboxItem>
            );
          })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="convexadmin/admin/src/components/elements/RenderServerComponent.tsx">
import type { ImportMap, PayloadComponent } from '@convexcms/core'

import { getFromImportMap, isPlainObject, isReactServerComponentOrFunction } from '@convexcms/core/shared'
import React from 'react'

import { removeUndefined } from '../../utilities/removeUndefined.js'

type RenderServerComponentFn = (args: {
  readonly clientProps?: object
  readonly Component?:
    | PayloadComponent
    | PayloadComponent[]
    | React.ComponentType
    | React.ComponentType[]
  readonly Fallback?: React.ComponentType
  readonly importMap: ImportMap
  readonly key?: string
  readonly serverProps?: object
}) => React.ReactNode

/**
 * Can be used to render both MappedComponents and React Components.
 */
export const RenderServerComponent: RenderServerComponentFn = ({
  clientProps = {},
  Component,
  Fallback,
  importMap,
  key,
  serverProps,
}) => {
  if (Array.isArray(Component)) {
    return Component.map((c, index) =>
      RenderServerComponent({
        clientProps,
        Component: c,
        importMap,
        key: index,
        serverProps,
      }),
    )
  }

  if (typeof Component === 'function') {
    const isRSC = isReactServerComponentOrFunction(Component)

    // prevent $undefined from being passed through the rsc requests
    const sanitizedProps = removeUndefined({
      ...clientProps,
      ...(isRSC ? serverProps : {}),
    })

    return <Component key={key} {...sanitizedProps} />
  }

  if (typeof Component === 'string' || isPlainObject(Component)) {
    const ResolvedComponent = getFromImportMap<React.ComponentType>({
      importMap,
      PayloadComponent: Component,
      schemaPath: '',
    })

    if (ResolvedComponent) {
      const isRSC = isReactServerComponentOrFunction(ResolvedComponent)

      // prevent $undefined from being passed through rsc requests
      const sanitizedProps = removeUndefined({
        ...clientProps,
        ...(isRSC ? serverProps : {}),
        ...(isRSC && typeof Component === 'object' && Component?.serverProps
          ? Component.serverProps
          : {}),
        ...(typeof Component === 'object' && Component?.clientProps ? Component.clientProps : {}),
      })

      return <ResolvedComponent key={key} {...sanitizedProps} />
    }
  }

  return Fallback
    ? RenderServerComponent({
        clientProps,
        Component: Fallback,
        importMap,
        key,
        serverProps,
      })
    : null
}
</file>

<file path="convexadmin/admin/src/components/puck/fields/ColumnConfigField.tsx">
"use client";

import React, { useEffect, useState } from "react";

// import type { FieldProps } from "@measured/puck"; // Removed unused import
import { GripVertical } from "lucide-react";
import type { ItemLoopColumnConfig } from "../ItemLoop";
// Corrected Shadcn UI import paths
import { Label } from "@/convexadmin/components/ui/label";
import { Switch } from "@/convexadmin/components/ui/switch";
import { api } from "@/convex/_generated/api";
import { usePuck } from "@measured/puck"; // Import usePuck
import { useQuery } from "convex/react";

// Shadcn UI Accordion & Input
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/convexadmin/components/ui/accordion";
import { Input } from "@/convexadmin/components/ui/input";

// Import Button
import { Button } from "@/convexadmin/components/ui/button";

// Dnd Imports
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";

// Define the props structure expected by Puck's render function
interface CustomFieldRenderProps {
  field: { label?: string; [key: string]: any }; // Basic field definition structure
  name: string;
  id: string;
  value: ItemLoopColumnConfig[] | undefined;
  onChange: (value: ItemLoopColumnConfig[] | undefined) => void;
  readOnly?: boolean;
}

// Helper type
type ManagedColumn = ItemLoopColumnConfig & {
  isFromData: boolean;
  // id: string; // Use 'key' as the stable identifier for dnd-kit
};

// --- SortableItem Component --- //
interface SortableItemProps {
  col: ManagedColumn;
  handleVisibilityChange: (key: string, checked: boolean) => void;
  handleLabelChange: (key: string, newLabel: string) => void; // Add label change handler
}

const SortableItem: React.FC<SortableItemProps> = ({
  col,
  handleVisibilityChange,
  handleLabelChange,
}) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: col.key });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    // Add other styles as needed, e.g., zIndex while dragging
  };

  return (
    <AccordionItem value={col.key} className="border-b-0">
      <div
        ref={setNodeRef}
        style={style}
        className="rounded border bg-muted/50 overflow-hidden"
      >
        <AccordionTrigger
          {...attributes}
          className="flex w-full items-center justify-between gap-2 p-2 hover:no-underline"
        >
          <div className="flex items-center gap-2 flex-grow min-w-0">
            <button {...listeners} className="cursor-grab p-1 flex-shrink-0">
              <GripVertical className="h-4 w-4 text-muted-foreground" />
            </button>
            <span
              className="text-sm font-mono truncate flex-grow"
              title={col.key}
            >
              {col.key}
            </span>
          </div>
          <Switch
            className="flex-shrink-0 mr-2"
            checked={col.visible}
            onClick={(e) => e.stopPropagation()}
            onCheckedChange={(checked: boolean) =>
              handleVisibilityChange(col.key, checked)
            }
            aria-label={`Toggle visibility for column ${col.key}`}
          />
        </AccordionTrigger>

        <AccordionContent className="p-3 pt-0">
          <div className="space-y-1.5">
            <Label htmlFor={`label-${col.key}`} className="text-xs">
              Display Name
            </Label>
            <Input
              id={`label-${col.key}`}
              placeholder="(defaults to column key)"
              value={col.label || ""}
              onChange={(e) => handleLabelChange(col.key, e.target.value)}
              className="text-xs h-8"
            />
          </div>
        </AccordionContent>
      </div>
    </AccordionItem>
  );
};
// --- End SortableItem --- //

// Update component signature: use standard function declaration
export const ColumnConfigField = ({
  value = [],
  onChange,
  field,
}: CustomFieldRenderProps) => {
  // Get Puck state, specifically the selected item
  const { selectedItem } = usePuck();

  // Get tableName dynamically from the selected ItemLoop component's props
  // Assuming the custom field is used directly on ItemLoop
  const tableName = selectedItem?.props?.tableName as string | undefined;

  const fetchedKeys = useQuery(
    api.documents.getDocumentKeys,
    tableName ? { tableName: tableName as any } : "skip",
  );

  const [managedColumns, setManagedColumns] = useState<ManagedColumn[]>([]);

  // Effect to merge fetched keys and initial value
  useEffect(() => {
    const configMap = new Map(
      value.map((item: ItemLoopColumnConfig) => [item.key, item]),
    );
    const fetchedKeysSet = new Set(fetchedKeys || []);
    const newManagedColumns: ManagedColumn[] = [];

    // Prioritize order from `value` if items exist there
    value.forEach((item: ItemLoopColumnConfig) => {
      newManagedColumns.push({
        ...item,
        isFromData: fetchedKeysSet.has(item.key),
      });
    });

    // Add newly discovered keys not in `value`
    (fetchedKeys || []).forEach((key) => {
      if (!configMap.has(key)) {
        newManagedColumns.push({
          key: key,
          visible: true,
          isFromData: true,
        });
      }
    });

    // Update state only if changed (no need to sort for this initial merge)
    if (JSON.stringify(newManagedColumns) !== JSON.stringify(managedColumns)) {
      setManagedColumns(newManagedColumns);
    }
  }, [value, fetchedKeys]); // Only depend on value and fetchedKeys for merging

  // Dnd Sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  // Handler for drag end
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setManagedColumns((items) => {
        const oldIndex = items.findIndex((item) => item.key === active.id);
        const newIndex = items.findIndex((item) => item.key === over.id);
        const reorderedItems = arrayMove(items, oldIndex, newIndex);

        // Save the reordered state back to Puck
        const configToSave = reorderedItems.map(
          ({ isFromData, ...rest }: ManagedColumn) => rest,
        );
        onChange(configToSave);

        return reorderedItems;
      });
    }
  };

  // Handler for visibility change (remains the same conceptually)
  const handleVisibilityChange = (key: string, newVisibility: boolean) => {
    const updatedColumns = managedColumns.map((col) =>
      col.key === key ? { ...col, visible: newVisibility } : col,
    );
    // Update local state immediately
    setManagedColumns(updatedColumns);
    // Save the updated state back to Puck
    const configToSave = updatedColumns.map(
      ({ isFromData, ...rest }: ManagedColumn) => rest,
    );
    onChange(configToSave);
  };

  // Handler for label change
  const handleLabelChange = (key: string, newLabel: string) => {
    const updatedColumns = managedColumns.map(
      (col) =>
        col.key === key ? { ...col, label: newLabel || undefined } : col, // Set to undefined if empty
    );
    setManagedColumns(updatedColumns);
    const configToSave = updatedColumns.map(
      ({ isFromData, ...rest }: ManagedColumn) => rest,
    );
    onChange(configToSave);
  };

  // Handler for Reset button
  const handleReset = () => {
    if (!fetchedKeys) return; // Cannot reset if keys aren't loaded

    // Create the default config: all fetched keys visible, sorted, no labels
    const defaultConfig: ItemLoopColumnConfig[] = fetchedKeys
      .map((key) => ({ key: key, visible: true, label: undefined }))
      .sort((a, b) => a.key.localeCompare(b.key)); // Consistent default sort

    // Update local state (add isFromData for internal consistency)
    const defaultManagedColumns: ManagedColumn[] = defaultConfig.map((col) => ({
      ...col,
      isFromData: true,
    }));
    setManagedColumns(defaultManagedColumns);

    // Save the default state back to Puck
    onChange(defaultConfig);
  };

  if (!tableName) {
    return (
      <div className="text-sm text-muted-foreground p-2 border rounded">
        Select a Data Source table first.
      </div>
    );
  }

  if (fetchedKeys === undefined && !value.length) {
    // Show loading only if no keys fetched AND no initial value
    return (
      <div className="text-sm text-muted-foreground p-2 border rounded">
        Loading columns for {tableName}...
      </div>
    );
  }

  // Render the list using DndContext and SortableContext
  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={managedColumns.map((col) => col.key)}
        strategy={verticalListSortingStrategy}
      >
        <div className="space-y-2 rounded border p-3 bg-background">
          {/* Header Row with Label and Reset Button */}
          <div className="flex items-center justify-between mb-2">
            <Label className="font-medium">
              {field.label || "Column Visibility & Order"}
            </Label>
            <Button
              variant="outline"
              size="sm"
              onClick={handleReset}
              disabled={!fetchedKeys} // Disable if keys aren't loaded
              className="text-xs h-7"
            >
              Reset
            </Button>
          </div>

          {managedColumns.length === 0 && (
            <p className="text-sm text-muted-foreground">
              No columns found or configured for {tableName}.
            </p>
          )}
          <Accordion type="single" collapsible className="w-full space-y-2">
            {managedColumns.map((col) => (
              <SortableItem
                key={col.key}
                col={col}
                handleVisibilityChange={handleVisibilityChange}
                handleLabelChange={handleLabelChange}
              />
            ))}
          </Accordion>
        </div>
      </SortableContext>
    </DndContext>
  );
};
</file>

<file path="convexadmin/admin/src/components/puck/fields/SliderField.tsx">
"use client";

import type { CustomField } from "@measured/puck";
import { Label } from "@/convexadmin/components/ui/label";
import React from "react";
import type { ReactElement } from "react"; // Removed JSXElementConstructor
import { Slider } from "@/convexadmin/components/ui/slider";

// Define the exact prop structure expected by Puck for custom field render
type PuckRenderProps = {
  field: CustomField<number | undefined> & {
    min?: number;
    max?: number;
    label?: string;
  };
  name: string;
  id: string; // Puck provides an id
  value: number | undefined;
  onChange: (value: number | undefined) => void;
  readOnly?: boolean | undefined;
};

// Use the PuckRenderProps directly in the component function signature
export const SliderField = ({
  field,
  name,
  id, // Accept the id prop
  value,
  onChange,
  // readOnly // Accept if needed
}: PuckRenderProps): ReactElement => {
  // Match return type
  // Match return type
  const label = field.label ?? name;
  const min = field.min ?? 1;
  const max = field.max ?? 6;

  const currentValue =
    typeof value === "number" && value >= min && value <= max ? value : min;

  const handleValueChange = (newValue: number[]) => {
    onChange(newValue[0]);
  };

  return (
    <div>
      <Label htmlFor={id} className="mb-2 block text-sm font-medium">
        {label}
      </Label>
      <div className="flex items-center space-x-3">
        <Slider
          id={id} // Use the id prop from Puck
          name={name}
          value={[currentValue]}
          min={min}
          max={max}
          step={1}
          onValueChange={handleValueChange}
          className="flex-grow"
        />
        <span className="w-8 text-right text-sm font-medium tabular-nums">
          {currentValue}
        </span>
      </div>
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/puck/HeadingBlock.tsx">
"use client";

import React from "react";

export type HeadingBlockProps = {
  children: string;
  backgroundColor?: string;

  specificSettings?: {
    children: string;
  };
  globalStyles?: {
    backgroundColor?: string;
  };

  // Dummy prop to match the top-level custom field key in config
  groupedSettings?: object;
};

export const HeadingBlock: React.FC<HeadingBlockProps> = ({ children }) => {
  // Note: We use React directly here, useState example from docs isn't needed for basic rendering
  return <h1>{children}</h1>;
};

// Default export might be useful depending on config style
export default HeadingBlock;
</file>

<file path="convexadmin/admin/src/components/puck/ItemLoop.tsx">
"use client";

import type { Doc } from "@/convex/_generated/dataModel";
import React from "react";
import { api } from "@/convex/_generated/api";
import { useQuery } from "convex/react";

export type ItemLoopColumnConfig = {
  key: string; // The original key from the data object
  visible: boolean;
  label?: string; // Optional: Custom display name for the column
};

// Expanded props
export type ItemLoopProps = {
  tableName?: string; // Add tableName prop
  displayMode?: "grid" | "table";
  gridColumns?: number;
  spacing?: "sm" | "md" | "lg";
  backgroundColor?: string;
  columnConfig?: ItemLoopColumnConfig[]; // Array for column config

  // Dummy prop to match the top-level custom field key in config
  groupedSettings?: object;
  // Remove unused nested prop definitions
  // specificSettings?: { ... };
  // globalStyles?: { ... };
};

// Helper function to render a single item (used by both list and table)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const renderItemData = (data: any) => {
  if (
    typeof data === "string" ||
    typeof data === "number" ||
    typeof data === "boolean"
  ) {
    return String(data);
  }
  // Basic JSON representation for objects/arrays - customize as needed
  return (
    <pre className="overflow-x-auto text-xs">
      {JSON.stringify(data, null, 2)}
    </pre>
  );
};

export const ItemLoop: React.FC<ItemLoopProps> = (props) => {
  console.log("[ItemLoop] Received props:", props);

  const {
    tableName,
    displayMode = "grid",
    gridColumns = 3,
    spacing = "md",
    backgroundColor,
    columnConfig = [], // Destructure columnConfig, default to empty array
  } = props;

  console.log("[ItemLoop] Derived displayMode:", displayMode);
  console.log("[ItemLoop] Derived gridColumns:", gridColumns);
  console.log("[ItemLoop] Derived spacing:", spacing);
  console.log("[ItemLoop] Received columnConfig:", columnConfig);

  const documents = useQuery(
    api.documents.listDocuments,
    // Use tableName prop, skip if undefined or empty
    tableName ? { tableName: tableName as any } : "skip", // Cast necessary because prop is string, query expects specific literals
  );

  // --- Loading / No Data States --- //
  // Use tableName for display messages
  if (!tableName) {
    return (
      <div className="p-4 text-center text-gray-500">
        Item Loop: Please select a Data Source (Table) in the editor.
      </div>
    );
  }

  if (documents === undefined) {
    // Loading state
    return (
      <div className="p-4 text-center text-gray-500">
        Loading items for &quot;{tableName}&quot;...
      </div>
    );
  }

  if (!documents || documents.length === 0) {
    return (
      <div className="p-4 text-center text-gray-500">
        No items found in &quot;{tableName}&quot;.
      </div>
    );
  }

  // --- Determine Columns to Display --- //
  const allDataKeys = documents.length > 0 ? Object.keys(documents[0]) : [];
  const configMap = new Map(columnConfig.map((item) => [item.key, item]));

  // Build the final list of columns *objects* to display, including label
  const displayColumnsConfig: ItemLoopColumnConfig[] = columnConfig
    .filter((item) => item.visible)
    // Keep the whole config object
    .concat(
      allDataKeys
        .filter((key) => !configMap.has(key))
        // Create default config for unconfigured keys
        .map((key) => ({ key: key, visible: true, label: undefined })),
    );

  console.log("[ItemLoop] Columns config to display:", displayColumnsConfig);

  // --- Dynamic Tailwind Classes --- //
  // Grid columns
  const gridColsClasses: { [key: number]: string } = {
    1: "grid-cols-1",
    2: "sm:grid-cols-2",
    3: "sm:grid-cols-2 md:grid-cols-3",
    4: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4",
    5: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5",
    6: "sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6",
  };
  const gridColsClass = gridColsClasses[gridColumns] || gridColsClasses[3]; // Default to 3 if invalid

  // Spacing (gap)
  const spacingClasses: { [key: string]: string } = {
    sm: "gap-2",
    md: "gap-4",
    lg: "gap-6",
  };
  const spacingClass = spacingClasses[spacing] || spacingClasses["md"]; // Default to md
  // --- End Dynamic Classes --- //

  return (
    // Apply background color to the main wrapper
    <div className="p-4" style={{ backgroundColor }}>
      {/* Use tableName for the heading */}
      <h3 className="mb-4 text-lg font-semibold">Items in {tableName}</h3>

      {/* Conditional Rendering based on displayMode */}
      {displayMode === "grid" ? (
        // Apply dynamic grid and spacing classes
        <div className={`grid ${gridColsClass} ${spacingClass}`}>
          {/* eslint-disable-next-line @typescript-eslint/no-explicit-any */}
          {documents.map((doc: Doc<any>) => (
            <div
              key={doc._id}
              className="rounded border bg-card p-3 shadow-sm space-y-1"
            >
              {/* Render grid items using displayColumnsConfig */}
              {displayColumnsConfig.map((colConfig) => (
                <div key={colConfig.key} className="text-xs">
                  <span className="font-medium text-muted-foreground">
                    {/* Use label || key for display */}
                    {colConfig.label || colConfig.key}:{" "}
                  </span>
                  <span>{renderItemData(doc[colConfig.key])}</span>
                </div>
              ))}
            </div>
          ))}
        </div>
      ) : (
        <div className="overflow-x-auto rounded border">
          <table className="w-full text-left text-sm">
            <thead className="bg-muted text-muted-foreground">
              <tr>
                {/* Use displayColumnsConfig for headers */}
                {displayColumnsConfig.map((colConfig) => (
                  <th key={colConfig.key} className="p-3 font-medium">
                    {/* Use label || key for header */}
                    {colConfig.label || colConfig.key}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {/* eslint-disable-next-line @typescript-eslint/no-explicit-any */}
              {documents.map((doc: Doc<any>) => (
                <tr key={doc._id} className="border-b last:border-b-0">
                  {/* Use displayColumnsConfig for data cells */}
                  {displayColumnsConfig.map((colConfig) => (
                    <td
                      key={`${doc._id}-${colConfig.key}`}
                      className="p-3 align-top"
                    >
                      {renderItemData(doc[colConfig.key])}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="convexadmin/admin/src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/convexadmin/lib/utils"
import { buttonVariants } from "@/convexadmin/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="convexadmin/admin/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/convexadmin/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="convexadmin/admin/src/components/ui/aspect-ratio.tsx">
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }
</file>

<file path="convexadmin/admin/src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/convexadmin/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="convexadmin/admin/src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/convexadmin/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="convexadmin/admin/src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="convexadmin/admin/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/convexadmin/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="convexadmin/admin/src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/convexadmin/lib/utils"
import { buttonVariants } from "@/convexadmin/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }
</file>

<file path="convexadmin/admin/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/convexadmin/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="convexadmin/admin/src/components/ui/carousel.tsx">
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"
import { Button } from "@/convexadmin/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)

    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="convexadmin/admin/src/components/ui/chart.tsx">
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/convexadmin/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, '@convexcms/core' | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    '@convexcms/core' in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="convexadmin/admin/src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
</file>

<file path="convexadmin/admin/src/components/ui/collapsible.tsx">
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="convexadmin/admin/src/components/ui/command.tsx">
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/convexadmin/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="convexadmin/admin/src/components/ui/context-menu.tsx">
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="convexadmin/admin/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="convexadmin/admin/src/components/ui/drawer.tsx">
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/convexadmin/lib/utils"

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="convexadmin/admin/src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="convexadmin/admin/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/convexadmin/lib/utils"
import { Label } from "@/convexadmin/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="convexadmin/admin/src/components/ui/hover-card.tsx">
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/convexadmin/lib/utils"

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="convexadmin/admin/src/components/ui/input-otp.tsx">
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="convexadmin/admin/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/convexadmin/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="convexadmin/admin/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/convexadmin/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="convexadmin/admin/src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}
</file>

<file path="convexadmin/admin/src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1"
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}
</file>

<file path="convexadmin/admin/src/components/ui/pagination.tsx">
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"
import { Button, buttonVariants } from "@/convexadmin/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
</file>

<file path="convexadmin/admin/src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/convexadmin/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="convexadmin/admin/src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/convexadmin/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }
</file>

<file path="convexadmin/admin/src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }
</file>

<file path="convexadmin/admin/src/components/ui/resizable.tsx">
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/convexadmin/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="convexadmin/admin/src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/convexadmin/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="convexadmin/admin/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="convexadmin/admin/src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/convexadmin/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="convexadmin/admin/src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/convexadmin/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="convexadmin/admin/src/components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/convexadmin/hooks/use-mobile"
import { cn } from "@/convexadmin/lib/utils"
import { Button } from "@/convexadmin/components/ui/button"
import { Input } from "@/convexadmin/components/ui/input"
import { Separator } from "@/convexadmin/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/convexadmin/components/ui/sheet"
import { Skeleton } from "@/convexadmin/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/convexadmin/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="convexadmin/admin/src/components/ui/skeleton.tsx">
import { cn } from "@/convexadmin/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="convexadmin/admin/src/components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/convexadmin/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }
</file>

<file path="convexadmin/admin/src/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="convexadmin/admin/src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/convexadmin/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="convexadmin/admin/src/components/ui/table.tsx">
"use client";

import * as React from "react";

import { cn } from "@/convexadmin/lib/utils";

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  );
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  );
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  );
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className,
      )}
      {...props}
    />
  );
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className,
      )}
      {...props}
    />
  );
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  );
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  );
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  );
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
</file>

<file path="convexadmin/admin/src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/convexadmin/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="convexadmin/admin/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/convexadmin/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="convexadmin/admin/src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/convexadmin/lib/utils"
import { toggleVariants } from "@/convexadmin/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="convexadmin/admin/src/components/ui/toggle.tsx">
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/convexadmin/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }
</file>

<file path="convexadmin/admin/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/convexadmin/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="convexadmin/admin/src/components/views/CollectionSettingsPage.tsx">
"use client";

import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/convexadmin/components/ui/tabs";

import type { AdminCollectionConfig } from "@/convexadmin/types";
import React from "react";
import { useRouter } from "next/navigation";
import { Puck, type Data } from "@measured/puck";
import { puckConfig } from "@/convexadmin/puck.config";
import "@measured/puck/puck.css";

interface CollectionSettingsPageProps {
  collectionSlug: string;
  collection: AdminCollectionConfig;
  tabSlug?: string;
  // config is also passed but likely not needed directly here
}

export const CollectionSettingsPage: React.FC<CollectionSettingsPageProps> = ({
  collectionSlug,
  collection,
  tabSlug = "frontend",
}) => {
  const router = useRouter();

  // TODO: Fetch actual initial data for the page from Convex based on collectionSlug
  // Valid empty state for Puck Data type
  const initialData: Data = { root: {}, content: [] };

  // TODO: Implement actual save mutation in Convex
  const handlePublish = React.useCallback(
    (data: Data) => {
      console.log("Puck data to save:", JSON.stringify(data, null, 2));
      alert("Check console for Puck data to save.");
    },
    [collectionSlug],
  );

  const handleTabChange = (value: string) => {
    const href = `/admin/collections/${collectionSlug}/settings/${value}`;
    router.push(href);
  };

  return (
    <div className="p-4 md:p-6">
      <h1 className="text-2xl font-bold mb-4">
        Settings for {collection.pluralLabel || collectionSlug}
      </h1>

      <Tabs value={tabSlug} onValueChange={handleTabChange} className="w-full">
        <TabsList className="grid w-full grid-cols-3 mb-4">
          <TabsTrigger value="frontend">Frontend</TabsTrigger>
          <TabsTrigger value="custom2">Custom 2</TabsTrigger>
          <TabsTrigger value="custom3">Custom 3</TabsTrigger>
        </TabsList>
        <TabsContent value="frontend">
          {tabSlug === "frontend" && (
            <Puck
              config={puckConfig}
              data={initialData}
              onPublish={handlePublish}
            />
          )}
        </TabsContent>
        <TabsContent value="custom2">
          <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center text-gray-500">
            <p>Custom 2 Settings Placeholder</p>
            <p className="mt-2 text-sm">Slug: {collectionSlug}</p>
            {/* TODO: Add actual custom2 setting fields/forms here */}
          </div>
        </TabsContent>
        <TabsContent value="custom3">
          <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center text-gray-500">
            <p>Custom 3 Settings Placeholder</p>
            <p className="mt-2 text-sm">Slug: {collectionSlug}</p>
            {/* TODO: Add actual custom3 setting fields/forms here */}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/views/DashboardView.tsx">
"use client";

import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/convexadmin/components/ui/card";

import type { AdminConfig } from "@/convexadmin/types";
import Link from "next/link";
import React from "react";

// Assuming Shadcn Card is available

interface DashboardViewProps {
  config: AdminConfig;
}

export const DashboardView = ({ config }: DashboardViewProps) => {
  const collections = Object.entries(config.collections || {});
  // TODO: Add globals handling later
  // const globals = Object.entries(config.globals || {});

  return (
    <div className="p-4 md:p-6">
      <h1 className="text-2xl font-bold mb-6">Dashboard</h1>

      <section>
        <h2 className="text-xl font-semibold mb-4">Collections</h2>
        {collections.length === 0 ? (
          <p className="text-muted-foreground">No collections configured.</p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {collections.map(([slug, collectionConfig]) => (
              <Link
                href={`/admin/collections/${slug}`}
                key={slug}
                className="block hover:shadow-lg transition-shadow duration-200 rounded-lg"
              >
                <Card className="h-full">
                  <CardHeader>
                    <CardTitle>
                      {collectionConfig.pluralLabel || slug}
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    {/* Optional: Add description or count later */}
                    <p className="text-sm text-muted-foreground">
                      Manage {collectionConfig.pluralLabel || slug}.
                    </p>
                  </CardContent>
                </Card>
              </Link>
            ))}
          </div>
        )}
      </section>

      {/* TODO: Add Globals section later */}
      {/* <section className="mt-8">
        <h2 className="text-xl font-semibold mb-4">Globals</h2>
        {globals.length === 0 ? (
          <p className="text-muted-foreground">No globals configured.</p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {globals.map(([slug, globalConfig]) => (
              <Link href={`/admin/globals/${slug}`} key={slug} className="block hover:shadow-lg transition-shadow duration-200 rounded-lg">
                <Card className="h-full">
                  <CardHeader>
                    <CardTitle>{globalConfig.label || slug}</CardTitle>
                  </CardHeader>
                  <CardContent>
                    <p className="text-sm text-muted-foreground">Edit {globalConfig.label || slug}.</p>
                  </CardContent>
                </Card>
              </Link>
            ))}
          </div>
        )}
      </section> */}
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/views/EditView.tsx">
"use client";

import type { AdminCollectionConfig, AdminConfig } from "@/convexadmin/types";
import type { Doc, Id } from "@/convex/_generated/dataModel";
import { FormProvider, SubmitHandler, useForm } from "react-hook-form";
import React, { useEffect } from "react";
import { useMutation, useQuery } from "convex/react";

import { Button } from "@/convexadmin/components/ui/button";
import { DocumentFields } from "@/convexui/src/elements/DocumentFields"; // Import DocumentFields
import type { FunctionReference } from "convex/server";
import { Skeleton } from "@/convexadmin/components/ui/skeleton";
import { api } from "@/convex/_generated/api";
import { toast } from "sonner"; // For notifications
import { useDocumentInfo } from "@/convexui/src/providers/DocumentInfo"; // Import the hook
import { useRouter } from "next/navigation"; // Import useRouter for redirection
import { z } from "zod"; // Optional: for validation schema
import { zodResolver } from "@hookform/resolvers/zod"; // Optional: for validation

// Helper to get the correct get query function reference
const getGetQueryRef = (
  slug: string,
): FunctionReference<
  "query",
  "public",
  { id: Id<any> },
  Doc<any> | null
> | null => {
  switch (slug) {
    case "todos":
      return api.todos.getTodoById as FunctionReference<
        "query",
        "public",
        { id: Id<"todos"> },
        Doc<"todos"> | null
      >;
    // Add cases for other collection slugs here
    default:
      console.error(`No get query mapped for slug: ${slug}`);
      return null;
  }
};

// Helper to get the correct update mutation function reference
const getUpdateMutationRef = (
  slug: string,
): FunctionReference<
  "mutation",
  "public",
  { id: Id<any>; data: any },
  null // updateTodo returns null
> | null => {
  switch (slug) {
    case "todos":
      return api.todos.updateTodo as FunctionReference<
        "mutation",
        "public",
        { id: Id<"todos">; data: Partial<Doc<"todos">> },
        null
      >;
    // Add cases for other collection slugs here
    default:
      console.error(`No update mutation mapped for slug: ${slug}`);
      return null;
  }
};

// Helper to get the correct create mutation function reference
const getCreateMutationRef = (
  slug: string,
): FunctionReference<
  "mutation",
  "public",
  Partial<Doc<any>>, // Assuming create takes the document fields directly
  Id<any> // Assuming create returns the new document ID
> | null => {
  switch (slug) {
    case "todos":
      // Assuming args for createTodo is { text: string }, which aligns with Partial<Doc<'todos'>> needing at least 'text'
      return api.todos.createTodo as FunctionReference<
        "mutation",
        "public",
        Pick<Doc<"todos">, "text">,
        Id<"todos">
      >;
    // Add cases for other collection slugs here
    default:
      console.error(`No create mutation mapped for slug: ${slug}`);
      return null;
  }
};

// Props now only include config and collection details
interface EditViewProps {
  collection: AdminCollectionConfig;
  // Removed: collectionSlug (comes from context)
  config: AdminConfig;
  // Removed: documentId (comes from context)
}

// Basic Zod schema generation (example - enhance as needed)
const generateSchema = (fields: Record<string, { type: string }>) => {
  const schemaShape: Record<string, z.ZodType<any, any>> = {};
  for (const key in fields) {
    // Simple mapping - extend for more types and validation rules
    switch (fields[key].type) {
      case "text":
      case "string":
        schemaShape[key] = z.string().optional();
        break;
      case "number":
        schemaShape[key] = z.number().optional();
        break;
      case "boolean":
        schemaShape[key] = z.boolean().optional();
        break;
      // Add more type mappings (date, relation, etc.)
      default:
        schemaShape[key] = z.any().optional(); // Fallback
    }
  }
  return z.object(schemaShape);
};

type FormData = z.infer<ReturnType<typeof generateSchema>>; // Infer type from schema

export const EditView = ({
  collection,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  config, // Kept for future use
}: EditViewProps) => {
  // --- Hooks must be called unconditionally at the top level ---
  const {
    collectionSlug,
    documentId,
    AfterFields,
    BeforeFields,
    docPermissions,
    hasSavePermission,
  } = useDocumentInfo();
  const router = useRouter(); // For redirection after create
  const isCreating = documentId === undefined;

  // Comment out router if not used yet
  // const router = useRouter();

  // Get query/mutation refs *before* potential early return
  // Note: These helpers themselves don't violate hook rules
  const getQueryRef = getGetQueryRef(collectionSlug || ""); // Pass empty string if slug is initially undefined
  const updateMutationRef = getUpdateMutationRef(collectionSlug || "");
  const createMutationRef = getCreateMutationRef(collectionSlug || ""); // Get create ref

  // Fetch data - conditionally skip via args, not by skipping the hook call
  const document = useQuery(
    getQueryRef!,
    getQueryRef && documentId ? { id: documentId } : "skip",
  );

  // Get mutation function - Hook call is unconditional
  const updateDocument = useMutation(updateMutationRef!);
  const createDocument = useMutation(createMutationRef!); // Unconditional hook call

  // Form setup
  const validationSchema = generateSchema(collection.fields);
  // Get all methods from useForm
  const methods = useForm<FormData>({
    resolver: zodResolver(validationSchema),
    defaultValues: {},
  });
  const {
    handleSubmit,
    reset,
    formState: { isSubmitting, isDirty },
  } = methods; // Destructure needed methods

  // Effect setup - Hook call is unconditional
  useEffect(() => {
    // Reset logic runs conditionally inside the effect
    if (!isCreating && document) {
      reset(document as FormData);
    }
  }, [document, reset, isCreating]);
  // --- End of unconditional hook calls ---

  // Now perform checks and potential early returns
  if (!collectionSlug) {
    return (
      <div className="p-4 text-red-600">Error: Collection context missing.</div>
    );
  }
  if (!isCreating && !getQueryRef) {
    return (
      <div className="p-4 text-red-600">Error: No detail view configured.</div>
    );
  }
  if (isCreating && !createMutationRef) {
    return (
      <div className="p-4 text-red-600">
        Error: No create action configured.
      </div>
    );
  }
  if (!isCreating && !updateMutationRef) {
    return (
      <div className="p-4 text-red-600">
        Error: No update action configured.
      </div>
    );
  }

  // --- Submit Handler --- //
  const onSubmit: SubmitHandler<FormData> = async (data) => {
    console.log("onSubmit triggered. isCreating:", isCreating);
    console.log("Form data:", data);
    try {
      console.log("Inside try block...");
      if (isCreating) {
        console.log("Attempting create...");
        // --- Create Logic --- //
        if (!createMutationRef) {
          console.error("Create mutation ref is missing!");
          throw new Error("Create mutation not configured");
        }
        console.log("Calling createDocument...");
        const newId = await createDocument(data as Partial<Doc<any>>);
        console.log("Create successful, new ID:", newId);
        toast.success(`${collection.label} created successfully!`);
        router.push(`/admin/collections/${collectionSlug}/${newId}`);
      } else {
        console.log("Attempting update...");
        // --- Update Logic --- //
        if (!updateMutationRef || !documentId) {
          console.error("Update mutation ref or documentId is missing!");
          throw new Error("Update configuration missing");
        }
        console.log("Calling updateDocument with ID:", documentId);
        await updateDocument({ id: documentId, data });
        console.log("Update successful.");
        toast.success(`${collection.label} updated successfully!`);
        reset(data);
      }
    } catch (error) {
      console.error("Submit failed inside catch block:", error);
      toast.error(
        `Failed to ${isCreating ? "create" : "update"} ${collection.label}.`,
      );
    }
  };

  // Loading/Error states for fetched data
  if (!isCreating) {
    if (document === undefined) {
      return (
        <div className="p-4 md:p-6 space-y-4">
          <Skeleton className="h-8 w-1/4" />
          <Skeleton className="h-10 w-full" />
          <Skeleton className="h-10 w-full" />
        </div>
      );
    }
    if (document === null) {
      return <div className="p-4 text-red-600">Error: Document not found.</div>;
    }
  }

  // Render the form
  return (
    <div className="p-4 md:p-6">
      <h1 className="text-2xl font-bold mb-4">
        {isCreating ? `Create ${collection.label}` : `Edit ${collection.label}`}
        {!isCreating && documentId && (
          <span className="text-sm font-normal text-muted-foreground ml-2">
            (ID: {documentId.toString()})
          </span>
        )}
      </h1>
      {/* Wrap form content with FormProvider */}
      <FormProvider {...methods}>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <DocumentFields
            AfterFields={AfterFields}
            BeforeFields={BeforeFields}
            docPermissions={docPermissions}
            fields={collection.fields}
            readOnly={isSubmitting} // Simple readOnly while submitting
          />
          <Button
            type="submit"
            disabled={isSubmitting || (!isCreating && !isDirty)}
          >
            {isSubmitting
              ? "Saving..."
              : isCreating
                ? `Create ${collection.label}`
                : "Save Changes"}
          </Button>
        </form>
      </FormProvider>
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/views/ListView.tsx">
"use client";

import type { AdminCollectionConfig, AdminConfig } from "@/convexadmin/types";
import {
  ColumnDef,
  SortingState,
  VisibilityState,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { PlusCircle, Settings } from "lucide-react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/convexadmin/components/ui/table";

import { Button } from "@/convexadmin/components/ui/button";
import { DataTableColumnHeader } from "../data-table/data-table-column-header";
import { DataTablePagination } from "../data-table/data-table-pagination";
import { DataTableRowActions } from "../data-table/data-table-row-actions";
import { DataTableViewOptions } from "../data-table/data-table-view-options";
import type { FunctionReference } from "convex/server";
import type { Id } from "@/convex/_generated/dataModel";
import Link from "next/link";
import React from "react";
import { api } from "@/convex/_generated/api";
import { useQuery } from "convex/react";

// Define a generic document type constraint
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type DocumentWithId = { _id: Id<any> } & Record<string, any>;

// Helper to get query ref
const getListQueryRef = (
  slug: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
): FunctionReference<"query", "public", any, DocumentWithId[]> | null => {
  switch (slug) {
    case "todos":
      return api.todos.getTodos;
    case "posts":
      return api.posts.getPosts;
    case "plugins":
      return api.plugins.getPlugins;
    default:
      console.error(`No list query mapped for slug: ${slug}`);
      return null;
  }
};

// --- Function to generate columns dynamically ---
const generateColumns = <TData extends DocumentWithId>(
  collection: AdminCollectionConfig,
  collectionSlug: string,
): ColumnDef<TData>[] => {
  const fieldColumns: ColumnDef<TData>[] = Object.entries(
    collection.fields,
  ).map(([key, fieldConfig]) => ({
    accessorKey: key,
    header: ({ column }) => (
      <DataTableColumnHeader column={column} title={fieldConfig.label || key} />
    ),
    cell: ({ row }) => <div>{String(row.getValue(key) ?? "")}</div>,
    enableSorting: true, // Enable sorting for all fields by default
    enableHiding: true,
  }));

  return [
    // TODO: Add Checkbox column for row selection later if needed
    // {
    //   id: "select",
    //   header: ({ table }) => (...),
    //   cell: ({ row }) => (...),
    //   enableSorting: false,
    //   enableHiding: false,
    // },
    {
      accessorKey: "_id",
      header: ({ column }) => (
        <DataTableColumnHeader column={column} title="ID" />
      ),
      cell: ({ row }) => (
        <Link
          href={`/admin/collections/${collectionSlug}/${row.original._id}`}
          className="text-blue-600 hover:underline"
        >
          {row.original._id}
        </Link>
      ),
      enableSorting: true,
      enableHiding: true,
    },
    ...fieldColumns,
    {
      id: "actions",
      cell: ({ row }) => (
        <DataTableRowActions row={row} collectionSlug={collectionSlug} />
      ),
      enableSorting: false,
      enableHiding: false,
    },
  ];
};

interface ListViewProps {
  collection: AdminCollectionConfig;
  collectionSlug: string;
  config: AdminConfig;
  searchParams: { [key: string]: string | string[] };
}

export const ListView = ({
  collection,
  collectionSlug,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  config,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  searchParams,
}: ListViewProps) => {
  const listQueryRef = getListQueryRef(collectionSlug);

  // Fetch documents - This remains the source of truth for data
  const documents = useQuery(listQueryRef!, listQueryRef ? {} : "skip");

  // --- TanStack Table State Hooks ---
  const [sorting, setSorting] = React.useState<SortingState>([]);
  const [columnVisibility, setColumnVisibility] =
    React.useState<VisibilityState>({});
  const [rowSelection, setRowSelection] = React.useState({}); // For potential future use

  // Memoize columns to prevent regeneration on every render
  const columns = React.useMemo(
    () => generateColumns(collection, collectionSlug),
    [collection, collectionSlug],
  );

  const table = useReactTable({
    data: documents ?? [], // Provide fetched data or empty array while loading
    columns,
    state: {
      sorting,
      columnVisibility,
      rowSelection,
    },
    onSortingChange: setSorting,
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    // TODO: Add getFilteredRowModel() when filtering is implemented
  });

  // Handle the error case where no query function is mapped
  if (!listQueryRef) {
    return (
      <div className="p-4 text-red-600">
        Error: No list view configured for {collectionSlug}.
      </div>
    );
  }
  if (documents === undefined) {
    // Basic loading state (could be improved with skeletons within table structure)
    return (
      <div className="p-4 md:p-6 space-y-4">
        <div className="flex items-center justify-between">
          {/* Using div placeholders for skeleton effect */}
          <div className="h-8 w-40 bg-muted rounded" />
          <div className="h-9 w-24 bg-muted rounded" />
        </div>
        <div className="h-10 w-full bg-muted rounded" />
        <div className="h-64 w-full border rounded-lg bg-muted" />
        <div className="h-10 w-full bg-muted rounded" />
      </div>
    );
  }

  return (
    <div className="p-4 md:p-6 w-full space-y-4">
      {/* Header: Title and Action Buttons */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">{collection.pluralLabel}</h1>
        <div className="flex items-center space-x-2">
          {" "}
          {/* Group buttons */}
          {/* Settings Button - No whitespace around Link */}
          <Button asChild size="sm" variant="outline">
            <Link href={`/admin/collections/${collectionSlug}/settings`}>
              <Settings className="mr-2 h-4 w-4" />
              Settings
            </Link>
          </Button>
          {/* Add New Button - No whitespace around Link */}
          <Button asChild size="sm">
            <Link href={`/admin/collections/${collectionSlug}/create`}>
              <PlusCircle className="mr-2 h-4 w-4" />
              Add New
            </Link>
          </Button>
        </div>
      </div>

      {/* Toolbar: Filtering (future) and View Options */}
      <div className="flex items-center py-4 gap-3">
        {/* TODO: Add filtering input */}
        {/* <Input placeholder="Filter..." className="max-w-sm" /> */}
        <DataTableViewOptions table={table} />
      </div>

      {/* Data Table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id} colSpan={header.colSpan}>
                    {" "}
                    {/* Added colSpan */}
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext(),
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext(),
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length} // Use columns length for colspan
                  className="h-24 text-center"
                >
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      <DataTablePagination table={table} />
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/views/NotFoundView.tsx">
import React from "react";
export const NotFoundView = () => <div>Admin: Resource Not Found</div>;
</file>

<file path="convexadmin/admin/src/components/AdminProvider.tsx">
"use client";

import React, {
  ReactNode,
  createContext,
  useContext,
  useEffect,
  useState,
} from "react";

// Define the structure of the admin config (can be refined later)
export interface AdminCollectionField {
  label: string;
  type: string;
  // Add more fields like description, ui hints, etc.
}

export interface AdminCollectionConfig {
  label: string;
  pluralLabel: string;
  fields: Record<string, AdminCollectionField>;
}

export interface AdminConfig {
  collections: Record<string, AdminCollectionConfig>;
}

interface AdminContextType {
  config: AdminConfig | null;
  loading: boolean;
  error: Error | null;
}

const AdminContext = createContext<AdminContextType | undefined>(undefined);

export const AdminProvider = ({ children }: { children: ReactNode }) => {
  const [config, setConfig] = useState<AdminConfig | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // In a real app, fetch this dynamically or pass from server component
    // For now, simulate async loading
    const loadConfig = async () => {
      try {
        // Fetch or import the config JSON
        // Note: Direct import might not work well with the build process
        // A fetch call or passing via props from a server component is usually better.
        // Using fetch as an example:
        const response = await fetch("/.generated/admin-config.json");
        if (!response.ok) {
          throw new Error(
            `Failed to load admin config: ${response.statusText}`,
          );
        }
        const loadedConfig = await response.json();
        setConfig(loadedConfig as AdminConfig);
      } catch (err) {
        console.error("Error loading admin config:", err);
        setError(err instanceof Error ? err : new Error(String(err)));
      } finally {
        setLoading(false);
      }
    };

    loadConfig();
  }, []);

  return (
    <AdminContext.Provider value={{ config, loading, error }}>
      {children}
    </AdminContext.Provider>
  );
};

export const useAdminConfig = () => {
  const context = useContext(AdminContext);
  if (context === undefined) {
    throw new Error("useAdminConfig must be used within an AdminProvider");
  }
  return context;
};
</file>

<file path="convexadmin/admin/src/components/ConvexAdminProvider.tsx">
"use client";

import React, { createContext, useContext } from "react";
import { SidebarInset, SidebarProvider } from "./ui/sidebar"; // Import SidebarProvider

import type { AdminConfig } from "@/convexadmin/types";
import { AppSidebar } from "@/convexui/src/elements/AppSidebar";

interface ConvexAdminContextType {
  config: AdminConfig;
  // Add other global states later if needed, e.g.:
  // isAuthenticated: boolean;
  // isLoadingAuth: boolean;
  // user: any; // Type this appropriately based on your auth setup
}

const ConvexAdminContext = createContext<ConvexAdminContextType | null>(null);

export const ConvexAdminProvider = ({
  children,
  config,
}: {
  children: React.ReactNode;
  config: AdminConfig;
}) => {
  // Optional: Fetch auth state if needed globally in the admin UI
  // const { isLoading, isAuthenticated } = useConvexAuth();

  // For now, just provide the config
  const value = {
    config,
    // isLoadingAuth: isLoading,
    // isAuthenticated,
  };

  return (
    <ConvexAdminContext.Provider value={value}>
      <SidebarProvider>
        <AppSidebar />
        <SidebarInset>{children}</SidebarInset>
      </SidebarProvider>
    </ConvexAdminContext.Provider>
  );
};

// Custom hook to easily access the context
export const useConvexAdmin = (): ConvexAdminContextType => {
  const context = useContext(ConvexAdminContext);
  if (!context) {
    throw new Error("useConvexAdmin must be used within a ConvexAdminProvider");
  }
  return context;
};
</file>

<file path="convexadmin/admin/src/components/DebugPanel.tsx">
"use client";

import React from "react";

interface DebugPanelProps {
  title?: string;
  data: unknown; // Use unknown instead of any
}

export const DebugPanel: React.FC<DebugPanelProps> = ({
  title = "Debug Info",
  data,
}) => {
  return (
    <div className="fixed bottom-4 right-4 z-50 max-w-xs max-h-60 overflow-auto bg-gray-900 text-white text-xs p-4 rounded-lg shadow-xl border border-gray-700">
      <h4 className="font-bold mb-2 sticky top-0 bg-gray-900 pb-1 border-b border-gray-700">
        {title}
      </h4>
      <pre className="whitespace-pre-wrap break-words">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/components/RootLayout.tsx">
import type { AdminConfig } from "@/convexadmin/types";
import { ConvexAdminProvider } from "./ConvexAdminProvider"; // Import the provider
import React from "react";

export const metadata = {
  // TODO: Update metadata
  description: "Convex Admin Interface",
  title: "Convex Admin",
};

export const RootLayout = async ({
  children,
  config, // Accept AdminConfig
  htmlProps = {},
}: {
  readonly children: React.ReactNode;
  readonly config: AdminConfig; // Use our AdminConfig type
  readonly htmlProps?: React.HtmlHTMLAttributes<HTMLHtmlElement>;
  // Removed: importMap, serverFunction
}) => {
  // Removed: checkDependencies()
  // Removed: initReq block
  // Removed: getRequestTheme block
  // Removed: i18n block
  // Removed: getNavPrefs block
  // Removed: getClientConfig block

  return (
    <html
      lang="en" // Default to English
      suppressHydrationWarning // Consider keeping this if needed
      {...htmlProps}
      // Removed: data-theme, dir, lang (handled differently)
    >
      <head>
        {/* Add necessary meta tags, etc. */}
        {/* Removed: Payload style tag */}
      </head>
      <body>
        {/* Wrap children with the ConvexAdminProvider */}
        <ConvexAdminProvider config={config}>
          {/* ConvexAdminProvider now handles SidebarProvider internally */}
          {children}
        </ConvexAdminProvider>
        <div id="portal" /> {/* Keep for modals/portals */}
      </body>
    </html>
  );
};
</file>

<file path="convexadmin/admin/src/components/RootPage.tsx">
import React, { Fragment } from "react";

import type { AdminConfig } from "../types";
import { DefaultTemplate } from "../templates/Default";
import { DocumentInfoProvider } from "@/convexui/src/providers/DocumentInfo";
import type { Id } from "@/convex/_generated/dataModel";
import type { ImportMap } from "../lib/getViewFromConfig";
import { getViewFromConfig } from "../lib/getViewFromConfig";

// TODO: Import MinimalTemplate if/when created

interface RootPageProps {
  config: AdminConfig | null;
  importMap: ImportMap;
  params: Promise<{
    segments: string[];
  }>;
  searchParams: Promise<{
    [key: string]: string | string[];
  }>;
}

export const RootPage = async ({
  config,
  importMap,
  params: paramsPromise,
  searchParams: searchParamsPromise,
}: RootPageProps) => {
  if (!config) {
    return <div>Admin configuration is unavailable.</div>;
  }
  const searchParams = await searchParamsPromise;
  const params = await paramsPromise;
  const segments = params.segments || [];
  const currentRoute =
    "/admin" + (segments.length > 0 ? "/" + segments.join("/") : "");

  const {
    Component,
    props: viewProps,
    // viewType, // Commented out until template switching logic is needed
  } = getViewFromConfig({
    config,
    currentRoute,
    importMap,
    searchParams,
    segments,
  });

  // *** Add logging to check the props ***
  console.log("getViewFromConfig returned props:", viewProps);

  // Extract potential context values from props
  const collectionSlug = viewProps?.collectionSlug as string | undefined;
  const documentId = viewProps?.documentId as Id<any> | undefined;

  // *** Add logging for extracted values ***
  console.log("Extracted for Provider:", { collectionSlug, documentId });

  const RenderedView = React.createElement(Component, viewProps);

  // Use const since it's not reassigned currently
  const TemplateComponent = DefaultTemplate;
  // Example: if (viewType === 'login' || viewType === 'forgotPassword') {
  //   TemplateComponent = MinimalTemplate;
  // }

  return (
    <Fragment>
      <TemplateComponent>
        <DocumentInfoProvider
          collectionSlug={collectionSlug}
          documentId={documentId}
        >
          {RenderedView}
        </DocumentInfoProvider>
      </TemplateComponent>
    </Fragment>
  );
};
</file>

<file path="convexadmin/admin/src/components/TestGround.tsx">
"use client";

import type { AdminConfig } from "../types";
import { COLLECTION_PATH_SEGMENT } from "../constants";
import Link from "next/link";
import React from "react";

interface TestGroundProps {
  config: AdminConfig;
}

export const TestGround: React.FC<TestGroundProps> = ({ config }) => {
  const collectionEntries = Object.entries(config.collections);

  return (
    <div className="p-8">
      <h1 className="text-3xl font-bold mb-6">Admin Test Ground</h1>

      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-3 border-b pb-2">
          Registered Collections
        </h2>
        {collectionEntries.length === 0 ? (
          <p className="text-gray-500">
            No collections found in configuration.
          </p>
        ) : (
          <ul className="space-y-2">
            {collectionEntries.map(([slug, collectionConfig]) => (
              <li
                key={slug}
                className="flex items-center justify-between bg-white p-3 rounded shadow-sm"
              >
                <span className="font-medium">
                  {collectionConfig.label} ({slug})
                </span>
                <Link
                  href={`/admin/${COLLECTION_PATH_SEGMENT}/${slug}`}
                  className="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors"
                >
                  Go to List View
                </Link>
              </li>
            ))}
          </ul>
        )}
      </section>

      {/* Add more test sections here later */}
      <section>
        <h2 className="text-xl font-semibold mb-3 border-b pb-2">
          Other Tests
        </h2>
        <p className="text-gray-500">
          Future test components or info can go here.
        </p>
      </section>
    </div>
  );
};
</file>

<file path="convexadmin/admin/src/fields/CheckboxField.tsx">
import type { AdminCollectionField } from "@/convexadmin/types";
import React from "react";

interface FieldComponentProps {
  name: string;
  config: AdminCollectionField;
}

export const CheckboxField: React.FC<FieldComponentProps> = ({
  name,
  config,
}) => (
  <div>
    Checkbox Field Placeholder (Label: {config.label}, Name: {name})
  </div>
);
</file>

<file path="convexadmin/admin/src/fields/NumberField.tsx">
import type { AdminCollectionField } from "@/convexadmin/types";
import React from "react";

interface FieldComponentProps {
  name: string;
  config: AdminCollectionField;
}

export const NumberField: React.FC<FieldComponentProps> = ({
  name,
  config,
}) => (
  <div>
    Number Field Placeholder (Label: {config.label}, Name: {name})
  </div>
);
</file>

<file path="convexadmin/admin/src/fields/TextField.tsx">
import type { AdminCollectionField } from "@/convexadmin/types";
import React from "react";

// Basic props for placeholder field components
interface FieldComponentProps {
  name: string;
  config: AdminCollectionField;
  // Add form handling props later (e.g., register from react-hook-form)
}

export const TextField: React.FC<FieldComponentProps> = ({ name, config }) => (
  <div>
    Text Field Placeholder (Label: {config.label}, Name: {name})
  </div>
);
</file>

<file path="convexadmin/admin/src/fields/UnknownField.tsx">
import type { AdminCollectionField } from "@/convexadmin/types";
import React from "react";

interface FieldComponentProps {
  name: string;
  config: AdminCollectionField;
}

export const UnknownField: React.FC<FieldComponentProps> = ({
  name,
  config,
}) => (
  <div
    className="p-2 border border-dashed border-red-300 bg-red-50 text-red-700 text-xs rounded"
    title={`Field Name: ${name}`}
  >
    Unsupported Field Type: {config?.type || "N/A"}
  </div>
);
</file>

<file path="convexadmin/admin/src/hooks/use-mobile.ts">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="convexadmin/admin/src/lib/formatDocTitle.ts">
// Placeholder for formatting document titles
// TODO: Implement logic based on Payload's formatDocTitle utility

import type { Id } from "@/convex/_generated/dataModel";

interface FormatDocTitleArgs {
  collectionConfig?: { slug: string; admin: { useAsTitle?: string } }; // Simplified config
  globalConfig?: { slug: string; label: string }; // Simplified config
  data: Record<string, unknown> & { id?: Id<any> | string }; // Document data
  fallback?: string; // Fallback title
  // Add other necessary args like dateFormat, i18n if needed
}

export const formatDocTitle = ({
  data,
  collectionConfig,
  globalConfig,
  fallback,
}: FormatDocTitleArgs): string => {
  // Basic implementation: Use field from config, ID, or fallback
  if (
    collectionConfig?.admin?.useAsTitle &&
    data[collectionConfig.admin.useAsTitle]
  ) {
    return String(data[collectionConfig.admin.useAsTitle]);
  }

  if (globalConfig) {
    return globalConfig.label; // Globals usually have a fixed label
  }

  const idString = data.id ? String(data.id) : null;

  return fallback || idString || "Untitled Document";
};
</file>

<file path="convexadmin/admin/src/lib/getViewFromConfig.ts">
import type { AdminConfig } from "../types";
import React from "react";

// Keep ImportMap definition - Ensure this matches the generated importMap
export type ImportMap = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fields: Record<string, React.ComponentType<any>>; // Keep this flexible for now
  views: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Dashboard: React.ComponentType<any>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NotFound: React.ComponentType<any>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CollectionList: React.ComponentType<any>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CollectionEdit: React.ComponentType<any>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CollectionCreate: React.ComponentType<any>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CollectionSettings: React.ComponentType<any>; // Add Settings view type
    // TODO: Add GlobalEdit view type when globals are supported
  };
};

// Arguments for getViewFromConfig
export interface GetViewFromConfigArgs {
  config: AdminConfig;
  currentRoute: string; // Keep for potential future use, but logic primarily uses segments
  importMap: ImportMap;
  searchParams: { [key: string]: string | string[] }; // Keep for potential filtering/sorting
  segments: string[];
}

// Result from getViewFromConfig
export interface ViewConfigResult {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Component: React.ComponentType<any>; // Component to render
  props: Record<string, unknown>; // Props for the component
  viewType:
    | "dashboard"
    | "collectionList"
    | "collectionCreate"
    | "collectionEdit"
    | "collectionSettings" // Add Settings view type
    // | "globalEdit" // Removed until globals are supported
    | "notFound";
}

// Alias for clarity in RootPage
export type GetViewFromConfigResult = ViewConfigResult;

// Default Not Found Component (can be overridden by importMap)
const DefaultNotFound: React.FC = () => {
  return React.createElement(
    "div",
    { className: "p-4 text-center" },
    "404 - Not Found",
  );
};

export const getViewFromConfig = (
  args: GetViewFromConfigArgs,
): GetViewFromConfigResult => {
  const { config, segments, importMap, searchParams } = args;
  const { views } = importMap;

  const NotFoundComponent = views.NotFound || DefaultNotFound;

  // Determine view based on segments
  switch (segments.length) {
    case 0:
      // Dashboard View: /admin
      return {
        Component: views.Dashboard,
        props: { config }, // Pass config to dashboard
        viewType: "dashboard",
      };

    case 2:
      if (segments[0] === "collections") {
        // Collection List View: /admin/collections/:slug
        const collectionSlug = segments[1];
        // *** Corrected: Access collection config by slug key ***
        const collection = config.collections[collectionSlug];

        if (collection) {
          return {
            Component: views.CollectionList,
            // Pass the collection config and the slug itself
            props: { collection, collectionSlug, config, searchParams },
            viewType: "collectionList",
          };
        }
      }
      // Removed global logic - Add back when AdminGlobalConfig and config.globals exist
      break;

    case 3:
      if (segments[0] === "collections") {
        const collectionSlug = segments[1];
        const collection = config.collections[collectionSlug];

        if (collection) {
          if (segments[2] === "create") {
            // Collection Create View: /admin/collections/:slug/create
            // *** Use CollectionEdit component but pass undefined documentId ***
            return {
              Component: views.CollectionEdit, // Changed from CollectionCreate
              props: {
                collection,
                collectionSlug,
                config,
                documentId: undefined,
              }, // Pass undefined ID
              viewType: "collectionEdit", // Treat as an edit view type internally for consistency
            };
          } else if (segments[2] === "settings") {
            // Base Collection Settings View: /admin/collections/:slug/settings
            // Defaults to the first tab (e.g., 'frontend')
            return {
              Component: views.CollectionSettings,
              props: {
                collection,
                collectionSlug,
                config,
                tabSlug: "frontend",
              }, // Default tab
              viewType: "collectionSettings",
            };
          } else {
            // Collection Edit View: /admin/collections/:slug/:id
            const documentId = segments[2];
            return {
              Component: views.CollectionEdit,
              props: { collection, collectionSlug, config, documentId },
              viewType: "collectionEdit",
            };
          }
        }
      }
      break;

    case 4:
      // Handle /admin/collections/:slug/settings/:tab
      if (segments[0] === "collections" && segments[2] === "settings") {
        const collectionSlug = segments[1];
        const collection = config.collections[collectionSlug];
        const tabSlug = segments[3]; // The specific tab

        if (collection) {
          return {
            Component: views.CollectionSettings,
            props: { collection, collectionSlug, config, tabSlug }, // Pass the specific tab
            viewType: "collectionSettings",
          };
        }
      }
      break;

    // Add more cases for deeper routes if needed

    default:
      // Fallthrough: If no specific route matched
      break;
  }

  // Not Found Fallback
  return {
    Component: NotFoundComponent,
    props: { segments }, // Pass segments for potential debugging
    viewType: "notFound",
  };
};
</file>

<file path="convexadmin/admin/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="convexadmin/admin/src/preferences/operations/delete.ts">
import type { Document, Where } from '../../types/index.js'
import type { PreferenceRequest } from '../types.js'

import { NotFound } from '../../errors/NotFound.js'
import { UnauthorizedError } from '../../errors/UnauthorizedError.js'
import { preferencesCollectionSlug } from '../config.js'

export async function deleteOperation(args: PreferenceRequest): Promise<Document> {
  const {
    key,
    req: { payload },
    req,
    user,
  } = args

  if (!user) {
    throw new UnauthorizedError(req.t)
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const result = await payload.db.deleteOne({
    collection: preferencesCollectionSlug,
    req,
    where,
  })

  if (result) {
    return result
  }
  throw new NotFound(req.t)
}
</file>

<file path="convexadmin/admin/src/preferences/operations/findOne.ts">
// @ts-strict-ignore
import type { TypedCollection } from '../../index.js'
import type { Where } from '../../types/index.js'
import type { PreferenceRequest } from '../types.js'

import { preferencesCollectionSlug } from '../config.js'

export async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {
  const {
    key,
    req: { payload },
    req,
    user,
  } = args

  if (!user) {
    return null
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const { docs } = await payload.db.find({
    collection: preferencesCollectionSlug,
    limit: 1,
    pagination: false,
    req,
    sort: '-updatedAt',
    where,
  })

  return docs?.[0] || null
}
</file>

<file path="convexadmin/admin/src/preferences/operations/update.ts">
import type { Where } from '../../types/index.js'
import type { PreferenceUpdateRequest } from '../types.js'

import { UnauthorizedError } from '../../errors/UnauthorizedError.js'
import { preferencesCollectionSlug } from '../config.js'

export async function update(args: PreferenceUpdateRequest) {
  const {
    key,
    req: { payload },
    req,
    user,
    value,
  } = args

  if (!user) {
    throw new UnauthorizedError(req.t)
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const preference = {
    key,
    user: {
      relationTo: user.collection,
      value: user.id,
    },
    value,
  }

  return await payload.db.upsert({
    collection: preferencesCollectionSlug,
    data: preference,
    req,
    where,
  })
}
</file>

<file path="convexadmin/admin/src/preferences/requestHandlers/delete.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { deleteOperation } from '../operations/delete.js'

export const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (error) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const result = await deleteOperation({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData.user,
  })

  return Response.json(
    {
      ...result,
      message: reqWithData.t('general:deletedSuccessfully'),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/preferences/requestHandlers/findOne.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { findOne } from '../operations/findOne.js'

export const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (error) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const result = await findOne({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData.user,
  })

  return Response.json(
    {
      ...(result
        ? result
        : {
            message: reqWithData.t('general:notFound'),
            value: null,
          }),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/preferences/requestHandlers/update.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { update } from '../operations/update.js'

export const updateHandler: PayloadHandler = async (incomingReq) => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (_err) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const doc = await update({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData?.user,
    value: reqWithData.data.value || reqWithData.data,
  })

  return Response.json(
    {
      doc,
      message: reqWithData.t('general:updatedSuccessfully'),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="convexadmin/admin/src/preferences/config.ts">
// @ts-strict-ignore
import type { CollectionConfig } from '../collections/config/types.js'
import type { Access, Config } from '../config/types.js'

import { deleteHandler } from './requestHandlers/delete.js'
import { findByIDHandler } from './requestHandlers/findOne.js'
import { updateHandler } from './requestHandlers/update.js'

const preferenceAccess: Access = ({ req }) => {
  if (!req.user) {
    return false
  }

  return {
    'user.value': {
      equals: req?.user?.id,
    },
  }
}

export const preferencesCollectionSlug = 'payload-preferences'

export const getPreferencesCollection = (config: Config): CollectionConfig => ({
  slug: preferencesCollectionSlug,
  access: {
    delete: preferenceAccess,
    read: preferenceAccess,
  },
  admin: {
    hidden: true,
  },
  endpoints: [
    {
      handler: findByIDHandler,
      method: 'get',
      path: '/:key',
    },
    {
      handler: deleteHandler,
      method: 'delete',
      path: '/:key',
    },
    {
      handler: updateHandler,
      method: 'post',
      path: '/:key',
    },
  ],
  fields: [
    {
      name: 'user',
      type: 'relationship',
      hooks: {
        beforeValidate: [
          ({ req }) => {
            if (!req?.user) {
              return null
            }

            return {
              relationTo: req?.user.collection,
              value: req?.user.id,
            }
          },
        ],
      },
      index: true,
      relationTo: config.collections
        .filter((collectionConfig) => collectionConfig.auth)
        .map((collectionConfig) => collectionConfig.slug),
      required: true,
    },
    {
      name: 'key',
      type: 'text',
      index: true,
    },
    {
      name: 'value',
      type: 'json',
      validate: (value) => {
        if (value) {
          try {
            JSON.parse(JSON.stringify(value))
          } catch {
            return 'Invalid JSON'
          }
        }

        return true
      },
    },
  ],
  lockDocuments: false,
})
</file>

<file path="convexadmin/admin/src/preferences/deleteUserPreferences.ts">
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { Payload } from '../index.js'
import type { PayloadRequest } from '../types/index.js'

import { preferencesCollectionSlug } from './config.js'

type Args = {
  collectionConfig: SanitizedCollectionConfig
  /**
   * User IDs to delete
   */
  ids: (number | string)[]
  payload: Payload
  req: PayloadRequest
}
export const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {
  if (collectionConfig.auth) {
    await payload.db.deleteMany({
      collection: preferencesCollectionSlug,
      req,
      where: {
        or: [
          {
            and: [
              {
                'user.value': { in: ids },
              },
              {
                'user.relationTo': { equals: collectionConfig.slug },
              },
            ],
          },
          {
            key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },
          },
        ],
      },
    })
  } else {
    await payload.db.deleteMany({
      collection: preferencesCollectionSlug,
      req,
      where: {
        key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },
      },
    })
  }
}
</file>

<file path="convexadmin/admin/src/preferences/types.ts">
import type { DefaultDocumentIDType } from '../index.js'
import type { PayloadRequest } from '../types/index.js'

export type PreferenceRequest = {
  key: string
  overrideAccess?: boolean
  req: PayloadRequest
  user: PayloadRequest['user']
}

export type PreferenceUpdateRequest = { value: unknown } & PreferenceRequest

export type CollapsedPreferences = string[]

export type TabsPreferences = Array<{
  [path: string]: number
}>

export type InsideFieldsPreferences = {
  collapsed: CollapsedPreferences
  tabIndex: number
}

export type FieldsPreferences = {
  [key: string]: InsideFieldsPreferences
}

export type DocumentPreferences = {
  fields: FieldsPreferences
}

export type ColumnPreference = {
  accessor: string
  active: boolean
}

export type ListPreferences = {
  columns?: ColumnPreference[]
  limit?: number
  preset?: DefaultDocumentIDType
  sort?: string
}
</file>

<file path="convexadmin/admin/src/templates/Default/NavHamburger/index.tsx">
"use client";

import { Menu, X } from "lucide-react"; // Assuming lucide-react is installed

import { Button } from "@/convexadmin/components/ui/button"; // Use Shadcn Button
import React from "react";
import { SidebarTrigger } from "@/convexadmin/components/ui/sidebar";
import { useNav } from "@/convexui/src/providers/NavProvider"; // Updated import path

export const NavHamburger = () => {
  const { isNavOpen, setIsNavOpen } = useNav();

  const toggleNav = () => setIsNavOpen(!isNavOpen);

  return <SidebarTrigger />;
};
</file>

<file path="convexadmin/admin/src/templates/Default/Wrapper/index.tsx">
// Placeholder for Wrapper component used in Payload's DefaultTemplate
import React from "react";

interface WrapperProps {
  children: React.ReactNode;
  baseClass?: string; // Prop used by Payload's component
  className?: string; // Prop used by Payload's component
}

export const Wrapper = ({ children }: WrapperProps) => {
  // Just render children for now, as we are not using baseClass/className logic
  return <>{children}</>;
};
</file>

<file path="convexadmin/admin/src/templates/Default/index.tsx">
"use client";

import { NavProvider, useNav } from "@/convexui/src/providers/NavProvider";

import { NavHamburger } from "./NavHamburger";
import React from "react";

// import AdminHeader from '../../components/layout/AdminHeader'; // TODO: Create Header - Adjusted path
// import AdminSidebar from '../../components/layout/AdminSidebar'; // TODO: Create Sidebar - Adjusted path

interface DefaultTemplateProps {
  children: React.ReactNode;
}

// Inner component to access nav context
const TemplateLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div className="flex h-screen bg-muted/40">
      {/* Conditionally render sidebar based on context state */}

      {/* TODO: Add mobile sidebar overlay/drawer */}

      <div className="flex flex-col flex-1 overflow-hidden">
        <header className="border-b p-4 bg-background flex items-center space-x-4">
          {/* Place Hamburger toggle in the header */}
          <NavHamburger />
          <h2 className="font-semibold">Header Placeholder</h2>
          {/* TODO: Replace with AdminHeader component */}
        </header>

        <main className="flex-1 overflow-y-auto p-4 md:p-6">{children}</main>
      </div>
    </div>
  );
};

// Outer component to provide context
export const DefaultTemplate = ({ children }: DefaultTemplateProps) => {
  return (
    <NavProvider>
      <TemplateLayout>{children}</TemplateLayout>
    </NavProvider>
  );
};
</file>

<file path="convexadmin/admin/src/templates/MinimalTemplate.tsx">
import React from 'react'

import './index.scss'

const baseClass = 'template-minimal'

export type MinimalTemplateProps = {
  children?: React.ReactNode
  className?: string
  style?: React.CSSProperties
  width?: 'normal' | 'wide'
}

export const MinimalTemplate: React.FC<MinimalTemplateProps> = (props) => {
  const { children, className, style = {}, width = 'normal' } = props

  const classes = [className, baseClass, `${baseClass}--width-${width}`].filter(Boolean).join(' ')

  return (
    <section className={classes} style={style}>
      <div className={`${baseClass}__wrap`}>{children}</div>
    </section>
  )
}
</file>

<file path="convexadmin/admin/src/utilities/formatAdminURL.ts">
import type { Config } from '../config/types.js'

/** Will read the `routes.admin` config and appropriately handle `"/"` admin paths */
export const formatAdminURL = (args: {
  adminRoute: NonNullable<Config['routes']>['admin']
  basePath?: string
  path: '' | `/${string}` | null | undefined
  serverURL?: Config['serverURL']
}): string => {
  const { adminRoute, basePath = '', path: pathFromArgs, serverURL } = args
  const path = pathFromArgs || ''

  if (adminRoute) {
    if (adminRoute === '/') {
      if (!path) {
        return `${serverURL || ''}${basePath}${adminRoute}`
      }
    } else {
      return `${serverURL || ''}${basePath}${adminRoute}${path}`
    }
  }

  return `${serverURL || ''}${basePath}${path}`
}
</file>

<file path="convexadmin/admin/src/utilities/getClientConfig.ts">
import type { I18nClient, SupportedLanguages } from '@convexcms/translations'
import type { ClientConfig, ImportMap, SanitizedConfig } from '@convexcms/core'

import { createClientConfig } from '@convexcms/core'
import { cache } from 'react'

let cachedClientConfigs = global._payload_clientConfigs as Record<
  keyof SupportedLanguages,
  ClientConfig
>

if (!cachedClientConfigs) {
  cachedClientConfigs = global._payload_clientConfigs = {} as Record<
    keyof SupportedLanguages,
    ClientConfig
  >
}

export const getClientConfig = cache(
  (args: { config: SanitizedConfig; i18n: I18nClient; importMap: ImportMap }): ClientConfig => {
    const { config, i18n, importMap } = args
    const currentLanguage = i18n.language

    if (cachedClientConfigs[currentLanguage] && !global._payload_doNotCacheClientConfig) {
      return cachedClientConfigs[currentLanguage]
    }

    const cachedClientConfig = createClientConfig({
      config,
      i18n,
      importMap,
    })

    cachedClientConfigs[currentLanguage] = cachedClientConfig
    global._payload_clientConfigs = cachedClientConfigs
    global._payload_doNotCacheClientConfig = false

    return cachedClientConfig
  },
)
</file>

<file path="convexadmin/admin/src/utilities/initPage.ts">
import type { InitPageResult, VisibleEntities } from '@convexcms/core'

import { notFound } from 'next/navigation.js'
import { isEntityHidden } from '@convexcms/core'
import * as qs from 'qs-esm'

import type { Args } from './types.js'

import { initReq } from '../initReq.js'
import { getRouteInfo } from './handleAdminPage.js'
import { handleAuthRedirect } from './handleAuthRedirect.js'
import { isCustomAdminView } from './isCustomAdminView.js'
import { isPublicAdminRoute } from './shared.js'

export const initPage = async ({
  config: configPromise,
  importMap,
  route,
  searchParams,
  useLayoutReq,
}: Args): Promise<InitPageResult> => {
  const queryString = `${qs.stringify(searchParams ?? {}, { addQueryPrefix: true })}`

  const {
    cookies,
    locale,
    permissions,
    req,
    req: { payload },
  } = await initReq({
    configPromise,
    importMap,
    key: useLayoutReq ? 'RootLayout' : 'initPage',
    overrides: {
      fallbackLocale: false,
      req: {
        query: qs.parse(queryString, {
          depth: 10,
          ignoreQueryPrefix: true,
        }),
      },
      urlSuffix: `${route}${searchParams ? queryString : ''}`,
    },
  })

  const {
    collections,
    globals,
    routes: { admin: adminRoute },
  } = payload.config

  const languageOptions = Object.entries(payload.config.i18n.supportedLanguages || {}).reduce(
    (acc, [language, languageConfig]) => {
      if (Object.keys(payload.config.i18n.supportedLanguages).includes(language)) {
        acc.push({
          label: languageConfig.translations.general.thisLanguage,
          value: language,
        })
      }

      return acc
    },
    [],
  )

  const visibleEntities: VisibleEntities = {
    collections: collections
      .map(({ slug, admin: { hidden } }) =>
        !isEntityHidden({ hidden, user: req.user }) ? slug : null,
      )
      .filter(Boolean),
    globals: globals
      .map(({ slug, admin: { hidden } }) =>
        !isEntityHidden({ hidden, user: req.user }) ? slug : null,
      )
      .filter(Boolean),
  }

  let redirectTo = null

  if (
    !permissions.canAccessAdmin &&
    !isPublicAdminRoute({ adminRoute, config: payload.config, route }) &&
    !isCustomAdminView({ adminRoute, config: payload.config, route })
  ) {
    redirectTo = handleAuthRedirect({
      config: payload.config,
      route,
      searchParams,
      user: req.user,
    })
  }

  const { collectionConfig, collectionSlug, docID, globalConfig, globalSlug } = getRouteInfo({
    adminRoute,
    config: payload.config,
    defaultIDType: payload.db.defaultIDType,
    payload,
    route,
  })

  if ((collectionSlug && !collectionConfig) || (globalSlug && !globalConfig)) {
    return notFound()
  }

  return {
    collectionConfig,
    cookies,
    docID,
    globalConfig,
    languageOptions,
    locale,
    permissions,
    redirectTo,
    req,
    translations: req.i18n.translations,
    visibleEntities,
  }
}
</file>

<file path="convexadmin/scripts/generate-admin.ts">
import type {
  AdminCollectionConfig,
  AdminCollectionField,
  AdminConfig,
} from "../types";
import {
  CallExpression,
  Project,
  PropertyAccessExpression,
  PropertyAssignment,
  SourceFile,
  SyntaxKind,
} from "ts-morph";
import { mkdirSync, writeFileSync } from "fs";

import { join } from "path";
import prettier from "prettier";

// ----- Helper Functions -----
function simplifyConvexType(typeString: string): string {
  const match = typeString.match(/^v\.(\w+)/);
  if (match && match[1]) {
    const typeMap: Record<string, string> = {
      string: "string",
      number: "number",
      boolean: "boolean",
      id: "id",
      array: "array",
      object: "object",
      union: "union",
      literal: "literal",
      int64: "number",
    };
    return typeMap[match[1]] || "unknown";
  }
  return "unknown";
}

function toTitleCase(str: string): string {
  str = str.replace(/([A-Z])/g, " $1");
  str = str.replace(/[_-]/g, " ");
  return str
    .toLowerCase()
    .split(" ")
    .filter((word) => word.length > 0)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

function generateFieldsConfig(
  fields: Record<string, string>,
): Record<string, AdminCollectionField> {
  return Object.fromEntries(
    Object.entries(fields).map(([fieldName, fieldType]) => [
      fieldName,
      {
        label: toTitleCase(fieldName),
        type: fieldType,
      } as AdminCollectionField,
    ]),
  );
}

function generateConfig(
  tables: Record<string, Record<string, string>>,
): AdminConfig {
  return {
    collections: Object.fromEntries(
      Object.entries(tables).map(([tableName, fields]) => [
        tableName,
        {
          label: toTitleCase(tableName),
          pluralLabel: toTitleCase(tableName),
          fields: generateFieldsConfig(fields),
        } as AdminCollectionConfig,
      ]),
    ),
  };
}

function parseConvexSchema(
  sourceFile: SourceFile,
): Record<string, Record<string, string>> {
  const tables: Record<string, Record<string, string>> = {};
  const defaultExportAssignment = sourceFile.getDescendantsOfKind(
    SyntaxKind.ExportAssignment,
  )[0];
  if (!defaultExportAssignment) {
    console.error("Could not find default export assignment in schema.ts");
    return tables;
  }
  const schemaDeclaration = defaultExportAssignment.getExpression();
  if (
    !schemaDeclaration ||
    !schemaDeclaration.isKind(SyntaxKind.CallExpression)
  ) {
    console.error(
      "Default export expression is not a call expression (defineSchema)",
    );
    return tables;
  }
  const schemaObject = schemaDeclaration.getArguments()[0];
  if (
    !schemaObject ||
    !schemaObject.isKind(SyntaxKind.ObjectLiteralExpression)
  ) {
    console.error("defineSchema argument is not an object literal");
    return tables;
  }

  schemaObject.getProperties().forEach((property) => {
    if (property.isKind(SyntaxKind.PropertyAssignment)) {
      const tableName = property.getName();
      let tableInitializer = property.getInitializer();
      while (
        tableInitializer?.isKind(SyntaxKind.CallExpression) &&
        tableInitializer
          .getExpression()
          .isKind(SyntaxKind.PropertyAccessExpression)
      ) {
        const propAccess =
          tableInitializer.getExpression() as PropertyAccessExpression;
        tableInitializer = propAccess.getExpression();
      }
      if (tableInitializer?.isKind(SyntaxKind.CallExpression)) {
        const defineTableCall = tableInitializer as CallExpression;
        const funcName = defineTableCall.getExpression().getText();
        if (funcName.endsWith("defineTable")) {
          const tableFieldsObject = defineTableCall.getArguments()[0];
          if (tableFieldsObject?.isKind(SyntaxKind.ObjectLiteralExpression)) {
            const fields: Record<string, string> = {};
            tableFieldsObject.getProperties().forEach((fieldProperty) => {
              if (fieldProperty.isKind(SyntaxKind.PropertyAssignment)) {
                const assignment = fieldProperty as PropertyAssignment;
                const fieldName = assignment.getName();
                const fieldTypeNode = assignment.getInitializer();
                const fieldType = fieldTypeNode?.getText() ?? "unknown";
                fields[fieldName] = simplifyConvexType(fieldType);
              }
            });
            tables[tableName] = fields;
          } else {
            console.warn(`Could not find fields object for table ${tableName}`);
          }
        } else {
          console.warn(
            `Expected defineTable call for ${tableName}, found ${funcName}`,
          );
        }
      } else {
        console.warn(
          `Could not parse initializer for table ${tableName}: ${tableInitializer?.getKindName()}`,
        );
      }
    }
  });
  return tables;
}

// Function to generate the content for importMap.ts
function generateImportMapContent(): string {
  const imports = `
// View Imports
import { DashboardView } from '@/convexadmin/components/views/DashboardView';
import { ListView } from '@/convexadmin/components/views/ListView';
import { EditView } from '@/convexadmin/components/views/EditView';
import { NotFoundView } from '@/convexadmin/components/views/NotFoundView';
import { CollectionSettingsPage } from '@/convexadmin/components/views/CollectionSettingsPage';
// Field Imports
import { TextField } from '@/convexadmin/fields/TextField';
import { CheckboxField } from '@/convexadmin/fields/CheckboxField';
import { NumberField } from '@/convexadmin/fields/NumberField';
import { UnknownField } from '@/convexadmin/fields/UnknownField';
`;

  const mapObject = `
export const importMap = {
  views: {
    Dashboard: DashboardView,
    CollectionList: ListView,
    CollectionEdit: EditView,
    CollectionCreate: CreateView,
    CollectionSettings: CollectionSettingsPage,
    NotFound: NotFoundView,
  },
  fields: {
    string: TextField,
    boolean: CheckboxField,
    number: NumberField,
    unknown: UnknownField,
  },
};
`;

  return `// This file is generated automatically. Do not edit.
/* eslint-disable */
${imports}
${mapObject}
`;
}

// ----- Formatting Function -----
async function formatCode(code: string): Promise<string> {
  try {
    const options = (await prettier.resolveConfig(process.cwd())) ?? {};
    options.parser = "typescript";
    return await prettier.format(code, options);
  } catch (error) {
    console.warn(
      "Prettier formatting failed, falling back to unformatted code:",
      error,
    );
    return code;
  }
}

// ----- Main Generation Logic -----
async function runGeneration() {
  console.log("Generating admin config & import map...");
  const project = new Project({
    // Optional compiler options
  });
  const schemaFile = project.addSourceFileAtPath("./convex/schema.ts");
  const tables = parseConvexSchema(schemaFile);
  const adminConfig = generateConfig(tables);

  const outputDir = join(process.cwd(), ".generated");
  mkdirSync(outputDir, { recursive: true });

  // --- Generate config.ts ---
  const configOutputFile = join(outputDir, "convexadmin.config.ts");
  const configString = JSON.stringify(adminConfig, null, 2);
  const configTypeImportPath = "@/convexadmin/types";
  const configTsContent = `// This file is generated automatically. Do not edit.
/* eslint-disable */
import type { AdminConfig } from '${configTypeImportPath}'; 

export const config: AdminConfig = ${configString};
`;
  const formattedConfigTsContent = await formatCode(configTsContent);
  writeFileSync(configOutputFile, formattedConfigTsContent);
  console.log(`Admin config TS module written to ${configOutputFile}`);

  // --- Generate importMap.ts ---
  const importMapOutputFile = join(outputDir, "convexadmin.importMap.ts");
  const importMapTsContent = generateImportMapContent();
  const formattedImportMapTsContent = await formatCode(importMapTsContent);
  writeFileSync(importMapOutputFile, formattedImportMapTsContent);
  console.log(`Admin import map TS module written to ${importMapOutputFile}`);
}

runGeneration().catch((error) => {
  console.error("Error generating admin files:", error);
  process.exit(1);
});
</file>

<file path="convexadmin/ui/src/elements/DocumentFields/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .document-fields {
    width: 100%;
    display: flex;
    --doc-sidebar-width: 325px;

    &--has-sidebar {
      .document-fields {
        &__main {
          width: 66.66%;
        }

        &__edit {
          [dir='ltr'] & {
            top: 0;
            right: 0;
            border-right: 1px solid var(--theme-elevation-100);
            padding-right: calc(var(--base) * 2);
          }

          [dir='rtl'] & {
            top: 0;
            left: 0;
            border-left: 1px solid var(--theme-elevation-100);
            padding-left: calc(var(--base) * 2);
          }
        }

        &__fields {
          & > .tabs-field,
          & > .group-field {
            margin-right: calc(var(--base) * -2);
          }
        }
      }
    }

    &__main {
      width: 100%;
      display: flex;
      flex-direction: column;
      min-height: 100%;
      flex-grow: 1;
    }

    &__edit {
      padding-top: calc(var(--base) * 1.5);
      padding-bottom: var(--spacing-view-bottom);
      flex-grow: 1;
    }

    &__sidebar-wrap {
      position: sticky;
      top: var(--doc-controls-height);
      width: 33.33%;
      height: calc(100vh - var(--doc-controls-height));
      min-width: var(--doc-sidebar-width);
      flex-shrink: 0;
    }

    &__sidebar {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__sidebar-fields {
      display: flex;
      flex-direction: column;
      gap: var(--base);
      padding-top: calc(var(--base) * 1.5);
      padding-left: calc(var(--base) * 2);
      padding-right: var(--gutter-h);
      padding-bottom: var(--spacing-view-bottom);
    }

    &__label {
      color: var(--theme-elevation-400);
    }

    &--force-sidebar-wrap {
      display: block;

      .document-fields {
        &__main {
          width: 100%;
          min-height: initial;
        }

        &__sidebar-wrap {
          position: static;
          width: 100%;
          height: initial;
          border-left: 0;
        }

        &__sidebar {
          padding-bottom: base(3.5);
          overflow: visible;
        }

        &__sidebar-fields {
          padding-top: 0;
          padding-left: var(--gutter-h);
          padding-bottom: 0;
        }
      }
    }

    @include mid-break {
      display: block;

      &--has-sidebar {
        .document-fields {
          &__main {
            width: 100%;
          }

          &__edit {
            [dir='ltr'] & {
              border-right: 0;
              padding-right: var(--gutter-h);
            }

            [dir='rtl'] & {
              border-left: 0;
              padding-left: var(--gutter-h);
            }
          }

          &__fields {
            & > .tabs-field,
            & > .group-field {
              margin-right: calc(var(--gutter-h) * -1);
            }
          }
        }
      }

      &__main {
        width: 100%;
        min-height: initial;
      }

      &__sidebar-wrap {
        position: static;
        width: 100%;
        height: initial;
        border-left: 0;
      }

      &__form {
        display: block;
      }

      &__sidebar-fields {
        padding-top: 0;
        padding-left: var(--gutter-h);
        padding-right: var(--gutter-h);
        padding-bottom: 0;
        gap: base(0.5);

        [dir='ltr'] & {
          padding-right: var(--gutter-h);
        }

        [dir='rtl'] & {
          padding-left: var(--gutter-h);
        }
      }

      &__sidebar {
        padding-bottom: base(3.5);
        overflow: visible;
      }
    }

    @include small-break {
      &__sidebar-wrap {
        min-width: initial;
        width: 100%;
      }

      &__edit {
        padding-top: calc(var(--base) / 2);
      }
    }
  }
}
</file>

<file path="convexadmin/ui/src/elements/DocumentFields/index.tsx">
"use client";

import React, { useMemo } from "react";

import type { AdminCollectionField } from "@/convexadmin/types";
import { Gutter } from "../Gutter";
import { RenderFields } from "@/convexui/src/forms/RenderFields";
import { fieldIsSidebar } from "@/convexui/src/utilities/fieldIsSidebar";

// Mock permission type for now
// TODO: Define actual permissions structure if needed
type MockPermissions = any;

type DocumentFieldsProps = {
  AfterFields?: React.ReactNode;
  BeforeFields?: React.ReactNode;
  Description?: React.ReactNode;
  docPermissions: MockPermissions;
  fields: Record<string, AdminCollectionField>;
  forceSidebarWrap?: boolean;
  readOnly?: boolean;
};

export const DocumentFields: React.FC<DocumentFieldsProps> = ({
  AfterFields,
  BeforeFields,
  Description,
  docPermissions,
  fields,
  forceSidebarWrap,
  readOnly,
}) => {
  // Use Object.entries to get [key, value] pairs
  const fieldEntries = useMemo(() => Object.entries(fields || {}), [fields]);

  // Separate fields, adding the name property to each field object
  const { hasSidebarFields, mainFields, sidebarFields } = useMemo(() => {
    return fieldEntries.reduce(
      (acc, [name, fieldConfig]) => {
        // Destructure [name, fieldConfig]
        const fieldWithName = { ...fieldConfig, name }; // Add name property

        if (fieldIsSidebar(fieldWithName)) {
          // Check the enriched field
          acc.sidebarFields.push(fieldWithName);
          acc.hasSidebarFields = true;
        } else {
          acc.mainFields.push(fieldWithName);
        }
        return acc;
      },
      {
        hasSidebarFields: false,
        mainFields: [] as (AdminCollectionField & { name: string })[], // Update type
        sidebarFields: [] as (AdminCollectionField & { name: string })[], // Update type
      },
    );
  }, [fieldEntries]);

  // Render structure remains the same, just passes enriched fields
  return (
    <div
      className={`flex flex-wrap ${forceSidebarWrap ? "force-sidebar-wrap" : ""}`}
    >
      <div
        className={`flex-grow ${hasSidebarFields ? "w-full md:w-2/3" : "w-full"}`}
      >
        <Gutter className="document-fields-edit">
          {Description && (
            <header className="mb-4">
              <div>{Description}</div>
            </header>
          )}
          {BeforeFields}
          <RenderFields
            className="space-y-6"
            fields={mainFields} // Pass enriched mainFields
            parentIndexPath=""
            parentPath=""
            parentSchemaPath=""
            permissions={docPermissions?.fields}
            readOnly={readOnly}
          />
          {AfterFields}
        </Gutter>
      </div>

      {hasSidebarFields && (
        <div className="w-full md:w-1/3 md:pl-8 mt-6 md:mt-0">
          <div className="bg-card p-4 rounded-lg border">
            <h3 className="font-semibold mb-4">Sidebar</h3>
            <RenderFields
              className="space-y-6"
              fields={sidebarFields} // Pass enriched sidebarFields
              parentIndexPath=""
              parentPath=""
              parentSchemaPath=""
              permissions={docPermissions?.fields}
              readOnly={readOnly}
            />
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/elements/Gutter/index.tsx">
"use client";

// Mock Gutter component (Payload uses this for consistent spacing)
import React from "react";

interface GutterProps {
  children: React.ReactNode;
  className?: string;
  // Add other props if needed based on usage
}

export const Gutter = ({ children, className }: GutterProps) => {
  // Render a simple div, optionally passing className
  // Adjust padding/margin as needed for your layout
  return <div className={`px-4 md:px-6 ${className || ""}`}>{children}</div>;
};
</file>

<file path="convexadmin/ui/src/elements/Nav/NavToggler/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .nav-toggler {
    position: relative;
    background: transparent;
    padding: 0;
    margin: 0;
    border: 0;
    cursor: pointer;
  }
}
</file>

<file path="convexadmin/ui/src/elements/Nav/NavToggler/index.tsx">
'use client'
import { useWindowInfo } from '@faceless-ui/window-info'
import React from 'react'

import { usePreferences } from '../../../providers/Preferences/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { useNav } from '../context.js'
import './index.scss'

const baseClass = 'nav-toggler'

export const NavToggler: React.FC<{
  children?: React.ReactNode
  className?: string
  id?: string
  tabIndex?: number
}> = (props) => {
  const { id, children, className, tabIndex = 0 } = props

  const { t } = useTranslation()

  const { setPreference } = usePreferences()

  const { navOpen, setNavOpen } = useNav()

  const {
    breakpoints: { l: largeBreak },
  } = useWindowInfo()

  return (
    <button
      aria-label={`${navOpen ? t('general:close') : t('general:open')} ${t('general:menu')}`}
      className={[baseClass, navOpen && `${baseClass}--is-open`, className]
        .filter(Boolean)
        .join(' ')}
      id={id}
      onClick={async () => {
        setNavOpen(!navOpen)

        // only when the user explicitly toggles the nav on desktop do we want to set the preference
        // this is because the js may open or close the nav based on the window size, routing, etc
        if (!largeBreak) {
          await setPreference(
            'nav',
            {
              open: !navOpen,
            },
            true,
          )
        }
      }}
      tabIndex={tabIndex}
      type="button"
    >
      {children}
    </button>
  )
}
</file>

<file path="convexadmin/ui/src/elements/Nav/context.tsx">
"use client";

import React, { useEffect, useRef } from "react";

import { usePathname } from "next/navigation.js";
import { useWindowInfo } from "@faceless-ui/window-info";

// import { usePreferences } from '../../providers/Preferences/index.js'

type NavContextType = {
  hydrated: boolean;
  navOpen: boolean;
  navRef: React.RefObject<HTMLDivElement | null>;
  setNavOpen: (value: boolean) => void;
  shouldAnimate: boolean;
};

export const NavContext = React.createContext<NavContextType>({
  hydrated: false,
  navOpen: true,
  navRef: null,
  setNavOpen: () => {},
  shouldAnimate: false,
});

export const useNav = () => React.use(NavContext);

const getNavPreference = async (getPreference): Promise<boolean> => {
  const navPrefs = await getPreference("nav");
  const preferredState = navPrefs?.open;
  if (typeof preferredState === "boolean") {
    return preferredState;
  } else {
    return true;
  }
};

export const NavProvider: React.FC<{
  children: React.ReactNode;
  initialIsOpen?: boolean;
}> = ({ children, initialIsOpen }) => {
  const {
    breakpoints: { l: largeBreak, m: midBreak, s: smallBreak },
  } = useWindowInfo();

  const pathname = usePathname();

  // const { getPreference } = usePreferences()
  const navRef = useRef(null);

  // initialize the nav to be closed
  // this is because getting the preference is async
  // so instead of closing it after the preference is loaded
  // we will open it after the preference is loaded
  const [navOpen, setNavOpen] = React.useState(initialIsOpen);

  const [shouldAnimate, setShouldAnimate] = React.useState(false);
  const [hydrated, setHydrated] = React.useState(false);

  // on load check the user's preference and set "initial" state
  // useEffect(() => {
  //   if (largeBreak === false) {
  //     const setNavFromPreferences = async () => {
  //       const preferredState = await getNavPreference(getPreference)
  //       setNavOpen(preferredState)
  //     }

  //     void setNavFromPreferences()
  //   }
  // }, [largeBreak, getPreference, setNavOpen])

  // on smaller screens where the nav is a modal
  // close the nav when the user navigates away
  useEffect(() => {
    if (smallBreak === true) {
      setNavOpen(false);
    }
  }, [pathname]);

  // on open and close, lock the body scroll
  // do not do this on desktop, the sidebar is not a modal
  useEffect(() => {
    if (navRef.current) {
      if (navOpen && midBreak) {
        navRef.current.style.overscrollBehavior = "contain";
      } else {
        navRef.current.style.overscrollBehavior = "auto";
      }
    }
  }, [navOpen, midBreak]);

  // on smaller screens where the nav is a modal
  // close the nav when the user resizes down to mobile
  // the sidebar is a modal on mobile
  useEffect(() => {
    if (largeBreak === true || midBreak === true || smallBreak === true) {
      setNavOpen(false);
    }
    setHydrated(true);

    setTimeout(() => {
      setShouldAnimate(true);
    }, 100);
  }, [largeBreak, midBreak, smallBreak]);

  // when the component unmounts, clear all body scroll locks
  useEffect(() => {
    return () => {
      if (navRef.current) {
        navRef.current.style.overscrollBehavior = "auto";
      }
    };
  }, []);

  return (
    <NavContext
      value={{ hydrated, navOpen, navRef, setNavOpen, shouldAnimate }}
    >
      {children}
    </NavContext>
  );
};
</file>

<file path="convexadmin/ui/src/elements/RenderIfInViewport/index.tsx">
"use client";

import React from "react";
import { useIntersect } from "../../hooks/useIntersect";

export const RenderIfInViewport: React.FC<{
  children: React.ReactNode;
  className?: string;
  forceRender?: boolean;
}> = ({ children, className, forceRender }) => {
  const [hasRendered, setHasRendered] = React.useState(Boolean(forceRender));
  const [intersectionRef, entry] = useIntersect(
    {
      rootMargin: "1000px",
    },
    Boolean(forceRender),
  );

  const isIntersecting = Boolean(entry?.isIntersecting);
  const isAboveViewport = entry?.boundingClientRect?.top < 0;
  const shouldRender = forceRender || isIntersecting || isAboveViewport;

  React.useEffect(() => {
    if (shouldRender && !hasRendered) {
      setHasRendered(true);
    }
  }, [shouldRender, hasRendered]);

  return (
    <div className={className} ref={intersectionRef}>
      {hasRendered ? children : null}
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/elements/AppSidebar.tsx">
import * as React from "react";

import {
  Sidebar,
  SidebarContent,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarRail,
} from "@/convexadmin/components/ui/sidebar";

import { AdminCollectionConfig } from "@/convexadmin/types"; // Import the type
import { HomeIcon } from "lucide-react"; // Import an icon
import Link from "next/link"; // Import Link for navigation
import { VersionSwitcher } from "./version-switcher";
import { useConvexAdmin } from "@/convexadmin/components/ConvexAdminProvider"; // Import the hook

// This is sample data.
const data = {
  versions: ["1.0.1", "1.1.0-alpha", "2.0.0-beta1"],
};
// Removed static data import/definition

export function AppSidebar({ ...props }: React.ComponentProps<typeof Sidebar>) {
  const { config } = useConvexAdmin(); // Get config from context

  // Determine if the current path matches a collection link
  // TODO: Use Next.js router (usePathname) for more robust active state detection
  const currentPath =
    typeof window !== "undefined" ? window.location.pathname : "";

  return (
    <Sidebar variant="inset" collapsible="icon" {...props}>
      <SidebarHeader>
        {/* TODO: Add relevant header content, maybe app title/logo */}
        <VersionSwitcher
          versions={data.versions}
          defaultVersion={data.versions[0]}
        />
        {/* <SearchForm /> */}
      </SidebarHeader>
      <SidebarContent>
        {/* Dashboard Link */}
        <SidebarGroup>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem>
                <SidebarMenuButton
                  asChild
                  isActive={
                    currentPath === "/admin" ||
                    currentPath === "/admin/dashboard"
                  } // Basic active check
                >
                  <Link href="/admin">
                    {" "}
                    {/* Or /admin/dashboard */}
                    <HomeIcon className="mr-2 h-4 w-4" />
                    Dashboard
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>

        {/* Collections Group */}
        {config?.collections && typeof config.collections === "object" && (
          <SidebarGroup>
            <SidebarGroupLabel>Collections</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {Object.entries(config.collections).map(
                  ([slug, collectionConfig]: [
                    string,
                    AdminCollectionConfig,
                  ]) => {
                    const href = `/admin/collections/${slug}`;
                    // Basic active check, replace with router logic later
                    const isActive = currentPath === href;
                    return (
                      <SidebarMenuItem key={slug}>
                        <SidebarMenuButton asChild isActive={isActive}>
                          <Link href={href}>
                            {/* TODO: Add collection icons? */}
                            {collectionConfig.label || slug}
                          </Link>
                        </SidebarMenuButton>
                      </SidebarMenuItem>
                    );
                  },
                )}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        )}

        {/* TODO: Add other groups like Globals */}

        {/* Example of original static data structure - remove or adapt */}
        {/* {data.navMain.map((item) => (
          <SidebarGroup key={item.title}>
            <SidebarGroupLabel>{item.title}</SidebarGroupLabel>
            <SidebarGroupContent>
              <SidebarMenu>
                {item.items.map((item) => (
                  <SidebarMenuItem key={item.title}>
                    <SidebarMenuButton asChild isActive={item.isActive}>
                      <a href={item.url}>{item.title}</a>
                    </SidebarMenuButton>
                  </SidebarMenuItem>
                ))}
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        ))} */}
      </SidebarContent>
      <SidebarRail />
    </Sidebar>
  );
}
</file>

<file path="convexadmin/ui/src/elements/version-switcher.tsx">
"use client";

import * as React from "react";

import { Check, ChevronsUpDown, GalleryVerticalEnd } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/convexadmin/components/ui/dropdown-menu";
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/convexadmin/components/ui/sidebar";

export function VersionSwitcher({
  versions,
  defaultVersion,
}: {
  versions: string[];
  defaultVersion: string;
}) {
  const [selectedVersion, setSelectedVersion] = React.useState(defaultVersion);

  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <div className="flex aspect-square size-8 items-center justify-center rounded-lg bg-sidebar-primary text-sidebar-primary-foreground">
                <GalleryVerticalEnd className="size-4" />
              </div>
              <div className="flex flex-col gap-0.5 leading-none">
                <span className="font-semibold">Documentation</span>
                <span className="">v{selectedVersion}</span>
              </div>
              <ChevronsUpDown className="ml-auto" />
            </SidebarMenuButton>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            className="w-[--radix-dropdown-menu-trigger-width]"
            align="start"
          >
            {versions.map((version) => (
              <DropdownMenuItem
                key={version}
                onSelect={() => setSelectedVersion(version)}
              >
                v{version}{" "}
                {version === selectedVersion && <Check className="ml-auto" />}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  );
}
</file>

<file path="convexadmin/ui/src/fields/Checkbox/index.tsx">
"use client";

import type { AdminCollectionField } from "@/convexadmin/types";
import { Checkbox } from "@/convexadmin/components/ui/checkbox";
import { Label } from "@/convexadmin/components/ui/label";
import React from "react";

// Basic Mock CheckboxField
export const CheckboxField = (props: {
  path: string;
  readOnly?: boolean;
  field: AdminCollectionField;
}) => {
  console.warn(
    `Mock CheckboxField rendering for path: ${props.path} - Using Shadcn`,
  );
  const label = props.field?.label || props.path;
  const uniqueId = `field-${props.path}`;

  return (
    <div className="flex items-center space-x-2 py-2">
      <Checkbox
        id={uniqueId}
        name={props.path}
        disabled={props.readOnly}
        aria-label={label}
      />
      <Label
        htmlFor={uniqueId}
        className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 select-none"
      >
        {label}
      </Label>
      {/* Add error display later */}
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/fields/Number/index.tsx">
"use client";

import type { AdminCollectionField } from "@/convexadmin/types";
import { Input } from "@/convexadmin/components/ui/input";
import { Label } from "@/convexadmin/components/ui/label";
import React from "react";

// Basic Mock NumberField
export const NumberField = (props: {
  path: string;
  readOnly?: boolean;
  field: AdminCollectionField;
}) => {
  console.warn(
    `Mock NumberField rendering for path: ${props.path} - Using Shadcn`,
  );
  const label = props.field?.label || props.path;
  const uniqueId = `field-${props.path}`;

  return (
    <div className="py-2">
      <Label htmlFor={uniqueId} className="text-sm font-medium">
        {label}
      </Label>
      <Input
        id={uniqueId}
        name={props.path}
        type="number"
        disabled={props.readOnly}
        placeholder={`Enter ${label.toLowerCase()}`}
        className="mt-1"
        // Add step, min, max props from field config if needed later
        // Note: Shadcn Input value needs to be managed via react-hook-form Controller
      />
      {/* Add error display later */}
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/fields/Select/index.tsx">
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/convexadmin/components/ui/select";

import type { AdminCollectionField } from "@/convexadmin/types";
import { Label } from "@/convexadmin/components/ui/label";
import React from "react";

// Basic Mock SelectField
// Needs props like field definition (including options)
/*
interface MockSelectFieldProps {
  path: string;
  readOnly?: boolean;
  field?: AdminCollectionField & {
    options?: Array<{ label: string; value: string }>;
  };
}
*/

export const SelectField = (props: {
  path: string;
  readOnly?: boolean;
  field: AdminCollectionField & {
    options?: Array<{ label: string; value: string }>;
  };
}) => {
  console.warn(
    `Mock SelectField rendering for path: ${props.path} - Using Shadcn`,
  );
  const label = props.field?.label || props.path;
  const uniqueId = `field-${props.path}`;
  const options = props.field?.options || [];

  return (
    <div className="grid w-full items-center gap-1.5 py-2">
      <Label htmlFor={uniqueId}>{label}</Label>
      <Select name={props.path} disabled={props.readOnly}>
        <SelectTrigger id={uniqueId} aria-label={label}>
          <SelectValue placeholder={`Select ${label}...`} />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {/* Add error display later */}
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/fields/Text/index.tsx">
"use client";

import { Controller, useFormContext } from "react-hook-form";

import type { AdminCollectionField } from "@/convexadmin/types";
import { Input } from "@/convexadmin/components/ui/input";
import { Label } from "@/convexadmin/components/ui/label";
import React from "react";

// Basic props expected by the field component
interface TextFieldProps {
  path: string;
  readOnly?: boolean;
  field: AdminCollectionField;
}

export const TextField: React.FC<TextFieldProps> = ({
  path,
  readOnly,
  field: clientFieldConfig,
}) => {
  const formContext = useFormContext();

  console.log(`TextField mounted for path: "${path}"`);
  if (!formContext) {
    console.error(`!!! useFormContext is NULL for path: "${path}" !!!`);
    return <div>Error: Form context not found for {path}</div>;
  }
  const { control } = formContext;

  const label = clientFieldConfig?.label || path;
  const uniqueId = `field-${path.replace(/\./g, "-")}`;

  return (
    <div className="py-2">
      <Label htmlFor={uniqueId} className="text-sm font-medium">
        {label}
      </Label>
      <Controller
        name={path}
        control={control}
        render={({ field }) => {
          console.log(`Controller render for path: "${path}"`, { field });
          return (
            <Input
              {...field}
              id={uniqueId}
              type="text"
              disabled={readOnly}
              placeholder={`Enter ${label.toLowerCase()}`}
              className="mt-1"
            />
          );
        }}
      />
    </div>
  );
};
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/index.ts">
import type {
  Data,
  Field as FieldSchema,
  PayloadRequest,
  SelectMode,
  SelectType,
  User,
} from '@convexcms/core'

import { iterateFields } from './iterateFields.js'

type Args = {
  data: Data
  fields: FieldSchema[]
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}

export const calculateDefaultValues = async ({
  id,
  data,
  fields,
  locale,
  req,
  select,
  selectMode,
  user,
}: Args): Promise<Data> => {
  await iterateFields({
    id,
    data,
    fields,
    locale,
    req,
    select,
    selectMode,
    siblingData: data,
    user,
  })

  return data
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/iterateFields.ts">
import type { Data, Field, PayloadRequest, SelectMode, SelectType, TabAsField, User } from '@convexcms/core'

import { defaultValuePromise } from './promise.js'

type Args<T> = {
  data: T
  fields: (Field | TabAsField)[]
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}

export const iterateFields = async <T>({
  id,
  data,
  fields,
  locale,
  req,
  select,
  selectMode,
  siblingData,
  user,
}: Args<T>): Promise<void> => {
  const promises = []

  fields.forEach((field) => {
    promises.push(
      defaultValuePromise({
        id,
        data,
        field,
        locale,
        req,
        select,
        selectMode,
        siblingData,
        user,
      }),
    )
  })

  await Promise.all(promises)
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/promise.ts">
import type {
  Data,
  Field,
  FlattenedBlock,
  PayloadRequest,
  SelectMode,
  SelectType,
  TabAsField,
  User,
} from '@convexcms/core'

import { getBlockSelect, getDefaultValue, stripUnselectedFields } from '@convexcms/core'
import { fieldAffectsData, tabHasName } from '@convexcms/core/shared'

import { iterateFields } from './iterateFields.js'

type Args<T> = {
  data: T
  field: Field | TabAsField
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}

// TODO: Make this works for rich text subfields
export const defaultValuePromise = async <T>({
  id,
  data,
  field,
  locale,
  req,
  select,
  selectMode,
  siblingData,
  user,
}: Args<T>): Promise<void> => {
  const shouldContinue = stripUnselectedFields({
    field,
    select,
    selectMode,
    siblingDoc: siblingData,
  })

  if (!shouldContinue) {
    return
  }

  if (fieldAffectsData(field)) {
    if (
      typeof siblingData[field.name] === 'undefined' &&
      typeof field.defaultValue !== 'undefined'
    ) {
      try {
        siblingData[field.name] = await getDefaultValue({
          defaultValue: field.defaultValue,
          locale,
          req,
          user,
          value: siblingData[field.name],
        })
      } catch (err) {
        req.payload.logger.error({
          err,
          msg: `Error calculating default value for field: ${field.name}`,
        })
      }
    }
  }

  // Traverse subfields
  switch (field.type) {
    case 'array': {
      const rows = siblingData[field.name]

      if (Array.isArray(rows)) {
        const promises = []
        const arraySelect = select?.[field.name]

        rows.forEach((row) => {
          promises.push(
            iterateFields({
              id,
              data,
              fields: field.fields,
              locale,
              req,
              select: typeof arraySelect === 'object' ? arraySelect : undefined,
              selectMode,
              siblingData: row,
              user,
            }),
          )
        })

        await Promise.all(promises)
      }
      break
    }

    case 'blocks': {
      const rows = siblingData[field.name]

      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row) => {
          const blockTypeToMatch: string = row.blockType

          const block =
            req.payload.blocks[blockTypeToMatch] ??
            ((field.blockReferences ?? field.blocks).find(
              (blockType) => typeof blockType !== 'string' && blockType.slug === blockTypeToMatch,
            ) as FlattenedBlock | undefined)

          const { blockSelect, blockSelectMode } = getBlockSelect({
            block,
            select: select?.[field.name],
            selectMode,
          })

          if (block) {
            row.blockType = blockTypeToMatch

            promises.push(
              iterateFields({
                id,
                data,
                fields: block.fields,
                locale,
                req,
                select: typeof blockSelect === 'object' ? blockSelect : undefined,
                selectMode: blockSelectMode,
                siblingData: row,
                user,
              }),
            )
          }
        })
        await Promise.all(promises)
      }

      break
    }

    case 'collapsible':
    case 'row': {
      await iterateFields({
        id,
        data,
        fields: field.fields,
        locale,
        req,
        select,
        selectMode,
        siblingData,
        user,
      })

      break
    }
    case 'group': {
      if (typeof siblingData[field.name] !== 'object') {
        siblingData[field.name] = {}
      }

      const groupData = siblingData[field.name] as Record<string, unknown>

      const groupSelect = select?.[field.name]

      await iterateFields({
        id,
        data,
        fields: field.fields,
        locale,
        req,
        select: typeof groupSelect === 'object' ? groupSelect : undefined,
        selectMode,
        siblingData: groupData,
        user,
      })

      break
    }

    case 'tab': {
      let tabSiblingData

      const isNamedTab = tabHasName(field)

      let tabSelect: SelectType | undefined

      if (isNamedTab) {
        if (typeof siblingData[field.name] !== 'object') {
          siblingData[field.name] = {}
        }

        tabSiblingData = siblingData[field.name] as Record<string, unknown>

        if (typeof select?.[field.name] === 'object') {
          tabSelect = select?.[field.name] as SelectType
        }
      } else {
        tabSiblingData = siblingData
        tabSelect = select
      }

      await iterateFields({
        id,
        data,
        fields: field.fields,
        locale,
        req,
        select: tabSelect,
        selectMode,
        siblingData: tabSiblingData,
        user,
      })

      break
    }

    case 'tabs': {
      await iterateFields({
        id,
        data,
        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
        locale,
        req,
        select,
        selectMode,
        siblingData,
        user,
      })

      break
    }

    default: {
      break
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/addFieldStatePromise.ts">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FieldState,
  FlattenedBlock,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  Row,
  SanitizedFieldPermissions,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
  Validate,
} from '@convexcms/core'

import ObjectIdImport from 'bson-objectid'
import { getBlockSelect } from '@convexcms/core'
import {
  deepCopyObjectSimple,
  fieldAffectsData,
  fieldHasSubFields,
  fieldIsHiddenOrDisabled,
  fieldIsID,
  fieldIsLocalized,
  getFieldPaths,
  tabHasName,
} from '@convexcms/core/shared'

import type { RenderFieldMethod } from './types.js'

import { resolveFilterOptions } from '../../utilities/resolveFilterOptions.js'
import { iterateFields } from './iterateFields.js'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

export type AddFieldStatePromiseArgs = {
  addErrorPathToParent: (fieldPath: string) => void
  /**
   * if all parents are localized, then the field is localized
   */
  anyParentLocalized?: boolean
  /**
   * Data of the nearest parent block, or undefined
   */
  blockData: Data | undefined
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data: Data
  field: Field
  fieldIndex: number
  fieldSchemaMap: FieldSchemaMap
  /**
   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.
   */
  filter?: (args: AddFieldStatePromiseArgs) => boolean
  /**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
  forceFullValue?: boolean
  fullData: Data
  id: number | string
  /**
   * Whether the field schema should be included in the state
   */
  includeSchema?: boolean
  indexPath: string
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  /**
   * Whether to omit parent fields in the state. @default false
   */
  omitParents?: boolean
  operation: 'create' | 'update'
  parentIndexPath: string
  parentPath: string
  parentPermissions: SanitizedFieldsPermissions
  parentSchemaPath: string
  passesCondition: boolean
  path: string
  preferences: DocumentPreferences
  previousFormState: FormState
  renderAllFields: boolean
  renderFieldFn: RenderFieldMethod
  /**
   * Req is used for validation and defaultValue calculation. If you don't need validation,
   * just create your own req and pass in the locale and the user
   */
  req: PayloadRequest
  schemaPath: string
  select?: SelectType
  selectMode?: SelectMode
  /**
   * Whether to skip checking the field's condition. @default false
   */
  skipConditionChecks?: boolean
  /**
   * Whether to skip validating the field. @default false
   */
  skipValidation?: boolean
  state: FormStateWithoutComponents
}

/**
 * Flattens the fields schema and fields data.
 * The output is the field path (e.g. array.0.name) mapped to a FormField object.
 */
export const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> => {
  const {
    id,
    addErrorPathToParent: addErrorPathToParentArg,
    anyParentLocalized = false,
    blockData,
    clientFieldSchemaMap,
    collectionSlug,
    data,
    field,
    fieldSchemaMap,
    filter,
    forceFullValue = false,
    fullData,
    includeSchema = false,
    indexPath,
    mockRSCs,
    omitParents = false,
    operation,
    parentPath,
    parentPermissions,
    parentSchemaPath,
    passesCondition,
    path,
    preferences,
    previousFormState,
    renderAllFields,
    renderFieldFn,
    req,
    schemaPath,
    select,
    selectMode,
    skipConditionChecks = false,
    skipValidation = false,
    state,
  } = args

  if (!args.clientFieldSchemaMap && args.renderFieldFn) {
    console.warn(
      'clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance',
    )
  }

  const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath

  let fieldPermissions: SanitizedFieldPermissions = true

  const fieldState: FieldState = {}

  if (lastRenderedPath) {
    fieldState.lastRenderedPath = lastRenderedPath
  }

  if (passesCondition === false) {
    fieldState.passesCondition = false
  }

  if (includeSchema) {
    fieldState.fieldSchema = field
  }

  if (fieldAffectsData(field) && !fieldIsHiddenOrDisabled(field)) {
    fieldPermissions =
      parentPermissions === true
        ? parentPermissions
        : deepCopyObjectSimple(parentPermissions?.[field.name])

    let hasPermission: boolean =
      fieldPermissions === true || deepCopyObjectSimple(fieldPermissions?.read)

    if (typeof field?.access?.read === 'function') {
      hasPermission = await field.access.read({
        id,
        blockData,
        data: fullData,
        req,
        siblingData: data,
      })
    } else {
      hasPermission = true
    }

    if (!hasPermission) {
      return
    }

    const validate: Validate = field.validate

    let validationResult: string | true = true

    if (typeof validate === 'function' && !skipValidation && passesCondition) {
      let jsonError

      if (field.type === 'json' && typeof data[field.name] === 'string') {
        try {
          JSON.parse(data[field.name])
        } catch (e) {
          jsonError = e
        }
      }

      try {
        validationResult = await validate(data?.[field.name], {
          ...field,
          id,
          blockData,
          collectionSlug,
          data: fullData,
          event: 'onChange',
          // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d
          // @ts-expect-error-next-line
          jsonError,
          operation,
          preferences,
          previousValue: previousFormState?.[path]?.initialValue,
          req,
          siblingData: data,
        })
      } catch (err) {
        validationResult = `Error validating field at path: ${path}`

        req.payload.logger.error({
          err,
          msg: validationResult,
        })
      }
    }

    const addErrorPathToParent = (errorPath: string) => {
      if (typeof addErrorPathToParentArg === 'function') {
        addErrorPathToParentArg(errorPath)
      }

      if (!fieldState.errorPaths) {
        fieldState.errorPaths = []
      }

      if (!fieldState.errorPaths.includes(errorPath)) {
        fieldState.errorPaths.push(errorPath)
        fieldState.valid = false
      }
    }

    if (typeof validationResult === 'string') {
      fieldState.errorMessage = validationResult
      fieldState.valid = false
      addErrorPathToParent(path)
    }

    switch (field.type) {
      case 'array': {
        const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : []

        const arraySelect = select?.[field.name]

        const { promises, rows } = arrayValue.reduce(
          (acc, row, i: number) => {
            const parentPath = path + '.' + i
            row.id = row?.id || new ObjectId().toHexString()

            if (!omitParents && (!filter || filter(args))) {
              const idKey = parentPath + '.id'

              state[idKey] = {
                initialValue: row.id,
                value: row.id,
              }

              if (includeSchema) {
                state[idKey].fieldSchema = field.fields.find((field) => fieldIsID(field))
              }
            }

            acc.promises.push(
              iterateFields({
                id,
                addErrorPathToParent,
                anyParentLocalized: field.localized || anyParentLocalized,
                blockData,
                clientFieldSchemaMap,
                collectionSlug,
                data: row,
                fields: field.fields,
                fieldSchemaMap,
                filter,
                forceFullValue,
                fullData,
                includeSchema,
                mockRSCs,
                omitParents,
                operation,
                parentIndexPath: '',
                parentPassesCondition: passesCondition,
                parentPath,
                parentSchemaPath: schemaPath,
                permissions:
                  fieldPermissions === true ? fieldPermissions : fieldPermissions?.fields || {},
                preferences,
                previousFormState,
                renderAllFields,
                renderFieldFn,
                req,
                select: typeof arraySelect === 'object' ? arraySelect : undefined,
                selectMode,
                skipConditionChecks,
                skipValidation,
                state,
              }),
            )

            if (!acc.rows) {
              acc.rows = []
            }

            const previousRows = previousFormState?.[path]?.rows || []

            // First, check if `previousFormState` has a matching row
            const previousRow: Row = previousRows.find((prevRow) => prevRow.id === row.id)

            const newRow: Row = {
              id: row.id,
              isLoading: false,
            }

            if (previousRow?.lastRenderedPath) {
              newRow.lastRenderedPath = previousRow.lastRenderedPath
            }

            acc.rows.push(newRow)

            const collapsedRowIDsFromPrefs = preferences?.fields?.[path]?.collapsed

            const collapsed = (() => {
              if (previousRow) {
                return previousRow.collapsed ?? false
              }

              // If previousFormState is undefined, check preferences
              if (collapsedRowIDsFromPrefs !== undefined) {
                return collapsedRowIDsFromPrefs.includes(row.id) // Check if collapsed in preferences
              }

              // If neither exists, fallback to `field.admin.initCollapsed`
              return field.admin.initCollapsed
            })()

            if (collapsed) {
              acc.rows[acc.rows.length - 1].collapsed = collapsed
            }

            return acc
          },
          {
            promises: [],
            rows: undefined,
          },
        )

        // Wait for all promises and update fields with the results
        await Promise.all(promises)

        if (rows) {
          fieldState.rows = rows
        }

        // Add values to field state
        if (data[field.name] !== null) {
          fieldState.value = forceFullValue ? arrayValue : arrayValue.length
          fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length

          if (arrayValue.length > 0) {
            fieldState.disableFormData = true
          }
        }

        // Add field to state
        if (!omitParents && (!filter || filter(args))) {
          state[path] = fieldState
        }

        break
      }

      case 'blocks': {
        const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : []

        const { promises, rowMetadata } = blocksValue.reduce(
          (acc, row, i: number) => {
            const blockTypeToMatch: string = row.blockType

            const block =
              req.payload.blocks[blockTypeToMatch] ??
              ((field.blockReferences ?? field.blocks).find(
                (blockType) => typeof blockType !== 'string' && blockType.slug === blockTypeToMatch,
              ) as FlattenedBlock | undefined)

            if (!block) {
              throw new Error(
                `Block with type "${row.blockType}" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`,
              )
            }

            const { blockSelect, blockSelectMode } = getBlockSelect({
              block,
              select: select?.[field.name],
              selectMode,
            })

            const parentPath = path + '.' + i

            if (block) {
              row.id = row?.id || new ObjectId().toHexString()

              if (!omitParents && (!filter || filter(args))) {
                // Handle block `id` field
                const idKey = parentPath + '.id'

                state[idKey] = {
                  initialValue: row.id,
                  value: row.id,
                }

                if (includeSchema) {
                  state[idKey].fieldSchema = includeSchema
                    ? block.fields.find((blockField) => fieldIsID(blockField))
                    : undefined
                }

                // Handle `blockType` field
                const fieldKey = parentPath + '.blockType'

                state[fieldKey] = {
                  initialValue: row.blockType,
                  value: row.blockType,
                }

                if (includeSchema) {
                  state[fieldKey].fieldSchema = block.fields.find(
                    (blockField) => 'name' in blockField && blockField.name === 'blockType',
                  )
                }

                // Handle `blockName` field
                const blockNameKey = parentPath + '.blockName'

                state[blockNameKey] = {}

                if (row.blockName) {
                  state[blockNameKey].initialValue = row.blockName
                  state[blockNameKey].value = row.blockName
                }

                if (includeSchema) {
                  state[blockNameKey].fieldSchema = block.fields.find(
                    (blockField) => 'name' in blockField && blockField.name === 'blockName',
                  )
                }
              }

              acc.promises.push(
                iterateFields({
                  id,
                  addErrorPathToParent,
                  anyParentLocalized: field.localized || anyParentLocalized,
                  blockData: row,
                  clientFieldSchemaMap,
                  collectionSlug,
                  data: row,
                  fields: block.fields,
                  fieldSchemaMap,
                  filter,
                  forceFullValue,
                  fullData,
                  includeSchema,
                  mockRSCs,
                  omitParents,
                  operation,
                  parentIndexPath: '',
                  parentPassesCondition: passesCondition,
                  parentPath,
                  parentSchemaPath: schemaPath + '.' + block.slug,
                  permissions:
                    fieldPermissions === true
                      ? fieldPermissions
                      : parentPermissions?.[field.name]?.blocks?.[block.slug] === true
                        ? true
                        : parentPermissions?.[field.name]?.blocks?.[block.slug]?.fields || {},
                  preferences,
                  previousFormState,
                  renderAllFields,
                  renderFieldFn,
                  req,
                  select: typeof blockSelect === 'object' ? blockSelect : undefined,
                  selectMode: blockSelectMode,
                  skipConditionChecks,
                  skipValidation,
                  state,
                }),
              )

              const previousRows = previousFormState?.[path]?.rows || []

              // First, check if `previousFormState` has a matching row
              const previousRow: Row = previousRows.find((prevRow) => prevRow.id === row.id)

              const newRow: Row = {
                id: row.id,
                blockType: row.blockType,
                isLoading: false,
              }

              if (previousRow?.lastRenderedPath) {
                newRow.lastRenderedPath = previousRow.lastRenderedPath
              }

              acc.rowMetadata.push(newRow)

              const collapsedRowIDs = preferences?.fields?.[path]?.collapsed

              const collapsed =
                collapsedRowIDs === undefined
                  ? field.admin.initCollapsed
                  : collapsedRowIDs.includes(row.id)

              if (collapsed) {
                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed = collapsed
              }
            }

            return acc
          },
          {
            promises: [],
            rowMetadata: [],
          },
        )

        await Promise.all(promises)

        // Add values to field state
        if (data[field.name] === null) {
          fieldState.value = null
          fieldState.initialValue = null
        } else {
          fieldState.value = forceFullValue ? blocksValue : blocksValue.length
          fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length

          if (blocksValue.length > 0) {
            fieldState.disableFormData = true
          }
        }

        fieldState.rows = rowMetadata

        // Add field to state
        if (!omitParents && (!filter || filter(args))) {
          state[path] = fieldState
        }

        break
      }

      case 'group': {
        if (!filter || filter(args)) {
          fieldState.disableFormData = true
          state[path] = fieldState
        }

        const groupSelect = select?.[field.name]

        await iterateFields({
          id,
          addErrorPathToParent,
          anyParentLocalized: field.localized || anyParentLocalized,
          blockData,
          clientFieldSchemaMap,
          collectionSlug,
          data: data?.[field.name] || {},
          fields: field.fields,
          fieldSchemaMap,
          filter,
          forceFullValue,
          fullData,
          includeSchema,
          mockRSCs,
          omitParents,
          operation,
          parentIndexPath: '',
          parentPassesCondition: passesCondition,
          parentPath: path,
          parentSchemaPath: schemaPath,
          permissions:
            typeof fieldPermissions === 'boolean' ? fieldPermissions : fieldPermissions?.fields,
          preferences,
          previousFormState,
          renderAllFields,
          renderFieldFn,
          req,
          select: typeof groupSelect === 'object' ? groupSelect : undefined,
          selectMode,
          skipConditionChecks,
          skipValidation,
          state,
        })

        break
      }
      case 'relationship':
      case 'upload': {
        if (field.filterOptions) {
          if (typeof field.filterOptions === 'object') {
            if (typeof field.relationTo === 'string') {
              fieldState.filterOptions = {
                [field.relationTo]: field.filterOptions,
              }
            } else {
              fieldState.filterOptions = field.relationTo.reduce((acc, relation) => {
                acc[relation] = field.filterOptions
                return acc
              }, {})
            }
          }

          if (typeof field.filterOptions === 'function') {
            const query = await resolveFilterOptions(field.filterOptions, {
              id,
              blockData,
              data: fullData,
              relationTo: field.relationTo,
              req,
              siblingData: data,
              user: req.user,
            })

            fieldState.filterOptions = query
          }
        }

        if (field.hasMany) {
          const relationshipValue = Array.isArray(data[field.name])
            ? data[field.name].map((relationship) => {
                if (Array.isArray(field.relationTo)) {
                  return {
                    relationTo: relationship.relationTo,
                    value:
                      relationship.value && typeof relationship.value === 'object'
                        ? relationship.value?.id
                        : relationship.value,
                  }
                }
                if (typeof relationship === 'object' && relationship !== null) {
                  return relationship.id
                }
                return relationship
              })
            : undefined

          fieldState.value = relationshipValue
          fieldState.initialValue = relationshipValue
        } else if (Array.isArray(field.relationTo)) {
          if (
            data[field.name] &&
            typeof data[field.name] === 'object' &&
            'relationTo' in data[field.name] &&
            'value' in data[field.name]
          ) {
            const value =
              typeof data[field.name]?.value === 'object' &&
              data[field.name]?.value &&
              'id' in data[field.name].value
                ? data[field.name].value.id
                : data[field.name].value
            const relationshipValue = {
              relationTo: data[field.name]?.relationTo,
              value,
            }
            fieldState.value = relationshipValue
            fieldState.initialValue = relationshipValue
          }
        } else {
          const relationshipValue =
            data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]
              ? data[field.name].id
              : data[field.name]
          fieldState.value = relationshipValue
          fieldState.initialValue = relationshipValue
        }

        if (!filter || filter(args)) {
          state[path] = fieldState
        }

        break
      }

      default: {
        if (data[field.name] !== undefined) {
          fieldState.value = data[field.name]
          fieldState.initialValue = data[field.name]
        }

        // Add field to state
        if (!filter || filter(args)) {
          state[path] = fieldState
        }

        break
      }
    }
  } else if (fieldHasSubFields(field) && !fieldAffectsData(field)) {
    // Handle field types that do not use names (row, etc)

    if (!filter || filter(args)) {
      state[path] = {
        disableFormData: true,
      }

      if (passesCondition === false) {
        state[path].passesCondition = false
      }
    }

    await iterateFields({
      id,
      mockRSCs,
      select,
      selectMode,
      // passthrough parent functionality
      addErrorPathToParent: addErrorPathToParentArg,
      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,
      blockData,
      clientFieldSchemaMap,
      collectionSlug,
      data,
      fields: field.fields,
      fieldSchemaMap,
      filter,
      forceFullValue,
      fullData,
      includeSchema,
      omitParents,
      operation,
      parentIndexPath: indexPath,
      parentPassesCondition: passesCondition,
      parentPath,
      parentSchemaPath,
      permissions: parentPermissions, // TODO: Verify this is correct
      preferences,
      previousFormState,
      renderAllFields,
      renderFieldFn,
      req,
      skipConditionChecks,
      skipValidation,
      state,
    })
  } else if (field.type === 'tabs') {
    const promises = field.tabs.map((tab, tabIndex) => {
      const isNamedTab = tabHasName(tab)
      let tabSelect: SelectType | undefined

      const {
        indexPath: tabIndexPath,
        path: tabPath,
        schemaPath: tabSchemaPath,
      } = getFieldPaths({
        field: {
          ...tab,
          type: 'tab',
        },
        index: tabIndex,
        parentIndexPath: indexPath,
        parentPath,
        parentSchemaPath,
      })

      let childPermissions: SanitizedFieldsPermissions = undefined

      if (isNamedTab) {
        if (parentPermissions === true) {
          childPermissions = true
        } else {
          const tabPermissions = parentPermissions?.[tab.name]
          if (tabPermissions === true) {
            childPermissions = true
          } else {
            childPermissions = tabPermissions?.fields
          }
        }

        if (typeof select?.[tab.name] === 'object') {
          tabSelect = select?.[tab.name] as SelectType
        }
      } else {
        childPermissions = parentPermissions
        tabSelect = select
      }

      const pathSegments = path ? path.split('.') : []

      // If passesCondition is false then this should always result to false
      // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result
      let tabPassesCondition = passesCondition

      if (passesCondition && typeof tab.admin?.condition === 'function') {
        tabPassesCondition = tab.admin.condition(fullData, data, {
          blockData,
          path: pathSegments,
          user: req.user,
        })
      }

      if (tab?.id) {
        state[tab.id] = {
          passesCondition: tabPassesCondition,
        }
      }

      return iterateFields({
        id,
        addErrorPathToParent: addErrorPathToParentArg,
        anyParentLocalized: tab.localized || anyParentLocalized,
        blockData,
        clientFieldSchemaMap,
        collectionSlug,
        data: isNamedTab ? data?.[tab.name] || {} : data,
        fields: tab.fields,
        fieldSchemaMap,
        filter,
        forceFullValue,
        fullData,
        includeSchema,
        mockRSCs,
        omitParents,
        operation,
        parentIndexPath: isNamedTab ? '' : tabIndexPath,
        parentPassesCondition: tabPassesCondition,
        parentPath: isNamedTab ? tabPath : parentPath,
        parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,
        permissions: childPermissions,
        preferences,
        previousFormState,
        renderAllFields,
        renderFieldFn,
        req,
        select: tabSelect,
        selectMode,
        skipConditionChecks,
        skipValidation,
        state,
      })
    })

    await Promise.all(promises)
  } else if (field.type === 'ui') {
    if (!filter || filter(args)) {
      state[path] = fieldState
      state[path].disableFormData = true
    }
  }

  if (renderFieldFn && !fieldIsHiddenOrDisabled(field)) {
    const fieldState = state[path]

    const fieldConfig = fieldSchemaMap.get(schemaPath)

    if (!fieldConfig && !mockRSCs) {
      if (schemaPath.endsWith('.blockType')) {
        return
      } else {
        throw new Error(`Field config not found for ${schemaPath}`)
      }
    }

    if (!fieldState) {
      // Some fields (ie `Tab`) do not live in form state
      // therefore we cannot attach customComponents to them
      return
    }

    renderFieldFn({
      id,
      clientFieldSchemaMap,
      collectionSlug,
      data: fullData,
      fieldConfig: fieldConfig as Field,
      fieldSchemaMap,
      fieldState,
      formState: state,
      indexPath,
      lastRenderedPath,
      mockRSCs,
      operation,
      parentPath,
      parentSchemaPath,
      path,
      permissions: fieldPermissions,
      preferences,
      previousFieldState: previousFormState?.[path],
      renderAllFields,
      req,
      schemaPath,
      siblingData: data,
    })
  }
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/fieldSchemasToFormState.spec.js">
import fieldSchemasToFormState from './index.js'

describe('Form - fieldSchemasToFormState', () => {
  const defaultValue = 'Default'
  it('populates default value - normal fields', async () => {
    const fieldSchema = [
      {
        name: 'text',
        type: 'text',
        defaultValue,
        label: 'Text',
      },
    ]
    const state = await fieldSchemasToFormState({ fields: fieldSchema })
    expect(state.text.value).toBe(defaultValue)
  })
  it('field value overrides defaultValue - normal fields', async () => {
    const value = 'value'
    const data = { text: value }
    const fieldSchema = [
      {
        name: 'text',
        type: 'text',
        defaultValue,
        label: 'Text',
      },
    ]
    const state = await fieldSchemasToFormState({ data, fields: fieldSchema })
    expect(state.text.value).toBe(value)
  })
  it('populates default value from a function - normal fields', async () => {
    const user = { email: 'user@example.com' }
    const locale = 'en'
    const fieldSchema = [
      {
        name: 'text',
        type: 'text',
        defaultValue: (args) => {
          if (!args.locale) {
            return 'missing locale'
          }
          if (!args.user) {
            return 'missing user'
          }
          return 'Default'
        },
        label: 'Text',
      },
    ]
    const state = await fieldSchemasToFormState({ fields: fieldSchema, locale, user })
    expect(state.text.value).toBe(defaultValue)
  })
})
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/index.tsx">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
} from '@convexcms/core'

import type { RenderFieldMethod } from './types.js'

import { calculateDefaultValues } from './calculateDefaultValues/index.js'
import { iterateFields } from './iterateFields.js'

type Args = {
  /**
   * The client field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the client field schema map is not required.
   */
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data?: Data
  /**
   * If this is undefined, the `data` passed to this function will serve as `fullData` and `data` when iterating over
   * the top-level-fields to generate form state.
   * For sub fields, the `data` will be narrowed down to the sub fields, while `fullData` remains the same.
   *
   * Usually, the `data` passed to this function will be the document data. This means that running validation, read access control
   * or executing filterOptions here will have access to the full document through the passed `fullData` parameter, and that `fullData` and `data` will be identical.
   *
   * In some cases however, this function is used to generate form state solely for sub fields - independent from the parent form state.
   * This means that `data` will be the form state of the sub fields - the document data won't be available here.
   *
   * In these cases, you can pass `documentData` which will be used as `fullData` instead of `data`.
   *
   * This is useful for lexical blocks, as lexical block fields there are not part of the parent form state, yet we still want
   * document data to be available for validation and filterOptions, under the `data` key.
   */
  documentData?: Data
  fields: Field[] | undefined
  /**
   * The field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the field schema map is not required.
   */
  fieldSchemaMap: FieldSchemaMap | undefined
  id?: number | string
  /**
   * Validation, filterOptions and read access control will receive the `blockData`, which is the data of the nearest parent block. You can pass in
   * the initial block data here, which will be used as `blockData` for the top-level fields, until the first block is encountered.
   */
  initialBlockData?: Data
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  operation?: 'create' | 'update'
  permissions: SanitizedFieldsPermissions
  preferences: DocumentPreferences
  /**
   * Optionally accept the previous form state,
   * to be able to determine if custom fields need to be re-rendered.
   */
  previousFormState?: FormState
  /**
   * If renderAllFields is true, then no matter what is in previous form state,
   * all custom fields will be re-rendered.
   */
  renderAllFields: boolean
  renderFieldFn?: RenderFieldMethod
  req: PayloadRequest
  schemaPath: string
  select?: SelectType
  selectMode?: SelectMode
  skipValidation?: boolean
}

export const fieldSchemasToFormState = async ({
  id,
  clientFieldSchemaMap,
  collectionSlug,
  data = {},
  documentData,
  fields,
  fieldSchemaMap,
  initialBlockData,
  mockRSCs,
  operation,
  permissions,
  preferences,
  previousFormState,
  renderAllFields,
  renderFieldFn,
  req,
  schemaPath,
  select,
  selectMode,
  skipValidation,
}: Args): Promise<FormState> => {
  if (!clientFieldSchemaMap && renderFieldFn) {
    console.warn(
      'clientFieldSchemaMap is not passed to fieldSchemasToFormState - this will reduce performance',
    )
  }

  if (fields && fields.length) {
    const state: FormStateWithoutComponents = {}

    const dataWithDefaultValues = { ...data }

    await calculateDefaultValues({
      id,
      data: dataWithDefaultValues,
      fields,
      locale: req.locale,
      req,
      select,
      selectMode,
      siblingData: dataWithDefaultValues,
      user: req.user,
    })

    let fullData = dataWithDefaultValues

    if (documentData) {
      // By the time this function is used to get form state for nested forms, their default values should have already been calculated
      // => no need to run calculateDefaultValues here
      fullData = documentData
    }

    await iterateFields({
      id,
      addErrorPathToParent: null,
      blockData: initialBlockData,
      clientFieldSchemaMap,
      collectionSlug,
      data: dataWithDefaultValues,
      fields,
      fieldSchemaMap,
      fullData,
      mockRSCs,
      operation,
      parentIndexPath: '',
      parentPassesCondition: true,
      parentPath: '',
      parentSchemaPath: schemaPath,
      permissions,
      preferences,
      previousFormState,
      renderAllFields,
      renderFieldFn,
      req,
      select,
      selectMode,
      skipValidation,
      state,
    })

    return state
  }

  return {}
}

export { iterateFields }
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/iterateFields.ts">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field as FieldSchema,
  FieldSchemaMap,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
} from '@convexcms/core'

import { stripUnselectedFields } from '@convexcms/core'
import { getFieldPaths } from '@convexcms/core/shared'

import type { AddFieldStatePromiseArgs } from './addFieldStatePromise.js'
import type { RenderFieldMethod } from './types.js'

import { addFieldStatePromise } from './addFieldStatePromise.js'

type Args = {
  addErrorPathToParent: (fieldPath: string) => void
  /**
   * if any parents is localized, then the field is localized. @default false
   */
  anyParentLocalized?: boolean
  /**
   * Data of the nearest parent block, or undefined
   */
  blockData: Data | undefined
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data: Data
  fields: FieldSchema[]
  fieldSchemaMap: FieldSchemaMap
  filter?: (args: AddFieldStatePromiseArgs) => boolean
  /**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
  forceFullValue?: boolean
  fullData: Data
  id?: number | string
  /**
   * Whether the field schema should be included in the state. @default false
   */
  includeSchema?: boolean
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  /**
   * Whether to omit parent fields in the state. @default false
   */
  omitParents?: boolean
  /**
   * operation is only needed for validation
   */
  operation: 'create' | 'update'
  parentIndexPath: string
  parentPassesCondition?: boolean
  parentPath: string
  parentSchemaPath: string
  permissions: SanitizedFieldsPermissions
  preferences?: DocumentPreferences
  previousFormState: FormState
  renderAllFields: boolean
  renderFieldFn: RenderFieldMethod
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  /**
   * Whether to skip checking the field's condition. @default false
   */
  skipConditionChecks?: boolean
  /**
   * Whether to skip validating the field. @default false
   */
  skipValidation?: boolean
  state?: FormStateWithoutComponents
}

/**
 * Flattens the fields schema and fields data
 */
export const iterateFields = async ({
  id,
  addErrorPathToParent: addErrorPathToParentArg,
  anyParentLocalized = false,
  blockData,
  clientFieldSchemaMap,
  collectionSlug,
  data,
  fields,
  fieldSchemaMap,
  filter,
  forceFullValue = false,
  fullData,
  includeSchema = false,
  mockRSCs,
  omitParents = false,
  operation,
  parentIndexPath,
  parentPassesCondition = true,
  parentPath,
  parentSchemaPath,
  permissions,
  preferences,
  previousFormState,
  renderAllFields,
  renderFieldFn: renderFieldFn,
  req,
  select,
  selectMode,
  skipConditionChecks = false,
  skipValidation = false,
  state = {},
}: Args): Promise<void> => {
  const promises = []

  fields.forEach((field, fieldIndex) => {
    let passesCondition = true

    const { indexPath, path, schemaPath } = getFieldPaths({
      field,
      index: fieldIndex,
      parentIndexPath: 'name' in field ? '' : parentIndexPath,
      parentPath,
      parentSchemaPath,
    })

    if (path !== 'id') {
      const shouldContinue = stripUnselectedFields({
        field,
        select,
        selectMode,
        siblingDoc: data,
      })

      if (!shouldContinue) {
        return
      }
    }

    const pathSegments = path ? path.split('.') : []

    if (!skipConditionChecks) {
      try {
        passesCondition = Boolean(
          (field?.admin?.condition
            ? Boolean(
                field.admin.condition(fullData || {}, data || {}, {
                  blockData,
                  path: pathSegments,
                  user: req.user,
                }),
              )
            : true) && parentPassesCondition,
        )
      } catch (err) {
        passesCondition = false

        req.payload.logger.error({
          err,
          msg: `Error evaluating field condition at path: ${path}`,
        })
      }
    }

    promises.push(
      addFieldStatePromise({
        id,
        addErrorPathToParent: addErrorPathToParentArg,
        anyParentLocalized,
        blockData,
        clientFieldSchemaMap,
        collectionSlug,
        data,
        field,
        fieldIndex,
        fieldSchemaMap,
        filter,
        forceFullValue,
        fullData,
        includeSchema,
        indexPath,
        mockRSCs,
        omitParents,
        operation,
        parentIndexPath,
        parentPath,
        parentPermissions: permissions,
        parentSchemaPath,
        passesCondition,
        path,
        preferences,
        previousFormState,
        renderAllFields,
        renderFieldFn,
        req,
        schemaPath,
        select,
        selectMode,
        skipConditionChecks,
        skipValidation,
        state,
      }),
    )
  })

  await Promise.all(promises)
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/renderField.tsx">
import type {
  ClientComponentProps,
  ClientField,
  FieldPaths,
  FlattenedBlock,
  ServerComponentProps,
} from '@convexcms/core'

import { getTranslation } from '@convexcms/translations'
import { createClientField, MissingEditorProp } from '@convexcms/core'
import { fieldIsHiddenOrDisabled } from '@convexcms/core/shared'

import type { RenderFieldMethod } from './types.js'

import { RenderServerComponent } from '../../elements/RenderServerComponent/index.js'

// eslint-disable-next-line payload/no-imports-from-exports-dir -- need this to reference already existing bundle. Otherwise, bundle size increases., payload/no-imports-from-exports-dir
import { FieldDescription, WatchCondition } from '../../exports/client/index.js'

const defaultUIFieldComponentKeys: Array<'Cell' | 'Description' | 'Field' | 'Filter'> = [
  'Cell',
  'Description',
  'Field',
  'Filter',
]

export const renderField: RenderFieldMethod = ({
  id,
  clientFieldSchemaMap,
  collectionSlug,
  data,
  fieldConfig,
  fieldSchemaMap,
  fieldState,
  formState,
  indexPath,
  lastRenderedPath,
  mockRSCs,
  operation,
  parentPath,
  parentSchemaPath,
  path,
  permissions,
  preferences,
  renderAllFields,
  req,
  schemaPath,
  siblingData,
}) => {
  const requiresRender = renderAllFields || !lastRenderedPath || lastRenderedPath !== path

  if (!requiresRender && fieldConfig.type !== 'array' && fieldConfig.type !== 'blocks') {
    return
  }

  const clientField = clientFieldSchemaMap
    ? (clientFieldSchemaMap.get(schemaPath) as ClientField)
    : createClientField({
        defaultIDType: req.payload.config.db.defaultIDType,
        field: fieldConfig,
        i18n: req.i18n,
        importMap: req.payload.importMap,
      })

  const clientProps: ClientComponentProps & Partial<FieldPaths> = {
    field: clientField,
    path,
    permissions,
    readOnly: typeof permissions === 'boolean' ? !permissions : !permissions?.[operation],
    schemaPath,
  }

  if (fieldState?.customComponents) {
    clientProps.customComponents = fieldState.customComponents
  }

  // fields with subfields
  if (['array', 'blocks', 'collapsible', 'group', 'row', 'tabs'].includes(fieldConfig.type)) {
    clientProps.indexPath = indexPath
    clientProps.parentPath = parentPath
    clientProps.parentSchemaPath = parentSchemaPath
  }

  const serverProps: ServerComponentProps = {
    id,
    clientField,
    clientFieldSchemaMap,
    data,
    field: fieldConfig,
    fieldSchemaMap,
    permissions,
    // TODO: Should we pass explicit values? initialValue, value, valid
    // value and initialValue should be typed
    collectionSlug,
    formState,
    i18n: req.i18n,
    operation,
    payload: req.payload,
    preferences,
    req,
    siblingData,
    user: req.user,
  }

  switch (fieldConfig.type) {
    case 'array': {
      fieldState?.rows?.forEach((row, rowIndex) => {
        const rowLastRenderedPath = row.lastRenderedPath

        const rowPath = `${path}.${rowIndex}`

        const rowRequiresRender =
          renderAllFields || !rowLastRenderedPath || rowLastRenderedPath !== rowPath

        if (!rowRequiresRender) {
          return
        }

        row.lastRenderedPath = rowPath

        if (fieldConfig.admin?.components && 'RowLabel' in fieldConfig.admin.components) {
          if (!row.customComponents) {
            row.customComponents = {}
          }

          row.customComponents.RowLabel = !mockRSCs
            ? RenderServerComponent({
                clientProps,
                Component: fieldConfig.admin.components.RowLabel,
                importMap: req.payload.importMap,
                key: `${rowIndex}`,
                serverProps: {
                  ...serverProps,
                  rowLabel: `${getTranslation(fieldConfig.labels.singular, req.i18n)} ${String(
                    rowIndex + 1,
                  ).padStart(2, '0')}`,
                  rowNumber: rowIndex + 1,
                },
              })
            : 'Mock'
        }
      })

      break
    }

    case 'blocks': {
      fieldState?.rows?.forEach((row, rowIndex) => {
        const rowLastRenderedPath = row.lastRenderedPath

        const rowPath = `${path}.${rowIndex}`

        const rowRequiresRender =
          renderAllFields || !rowLastRenderedPath || rowLastRenderedPath !== rowPath

        if (!rowRequiresRender) {
          return
        }

        row.lastRenderedPath = rowPath

        const blockTypeToMatch: string = row.blockType

        const blockConfig =
          req.payload.blocks[blockTypeToMatch] ??
          ((fieldConfig.blockReferences ?? fieldConfig.blocks).find(
            (block) => typeof block !== 'string' && block.slug === blockTypeToMatch,
          ) as FlattenedBlock | undefined)

        if (blockConfig.admin?.components && 'Label' in blockConfig.admin.components) {
          if (!fieldState.rows[rowIndex]?.customComponents) {
            fieldState.rows[rowIndex].customComponents = {}
          }

          fieldState.rows[rowIndex].customComponents.RowLabel = !mockRSCs
            ? RenderServerComponent({
                clientProps,
                Component: blockConfig.admin.components.Label,
                importMap: req.payload.importMap,
                key: `${rowIndex}`,
                serverProps: {
                  ...serverProps,
                  blockType: row.blockType,
                  rowLabel: `${getTranslation(blockConfig.labels.singular, req.i18n)} ${String(
                    rowIndex + 1,
                  ).padStart(2, '0')}`,
                  rowNumber: rowIndex + 1,
                },
              })
            : 'Mock'
        }
      })

      break
    }
  }

  if (!requiresRender) {
    return
  }

  /**
   * Set the lastRenderedPath equal to the new path of the field
   */
  fieldState.lastRenderedPath = path

  if (fieldIsHiddenOrDisabled(clientField)) {
    return
  }

  /**
   * Only create the `customComponents` object if needed.
   * This will prevent unnecessary data from being transferred to the client.
   */
  if (fieldConfig.admin) {
    if (
      (Object.keys(fieldConfig.admin.components || {}).length > 0 ||
        fieldConfig.type === 'richText' ||
        ('description' in fieldConfig.admin &&
          typeof fieldConfig.admin.description === 'function')) &&
      !fieldState?.customComponents
    ) {
      fieldState.customComponents = {}
    }
  }

  switch (fieldConfig.type) {
    case 'richText': {
      if (!fieldConfig?.editor) {
        throw new MissingEditorProp(fieldConfig) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof fieldConfig?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      if (!fieldConfig.admin) {
        fieldConfig.admin = {}
      }

      if (!fieldConfig.admin.components) {
        fieldConfig.admin.components = {}
      }

      fieldState.customComponents.Field = !mockRSCs ? (
        <WatchCondition path={path}>
          {RenderServerComponent({
            clientProps,
            Component: fieldConfig.editor.FieldComponent,
            importMap: req.payload.importMap,
            serverProps,
          })}
        </WatchCondition>
      ) : (
        'Mock'
      )

      break
    }

    case 'ui': {
      if (fieldConfig?.admin?.components) {
        // Render any extra, untyped components
        for (const key in fieldConfig.admin.components) {
          if (key in defaultUIFieldComponentKeys) {
            continue
          }

          const Component = fieldConfig.admin.components[key]

          fieldState.customComponents[key] = !mockRSCs
            ? RenderServerComponent({
                clientProps,
                Component,
                importMap: req.payload.importMap,
                key: `field.admin.components.${key}`,
                serverProps,
              })
            : 'Mock'
        }
      }
      break
    }

    default: {
      break
    }
  }

  if (fieldConfig.admin) {
    if (
      'description' in fieldConfig.admin &&
      typeof fieldConfig.admin?.description === 'function'
    ) {
      fieldState.customComponents.Description = !mockRSCs ? (
        <FieldDescription
          description={fieldConfig.admin?.description({
            i18n: req.i18n,
            t: req.i18n.t,
          })}
          path={path}
        />
      ) : (
        'Mock'
      )
    }

    if (fieldConfig.admin?.components) {
      if ('afterInput' in fieldConfig.admin.components) {
        fieldState.customComponents.AfterInput = !mockRSCs
          ? RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.afterInput,
              importMap: req.payload.importMap,
              key: 'field.admin.components.afterInput',
              serverProps,
            })
          : 'Mock'
      }

      if ('beforeInput' in fieldConfig.admin.components) {
        fieldState.customComponents.BeforeInput = !mockRSCs
          ? RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.beforeInput,
              importMap: req.payload.importMap,
              key: 'field.admin.components.beforeInput',
              serverProps,
            })
          : 'Mock'
      }

      if ('Description' in fieldConfig.admin.components) {
        fieldState.customComponents.Description = !mockRSCs
          ? RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.Description,
              importMap: req.payload.importMap,
              key: 'field.admin.components.Description',
              serverProps,
            })
          : 'Mock'
      }

      if ('Error' in fieldConfig.admin.components) {
        fieldState.customComponents.Error = !mockRSCs
          ? RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.Error,
              importMap: req.payload.importMap,
              key: 'field.admin.components.Error',
              serverProps,
            })
          : 'Mock'
      }

      if ('Label' in fieldConfig.admin.components) {
        fieldState.customComponents.Label = !mockRSCs
          ? RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.Label,
              importMap: req.payload.importMap,
              key: 'field.admin.components.Label',
              serverProps,
            })
          : 'Mock'
      }

      if ('Field' in fieldConfig.admin.components) {
        fieldState.customComponents.Field = !mockRSCs ? (
          <WatchCondition path={path}>
            {RenderServerComponent({
              clientProps,
              Component: fieldConfig.admin.components.Field,
              importMap: req.payload.importMap,
              key: 'field.admin.components.Field',
              serverProps,
            })}
          </WatchCondition>
        ) : (
          'Mock'
        )
      }
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/fieldSchemasToFormState/types.ts">
import type {
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FieldState,
  FormState,
  Operation,
  PayloadRequest,
  SanitizedFieldPermissions,
} from '@convexcms/core'

export type RenderFieldArgs = {
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug: string
  data: Data
  fieldConfig: Field
  fieldSchemaMap: FieldSchemaMap
  fieldState: FieldState
  formState: FormState
  id?: number | string
  indexPath: string
  lastRenderedPath: string
  mockRSCs?: boolean
  operation: Operation
  parentPath: string
  parentSchemaPath: string
  path: string
  permissions: SanitizedFieldPermissions
  preferences: DocumentPreferences
  previousFieldState: FieldState
  renderAllFields: boolean
  req: PayloadRequest
  schemaPath: string
  siblingData: Data
}

export type RenderFieldMethod = (args: RenderFieldArgs) => void
</file>

<file path="convexadmin/ui/src/forms/Form/context.ts">
"use client";
// Removed Payload imports
// import type { RenderedField } from '@convexcms/core'
// import { createContext, use } from 'react'
// import {
//   createContext as createSelectorContext,
//   useContextSelector,
//   useContext as useFullContext,
// } from 'use-context-selector' // Removed dependency

// import type { Context, FormFieldsContext as FormFieldsContextType } from './types.js' // Keep if types are simple, otherwise remove

// --- Removed Payload context definitions ---
// const FormContext = createContext({} as Context)
// ... and others ...

// --- Mock Implementation ---

// Mock FormFieldsContextType if needed, or simplify
// Use unknown for the dispatched value type
type MockFormFieldsContextType = [Record<string, unknown>, unknown];

/**
 * Mock useFormFields hook needed by RenderField
 * Get and set the value of a form field based on a selector
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#useformfields
 */
export const useFormFields = <Value = unknown>(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  selector: (context: MockFormFieldsContextType) => Value,
): Value => {
  console.warn("Using mock useFormFields");
  // Return a default/mock value that allows RenderField to proceed
  // Payload returns an array [fields, dispatchField] - mock first element
  // Returning `undefined` for fields lookup, mimics no custom component override
  return undefined as Value;
};

// --- Mock other hooks if absolutely necessary, otherwise remove ---
// Example:
// export const useForm = () => { console.warn('Using mock useForm'); return {}; };
// export const useFormSubmitted = () => { console.warn('Using mock useFormSubmitted'); return false; };
// ... etc ...

// It's better to remove unused exports completely if they are not needed by adapted components.

// Remove exports that depend on removed contexts/types
// export {
//   BackgroundProcessingContext,
//   ...
// }
</file>

<file path="convexadmin/ui/src/forms/Form/createNestedClientFieldPath.ts">
'use client'
import type { ClientField } from '@convexcms/core'

import { fieldAffectsData } from '@convexcms/core/shared'

export const createNestedClientFieldPath = (parentPath: string, field: ClientField): string => {
  if (parentPath) {
    if (fieldAffectsData(field)) {
      return `${parentPath}.${field.name}`
    }
    return parentPath
  }

  if (fieldAffectsData(field)) {
    return field.name
  }

  return ''
}
</file>

<file path="convexadmin/ui/src/forms/Form/errorMessages.ts">
'use client'
export const errorMessages = {
  413: 'Your request was too large to submit successfully.',
}
</file>

<file path="convexadmin/ui/src/forms/Form/fieldReducer.ts">
'use client'
import type { FormField, FormState, Row } from '@convexcms/core'

import ObjectIdImport from 'bson-objectid'
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
import { deepCopyObjectSimple, deepCopyObjectSimpleWithoutReactComponents } from '@convexcms/core/shared'

import type { FieldAction } from './types.js'

import { flattenRows, separateRows } from './rows.js'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

/**
 * Reducer which modifies the form field state (all the current data of the fields in the form). When called using dispatch, it will return a new state object.
 */
export function fieldReducer(state: FormState, action: FieldAction): FormState {
  switch (action.type) {
    case 'ADD_ROW': {
      const { blockType, path, rowIndex: rowIndexFromArgs, subFieldState = {} } = action

      const rowIndex =
        typeof rowIndexFromArgs === 'number' ? rowIndexFromArgs : state[path]?.rows?.length || 0

      const withNewRow = [...(state[path]?.rows || [])]

      const newRow: Row = {
        id: (subFieldState?.id?.value as string) || new ObjectId().toHexString(),
        blockType: blockType || undefined,
        collapsed: false,
        isLoading: true,
      }

      withNewRow.splice(rowIndex, 0, newRow)

      if (blockType) {
        subFieldState.blockType = {
          initialValue: blockType,
          valid: true,
          value: blockType,
        }
      }

      // add new row to array _field state_
      const { remainingFields, rows: siblingRows } = separateRows(path, state)

      siblingRows.splice(rowIndex, 0, subFieldState)

      const newState: FormState = {
        ...remainingFields,
        ...flattenRows(path, siblingRows),
        [`${path}.${rowIndex}.id`]: {
          initialValue: newRow.id,
          passesCondition: true,
          valid: true,
          value: newRow.id,
        },
        [path]: {
          ...state[path],
          disableFormData: true,
          rows: withNewRow,
          value: siblingRows.length,
        },
      }

      return newState
    }

    case 'ADD_SERVER_ERRORS': {
      let newState = { ...state }

      const errorPaths: { fieldErrorPath: string; parentPath: string }[] = []

      action.errors.forEach(({ message, path: fieldPath }) => {
        newState[fieldPath] = {
          ...(newState[fieldPath] || {
            initialValue: null,
            value: null,
          }),
          errorMessage: message,
          valid: false,
        }

        const segments = fieldPath.split('.')
        if (segments.length > 1) {
          errorPaths.push({
            fieldErrorPath: fieldPath,
            parentPath: segments.slice(0, segments.length - 1).join('.'),
          })
        }
      })

      newState = Object.entries(newState).reduce((acc, [path, fieldState]) => {
        const fieldErrorPaths = errorPaths.reduce((errorACC, { fieldErrorPath, parentPath }) => {
          if (parentPath.startsWith(path)) {
            errorACC.push(fieldErrorPath)
          }
          return errorACC
        }, [])

        let changed = false

        if (fieldErrorPaths.length > 0) {
          const newErrorPaths = Array.isArray(fieldState.errorPaths) ? fieldState.errorPaths : []

          fieldErrorPaths.forEach((fieldErrorPath) => {
            if (!newErrorPaths.includes(fieldErrorPath)) {
              newErrorPaths.push(fieldErrorPath)
              changed = true
            }
          })

          if (changed) {
            acc[path] = {
              ...fieldState,
              errorPaths: newErrorPaths,
            }
          }
        }

        if (!changed) {
          acc[path] = fieldState
        }

        return acc
      }, {})

      return newState
    }

    case 'DUPLICATE_ROW': {
      const { path, rowIndex } = action
      const { remainingFields, rows } = separateRows(path, state)
      const rowsMetadata = [...(state[path].rows || [])]

      const duplicateRowMetadata = deepCopyObjectSimpleWithoutReactComponents(
        rowsMetadata[rowIndex],
      )

      if (duplicateRowMetadata.id) {
        duplicateRowMetadata.id = new ObjectId().toHexString()
      }

      const duplicateRowState = deepCopyObjectSimpleWithoutReactComponents(rows[rowIndex])

      if (duplicateRowState.id) {
        duplicateRowState.id.value = new ObjectId().toHexString()
        duplicateRowState.id.initialValue = new ObjectId().toHexString()
      }

      for (const key of Object.keys(duplicateRowState).filter((key) => key.endsWith('.id'))) {
        const idState = duplicateRowState[key]

        if (idState && typeof idState.value === 'string' && ObjectId.isValid(idState.value)) {
          duplicateRowState[key].value = new ObjectId().toHexString()
          duplicateRowState[key].initialValue = new ObjectId().toHexString()
        }
      }

      // If there are subfields
      if (Object.keys(duplicateRowState).length > 0) {
        // Add new object containing subfield names to unflattenedRows array
        rows.splice(rowIndex + 1, 0, duplicateRowState)
        rowsMetadata.splice(rowIndex + 1, 0, duplicateRowMetadata)
      }

      const newState = {
        ...remainingFields,
        ...flattenRows(path, rows),
        [path]: {
          ...state[path],
          disableFormData: true,
          rows: rowsMetadata,
          value: rows.length,
        },
      }

      return newState
    }

    case 'MOVE_ROW': {
      const { moveFromIndex, moveToIndex, path } = action

      // Handle moving rows on the top-level, i.e. `array.0.text` -> `array.1.text`
      const { remainingFields, rows: topLevelRows } = separateRows(path, state)
      const copyOfMovingRow = topLevelRows[moveFromIndex]
      topLevelRows.splice(moveFromIndex, 1)
      topLevelRows.splice(moveToIndex, 0, copyOfMovingRow)

      // modify array/block internal row state (i.e. collapsed, blockType)
      const rowsWithinField = [...(state[path]?.rows || [])]
      const copyOfMovingRow2 = { ...rowsWithinField[moveFromIndex] }
      rowsWithinField.splice(moveFromIndex, 1)
      rowsWithinField.splice(moveToIndex, 0, copyOfMovingRow2)

      const newState = {
        ...remainingFields,
        ...flattenRows(path, topLevelRows),
        [path]: {
          ...state[path],
          rows: rowsWithinField,
        },
      }

      return newState
    }

    case 'REMOVE': {
      const newState = { ...state }
      if (newState[action.path]) {
        delete newState[action.path]
      }
      return newState
    }

    case 'REMOVE_ROW': {
      const { path, rowIndex } = action
      const { remainingFields, rows } = separateRows(path, state)
      const rowsMetadata = [...(state[path]?.rows || [])]

      rows.splice(rowIndex, 1)
      rowsMetadata.splice(rowIndex, 1)

      const newState: FormState = {
        ...remainingFields,
        [path]: {
          ...state[path],
          disableFormData: rows.length > 0,
          rows: rowsMetadata,
          value: rows.length,
        },
        ...flattenRows(path, rows),
      }

      return newState
    }

    case 'REPLACE_ROW': {
      const { blockType, path, rowIndex: rowIndexArg, subFieldState = {} } = action

      const { remainingFields, rows: siblingRows } = separateRows(path, state)
      const rowIndex = Math.max(0, Math.min(rowIndexArg, siblingRows?.length - 1 || 0))

      const rowsMetadata = [...(state[path]?.rows || [])]
      rowsMetadata[rowIndex] = {
        id: new ObjectId().toHexString(),
        blockType: blockType || undefined,
        collapsed: false,
      }

      if (blockType) {
        subFieldState.blockType = {
          initialValue: blockType,
          valid: true,
          value: blockType,
        }
      }

      // replace form _field state_
      siblingRows[rowIndex] = subFieldState

      const newState: FormState = {
        ...remainingFields,
        ...flattenRows(path, siblingRows),
        [path]: {
          ...state[path],
          disableFormData: true,
          rows: rowsMetadata,
          value: siblingRows.length,
        },
      }

      return newState
    }

    case 'REPLACE_STATE': {
      if (action.optimize !== false) {
        // Only update fields that have changed
        // by comparing old value / initialValue to new
        // ..
        // This is a performance enhancement for saving
        // large documents with hundreds of fields
        const newState: FormState = {}

        for (const [path, newField] of Object.entries(action.state)) {
          const oldField = state[path]

          if (newField.valid !== false) {
            newField.valid = true
          }
          if (newField.passesCondition !== false) {
            newField.passesCondition = true
          }

          if (!dequal(oldField, newField)) {
            newState[path] = newField
          } else if (oldField) {
            newState[path] = oldField
          }
        }

        return newState
      }

      // TODO: Remove this in 4.0 - this is a temporary fix to prevent a breaking change
      if (action.sanitize) {
        for (const field of Object.values(action.state)) {
          if (field.valid !== false) {
            field.valid = true
          }
          if (field.passesCondition !== false) {
            field.passesCondition = true
          }
        }
      }
      // If we're not optimizing, just set the state to the new state
      return action.state
    }

    case 'SET_ALL_ROWS_COLLAPSED': {
      const { path, updatedRows } = action

      return {
        ...state,
        [path]: {
          ...state[path],
          rows: updatedRows,
        },
      }
    }

    case 'SET_ROW_COLLAPSED': {
      const { path, updatedRows } = action

      const newState = {
        ...state,
        [path]: {
          ...state[path],
          rows: updatedRows,
        },
      }

      return newState
    }

    case 'UPDATE': {
      const newField = Object.entries(action).reduce(
        (field, [key, value]) => {
          if (
            [
              'disableFormData',
              'errorMessage',
              'initialValue',
              'rows',
              'valid',
              'validate',
              'value',
            ].includes(key)
          ) {
            return {
              ...field,
              [key]: value,
            }
          }

          return field
        },
        state?.[action.path] || ({} as FormField),
      )

      const newState = {
        ...state,
        [action.path]: newField,
      }

      return newState
    }

    case 'UPDATE_MANY': {
      const newState = { ...state }

      Object.entries(action.formState).forEach(([path, field]) => {
        newState[path] = field
      })

      return newState
    }

    default: {
      return state
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/Form/index.scss">
@layer payload-default {
  .form {
    > * {
      width: 100%;
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/Form/index.tsx">
'use client'
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
import { useRouter } from 'next/navigation.js'
import { serialize } from 'object-to-formdata'
import { type FormState, type PayloadRequest } from '@convexcms/core'
import {
  deepCopyObjectSimpleWithoutReactComponents,
  getDataByPath as getDataByPathFunc,
  getSiblingData as getSiblingDataFunc,
  reduceFieldsToValues,
  wait,
} from '@convexcms/core/shared'
import React, { useCallback, useEffect, useReducer, useRef, useState } from 'react'
import { toast } from 'sonner'

import type {
  CreateFormData,
  Context as FormContextType,
  FormProps,
  GetDataByPath,
  SubmitOptions,
} from './types.js'

import { FieldErrorsToast } from '../../elements/Toasts/fieldErrors.js'
import { useDebouncedEffect } from '../../hooks/useDebouncedEffect.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useQueues } from '../../hooks/useQueues.js'
import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { useUploadHandlers } from '../../providers/UploadHandlers/index.js'
import { abortAndIgnore, handleAbortRef } from '../../utilities/abortAndIgnore.js'
import { requests } from '../../utilities/api.js'
import {
  BackgroundProcessingContext,
  DocumentFormContext,
  FormContext,
  FormFieldsContext,
  FormWatchContext,
  InitializingContext,
  ModifiedContext,
  ProcessingContext,
  SubmittedContext,
  useDocumentForm,
} from './context.js'
import { errorMessages } from './errorMessages.js'
import { fieldReducer } from './fieldReducer.js'
import { initContextState } from './initContextState.js'
import { mergeServerFormState } from './mergeServerFormState.js'

const baseClass = 'form'

export const Form: React.FC<FormProps> = (props) => {
  const { id, collectionSlug, docPermissions, getDocPreferences, globalSlug } = useDocumentInfo()

  const {
    action,
    beforeSubmit,
    children,
    className,
    disabled: disabledFromProps,
    disableSuccessStatus,
    disableValidationOnSubmit,
    // fields: fieldsFromProps = collection?.fields || global?.fields,
    el,
    handleResponse,
    initialState, // fully formed initial field state
    isDocumentForm,
    isInitializing: initializingFromProps,
    onChange,
    onSubmit,
    onSuccess,
    redirect,
    submitted: submittedFromProps,
    uuid,
    waitForAutocomplete,
  } = props

  const method = 'method' in props ? props?.method : undefined

  const router = useRouter()

  const documentForm = useDocumentForm()

  const { code: locale } = useLocale()
  const { i18n, t } = useTranslation()
  const { refreshCookie, user } = useAuth()
  const operation = useOperation()
  const { queueTask } = useQueues()

  const { getFormState } = useServerFunctions()
  const { startRouteTransition } = useRouteTransition()
  const { getUploadHandler } = useUploadHandlers()

  const { config } = useConfig()

  const [disabled, setDisabled] = useState(disabledFromProps || false)
  const [isMounted, setIsMounted] = useState(false)
  const [modified, setModified] = useState(false)

  /**
   * Tracks wether the form state passes validation.
   * For example the state could be submitted but invalid as field errors have been returned.
   */
  const [isValid, setIsValid] = useState(true)
  const [initializing, setInitializing] = useState(initializingFromProps)
  const [processing, setProcessing] = useState(false)
  const [backgroundProcessing, setBackgroundProcessing] = useState(false)

  const [submitted, setSubmitted] = useState(false)
  const formRef = useRef<HTMLFormElement>(null)
  const contextRef = useRef({} as FormContextType)
  const abortResetFormRef = useRef<AbortController>(null)
  const isFirstRenderRef = useRef(true)

  const fieldsReducer = useReducer(fieldReducer, {}, () => initialState)

  const [formState, dispatchFields] = fieldsReducer

  contextRef.current.fields = formState

  const prevFormState = useRef(formState)

  const validateForm = useCallback(async () => {
    const validatedFieldState = {}
    let isValid = true

    const data = contextRef.current.getData()

    const validationPromises = Object.entries(contextRef.current.fields).map(
      async ([path, field]) => {
        const validatedField = field
        const pathSegments = path ? path.split('.') : []

        if (field.passesCondition !== false) {
          let validationResult: boolean | string = validatedField.valid

          if ('validate' in field && typeof field.validate === 'function') {
            let valueToValidate = field.value

            if (field?.rows && Array.isArray(field.rows)) {
              valueToValidate = contextRef.current.getDataByPath(path)
            }

            validationResult = await field.validate(valueToValidate, {
              ...field,
              id,
              collectionSlug,
              // If there is a parent document form, we can get the data from that form
              blockData: undefined, // Will be expensive to get - not worth to pass to client-side validation, as this can be obtained by the user using `useFormFields()`
              data: documentForm?.getData ? documentForm.getData() : data,
              event: 'submit',
              operation,
              path: pathSegments,
              preferences: {} as any,
              req: {
                payload: {
                  config,
                },
                t,
                user,
              } as unknown as PayloadRequest,
              siblingData: contextRef.current.getSiblingData(path),
            })

            if (typeof validationResult === 'string') {
              validatedField.errorMessage = validationResult
              validatedField.valid = false
            } else {
              validatedField.valid = true
              validatedField.errorMessage = undefined
            }
          }

          if (validatedField.valid === false) {
            isValid = false
          }
        }

        validatedFieldState[path] = validatedField
      },
    )

    await Promise.all(validationPromises)

    if (!dequal(contextRef.current.fields, validatedFieldState)) {
      dispatchFields({ type: 'REPLACE_STATE', state: validatedFieldState })
    }

    setIsValid(isValid)

    return isValid
  }, [collectionSlug, config, dispatchFields, id, operation, t, user, documentForm])

  const submit = useCallback(
    async (options: SubmitOptions = {}, e): Promise<void> => {
      const {
        action: actionArg = action,
        method: methodToUse = method,
        overrides: overridesFromArgs = {},
        skipValidation,
      } = options

      if (disabled) {
        if (e) {
          e.preventDefault()
        }
        return
      }

      // create new toast promise which will resolve manually later
      let errorToast, successToast
      const promise = new Promise((resolve, reject) => {
        successToast = resolve
        errorToast = reject
      })

      const hasFormSubmitAction =
        actionArg || typeof action === 'string' || typeof action === 'function'

      if (redirect || disableSuccessStatus || !hasFormSubmitAction) {
        // Do not show submitting toast, as the promise toast may never disappear under these conditions.
        // Instead, make successToast() or errorToast() throw toast.success / toast.error
        successToast = (data) => toast.success(data)
        errorToast = (data) => toast.error(data)
      } else {
        toast.promise(promise, {
          error: (data) => {
            return data as string
          },
          loading: t('general:submitting'),
          success: (data) => {
            return data as string
          },
        })
      }

      if (e) {
        e.stopPropagation()
        e.preventDefault()
      }

      setProcessing(true)
      setDisabled(true)

      if (waitForAutocomplete) {
        await wait(100)
      }

      // Execute server side validations
      if (Array.isArray(beforeSubmit)) {
        let revalidatedFormState: FormState

        const serializableFields = deepCopyObjectSimpleWithoutReactComponents(
          contextRef.current.fields,
        )

        await beforeSubmit.reduce(async (priorOnChange, beforeSubmitFn) => {
          await priorOnChange

          const result = await beforeSubmitFn({
            formState: serializableFields,
          })

          revalidatedFormState = result
        }, Promise.resolve())

        const isValid = Object.entries(revalidatedFormState).every(
          ([, field]) => field.valid !== false,
        )

        setIsValid(isValid)

        if (!isValid) {
          setProcessing(false)
          setSubmitted(true)
          setDisabled(false)
          return dispatchFields({ type: 'REPLACE_STATE', state: revalidatedFormState })
        }
      }

      const isValid =
        skipValidation || disableValidationOnSubmit ? true : await contextRef.current.validateForm()

      setIsValid(isValid)
      // If not valid, prevent submission
      if (!isValid) {
        errorToast(t('error:correctInvalidFields'))
        setProcessing(false)
        setSubmitted(true)
        setDisabled(false)
        return
      }

      let overrides = {}

      if (typeof overridesFromArgs === 'function') {
        overrides = overridesFromArgs(contextRef.current.fields)
      } else if (typeof overridesFromArgs === 'object') {
        overrides = overridesFromArgs
      }

      // If submit handler comes through via props, run that
      if (onSubmit) {
        const serializableFields = deepCopyObjectSimpleWithoutReactComponents(
          contextRef.current.fields,
        )

        const data = reduceFieldsToValues(serializableFields, true)

        for (const [key, value] of Object.entries(overrides)) {
          data[key] = value
        }

        onSubmit(serializableFields, data)
      }

      if (!hasFormSubmitAction) {
        // No action provided, so we should return. An example where this happens are lexical link drawers. Upon submitting the drawer, we
        // want to close it without submitting the form. Stuff like validation would be handled by lexical before this, through beforeSubmit
        setProcessing(false)
        setSubmitted(true)
        setDisabled(false)
        return
      }

      const formData = await contextRef.current.createFormData(overrides, {
        mergeOverrideData: Boolean(typeof overridesFromArgs !== 'function'),
      })

      try {
        let res

        if (typeof actionArg === 'string') {
          res = await requests[methodToUse.toLowerCase()](actionArg, {
            body: formData,
            headers: {
              'Accept-Language': i18n.language,
            },
          })
        } else if (typeof action === 'function') {
          res = await action(formData)
        }

        setModified(false)
        setDisabled(false)

        if (typeof handleResponse === 'function') {
          handleResponse(res, successToast, errorToast)
          return
        }

        const contentType = res.headers.get('content-type')
        const isJSON = contentType && contentType.indexOf('application/json') !== -1

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let json: Record<string, any> = {}

        if (isJSON) {
          json = await res.json()
        }
        if (res.status < 400) {
          if (typeof onSuccess === 'function') {
            const newFormState = await onSuccess(json)
            if (newFormState) {
              const { newState: mergedFormState } = mergeServerFormState({
                acceptValues: true,
                existingState: contextRef.current.fields || {},
                incomingState: newFormState,
              })

              dispatchFields({
                type: 'REPLACE_STATE',
                optimize: false,
                state: mergedFormState,
              })
            }
          }
          setSubmitted(false)
          setProcessing(false)

          if (redirect) {
            startRouteTransition(() => router.push(redirect))
          } else if (!disableSuccessStatus) {
            successToast(json.message || t('general:submissionSuccessful'))
          }
        } else {
          setProcessing(false)
          setSubmitted(true)

          contextRef.current = { ...contextRef.current } // triggers rerender of all components that subscribe to form
          if (json.message) {
            errorToast(json.message)
            return
          }

          if (Array.isArray(json.errors)) {
            const [fieldErrors, nonFieldErrors] = json.errors.reduce(
              ([fieldErrs, nonFieldErrs], err) => {
                const newFieldErrs = []
                const newNonFieldErrs = []

                if (err?.message) {
                  newNonFieldErrs.push(err)
                }

                if (Array.isArray(err?.data?.errors)) {
                  err.data?.errors.forEach((dataError) => {
                    if (dataError?.path) {
                      newFieldErrs.push(dataError)
                    } else {
                      newNonFieldErrs.push(dataError)
                    }
                  })
                }

                return [
                  [...fieldErrs, ...newFieldErrs],
                  [...nonFieldErrs, ...newNonFieldErrs],
                ]
              },
              [[], []],
            )

            setIsValid(false)

            dispatchFields({
              type: 'ADD_SERVER_ERRORS',
              errors: fieldErrors,
            })

            nonFieldErrors.forEach((err) => {
              errorToast(<FieldErrorsToast errorMessage={err.message || t('error:unknown')} />)
            })

            return
          }

          const message = errorMessages?.[res.status] || res?.statusText || t('error:unknown')

          errorToast(message)
        }
      } catch (err) {
        console.error('Error submitting form', err) // eslint-disable-line no-console
        setProcessing(false)
        setSubmitted(true)
        setDisabled(false)
        errorToast(err.message)
      }
    },
    [
      beforeSubmit,
      startRouteTransition,
      action,
      disableSuccessStatus,
      disableValidationOnSubmit,
      disabled,
      dispatchFields,
      handleResponse,
      method,
      onSubmit,
      onSuccess,
      redirect,
      router,
      t,
      i18n,
      waitForAutocomplete,
    ],
  )

  const getFields = useCallback(() => contextRef.current.fields, [])

  const getField = useCallback((path: string) => contextRef.current.fields[path], [])

  const getData = useCallback(() => reduceFieldsToValues(contextRef.current.fields, true), [])

  const getSiblingData = useCallback(
    (path: string) => getSiblingDataFunc(contextRef.current.fields, path),
    [],
  )

  const getDataByPath = useCallback<GetDataByPath>(
    (path: string) => getDataByPathFunc(contextRef.current.fields, path),
    [],
  )

  const createFormData = useCallback<CreateFormData>(
    async (overrides, { mergeOverrideData = true }) => {
      let data = reduceFieldsToValues(contextRef.current.fields, true)

      let file = data?.file

      if (file) {
        delete data.file
      }

      if (mergeOverrideData) {
        data = {
          ...data,
          ...overrides,
        }
      } else {
        data = overrides
      }

      const handler = getUploadHandler({ collectionSlug })

      if (file && typeof handler === 'function') {
        let filename = file.name
        const clientUploadContext = await handler({
          file,
          updateFilename: (value) => {
            filename = value
          },
        })

        file = JSON.stringify({
          clientUploadContext,
          collectionSlug,
          filename,
          mimeType: file.type,
          size: file.size,
        })
      }

      const dataToSerialize = {
        _payload: JSON.stringify(data),
        file,
      }

      // nullAsUndefineds is important to allow uploads and relationship fields to clear themselves
      const formData = serialize(dataToSerialize, { indices: true, nullsAsUndefineds: false })

      return formData
    },
    [collectionSlug, getUploadHandler],
  )

  const reset = useCallback(
    async (data: unknown) => {
      const controller = handleAbortRef(abortResetFormRef)

      const docPreferences = await getDocPreferences()

      const { state: newState } = await getFormState({
        id,
        collectionSlug,
        data,
        docPermissions,
        docPreferences,
        globalSlug,
        locale,
        operation,
        renderAllFields: true,
        schemaPath: collectionSlug ? collectionSlug : globalSlug,
        signal: controller.signal,
        skipValidation: true,
      })

      contextRef.current = { ...initContextState } as FormContextType
      setModified(false)
      dispatchFields({ type: 'REPLACE_STATE', state: newState })

      abortResetFormRef.current = null
    },
    [
      collectionSlug,
      dispatchFields,
      globalSlug,
      id,
      operation,
      getFormState,
      docPermissions,
      getDocPreferences,
      locale,
    ],
  )

  const replaceState = useCallback(
    (state: FormState) => {
      contextRef.current = { ...initContextState } as FormContextType
      setModified(false)
      dispatchFields({ type: 'REPLACE_STATE', state })
    },
    [dispatchFields],
  )

  const addFieldRow: FormContextType['addFieldRow'] = useCallback(
    ({ blockType, path, rowIndex: rowIndexArg, subFieldState }) => {
      const newRows: unknown[] = getDataByPath(path) || []
      const rowIndex = rowIndexArg === undefined ? newRows.length : rowIndexArg

      // dispatch ADD_ROW adds a blank row to local form state.
      // This performs no form state request, as the debounced onChange effect will do that for us.
      dispatchFields({
        type: 'ADD_ROW',
        blockType,
        path,
        rowIndex,
        subFieldState,
      })

      setModified(true)
    },
    [dispatchFields, getDataByPath],
  )

  const moveFieldRow: FormContextType['moveFieldRow'] = useCallback(
    ({ moveFromIndex, moveToIndex, path }) => {
      dispatchFields({
        type: 'MOVE_ROW',
        moveFromIndex,
        moveToIndex,
        path,
      })

      setModified(true)
    },
    [dispatchFields],
  )

  const removeFieldRow: FormContextType['removeFieldRow'] = useCallback(
    ({ path, rowIndex }) => {
      dispatchFields({ type: 'REMOVE_ROW', path, rowIndex })

      setModified(true)
    },
    [dispatchFields],
  )

  const replaceFieldRow: FormContextType['replaceFieldRow'] = useCallback(
    ({ blockType, path, rowIndex: rowIndexArg, subFieldState }) => {
      const currentRows: unknown[] = getDataByPath(path)
      const rowIndex = rowIndexArg === undefined ? currentRows.length : rowIndexArg

      dispatchFields({
        type: 'REPLACE_ROW',
        blockType,
        path,
        rowIndex,
        subFieldState,
      })

      setModified(true)
    },
    [dispatchFields, getDataByPath],
  )

  useEffect(() => {
    const abortOnChange = abortResetFormRef.current

    return () => {
      abortAndIgnore(abortOnChange)
    }
  }, [])

  useEffect(() => {
    if (initializingFromProps !== undefined) {
      setInitializing(initializingFromProps)
    }
  }, [initializingFromProps])

  contextRef.current.submit = submit
  contextRef.current.getFields = getFields
  contextRef.current.getField = getField
  contextRef.current.getData = getData
  contextRef.current.getSiblingData = getSiblingData
  contextRef.current.getDataByPath = getDataByPath
  contextRef.current.validateForm = validateForm
  contextRef.current.createFormData = createFormData
  contextRef.current.setModified = setModified
  contextRef.current.setProcessing = setProcessing
  contextRef.current.setBackgroundProcessing = setBackgroundProcessing

  contextRef.current.setSubmitted = setSubmitted
  contextRef.current.setIsValid = setIsValid
  contextRef.current.disabled = disabled
  contextRef.current.setDisabled = setDisabled
  contextRef.current.formRef = formRef
  contextRef.current.reset = reset
  contextRef.current.replaceState = replaceState
  contextRef.current.dispatchFields = dispatchFields
  contextRef.current.addFieldRow = addFieldRow
  contextRef.current.removeFieldRow = removeFieldRow
  contextRef.current.moveFieldRow = moveFieldRow
  contextRef.current.replaceFieldRow = replaceFieldRow
  contextRef.current.uuid = uuid
  contextRef.current.initializing = initializing
  contextRef.current.isValid = isValid

  useEffect(() => {
    setIsMounted(true)
  }, [])

  useEffect(() => {
    if (typeof disabledFromProps === 'boolean') {
      setDisabled(disabledFromProps)
    }
  }, [disabledFromProps])

  useEffect(() => {
    if (typeof submittedFromProps === 'boolean') {
      setSubmitted(submittedFromProps)
    }
  }, [submittedFromProps])

  useEffect(() => {
    if (initialState) {
      contextRef.current = { ...initContextState } as FormContextType
      dispatchFields({
        type: 'REPLACE_STATE',
        optimize: false,
        sanitize: true,
        state: initialState,
      })
    }
  }, [initialState, dispatchFields])

  useThrottledEffect(
    () => {
      refreshCookie()
    },
    15000,
    [formState],
  )

  useEffect(() => {
    contextRef.current = { ...contextRef.current } // triggers rerender of all components that subscribe to form
    setModified(false)
  }, [locale])

  const classes = [className, baseClass].filter(Boolean).join(' ')

  const executeOnChange = useEffectEvent((submitted: boolean) => {
    queueTask(async () => {
      if (Array.isArray(onChange)) {
        let revalidatedFormState: FormState = contextRef.current.fields

        for (const onChangeFn of onChange) {
          // Edit view default onChange is in packages/ui/src/views/Edit/index.tsx. This onChange usually sends a form state request
          revalidatedFormState = await onChangeFn({
            formState: deepCopyObjectSimpleWithoutReactComponents(contextRef.current.fields),
            submitted,
          })
        }

        if (!revalidatedFormState) {
          return
        }

        const { changed, newState } = mergeServerFormState({
          existingState: contextRef.current.fields || {},
          incomingState: revalidatedFormState,
        })

        if (changed) {
          prevFormState.current = newState

          dispatchFields({
            type: 'REPLACE_STATE',
            optimize: false,
            state: newState,
          })
        }
      }
    })
  })

  useDebouncedEffect(
    () => {
      if ((isFirstRenderRef.current || !dequal(formState, prevFormState.current)) && modified) {
        executeOnChange(submitted)
      }

      prevFormState.current = formState
      isFirstRenderRef.current = false
    },
    [modified, submitted, formState],
    250,
  )

  const DocumentFormContextComponent: React.FC<any> = isDocumentForm
    ? DocumentFormContext
    : React.Fragment

  const documentFormContextProps = isDocumentForm
    ? {
        value: contextRef.current,
      }
    : {}

  const El: 'form' = (el as unknown as 'form') || 'form'

  return (
    <El
      action={typeof action === 'function' ? void action : action}
      className={classes}
      method={method}
      noValidate
      onSubmit={(e) => void contextRef.current.submit({}, e)}
      ref={formRef}
    >
      <DocumentFormContextComponent {...documentFormContextProps}>
        <FormContext value={contextRef.current}>
          <FormWatchContext
            value={{
              fields: formState,
              ...contextRef.current,
            }}
          >
            <SubmittedContext value={submitted}>
              <InitializingContext value={!isMounted || (isMounted && initializing)}>
                <ProcessingContext value={processing}>
                  <BackgroundProcessingContext value={backgroundProcessing}>
                    <ModifiedContext value={modified}>
                      {/* eslint-disable-next-line @eslint-react/no-context-provider */}
                      <FormFieldsContext.Provider value={fieldsReducer}>
                        {children}
                      </FormFieldsContext.Provider>
                    </ModifiedContext>
                  </BackgroundProcessingContext>
                </ProcessingContext>
              </InitializingContext>
            </SubmittedContext>
          </FormWatchContext>
        </FormContext>
      </DocumentFormContextComponent>
    </El>
  )
}

export {
  DocumentFormContext,
  FormContext,
  FormFieldsContext,
  FormWatchContext,
  ModifiedContext,
  ProcessingContext,
  SubmittedContext,
  useAllFormFields,
  useDocumentForm,
  useForm,
  useFormFields,
  useFormModified,
  useFormProcessing,
  useFormSubmitted,
  useWatchForm,
} from './context.js'

export { FormProps }
</file>

<file path="convexadmin/ui/src/forms/Form/initContextState.ts">
'use client'
import type { Data, FormField, FormState } from '@convexcms/core'

import type {
  Context,
  CreateFormData,
  DispatchFields,
  GetSiblingData,
  Reset,
  SetModified,
  SetProcessing,
  SetSubmitted,
  Submit,
  ValidateForm,
} from './types.js'

const submit: Submit = () => undefined
const getSiblingData: GetSiblingData = () => undefined
const dispatchFields: DispatchFields = () => undefined
const validateForm: ValidateForm = () => undefined
const createFormData: CreateFormData = () => undefined

const setModified: SetModified = () => undefined
const setProcessing: SetProcessing = () => undefined
const setBackgroundProcessing: SetProcessing = () => undefined
const setSubmitted: SetSubmitted = () => undefined
const reset: Reset = () => undefined

export const initContextState: Context = {
  addFieldRow: () => undefined,
  buildRowErrors: () => undefined,
  createFormData,
  disabled: false,
  dispatchFields,
  fields: {},
  formRef: null,
  getData: (): Data => undefined,
  getDataByPath: () => undefined,
  getField: (): FormField => undefined,
  getFields: (): FormState => ({}),
  getSiblingData,
  initializing: undefined,
  isValid: true,
  moveFieldRow: () => undefined,
  removeFieldRow: () => undefined,
  replaceFieldRow: () => undefined,
  replaceState: () => undefined,
  reset,
  setBackgroundProcessing,
  setDisabled: () => undefined,
  setIsValid: () => undefined,
  setModified,
  setProcessing,
  setSubmitted,
  submit,

  validateForm,
}
</file>

<file path="convexadmin/ui/src/forms/Form/mergeErrorPaths.ts">
'use client'
import { arraysHaveSameStrings } from '../../utilities/arraysHaveSameStrings.js'

export const mergeErrorPaths = (
  existing?: string[],
  incoming?: string[],
): {
  changed: boolean
  result?: string[]
} => {
  if (!existing) {
    return {
      changed: false,
      result: undefined,
    }
  }

  const existingErrorPaths: string[] = []
  const incomingErrorPaths: string[] = []

  if (Array.isArray(incoming) && incoming?.length) {
    incoming.forEach((path) => incomingErrorPaths.push(path))
  }

  if (Array.isArray(existing) && existing?.length) {
    existing.forEach((path) => existingErrorPaths.push(path))
  }

  if (!arraysHaveSameStrings(existingErrorPaths, incomingErrorPaths)) {
    return {
      changed: true,
      result: incomingErrorPaths,
    }
  }
  return {
    changed: false,
    result: existing,
  }
}
</file>

<file path="convexadmin/ui/src/forms/Form/mergeServerFormState.ts">
'use client'
import type { FieldState, FormState } from '@convexcms/core'

import { dequal } from 'dequal/lite' // lite: no need for Map and Set support

import { mergeErrorPaths } from './mergeErrorPaths.js'

type Args = {
  acceptValues?: boolean
  existingState: FormState
  incomingState: FormState
}

/**
 * Merges certain properties from the server state into the client state. These do not include values,
 * as we do not want to update them on the client like that, which would cause flickering.
 *
 * We want to use this to update the error state, and other properties that are not user input, as the error state
 * is the thing we want to keep in sync with the server (where it's calculated) on the client.
 */
export const mergeServerFormState = ({
  acceptValues,
  existingState,
  incomingState,
}: Args): { changed: boolean; newState: FormState } => {
  let changed = false

  const newState = {}

  if (existingState) {
    const serverPropsToAccept: Array<keyof FieldState> = [
      'passesCondition',
      'valid',
      'errorMessage',
      'errorPaths',
      'customComponents',
    ]

    if (acceptValues) {
      serverPropsToAccept.push('value')
      serverPropsToAccept.push('initialValue')
    }

    for (const [path, newFieldState] of Object.entries(existingState)) {
      if (!incomingState[path]) {
        continue
      }

      let fieldChanged = false

      /**
       * Handle error paths
       */
      const errorPathsResult = mergeErrorPaths(
        newFieldState.errorPaths,
        incomingState[path].errorPaths as unknown as string[],
      )

      if (errorPathsResult.result) {
        if (errorPathsResult.changed) {
          changed = errorPathsResult.changed
        }
        newFieldState.errorPaths = errorPathsResult.result
      }

      /**
       * Handle filterOptions
       */
      if (incomingState[path]?.filterOptions || newFieldState.filterOptions) {
        if (!dequal(incomingState[path]?.filterOptions, newFieldState.filterOptions)) {
          changed = true
          fieldChanged = true
          newFieldState.filterOptions = incomingState[path].filterOptions
        }
      }

      /**
       * Need to intelligently merge the rows array to ensure changes to local state are not lost while the request was pending
       * For example, the server response could come back with a row which has been deleted on the client
       * Loop over the incoming rows, if it exists in client side form state, merge in any new properties from the server
       */
      if (Array.isArray(incomingState[path].rows)) {
        incomingState[path].rows.forEach((row) => {
          const matchedExistingRowIndex = newFieldState.rows.findIndex(
            (existingRow) => existingRow.id === row.id,
          )

          if (matchedExistingRowIndex > -1) {
            newFieldState.rows[matchedExistingRowIndex] = {
              ...newFieldState.rows[matchedExistingRowIndex],
              ...row,
            }
          }
        })
      }

      /**
       * Handle adding all the remaining props that should be updated in the local form state from the server form state
       */
      serverPropsToAccept.forEach((propFromServer) => {
        if (!dequal(incomingState[path]?.[propFromServer], newFieldState[propFromServer])) {
          changed = true
          fieldChanged = true

          if (newFieldState?.serverPropsToIgnore?.includes(propFromServer)) {
            // Remove the ignored prop for the next request
            newFieldState.serverPropsToIgnore = newFieldState.serverPropsToIgnore.filter(
              (prop) => prop !== propFromServer,
            )

            // if no keys left, remove the entire object
            if (!newFieldState.serverPropsToIgnore.length) {
              delete newFieldState.serverPropsToIgnore
            }

            return
          }

          if (!(propFromServer in incomingState[path])) {
            // Regarding excluding the customComponents prop from being deleted: the incoming state might not have been rendered, as rendering components for every form onchange is expensive.
            // Thus, we simply re-use the initial render state
            if (propFromServer !== 'customComponents') {
              delete newFieldState[propFromServer]
            }
          } else {
            newFieldState[propFromServer as any] = incomingState[path][propFromServer]
          }
        }
      })

      if (newFieldState.valid !== false) {
        newFieldState.valid = true
      }

      if (newFieldState.passesCondition !== false) {
        newFieldState.passesCondition = true
      }

      // Conditions don't work if we don't memcopy the new state, as the object references would otherwise be the same
      newState[path] = fieldChanged ? { ...newFieldState } : newFieldState
    }

    // Now loop over values that are part of incoming state but not part of existing state, and add them to the new state.
    // This can happen if a new array row was added. In our local state, we simply add out stubbed `array` and `array.[index].id` entries to the local form state.
    // However, all other array sub-fields are not added to the local state - those will be added by the server and may be incoming here.
    for (const [path, field] of Object.entries(incomingState)) {
      if (!existingState[path]) {
        changed = true
        newState[path] = field
      }
    }
  }

  return { changed, newState }
}
</file>

<file path="convexadmin/ui/src/forms/Form/reduceToSerializableFields.ts">
import { type FormField, type FormState } from '@convexcms/core'

type BlacklistedKeys = 'customComponents' | 'validate'
const blacklistedKeys: BlacklistedKeys[] = ['validate', 'customComponents']

const sanitizeField = (incomingField: FormField): FormField => {
  const field = { ...incomingField } // shallow copy, as we only need to remove top-level keys

  for (const key of blacklistedKeys) {
    delete field[key]
  }

  return field
}

/**
 * Takes in FormState and removes fields that are not serializable.
 * Returns FormState without blacklisted keys.
 */
export const reduceToSerializableFields = (
  fields: FormState,
): {
  [key: string]: Omit<FormField, BlacklistedKeys>
} => {
  const result: Record<string, Omit<FormField, BlacklistedKeys>> = {}

  for (const key in fields) {
    result[key] = sanitizeField(fields[key])
  }

  return result
}
</file>

<file path="convexadmin/ui/src/forms/Form/rowHelpers.ts">
'use client'
import type { Row } from '@convexcms/core'

export const extractRowsAndCollapsedIDs = ({
  collapsed,
  rowID,
  rows,
}: {
  collapsed: boolean
  rowID: string
  rows: Row[]
}): {
  collapsedIDs: string[]
  updatedRows: Row[]
} => {
  return rows.reduce(
    (acc, row) => {
      if (rowID === row.id) {
        row.collapsed = collapsed
      }
      if (row.collapsed) {
        acc.collapsedIDs.push(row.id)
      }
      acc.updatedRows.push(row)
      return acc
    },
    {
      collapsedIDs: [],
      updatedRows: [],
    },
  )
}

export const toggleAllRows = ({
  collapsed,
  rows,
}): {
  collapsedIDs: string[]
  updatedRows: Row[]
} => {
  return rows.reduce(
    (acc, row) => {
      row.collapsed = collapsed
      if (collapsed) {
        acc.collapsedIDs.push(row.id)
      }
      acc.updatedRows.push(row)
      return acc
    },
    {
      collapsedIDs: [],
      updatedRows: [],
    },
  )
}
</file>

<file path="convexadmin/ui/src/forms/Form/rows.ts">
'use client'
import type { FormState } from '@convexcms/core'

type Result = {
  remainingFields: FormState
  rows: FormState[]
}

export const separateRows = (path: string, fields: FormState): Result => {
  const remainingFields: FormState = {}

  const rows = Object.entries(fields).reduce((incomingRows, [fieldPath, field]) => {
    const newRows = incomingRows

    if (fieldPath.indexOf(`${path}.`) === 0) {
      const [rowIndex] = fieldPath.replace(`${path}.`, '').split('.')
      if (!newRows[rowIndex]) {
        newRows[rowIndex] = {}
      }
      newRows[rowIndex][fieldPath.replace(`${path}.${String(rowIndex)}.`, '')] = { ...field }
    } else {
      remainingFields[fieldPath] = field
    }

    return newRows
  }, [])

  return {
    remainingFields,
    rows,
  }
}

export const flattenRows = (path: string, rows: FormState[]): FormState => {
  return rows.reduce(
    (fields, row, i) => ({
      ...fields,
      ...Object.entries(row).reduce((subFields, [subPath, subField]) => {
        return {
          ...subFields,
          [`${path}.${i}.${subPath}`]: { ...subField },
        }
      }, {}),
    }),
    {},
  )
}
</file>

<file path="convexadmin/ui/src/forms/Form/types.ts">
import type {
  ClientField,
  Data,
  FormField,
  FormState,
  Row,
  User,
  ValidationFieldError,
} from '@convexcms/core'
import type React from 'react'
import type { Dispatch } from 'react'

export type Preferences = {
  [key: string]: unknown
}

export type FormProps = {
  beforeSubmit?: ((args: { formState: FormState }) => Promise<FormState>)[]
  children?: React.ReactNode
  className?: string
  disabled?: boolean
  disableSuccessStatus?: boolean
  /**
   * If you would like to solely leverage server-side validation on submit,
   * you can disable checks that the form makes before it submits
   */
  disableValidationOnSubmit?: boolean
  /**
   * If you don't want the form to be a <form> element, you can pass a string here to use as the wrapper element.
   */
  el?: string
  /**
   * By default, the form will get the field schema (not data) from the current document. If you pass this in, you can override that behavior.
   * This is very useful for sub-forms, where the form's field schema is not necessarily the field schema of the current document (e.g. for the Blocks
   * feature of the Lexical Rich Text field)
   */
  fields?: ClientField[]
  handleResponse?: (
    res: Response,
    successToast: (value: string) => void,
    errorToast: (value: string) => void,
  ) => void
  initialState?: FormState
  /**
   * Determines if this Form is the main, top-level Form of a document. If set to true, the
   * Form's children will be wrapped in a DocumentFormContext, which lets you access this document
   * Form's data and fields from any child component - even if that child component is wrapped in a child
   * Form (e.g. a lexical block).
   */
  isDocumentForm?: boolean
  isInitializing?: boolean
  log?: boolean
  onChange?: ((args: { formState: FormState; submitted?: boolean }) => Promise<FormState>)[]
  onSubmit?: (fields: FormState, data: Data) => void
  onSuccess?: (json: unknown) => Promise<FormState | void> | void
  redirect?: string
  submitted?: boolean
  uuid?: string
  validationOperation?: 'create' | 'update'
  waitForAutocomplete?: boolean
} & (
  | {
      action: (formData: FormData) => Promise<void>
    }
  | {
      action?: string
      method?: 'DELETE' | 'GET' | 'PATCH' | 'POST'
    }
)

export type SubmitOptions = {
  action?: string
  method?: string
  overrides?: ((formState) => FormData) | Record<string, unknown>
  skipValidation?: boolean
}

export type DispatchFields = React.Dispatch<any>
export type Submit = (
  options?: SubmitOptions,
  e?: React.FormEvent<HTMLFormElement>,
) => Promise<void>

export type ValidateForm = () => Promise<boolean>

export type CreateFormData = (
  overrides?: Record<string, unknown>,
  /**
   * If mergeOverrideData true, the data will be merged with the existing data in the form state.
   * @default true
   */
  options?: { mergeOverrideData?: boolean },
) => FormData | Promise<FormData>

export type GetFields = () => FormState
export type GetField = (path: string) => FormField
export type GetData = () => Data
export type GetSiblingData = (path: string) => Data
export type GetDataByPath = <T = unknown>(path: string) => T
export type SetModified = (modified: boolean) => void
export type SetSubmitted = (submitted: boolean) => void
export type SetProcessing = (processing: boolean) => void

export type Reset = (data: unknown) => Promise<void>

export type REPLACE_STATE = {
  optimize?: boolean
  /**
   * If `sanitize` is true, default values will be set for form field properties that are not present in the incoming state.
   * For example, `valid` will be set to true if it is not present in the incoming state.
   */
  sanitize?: boolean
  state: FormState
  type: 'REPLACE_STATE'
}

export type REMOVE = {
  path: string
  type: 'REMOVE'
}

export type MODIFY_CONDITION = {
  path: string
  result: boolean
  type: 'MODIFY_CONDITION'
  user: User
}

export type UPDATE = {
  path: string
  type: 'UPDATE'
} & Partial<FormField>

export type UPDATE_MANY = {
  formState: FormState
  type: 'UPDATE_MANY'
}

export type REMOVE_ROW = {
  path: string
  rowIndex: number
  type: 'REMOVE_ROW'
}

export type ADD_ROW = {
  blockType?: string
  path: string
  rowIndex?: number
  subFieldState?: FormState
  type: 'ADD_ROW'
}

export type REPLACE_ROW = {
  blockType?: string
  path: string
  rowIndex: number
  subFieldState?: FormState
  type: 'REPLACE_ROW'
}

export type DUPLICATE_ROW = {
  path: string
  rowIndex: number
  type: 'DUPLICATE_ROW'
}

export type MOVE_ROW = {
  moveFromIndex: number
  moveToIndex: number
  path: string
  type: 'MOVE_ROW'
}

export type ADD_SERVER_ERRORS = {
  errors: ValidationFieldError[]
  type: 'ADD_SERVER_ERRORS'
}

export type SET_ROW_COLLAPSED = {
  path: string
  type: 'SET_ROW_COLLAPSED'
  updatedRows: Row[]
}

export type SET_ALL_ROWS_COLLAPSED = {
  path: string
  type: 'SET_ALL_ROWS_COLLAPSED'
  updatedRows: Row[]
}

export type FieldAction =
  | ADD_ROW
  | ADD_SERVER_ERRORS
  | DUPLICATE_ROW
  | MODIFY_CONDITION
  | MOVE_ROW
  | REMOVE
  | REMOVE_ROW
  | REPLACE_ROW
  | REPLACE_STATE
  | SET_ALL_ROWS_COLLAPSED
  | SET_ROW_COLLAPSED
  | UPDATE
  | UPDATE_MANY

export type FormFieldsContext = [FormState, Dispatch<FieldAction>]

export type Context = {
  addFieldRow: ({
    blockType,
    path,
    rowIndex,
    schemaPath,
    subFieldState,
  }: {
    blockType?: string
    path: string
    rowIndex?: number
    schemaPath: string
    subFieldState?: FormState
  }) => void
  buildRowErrors: () => void
  createFormData: CreateFormData
  disabled: boolean
  dispatchFields: Dispatch<FieldAction>
  /**
   * Form context fields may be outdated and should not be relied on. Instead, prefer `useFormFields`.
   */
  fields: FormState
  formRef: React.RefObject<HTMLFormElement>
  getData: GetData
  getDataByPath: GetDataByPath
  getField: GetField
  getFields: GetFields
  getSiblingData: GetSiblingData
  initializing: boolean
  /**
   * Tracks wether the form state passes validation.
   * For example the state could be submitted but invalid as field errors have been returned.
   */
  isValid: boolean
  moveFieldRow: ({
    moveFromIndex,
    moveToIndex,
    path,
  }: {
    moveFromIndex: number
    moveToIndex: number
    path: string
  }) => void
  removeFieldRow: ({ path, rowIndex }: { path: string; rowIndex: number }) => void
  replaceFieldRow: ({
    blockType,
    path,
    rowIndex,
    schemaPath,
    subFieldState,
  }: {
    blockType?: string
    path: string
    rowIndex: number
    schemaPath: string
    subFieldState?: FormState
  }) => void
  replaceState: (state: FormState) => void
  reset: Reset
  /**
   * If the form has started processing in the background (e.g.
   * if autosave is running), this will be true.
   */
  setBackgroundProcessing: SetProcessing
  setDisabled: (disabled: boolean) => void
  setIsValid: (processing: boolean) => void
  setModified: SetModified
  setProcessing: SetProcessing
  setSubmitted: SetSubmitted
  submit: Submit
  uuid?: string
  validateForm: ValidateForm
}
</file>

<file path="convexadmin/ui/src/forms/NullifyField/index.tsx">
'use client'

import * as React from 'react'

import { Banner } from '../../elements/Banner/index.js'
import { CheckboxField } from '../../fields/Checkbox/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'

type NullifyLocaleFieldProps = {
  readonly fieldValue?: [] | null | number
  readonly localized: boolean
  readonly path: string
}

export const NullifyLocaleField: React.FC<NullifyLocaleFieldProps> = ({
  fieldValue,
  localized,
  path,
}) => {
  const { code: currentLocale } = useLocale()
  const {
    config: { localization },
  } = useConfig()
  const [checked, setChecked] = React.useState<boolean>(typeof fieldValue !== 'number')
  const { t } = useTranslation()

  if (!localized || !localization) {
    // hide when field is not localized or localization is not enabled
    return null
  }

  if (localization.defaultLocale === currentLocale || !localization.fallback) {
    // if editing default locale or when fallback is disabled
    return null
  }

  if (fieldValue) {
    let hideCheckbox = false
    if (typeof fieldValue === 'number' && fieldValue > 0) {
      hideCheckbox = true
    }
    if (Array.isArray(fieldValue) && fieldValue.length > 0) {
      hideCheckbox = true
    }

    if (hideCheckbox) {
      if (checked) {
        setChecked(false)
      } // uncheck when field has value
      return null
    }
  }

  return (
    <Banner>
      <CheckboxField
        checked={checked}
        field={{
          name: '',
          label: t('general:fallbackToDefaultLocale'),
        }}
        id={`field-${path.replace(/\./g, '__')}`}
        path={path}
        schemaPath=""
        // onToggle={onChange}
      />
    </Banner>
  )
}
</file>

<file path="convexadmin/ui/src/forms/RenderFields/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  // Positioned field-type__wrap is needed for correct positioning of field tooltips.
  // This is set outside of .render-fields, so that manually rendered fields (e.g. in Auth/index.tsx)
  // outside RenderFields also receive this styling.
  .field-type__wrap {
    position: relative;
  }

  .render-fields {
    --spacing-field: var(--base);

    &--margins-small {
      --spacing-field: var(--base);
    }

    &--margins-none {
      --spacing-field: 0;
    }

    & > .field-type {
      margin-bottom: var(--spacing-field);
      position: relative;

      &[type='hidden'] {
        margin-bottom: 0;
      }

      &:first-child {
        margin-top: 0;
      }

      &:last-of-type {
        margin-bottom: 0;
      }
    }

    // at the top-level, add extra margins for the following field types
    &:not(.render-fields--margins-small) {
      & > .field-type {
        &.group-field,
        &.blocks-field,
        &.array-field,
        &.collapsible-field,
        &.rich-text {
          margin-top: calc(var(--spacing-field) * 2);
          margin-bottom: calc(var(--spacing-field) * 2);

          &:first-child {
            margin-top: 0;
          }

          &:last-child {
            margin-bottom: 0;
          }
        }
      }
    }

    @include small-break {
      --spacing-field: calc(var(--base) / 2);
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/RenderFields/index.tsx">
"use client";

import React from "react";
import { RenderField } from "./RenderField"; // Needs mock or adaptation
import type { RenderFieldsProps } from "./types.js";
import { RenderIfInViewport } from "@/convexui/src/elements/RenderIfInViewport"; // Needs mock or adaptation
// Import our mock utilities instead of payload/shared
import { fieldIsHiddenOrDisabled } from "@/convexui/src/utilities/fieldIsHiddenOrDisabled";
import { getFieldPaths } from "@/convexui/src/utilities/getFieldPaths";
import { getFieldPermissions } from "@/convexui/src/utilities/getFieldPermissions";
import { useOperation } from "@/convexui/src/providers/Operation"; // Needs mock or adaptation

// import './index.scss' // Removed SCSS

const baseClass = "render-fields";

export { RenderFieldsProps as Props };

export const RenderFields: React.FC<RenderFieldsProps> = (props) => {
  const {
    className,
    fields,
    forceRender,
    margins,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
    permissions,
    readOnly: readOnlyFromParent,
  } = props;

  const operation = useOperation();

  if (fields && fields.length > 0) {
    return (
      <RenderIfInViewport
        className={[
          baseClass,
          className,
          margins && `${baseClass}--margins-${margins}`,
          margins === false && `${baseClass}--margins-none`,
        ]
          .filter(Boolean)
          .join(" ")}
        forceRender={forceRender}
      >
        {fields.map((field, i) => {
          // For sidebar fields in the main fields array, `field` will be `null`, and visa versa
          // This is to keep the order of the fields consistent and maintain the correct index paths for the main fields (i)
          if (!field || fieldIsHiddenOrDisabled(field)) {
            return null;
          }

          const {
            operation: hasOperationPermission,
            permissions: fieldPermissions,
            read: hasReadPermission,
          } = getFieldPermissions({
            field,
            operation,
            parentName: parentPath?.includes(".")
              ? parentPath.split(".")[parentPath.split(".").length - 1]
              : parentPath,
            permissions,
          });

          // If the user cannot read the field, then filter it out
          // This is different from `admin.readOnly` which is executed based on `operation`
          if ("name" in field && !hasReadPermission) {
            return null;
          }

          // `admin.readOnly` displays the value but prevents the field from being edited
          let isReadOnly = readOnlyFromParent || field?.admin?.readOnly;

          // If parent field is `readOnly: true`, but this field is `readOnly: false`, the field should still be editable
          if (isReadOnly && field.admin?.readOnly === false) {
            isReadOnly = false;
          }

          // If the user does not have access at the operation level, to begin with, force it to be read-only
          if ("name" in field && !hasOperationPermission) {
            isReadOnly = true;
          }

          const { indexPath, path, schemaPath } = getFieldPaths({
            field,
            index: i,
            parentIndexPath,
            parentPath,
            parentSchemaPath,
          });

          return (
            <RenderField
              clientFieldConfig={field}
              forceRender={forceRender}
              indexPath={indexPath}
              key={`${path}-${i}`}
              parentPath={parentPath}
              parentSchemaPath={parentSchemaPath}
              path={path}
              permissions={fieldPermissions}
              readOnly={isReadOnly}
              schemaPath={schemaPath}
            />
          );
        })}
      </RenderIfInViewport>
    );
  }

  return null;
};
</file>

<file path="convexadmin/ui/src/forms/RenderFields/RenderField.tsx">
"use client";

import type { AdminCollectionField } from "@/convexadmin/types";
import { CheckboxField } from "@/convexui/src/fields/Checkbox";
import { NumberField } from "@/convexui/src/fields/Number";
import React from "react";
import { SelectField } from "@/convexui/src/fields/Select";
import { TextField } from "@/convexui/src/fields/Text";
import { useFormFields } from "@/convexui/src/forms/Form/context";

// --- Mock/Simplified Types ---
type MockSanitizedFieldPermissions = any;
interface SimplifiedClientComponentProps {
  forceRender?: boolean;
  permissions?: MockSanitizedFieldPermissions;
  readOnly?: boolean;
  schemaPath: string; // May keep for now
}
// --- End Mock/Simplified Types ---

type RenderFieldProps = {
  clientFieldConfig: AdminCollectionField;
  permissions: MockSanitizedFieldPermissions;
  path: string;
} & Pick<
  SimplifiedClientComponentProps,
  "forceRender" | "readOnly" | "schemaPath"
>;

export function RenderField({
  clientFieldConfig,
  forceRender,
  path,
  permissions,
  readOnly,
  schemaPath,
}: RenderFieldProps) {
  const formFieldsState = useFormFields(([fields]) => fields);
  const CustomField = formFieldsState?.[path]?.customComponents?.Field;

  if (CustomField !== undefined) {
    console.warn(`Rendering custom field component for path: ${path}`);
    return CustomField || null;
  }

  const baseFieldProps: Pick<
    SimplifiedClientComponentProps,
    "forceRender" | "permissions" | "readOnly" | "schemaPath"
  > = {
    forceRender,
    permissions,
    readOnly,
    schemaPath,
  };

  switch (clientFieldConfig.type) {
    case "boolean":
      return (
        <CheckboxField
          {...baseFieldProps}
          field={clientFieldConfig}
          path={path}
        />
      );
    case "number":
      return (
        <NumberField
          {...baseFieldProps}
          field={clientFieldConfig}
          path={path}
        />
      );
    case "select":
      return (
        <SelectField
          {...baseFieldProps}
          field={clientFieldConfig as any}
          path={path}
        />
      );
    case "text":
    case "string":
      return (
        <TextField {...baseFieldProps} field={clientFieldConfig} path={path} />
      );
    default:
      console.warn(
        `No field component mapped for type: ${clientFieldConfig.type} at path: ${path}`,
      );
      return (
        <div className="border p-2 bg-red-100 text-red-700">
          Field type &quot;{clientFieldConfig.type}&quot; not implemented for
          path &quot;{path}&quot;.
        </div>
      );
  }
}
</file>

<file path="convexadmin/ui/src/forms/RenderFields/types.ts">
import type { ClientField, SanitizedFieldPermissions } from '@convexcms/core'

export type RenderFieldsProps = {
  readonly className?: string
  readonly fields: ClientField[]
  /**
   * Controls the rendering behavior of the fields, i.e. defers rendering until they intersect with the viewport using the Intersection Observer API.
   *
   * If true, the fields will be rendered immediately, rather than waiting for them to intersect with the viewport.
   *
   * If a number is provided, will immediately render fields _up to that index_.
   */
  readonly forceRender?: boolean
  readonly margins?: 'small' | false
  readonly parentIndexPath: string
  readonly parentPath: string
  readonly parentSchemaPath: string
  readonly permissions:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | SanitizedFieldPermissions
  readonly readOnly?: boolean
}
</file>

<file path="convexadmin/ui/src/forms/RowLabel/Context/index.tsx">
'use client'

import React from 'react'

import { useWatchForm } from '../../Form/context.js'

type RowLabelType<T = unknown> = {
  readonly data: T
  readonly path: string
  readonly rowNumber?: number
}

const RowLabel = React.createContext<RowLabelType>({
  data: {},
  path: '',
  rowNumber: undefined,
})

type Props<T> = {
  readonly children: React.ReactNode
} & Omit<RowLabelType<T>, 'data'>

export const RowLabelProvider: React.FC<Props<unknown>> = ({ children, path, rowNumber }) => {
  'use no memo'
  const { getDataByPath, getSiblingData } = useWatchForm()
  const collapsibleData = getSiblingData(path)
  const arrayData = getDataByPath(path)

  const data = arrayData || collapsibleData

  return <RowLabel value={{ data, path, rowNumber }}>{children}</RowLabel>
}

export const useRowLabel = <T,>() => {
  return React.use(RowLabel) as RowLabelType<T>
}
</file>

<file path="convexadmin/ui/src/forms/RowLabel/index.tsx">
'use client'
import React from 'react'

import type { RowLabelProps } from './types.js'

import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { RowLabelProvider } from './Context/index.js'
export type { RowLabelProps }

const baseClass = 'row-label'

export const RowLabel: React.FC<RowLabelProps> = (props) => {
  const { className, CustomComponent, label, path, rowNumber } = props

  return (
    <RowLabelProvider path={path} rowNumber={rowNumber}>
      <RenderCustomComponent
        CustomComponent={CustomComponent}
        Fallback={
          typeof label === 'string' ? (
            <span
              className={[baseClass, className].filter(Boolean).join(' ')}
              style={{
                pointerEvents: 'none',
              }}
            >
              {label}
            </span>
          ) : (
            label
          )
        }
      />
    </RowLabelProvider>
  )
}
</file>

<file path="convexadmin/ui/src/forms/RowLabel/types.ts">
export type RowLabelProps = {
  readonly className?: string
  readonly CustomComponent?: React.ReactNode
  readonly label?: React.ReactNode | string
  readonly path: string
  readonly rowNumber?: number
}
</file>

<file path="convexadmin/ui/src/forms/Submit/index.scss">
@layer payload-default {
  form > .form-submit {
    .btn {
      width: 100%;
    }
  }
}
</file>

<file path="convexadmin/ui/src/forms/Submit/index.tsx">
'use client'
import React from 'react'

import type { Props } from '../../elements/Button/types.js'

import { Button } from '../../elements/Button/index.js'
import {
  useForm,
  useFormBackgroundProcessing,
  useFormInitializing,
  useFormProcessing,
} from '../Form/context.js'
import './index.scss'

const baseClass = 'form-submit'

export const FormSubmit: React.FC<Props> = (props) => {
  const {
    type = 'submit',
    buttonId: id,
    children,
    disabled: disabledFromProps,
    onClick,
    programmaticSubmit,
    ref,
  } = props

  const processing = useFormProcessing()
  const backgroundProcessing = useFormBackgroundProcessing()
  const initializing = useFormInitializing()
  const { disabled, submit } = useForm()

  const canSave = !(
    disabledFromProps ||
    initializing ||
    processing ||
    backgroundProcessing ||
    disabled
  )

  const handleClick =
    onClick ??
    (programmaticSubmit
      ? () => {
          void submit()
        }
      : undefined)

  return (
    <div className={baseClass}>
      <Button
        ref={ref}
        {...props}
        disabled={canSave ? undefined : true}
        id={id}
        onClick={handleClick}
        type={type}
      >
        {children}
      </Button>
    </div>
  )
}
</file>

<file path="convexadmin/ui/src/forms/useField/index.tsx">
'use client'
import type { PayloadRequest } from '@convexcms/core'

import { useCallback, useMemo, useRef } from 'react'

import type { UPDATE } from '../Form/types.js'
import type { FieldType, Options } from './types.js'

export type { FieldType, Options }

import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import {
  useDocumentForm,
  useForm,
  useFormFields,
  useFormInitializing,
  useFormModified,
  useFormProcessing,
  useFormSubmitted,
} from '../Form/context.js'

/**
 * Get and set the value of a form field.
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#usefield
 */
export const useField = <TValue,>(options: Options): FieldType<TValue> => {
  const { disableFormData = false, hasRows, path, validate } = options

  const submitted = useFormSubmitted()
  const processing = useFormProcessing()
  const initializing = useFormInitializing()
  const { user } = useAuth()
  const { id, collectionSlug } = useDocumentInfo()
  const operation = useOperation()

  const dispatchField = useFormFields(([_, dispatch]) => dispatch)
  const field = useFormFields(([fields]) => (fields && fields?.[path]) || null)

  const { t } = useTranslation()
  const { config } = useConfig()

  const { getData, getDataByPath, getSiblingData, setModified } = useForm()
  const documentForm = useDocumentForm()
  const modified = useFormModified()

  const filterOptions = field?.filterOptions
  const value = field?.value as TValue
  const initialValue = field?.initialValue as TValue
  const valid = typeof field?.valid === 'boolean' ? field.valid : true
  const showError = valid === false && submitted

  const prevValid = useRef(valid)
  const prevErrorMessage = useRef(field?.errorMessage)

  const pathSegments = path ? path.split('.') : []

  // Method to return from `useField`, used to
  // update field values from field component(s)
  const setValue = useCallback(
    (e, disableModifyingForm = false) => {
      const val = e && e.target ? e.target.value : e
      dispatchField({
        type: 'UPDATE',
        disableFormData: disableFormData || (hasRows && val > 0),
        path,
        value: val,
      })

      if (!disableModifyingForm) {
        if (typeof setModified === 'function') {
          // Only update setModified to true if the form is not already set to modified. Otherwise the following could happen:
          // 1. Text field: someone types in it in an unmodified form
          // 2. After setTimeout triggers setModified(true): form is set to modified. Save Button becomes available. Good!
          // 3. Type something in text field
          // 4. Click on save button before setTimeout in useField has finished (so setModified(true) has not been run yet)
          // 5. Form is saved, setModified(false) is set in the Form/index.tsx `submit` function, "saved successfully" toast appears
          // 6. setModified(true) inside the timeout is run, form is set to modified again, even though it was already saved and thus set to unmodified. Bad! This should have happened before the form is saved. Now the form should be unmodified and stay that way
          //    until a NEW change happens. Due to this, the "Leave without saving" modal appears even though it should not when leaving the page fast immediately after saving the document.
          // This is only an issue for forms which have already been set to modified true, as that causes the save button to be enabled. If we prevent this setTimeout to be run
          // for already-modified forms first place (which is unnecessary), we can avoid this issue. As for unmodified forms, this race issue will not happen, because you cannot click the save button faster
          // than the timeout in useField is run. That's because the save button won't even be enabled for clicking until the setTimeout in useField has run.
          // This fixes e2e test flakes, as e2e tests were often so fast that they were saving the form before the timeout in useField has run.
          // Specifically, this fixes the 'should not warn about unsaved changes when navigating to lexical editor with blocks node and then leaving the page after making a change and saving' lexical e2e test.
          if (modified === false) {
            // Update modified state after field value comes back
            // to avoid cursor jump caused by state value / DOM mismatch
            setTimeout(() => {
              setModified(true)
            }, 10)
          }
        }
      }
    },
    [setModified, path, dispatchField, disableFormData, hasRows, modified],
  )

  // Store result from hook as ref
  // to prevent unnecessary rerenders
  const result: FieldType<TValue> = useMemo(
    () => ({
      customComponents: field?.customComponents,
      disabled: processing || initializing,
      errorMessage: field?.errorMessage,
      errorPaths: field?.errorPaths || [],
      filterOptions,
      formInitializing: initializing,
      formProcessing: processing,
      formSubmitted: submitted,
      initialValue,
      path,
      rows: field?.rows,
      setValue,
      showError,
      valid: field?.valid,
      value,
    }),
    [
      field,
      processing,
      setValue,
      showError,
      submitted,
      value,
      initialValue,
      path,
      filterOptions,
      initializing,
    ],
  )

  // Throttle the validate function
  useThrottledEffect(
    () => {
      const validateField = async () => {
        let valueToValidate = value

        if (field?.rows && Array.isArray(field.rows)) {
          valueToValidate = getDataByPath(path)
        }

        let errorMessage: string | undefined = prevErrorMessage.current
        let valid: boolean | string = prevValid.current

        const data = getData()
        const isValid =
          typeof validate === 'function'
            ? await validate(valueToValidate, {
                id,
                blockData: undefined, // Will be expensive to get - not worth to pass to client-side validation, as this can be obtained by the user using `useFormFields()`
                collectionSlug,
                data: documentForm?.getData ? documentForm.getData() : data,
                event: 'onChange',
                operation,
                path: pathSegments,
                preferences: {} as any,
                req: {
                  payload: {
                    config,
                  },
                  t,
                  user,
                } as unknown as PayloadRequest,
                siblingData: getSiblingData(path),
              })
            : typeof prevErrorMessage.current === 'string'
              ? prevErrorMessage.current
              : prevValid.current

        if (typeof isValid === 'string') {
          valid = false
          errorMessage = isValid
        } else if (typeof isValid === 'boolean') {
          valid = isValid
          errorMessage = undefined
        }

        // Only dispatch if the validation result has changed
        // This will prevent unnecessary rerenders
        if (valid !== prevValid.current || errorMessage !== prevErrorMessage.current) {
          prevValid.current = valid
          prevErrorMessage.current = errorMessage

          const update: UPDATE = {
            type: 'UPDATE',
            errorMessage,
            path,
            rows: field?.rows,
            valid,
            validate,
            value,
          }

          if (disableFormData || (hasRows ? typeof value === 'number' && value > 0 : false)) {
            update.disableFormData = true
          }

          if (typeof dispatchField === 'function') {
            dispatchField(update)
          }
        }
      }

      void validateField()
    },
    150,
    [
      value,
      disableFormData,
      dispatchField,
      getData,
      getSiblingData,
      getDataByPath,
      id,
      operation,
      path,
      user,
      validate,
      field?.rows,
      collectionSlug,
    ],
  )

  return result
}
</file>

<file path="convexadmin/ui/src/forms/useField/types.ts">
import type { FieldState, FilterOptionsResult, Row, Validate } from '@convexcms/core'

export type Options = {
  disableFormData?: boolean
  hasRows?: boolean
  path: string
  validate?: Validate
}

export type FieldType<T> = {
  customComponents?: FieldState['customComponents']
  disabled: boolean
  errorMessage?: string
  errorPaths?: string[]
  filterOptions?: FilterOptionsResult
  formInitializing: boolean
  formProcessing: boolean
  formSubmitted: boolean
  initialValue?: T
  readOnly?: boolean
  rows?: Row[]
  setValue: (val: unknown, disableModifyingForm?: boolean) => void
  showError: boolean
  valid?: boolean
  value: T
}
</file>

<file path="convexadmin/ui/src/forms/WatchChildErrors/buildPathSegments.ts">
'use client'
import type { ClientField } from '@convexcms/core'

import { fieldAffectsData } from '@convexcms/core/shared'

export const buildPathSegments = (fields: ClientField[]): (`${string}.` | string)[] => {
  return fields.reduce((acc: (`${string}.` | string)[], field) => {
    const fields: ClientField[] = 'fields' in field ? field.fields : undefined

    if (fields) {
      if (fieldAffectsData(field)) {
        // group, block, array
        acc.push(`${field.name}.`)
      } else {
        // rows, collapsibles, unnamed-tab
        acc.push(...buildPathSegments(fields))
      }
    } else if (field.type === 'tabs') {
      // tabs
      if ('tabs' in field) {
        field.tabs?.forEach((tab) => {
          if ('name' in tab) {
            acc.push(`${tab.name}.`)
          } else {
            acc.push(...buildPathSegments(tab.fields))
          }
        })
      }
    } else if (fieldAffectsData(field)) {
      // text, number, date, etc.
      acc.push(field.name)
    }

    return acc
  }, [])
}
</file>

<file path="convexadmin/ui/src/forms/WatchChildErrors/index.tsx">
'use client'
import type { ClientField } from '@convexcms/core'
import type React from 'react'

import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAllFormFields, useFormSubmitted } from '../Form/context.js'
import { buildPathSegments } from './buildPathSegments.js'

type TrackSubSchemaErrorCountProps = {
  fields?: ClientField[]
  /**
   * This path should only include path segments that affect data
   * i.e. it should not include _index-0 type segments
   *
   * For collapsibles and tabs you can simply pass their parent path
   */
  path: (number | string)[]
  setErrorCount: (count: number) => void
}
export const WatchChildErrors: React.FC<TrackSubSchemaErrorCountProps> = ({
  fields,
  path: parentPath,
  setErrorCount,
}) => {
  const [formState] = useAllFormFields()
  const hasSubmitted = useFormSubmitted()

  const segmentsToMatch = buildPathSegments(fields)

  useThrottledEffect(
    () => {
      if (hasSubmitted) {
        let errorCount = 0
        Object.entries(formState).forEach(([key]) => {
          const matchingSegment = segmentsToMatch?.some((segment) => {
            const segmentToMatch = [...parentPath, segment].join('.')
            // match fields with same parent path
            if (segmentToMatch.endsWith('.')) {
              return key.startsWith(segmentToMatch)
            }
            // match fields with same path
            return key === segmentToMatch
          })

          if (matchingSegment) {
            const pathState = formState[key]
            if ('valid' in pathState && !pathState.valid) {
              errorCount += 1
            }
          }
        })
        setErrorCount(errorCount)
      }
    },
    250,
    [formState, hasSubmitted, fields],
  )

  return null
}
</file>

<file path="convexadmin/ui/src/forms/withCondition/index.tsx">
'use client'
import type { FieldPaths } from '@convexcms/core'
import type { MarkOptional } from 'ts-essentials'

import React from 'react'

import { WatchCondition } from './WatchCondition.js'

export const withCondition = <P extends MarkOptional<FieldPaths, 'indexPath' | 'path'>>(
  Field: React.ComponentType<P>,
): React.FC<P> => {
  const CheckForCondition: React.FC<P> = (props) => {
    const { path } = props

    return (
      <WatchCondition path={path}>
        <Field {...props} />
      </WatchCondition>
    )
  }

  return CheckForCondition
}
</file>

<file path="convexadmin/ui/src/forms/withCondition/WatchCondition.tsx">
'use client'

import type React from 'react'

import { useFormFields } from '../Form/context.js'

export const WatchCondition: React.FC<{
  children: React.ReactNode
  path: string
}> = (props) => {
  const { children, path } = props

  const field = useFormFields(([fields]) => (fields && fields?.[path]) || null)

  const { passesCondition } = field || {}

  if (passesCondition === false) {
    return null
  }

  return children
}
</file>

<file path="convexadmin/ui/src/hooks/useIntersect.ts">
'use client'

import type React from 'react'

import { useEffect, useRef, useState } from 'react'

type Intersect = [
  setNode: React.Dispatch<HTMLElement>,
  entry: IntersectionObserverEntry,
  node: HTMLElement,
]

export const useIntersect = (
  { root = null, rootMargin = '0px', threshold = 0 } = {},
  disable?: boolean,
): Intersect => {
  const [entry, updateEntry] = useState<IntersectionObserverEntry>()
  const [node, setNode] = useState(null)

  const observer = useRef(
    typeof window !== 'undefined' && 'IntersectionObserver' in window && !disable
      ? new window.IntersectionObserver(([ent]) => updateEntry(ent), {
          root,
          rootMargin,
          threshold,
        })
      : null,
  )

  useEffect(() => {
    if (disable) {
      return
    }
    const { current: currentObserver } = observer
    currentObserver.disconnect()

    if (node) {
      currentObserver.observe(node)
    }

    return () => currentObserver.disconnect()
  }, [node, disable])

  return [setNode, entry, node]
}
</file>

<file path="convexadmin/ui/src/providers/Auth/index.tsx">
"use client";

// Mock Auth Provider
import React from "react";

// Mock context value - adjust as needed if you implement actual auth
const mockAuthContext = {
  user: null, // Or a mock user object
  login: () => console.warn("Mock login called"),
  logout: () => console.warn("Mock logout called"),
  refreshCookieAsync: async () =>
    console.warn("Mock refreshCookieAsync called"),
  // Add other functions/state used by Payload's useAuth if needed
};

// Mock useAuth hook
export const useAuth = () => {
  console.warn("Using mock useAuth");
  return mockAuthContext;
};

// Mock Provider component (might not be needed if only hook is used)
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  console.warn("Using mock AuthProvider");
  // You could potentially provide mockAuthContext here if required
  return <>{children}</>;
};
</file>

<file path="convexadmin/ui/src/providers/Config/index.tsx">
"use client";

// Mock Config Provider
import React from "react";

// Mock context value - Should eventually provide AdminConfig
const mockConfigContext = {
  config: null, // Start with null or a default mock config
  // Payload's useConfig also returns getEntityConfig - mock that too if needed
  getEntityConfig: (args: { collectionSlug?: string; globalSlug?: string }) => {
    console.warn("Mock getEntityConfig called with:", args);
    // Return a placeholder structure
    return args.collectionSlug
      ? { slug: args.collectionSlug, fields: {} }
      : args.globalSlug
        ? { slug: args.globalSlug, fields: {} }
        : null;
  },
};

// Mock useConfig hook
export const useConfig = () => {
  console.warn("Using mock useConfig");
  return mockConfigContext;
};

// Mock Provider component (might not be needed if only hook is used)
export const ConfigProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  console.warn("Using mock ConfigProvider");
  // You could provide mockConfigContext here if required
  return <>{children}</>;
};
</file>

<file path="convexadmin/ui/src/providers/DocumentInfo/index.tsx">
"use client";

import type {
  DocumentInfoContextType,
  DocumentInfoProviderProps,
  GenericPermissions,
  GenericUser,
} from "./types";
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";

import type { DocumentPreferences } from "@/convexadmin/src/preferences/types";
import { formatDocTitle } from "@/convexadmin/lib/formatDocTitle";
import { usePreferences } from "../Preferences/index.js";

// Context Definition
const DocumentInfoContext = createContext<DocumentInfoContextType | null>(null);

// Provider Component
export const DocumentInfoProvider: React.FC<DocumentInfoProviderProps> = (
  props,
) => {
  const {
    children,
    collectionSlug,
    documentId: documentIdFromProps,
    id: idFromProps,
    globalSlug,
    initialData: initialDataFromProps,
    docPermissions: docPermissionsFromProps,
    hasSavePermission: hasSavePermissionFromProps,
    hasPublishPermission: hasPublishPermissionFromProps,
    hasPublishedDoc: hasPublishedDocFromProps,
    isLocked: isLockedFromProps,
    currentEditor: currentEditorFromProps,
    lastUpdateTime: lastUpdateTimeFromProps,
    versionCount: versionCountFromProps,
    unpublishedVersionCount: unpublishedVersionCountFromProps,
    mostRecentVersionIsAutosaved: mostRecentVersionIsAutosavedFromProps,
    AfterDocument,
    BeforeFields,
    AfterFields,
  } = props;

  const documentId = documentIdFromProps ?? idFromProps;
  const id = documentId;

  const [docPermissions, setDocPermissions] = useState<GenericPermissions>(
    docPermissionsFromProps ?? null,
  );
  const [hasSavePermission, setHasSavePermission] = useState<boolean>(
    hasSavePermissionFromProps ?? true,
  );
  const [hasPublishPermission, setHasPublishPermission] = useState<boolean>(
    hasPublishPermissionFromProps ?? true,
  );
  const [documentTitle, setDocumentTitle] = useState<string | undefined>(
    undefined,
  );
  const [versionCount, setVersionCount] = useState<number | undefined>(
    versionCountFromProps,
  );
  const [hasPublishedDoc, setHasPublishedDoc] = useState<boolean>(
    hasPublishedDocFromProps ?? false,
  );
  const [unpublishedVersionCount, setUnpublishedVersionCount] = useState<
    number | undefined
  >(unpublishedVersionCountFromProps);
  const [documentIsLocked, setDocumentIsLocked] = useState<boolean>(
    isLockedFromProps ?? false,
  );
  const [currentEditor, setCurrentEditor] = useState<GenericUser>(
    currentEditorFromProps ?? null,
  );
  const [lastUpdateTime, setLastUpdateTime] = useState<number | undefined>(
    lastUpdateTimeFromProps,
  );
  const [savedDocumentData, setSavedDocumentData] = useState<Record<
    string,
    unknown
  > | null>(initialDataFromProps ?? null);
  const [uploadStatus, setUploadStatus] = useState<
    "idle" | "uploading" | "failed"
  >("idle");
  const [mostRecentVersionIsAutosaved, setMostRecentVersionIsAutosaved] =
    useState<boolean | undefined>(mostRecentVersionIsAutosavedFromProps);

  const { getPreference, setPreference } = usePreferences();

  const isEditing = !!documentId;
  const action: "create" | "update" = isEditing ? "update" : "create";
  const isInitializing = false;

  const preferencesKey = useMemo(() => {
    if (globalSlug) {
      return `global-${globalSlug}`;
    }
    if (collectionSlug && documentId) {
      return `collection-${collectionSlug}-${documentId}`;
    }
    return undefined;
  }, [collectionSlug, documentId, globalSlug]);

  useEffect(() => {
    if (savedDocumentData) {
      const title = formatDocTitle({
        data: savedDocumentData,
        fallback: "Untitled",
      });
      setDocumentTitle(title);
    }
  }, [savedDocumentData]);

  const getDocPermissions =
    useCallback(async (): Promise<GenericPermissions> => {
      console.warn("(Mock) getDocPermissions called");
      return docPermissionsFromProps ?? null;
    }, [docPermissionsFromProps]);

  const getDocPreferences = useCallback(async () => {
    if (!preferencesKey) {
      console.warn("(Mock) getDocPreferences: No preferences key available.");
      return undefined;
    }
    return getPreference<DocumentPreferences>(preferencesKey);
  }, [getPreference, preferencesKey]);

  const setDocFieldPreferences = useCallback(
    async (
      path: string,
      fieldPreferences: Partial<DocumentPreferences["fields"][string]>,
    ) => {
      if (!preferencesKey) {
        console.warn("(Mock) setDocFieldPreferences: No preferences key.");
        return;
      }
      const allPreferences = await getDocPreferences();
      if (allPreferences && typeof allPreferences === "object") {
        try {
          await setPreference(preferencesKey, {
            ...allPreferences,
            fields: {
              ...(allPreferences.fields || {}),
              [path]: {
                ...(allPreferences.fields?.[path] || {}),
                ...fieldPreferences,
              },
            },
          });
        } catch (e) {
          console.error("Failed to set document field preferences:", e);
        }
      } else {
        try {
          await setPreference(preferencesKey, {
            fields: {
              [path]: { ...fieldPreferences },
            },
          });
        } catch (e) {
          console.error("Failed to initialize document field preferences:", e);
        }
      }
    },
    [getDocPreferences, preferencesKey, setPreference],
  );

  const incrementVersionCount = useCallback(() => {
    console.warn("(Mock) incrementVersionCount called");
  }, []);

  const unlockDocument = useCallback(
    async (docId: string | number, slug: string) => {
      console.warn(`(Mock) unlockDocument called for ${slug}:${docId}`);
      setDocumentIsLocked(false);
      setCurrentEditor(null);
    },
    [],
  );

  const updateDocumentEditor = useCallback(
    async (
      docId: string | number,
      slug: string,
      user: GenericUser | string | number,
    ) => {
      console.warn(
        `(Mock) updateDocumentEditor called for ${slug}:${docId}`,
        user,
      );
    },
    [],
  );

  const setContextSavedData = useCallback(
    (data: Record<string, unknown> | null) => {
      console.log("(Context) Updating savedDocumentData");
      setSavedDocumentData(data);
      if (data) {
        const title = formatDocTitle({ data, fallback: "Untitled" });
        setDocumentTitle(title);
      } else {
        setDocumentTitle(undefined);
      }
    },
    [],
  );

  const contextValue = useMemo(
    () => ({
      id,
      documentId,
      collectionSlug,
      globalSlug,
      preferencesKey,
      action,
      isEditing,
      isInitializing,
      savedDocumentData,
      title: documentTitle,
      docPermissions,
      hasSavePermission,
      hasPublishPermission,
      documentIsLocked,
      currentEditor,
      lastUpdateTime,
      versionCount,
      unpublishedVersionCount,
      mostRecentVersionIsAutosaved,
      incrementVersionCount,
      uploadStatus,
      getDocPreferences,
      setDocFieldPreferences,
      getDocPermissions,
      unlockDocument,
      updateDocumentEditor,
      updateSavedDocumentData: setContextSavedData,
      setDocumentTitle,
      setCurrentEditor,
      setDocumentIsLocked,
      setDocPermissions,
      setHasSavePermission,
      setHasPublishPermission,
      setLastUpdateTime,
      setHasPublishedDoc,
      setVersionCount,
      setUnpublishedVersionCount,
      setMostRecentVersionIsAutosaved,
      setUploadStatus,
      AfterDocument,
      BeforeFields,
      AfterFields,
    }),
    [
      id,
      documentId,
      collectionSlug,
      globalSlug,
      preferencesKey,
      action,
      isEditing,
      isInitializing,
      savedDocumentData,
      documentTitle,
      docPermissions,
      hasSavePermission,
      hasPublishPermission,
      documentIsLocked,
      currentEditor,
      lastUpdateTime,
      versionCount,
      unpublishedVersionCount,
      mostRecentVersionIsAutosaved,
      incrementVersionCount,
      uploadStatus,
      getDocPreferences,
      setDocFieldPreferences,
      getDocPermissions,
      unlockDocument,
      updateDocumentEditor,
      setContextSavedData,
      setDocumentTitle,
      setCurrentEditor,
      setDocumentIsLocked,
      setDocPermissions,
      setHasSavePermission,
      setHasPublishPermission,
      setLastUpdateTime,
      setHasPublishedDoc,
      setVersionCount,
      setUnpublishedVersionCount,
      setMostRecentVersionIsAutosaved,
      setUploadStatus,
      AfterDocument,
      BeforeFields,
      AfterFields,
    ],
  );

  return (
    <DocumentInfoContext.Provider value={contextValue}>
      {children}
    </DocumentInfoContext.Provider>
  );
};

// Custom hook to access the context
export const useDocumentInfo = (): DocumentInfoContextType => {
  const context = useContext(DocumentInfoContext);
  if (context === null) {
    throw new Error(
      "useDocumentInfo must be used within a DocumentInfoProvider",
    );
  }
  return context;
};
</file>

<file path="convexadmin/ui/src/providers/DocumentInfo/types.ts">
import type { DocumentPreferences as ConvexDocumentPreferences } from "@/convexadmin/src/preferences/types"; // Assuming this path exists
import type { Id } from "@/convex/_generated/dataModel";
import type React from "react";

// Represents a generic user object (replace with actual Clerk/Convex user type if available)
export type GenericUser = {
  id: string | number;
  collection: string; // e.g., 'users'
  // Add other relevant user fields if needed
} | null;

// Represents generic document permissions (replace with actual permission structure)
export type GenericPermissions = Record<string, unknown> | null;

// --- Props for the Provider Component ---
export interface DocumentInfoProviderProps {
  children: React.ReactNode;
  collectionSlug?: string;
  documentId?: Id<any>; // Using Id<any> for flexibility initially
  id?: Id<any>; // Payload uses 'id', mirroring for potential compatibility/easier adaptation
  globalSlug?: string; // For potential future global support

  // Props that might be passed down initially (Payload structure)
  // These might be fetched or managed differently in Convex, review as needed
  initialData?: Record<string, unknown> | null;
  // initialState?: any; // Likely replaced by RHF state in EditView
  docPermissions?: GenericPermissions; // Passed initial permissions
  hasSavePermission?: boolean;
  hasPublishPermission?: boolean;
  hasPublishedDoc?: boolean; // Status of the published version
  isLocked?: boolean; // Initial lock status
  currentEditor?: GenericUser; // Initial editor info
  lastUpdateTime?: number; // Timestamp of last update
  versionCount?: number;
  unpublishedVersionCount?: number;
  mostRecentVersionIsAutosaved?: boolean;

  // Custom Render Components (Slots for UI Injection)
  AfterDocument?: React.ReactNode;
  BeforeFields?: React.ReactNode;
  AfterFields?: React.ReactNode;
}

// --- Context Value Shape ---
export interface DocumentInfoContextType {
  // Identifiers
  id?: Id<any>;
  documentId?: Id<any>; // Explicitly keep both for clarity during transition
  collectionSlug?: string;
  globalSlug?: string;
  preferencesKey?: string; // Key used for storing preferences

  // Status & State
  action: "create" | "update";
  isEditing: boolean;
  isInitializing: boolean; // Tracks initial setup/loading state
  savedDocumentData: Record<string, unknown> | null; // Last known saved state
  title?: string; // Formatted document title

  // Permissions
  docPermissions: GenericPermissions;
  hasSavePermission: boolean;
  hasPublishPermission: boolean;

  // Locking
  documentIsLocked: boolean;
  currentEditor: GenericUser;
  lastUpdateTime?: number; // Timestamp of last update

  // Versioning (Mocked/Simplified for now)
  versionCount?: number;
  unpublishedVersionCount?: number;
  mostRecentVersionIsAutosaved?: boolean;
  incrementVersionCount: () => void;

  // Uploads (Mocked/Simplified for now)
  uploadStatus: "idle" | "uploading" | "failed";

  // Preferences
  getDocPreferences: () => Promise<ConvexDocumentPreferences | undefined>;
  setDocFieldPreferences: (
    path: string,
    fieldPreferences: Partial<ConvexDocumentPreferences["fields"][string]>,
  ) => Promise<void>;

  // Functions / Actions
  getDocPermissions: () => Promise<GenericPermissions>; // Placeholder fetch
  unlockDocument: (docId: string | number, slug: string) => Promise<void>; // Placeholder action
  updateDocumentEditor: (
    docId: string | number,
    slug: string,
    user: GenericUser | string | number,
  ) => Promise<void>; // Placeholder action
  updateSavedDocumentData: (data: Record<string, unknown> | null) => void;

  // Setters exposed by context
  setDocumentTitle: React.Dispatch<React.SetStateAction<string | undefined>>;
  setCurrentEditor: React.Dispatch<React.SetStateAction<GenericUser>>;
  setDocumentIsLocked: React.Dispatch<React.SetStateAction<boolean>>;
  setDocPermissions: React.Dispatch<React.SetStateAction<GenericPermissions>>;
  setHasSavePermission: React.Dispatch<React.SetStateAction<boolean>>;
  setHasPublishPermission: React.Dispatch<React.SetStateAction<boolean>>;
  setLastUpdateTime: React.Dispatch<React.SetStateAction<number | undefined>>;
  setHasPublishedDoc: React.Dispatch<React.SetStateAction<boolean>>;
  setVersionCount: React.Dispatch<React.SetStateAction<number | undefined>>;
  setUnpublishedVersionCount: React.Dispatch<
    React.SetStateAction<number | undefined>
  >;
  setMostRecentVersionIsAutosaved: React.Dispatch<
    React.SetStateAction<boolean | undefined>
  >;
  setUploadStatus: React.Dispatch<
    React.SetStateAction<"idle" | "uploading" | "failed">
  >;

  // Custom Render Component Slots
  AfterDocument?: React.ReactNode;
  BeforeFields?: React.ReactNode;
  AfterFields?: React.ReactNode;
}

// Type guard to check if a value is a GenericUser object
export const isGenericUser = (
  user: GenericUser | string | number,
): user is NonNullable<GenericUser> => {
  return typeof user === "object" && user !== null && "id" in user;
};
</file>

<file path="convexadmin/ui/src/providers/DocumentInfo/useGetDocPermissions.ts">
// Mock useGetDocPermissions hook

export const useGetDocPermissions = () => {
  console.warn("Using mock useGetDocPermissions");
  // Return a mock function that resolves with basic permissions
  // Adapt the return type if a more specific mock is needed
  return async (data?: unknown) => {
    console.warn("Mock getDocPermissions called", data);
    return {
      docPermissions: null, // Or mock permissions object
      draftPermissions: null,
      publishPermissions: null,
    };
  };
};
</file>

<file path="convexadmin/ui/src/providers/DocumentInfo/useGetDocPermissions.tsx">
import type { Data, SanitizedDocumentPermissions, SanitizedPermissions } from '@convexcms/core'

import * as qs from 'qs-esm'
import React from 'react'

import { hasSavePermission as getHasSavePermission } from '../../utilities/hasSavePermission.js'
import { isEditing as getIsEditing } from '../../utilities/isEditing.js'

export const useGetDocPermissions = ({
  id,
  api,
  collectionSlug,
  globalSlug,
  i18n,
  locale,
  permissions,
  serverURL,
  setDocPermissions,
  setHasPublishPermission,
  setHasSavePermission,
}: {
  api: string
  collectionSlug: string
  globalSlug: string
  i18n: any
  id: string
  locale: string
  permissions: SanitizedPermissions
  serverURL: string
  setDocPermissions: React.Dispatch<React.SetStateAction<SanitizedDocumentPermissions>>
  setHasPublishPermission: React.Dispatch<React.SetStateAction<boolean>>
  setHasSavePermission: React.Dispatch<React.SetStateAction<boolean>>
}) =>
  React.useCallback(
    async (data: Data) => {
      const params = {
        locale: locale || undefined,
      }

      const idToUse = data?.id || id
      const newIsEditing = getIsEditing({ id: idToUse, collectionSlug, globalSlug })

      if (newIsEditing) {
        const docAccessURL = collectionSlug
          ? `/${collectionSlug}/access/${idToUse}`
          : globalSlug
            ? `/globals/${globalSlug}/access`
            : null

        if (docAccessURL) {
          const res = await fetch(`${serverURL}${api}${docAccessURL}?${qs.stringify(params)}`, {
            body: JSON.stringify({
              ...(data || {}),
              _status: 'draft',
            }),
            credentials: 'include',
            headers: {
              'Accept-Language': i18n.language,
              'Content-Type': 'application/json',
            },
            method: 'post',
          })

          const json: SanitizedDocumentPermissions = await res.json()

          const publishedAccessJSON = await fetch(
            `${serverURL}${api}${docAccessURL}?${qs.stringify(params)}`,
            {
              body: JSON.stringify({
                ...(data || {}),
                _status: 'published',
              }),
              credentials: 'include',
              headers: {
                'Accept-Language': i18n.language,
                'Content-Type': 'application/json',
              },
              method: 'POST',
            },
          ).then((res) => res.json())

          setDocPermissions(json)

          setHasSavePermission(
            getHasSavePermission({
              collectionSlug,
              docPermissions: json,
              globalSlug,
              isEditing: newIsEditing,
            }),
          )

          setHasPublishPermission(publishedAccessJSON?.update)
        }
      } else {
        // when creating new documents, there is no permissions saved for this document yet
        // use the generic entity permissions instead
        const newDocPermissions = collectionSlug
          ? permissions?.collections?.[collectionSlug]
          : permissions?.globals?.[globalSlug]

        setDocPermissions(newDocPermissions)

        setHasSavePermission(
          getHasSavePermission({
            collectionSlug,
            docPermissions: newDocPermissions,
            globalSlug,
            isEditing: newIsEditing,
          }),
        )
      }
    },
    [serverURL, api, id, permissions, i18n.language, locale, collectionSlug, globalSlug],
  )
</file>

<file path="convexadmin/ui/src/providers/Locale/index.tsx">
"use client";

// Mock Locale Provider

// Mock useLocale hook
export const useLocale = () => {
  console.warn("Using mock useLocale");
  // Return a default locale or necessary mock state
  return "en"; // Default to English
};

// Mock useLocaleLoading hook (if used separately)
export const useLocaleLoading = () => {
  console.warn("Using mock useLocaleLoading");
  return false; // Default to not loading
};

// Mock Provider component (might not be needed)
import React from "react";
export const LocaleProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  console.warn("Using mock LocaleProvider");
  return <>{children}</>;
};
</file>

<file path="convexadmin/ui/src/providers/Operation/index.tsx">
'use client'
import React, { createContext, use } from 'react'

export const OperationContext = createContext('' as Operation)

export const OperationProvider: React.FC<{ children: React.ReactNode; operation: Operation }> = ({
  children,
  operation,
}) => <OperationContext value={operation}>{children}</OperationContext>

export type Operation = 'create' | 'update'

export const useOperation = (): Operation | undefined => use(OperationContext)
</file>

<file path="convexadmin/ui/src/providers/Preferences/index.tsx">
"use client";

import React, {
  createContext,
  use,
  useCallback,
  useEffect,
  useRef,
} from "react";

import { deepMergeSimple } from "../../utilities/deepMerge";
import { dequal } from "dequal/lite"; // lite: no need for Map and Set support
import { requests } from "../../utilities/api.js";
import { useAuth } from "../Auth/index.js";
import { useConfig } from "../Config/index.js";
import { useTranslation } from "../../providers/Translation/index.js";

type PreferencesContext = {
  getPreference: <T = any>(key: string) => Promise<T>;
  /**
   * @param key - a string identifier for the property being set
   * @param value - preference data to store
   * @param merge - when true will combine the existing preference object batch the change into one request for objects, default = false
   */
  setPreference: <T = any>(
    key: string,
    value: T,
    merge?: boolean,
  ) => Promise<void>;
};

const Context = createContext({} as PreferencesContext);

const requestOptions = (value, language) => ({
  body: JSON.stringify({ value }),
  headers: {
    "Accept-Language": language,
    "Content-Type": "application/json",
  },
});

export const PreferencesProvider: React.FC<{ children?: React.ReactNode }> = ({
  children,
}) => {
  const contextRef = useRef({} as PreferencesContext);
  const preferencesRef = useRef({});
  const pendingUpdate = useRef({});
  const { config } = useConfig();
  const { user } = useAuth();
  const { i18n } = useTranslation();

  const {
    routes: { api },
    serverURL,
  } = config;

  useEffect(() => {
    if (!user) {
      // clear preferences between users
      preferencesRef.current = {};
    }
  }, [user]);

  const getPreference = useCallback(
    async <T = any,>(key: string): Promise<T> => {
      const prefs = preferencesRef.current;

      if (typeof prefs[key] !== "undefined") {
        return prefs[key];
      }

      const promise = new Promise((resolve: (value: T) => void) => {
        void (async () => {
          const request = await requests.get(
            `${serverURL}${api}/payload-preferences/${key}`,
            {
              headers: {
                "Accept-Language": i18n.language,
              },
            },
          );

          let value = null;

          if (request.status === 200) {
            const preference = await request.json();
            value = preference.value;
          }

          preferencesRef.current[key] = value;

          resolve(value);
        })();
      });

      prefs[key] = promise;

      return promise;
    },
    [i18n.language, api, preferencesRef, serverURL],
  );

  const setPreference = useCallback(
    async (key: string, value: unknown, merge = false): Promise<void> => {
      if (merge === false) {
        preferencesRef.current[key] = value;

        await requests.post(
          `${serverURL}${api}/payload-preferences/${key}`,
          requestOptions(value, i18n.language),
        );

        return;
      }

      let newValue = value;
      const currentPreference = await getPreference(key);

      // handle value objects where multiple values can be set under one key
      if (
        typeof value === "object" &&
        typeof currentPreference === "object" &&
        typeof newValue === "object"
      ) {
        // merge the value with any existing preference for the key
        if (currentPreference) {
          newValue = deepMergeSimple(currentPreference, newValue);
        }

        if (dequal(newValue, currentPreference)) {
          return;
        }

        // add the requested changes to a pendingUpdate batch for the key
        pendingUpdate.current[key] = {
          ...pendingUpdate.current[key],
          ...(newValue as Record<string, unknown>),
        };
      } else {
        if (newValue === currentPreference) {
          return;
        }

        pendingUpdate.current[key] = newValue;
      }

      const updatePreference = async () => {
        // compare the value stored in context before sending to eliminate duplicate requests
        if (dequal(pendingUpdate.current[key], preferencesRef.current[key])) {
          return;
        }

        // preference set in context here to prevent other updatePreference at the same time
        preferencesRef.current[key] = pendingUpdate.current[key];

        await requests.post(
          `${serverURL}${api}/payload-preferences/${key}`,
          requestOptions(preferencesRef.current[key], i18n.language),
        );

        // reset any changes for this key after sending the request
        delete pendingUpdate.current[key];
      };

      // use timeout to allow multiple changes of different values using the same key in one request
      setTimeout(() => {
        void updatePreference();
      });
    },
    [api, getPreference, i18n.language, pendingUpdate, serverURL],
  );

  contextRef.current.getPreference = getPreference;
  contextRef.current.setPreference = setPreference;

  return <Context value={contextRef.current}>{children}</Context>;
};

export const usePreferences = (): PreferencesContext => use(Context);
</file>

<file path="convexadmin/ui/src/providers/Translation/index.tsx">
"use client";

// Mock Translation Provider

// Mock t function
const mockT = (key: string, options?: unknown): string => {
  console.warn(`Mock translation requested for key: ${key}`, options);
  return key; // Return the key itself as the translation
};

// Mock useTranslation hook
export const useTranslation = () => {
  console.warn("Using mock useTranslation");
  return { t: mockT };
};

// Mock Provider component (might not be needed)
import React from "react";
export const TranslationProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  console.warn("Using mock TranslationProvider");
  return <>{children}</>;
};
</file>

<file path="convexadmin/ui/src/providers/UploadEdits/index.tsx">
'use client'
import type { UploadEdits } from '@convexcms/core'

import React from 'react'

export type UploadEditsContext = {
  resetUploadEdits: () => void
  updateUploadEdits: (edits: UploadEdits) => void
  uploadEdits: UploadEdits
}

const Context = React.createContext<UploadEditsContext>({
  resetUploadEdits: undefined,
  updateUploadEdits: undefined,
  uploadEdits: undefined,
})

export const UploadEditsProvider = ({ children }) => {
  const [uploadEdits, setUploadEdits] = React.useState<UploadEdits>(undefined)

  const resetUploadEdits = () => {
    setUploadEdits({})
  }

  const updateUploadEdits = (edits: UploadEdits) => {
    setUploadEdits((prevEdits) => ({
      ...(prevEdits || {}),
      ...(edits || {}),
    }))
  }

  return <Context value={{ resetUploadEdits, updateUploadEdits, uploadEdits }}>{children}</Context>
}

export const useUploadEdits = (): UploadEditsContext => React.use(Context)
</file>

<file path="convexadmin/ui/src/providers/NavProvider.tsx">
"use client";

import React, { createContext, useContext, useMemo, useState } from "react";

type NavContextType = {
  isNavOpen: boolean;
  setIsNavOpen: React.Dispatch<React.SetStateAction<boolean>>;
};

const NavContext = createContext<NavContextType | null>(null);

export const NavProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [isNavOpen, setIsNavOpen] = useState(true); // Default to true
  const contextValue = useMemo(
    () => ({ isNavOpen, setIsNavOpen }),
    [isNavOpen],
  );

  return (
    <NavContext.Provider value={contextValue}>{children}</NavContext.Provider>
  );
};

export const useNav = (): NavContextType => {
  const context = useContext(NavContext);
  if (context === null) {
    throw new Error("useNav must be used within a NavProvider");
  }
  return context;
};
</file>

<file path="convexadmin/ui/src/utilities/formatDocTitle/index.ts">
// Mock formatDocTitle utility

// Payload uses this to format titles in nav/breadcrumbs etc.
export const formatDocTitle = (args: {
  doc: Record<string, unknown> | null;
  collectionConfig?: unknown;
  fallback?: string;
  t?: unknown;
}) => {
  console.warn("Using mock formatDocTitle");
  // Return a simple fallback title
  const docId = typeof args.doc?._id === "string" ? args.doc._id : undefined;
  return args.fallback || docId || "Untitled Document";
};
</file>

<file path="convexadmin/ui/src/utilities/api.ts">
// Mock API utilities

// Mock requests object (Payload uses this for internal API calls)
export const requests = {
  delete: async (url: string, options?: unknown) => {
    console.warn(`Mock DELETE request to: ${url}`, options);
    return Promise.resolve({ ok: true, json: () => Promise.resolve({}) });
  },
  get: async (url: string, options?: unknown) => {
    console.warn(`Mock GET request to: ${url}`, options);
    return Promise.resolve({ ok: true, json: () => Promise.resolve({}) });
  },
  post: async (url: string, options?: unknown) => {
    console.warn(`Mock POST request to: ${url}`, options);
    return Promise.resolve({ ok: true, json: () => Promise.resolve({}) });
  },
  patch: async (url: string, options?: unknown) => {
    console.warn(`Mock PATCH request to: ${url}`, options);
    return Promise.resolve({ ok: true, json: () => Promise.resolve({}) });
  },
};
</file>

<file path="convexadmin/ui/src/utilities/deepMerge.ts">
/**
 * Very simple, but fast deepMerge implementation. Only deepMerges objects, not arrays and clones everything.
 * Do not use this if your object contains any complex objects like React Components, or if you would like to combine Arrays.
 * If you only have simple objects and need a fast deepMerge, this is the function for you.
 *
 * obj2 takes precedence over obj1 - thus if obj2 has a key that obj1 also has, obj2's value will be used.
 *
 * @param obj1 base object
 * @param obj2 object to merge "into" obj1
 */
export function deepMergeSimple<T = object>(obj1: object, obj2: object): T {
  const output = { ...obj1 }

  for (const key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      if (typeof obj2[key] === 'object' && !Array.isArray(obj2[key]) && obj1[key]) {
        output[key] = deepMergeSimple(obj1[key], obj2[key])
      } else {
        output[key] = obj2[key]
      }
    }
  }

  return output as T
}
</file>

<file path="convexadmin/ui/src/utilities/fieldIsHiddenOrDisabled.ts">
// Mock for fieldIsHiddenOrDisabled

export const fieldIsHiddenOrDisabled = (
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  field: unknown,
): boolean => {
  console.warn("Using mock fieldIsHiddenOrDisabled, returning false.");
  // In a real scenario, check field.admin?.hidden or field.admin?.disabled
  return false;
};
</file>

<file path="convexadmin/ui/src/utilities/fieldIsSidebar.ts">
// Mock for Payload's fieldIsSidebar utility

// In Payload, this checks field metadata to see if it belongs in the sidebar.
// For our simplified version, we can assume fields don't have sidebar placement yet.
export const fieldIsSidebar = (
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  field: unknown, // Use unknown and disable unused var warning
): boolean => {
  console.warn("Using mock fieldIsSidebar, returning false.");
  return false;
};
</file>

<file path="convexadmin/ui/src/utilities/getFieldPaths.ts">
// Mock for getFieldPaths

interface GetFieldPathsArgs {
  field: { name?: string; [key: string]: unknown };
  index: number;
  parentIndexPath: string;
  parentPath: string;
  parentSchemaPath: string;
}

export const getFieldPaths = ({
  field,
  index,
  parentIndexPath,
  parentPath,
  parentSchemaPath,
}: GetFieldPathsArgs) => {
  console.warn("Using mock getFieldPaths");
  // Simple path generation, may need adjustment for nested fields/arrays
  const path = parentPath
    ? `${parentPath}.${field.name || index}`
    : field.name || String(index);
  const indexPath = parentIndexPath
    ? `${parentIndexPath}.${index}`
    : String(index);
  const schemaPath = parentSchemaPath
    ? `${parentSchemaPath}.${field.name || index}`
    : field.name || String(index);

  return { indexPath, path, schemaPath };
};
</file>

<file path="convexadmin/ui/src/utilities/getFieldPermissions.ts">
// Mock for getFieldPermissions

interface GetFieldPermissionsArgs {
  field: unknown;
  operation: "create" | "read" | "update" | "delete";
  parentName?: string;
  permissions: unknown; // Mock permission structure
}

// Return type reflects Payload's structure, but values are mocked
interface MockFieldPermissions {
  operation: boolean; // Can the user perform the current operation on this field?
  permissions: unknown; // Nested permissions (if any)
  read: boolean; // Can the user read this field?
}

export const getFieldPermissions = ({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  field,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  operation,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  parentName,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  permissions,
}: GetFieldPermissionsArgs): MockFieldPermissions => {
  console.warn("Using mock getFieldPermissions");
  // Default to allowing all operations for the mock
  return {
    operation: true,
    permissions: null, // No nested permissions in mock
    read: true,
  };
};
</file>

<file path="convexadmin/constants.ts">
/**
 * The standard URL path segment used before a collection slug.
 * e.g., /admin/collections/posts
 */
export const COLLECTION_PATH_SEGMENT = "collections";

/**
 * The standard URL path segment used before a global slug.
 * e.g., /admin/globals/settings
 */
export const GLOBAL_PATH_SEGMENT = "globals";

// Add other constants as needed (e.g., for actions like 'create', 'edit')
export const ACTION_CREATE = "create";
export const ACTION_EDIT = "edit";
</file>

<file path="convexadmin/puck.config.tsx">
import { ColumnConfigField } from "./components/puck/fields/ColumnConfigField";
import type { Config } from "@measured/puck";
import { HeadingBlock } from "./components/puck/HeadingBlock";
import type { HeadingBlockProps } from "./components/puck/HeadingBlock";
import { ItemLoop } from "./components/puck/ItemLoop";
import type { ItemLoopProps } from "./components/puck/ItemLoop";
import { SliderField } from "./components/puck/fields/SliderField";

type PuckProps = {
  HeadingBlock: HeadingBlockProps;
  ItemLoop: ItemLoopProps;
};

export const puckConfig: Config<PuckProps> = {
  components: {
    HeadingBlock: {
      fields: {
        children: {
          type: "text",
        },
        backgroundColor: {
          type: "text",
          label: "BG Color",
        },
      },
      render: ({ children, backgroundColor }) => (
        <div style={{ backgroundColor: backgroundColor }}>
          <HeadingBlock>{children}</HeadingBlock>
        </div>
      ),
      defaultProps: {
        children: "Default Heading",
        backgroundColor: "",
      },
    },
    ItemLoop: {
      fields: {
        tableName: {
          type: "select",
          label: "Data Source (Table)",
          options: [
            { label: "Todos", value: "todos" },
            { label: "Posts", value: "posts" },
            { label: "Plugins", value: "plugins" },
            { label: "Puck Pages", value: "puckPages" },
          ],
        },
        displayMode: {
          type: "select",
          options: [
            { label: "Grid", value: "grid" },
            { label: "Table", value: "table" },
          ],
        },
        gridColumns: {
          label: "Grid Columns",
          type: "number",
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore Property 'render' does not exist on type 'NumberField', but Puck uses it.
          render: SliderField,
          min: 1,
          max: 6,
        },
        spacing: {
          label: "Spacing",
          type: "select",
          options: [
            { label: "Small", value: "sm" },
            { label: "Medium", value: "md" },
            { label: "Large", value: "lg" },
          ],
        },
        backgroundColor: {
          type: "text",
          label: "BG Color",
        },
        columnConfig: {
          label: "Column Visibility & Order",
          type: "custom",
          render: ColumnConfigField,
        },
      },
      defaultProps: {
        tableName: "posts",
        displayMode: "grid",
        gridColumns: 3,
        spacing: "md",
        backgroundColor: "",
        columnConfig: [],
      },
      render: (props: ItemLoopProps) => <ItemLoop {...props} />,
    },
  },
};
</file>

<file path="convexadmin/types.ts">
// convexadmin/types.ts

export interface AdminCollectionField {
  label: string;
  type: string;
  // Add other admin-specific properties here later
  // e.g., description?: string; ui?: string; position?: 'main' | 'sidebar';
}

export interface AdminCollectionConfig {
  label: string;
  pluralLabel: string;
  fields: Record<string, AdminCollectionField>;
  // Add list/sort config later if needed
}

export interface AdminConfig {
  collections: Record<string, AdminCollectionConfig>;
}
</file>

<file path="docs/convex_native_payload_inspired.md">
# Building a Payload-Inspired System Natively on Convex

This document details the architecture for building a custom content management system inspired by Payload CMS's developer experience but built entirely on Convex, leveraging its unique strengths like real-time data synchronization and integrated backend functions.

## Core Architecture

### 1. Schema & Configuration

The system is built around two key files:

- **`convex/schema.ts`:** The primary source of truth for data structure.
- **`convexAppConfig.ts`:** Supplementary configuration for Admin UI generation.

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/schema";
import { v } from "convex/values";

export default defineSchema({
  posts: defineTable({
    title: v.string(),
    slug: v.string(),
    content: v.string(),
    status: v.union(v.literal("draft"), v.literal("published")),
    author: v.id("users"),
    tags: v.array(v.string()),
    createdAt: v.string(),
    updatedAt: v.string(),
  }),
  users: defineTable({
    name: v.string(),
    email: v.string(),
    role: v.union(v.literal("admin"), v.literal("editor")),
  }),
});

// convexAppConfig.ts
export const config = {
  collections: {
    posts: {
      label: "Blog Posts",
      pluralLabel: "Blog Posts",
      fields: {
        title: {
          label: "Post Title",
          admin: { useAsTitle: true },
        },
        slug: {
          admin: { position: "sidebar" },
        },
        content: {
          admin: { ui: "richText" },
        },
        status: {
          admin: {
            position: "sidebar",
            ui: "select",
          },
        },
      },
      list: {
        defaultColumns: ["title", "status", "author", "updatedAt"],
        defaultSort: { field: "updatedAt", order: "desc" },
      },
    },
    // ... other collections
  },
};
```

### 2. Schema Manifest Generation

A build step that analyzes `convex/schema.ts` and `convexAppConfig.ts` to generate a manifest for the Admin UI:

```typescript
// scripts/generateAdminManifest.ts
import { Project } from "ts-morph";
import { writeFileSync } from "fs";

async function generateManifest() {
  const project = new Project();
  const sourceFile = project.addSourceFileAtPath("./convex/schema.ts");

  // Parse schema using TypeScript Compiler API
  const tables = parseConvexSchema(sourceFile);

  // Merge with UI config
  const manifest = mergeWithConfig(tables, config);

  // Output manifest for Admin UI consumption
  writeFileSync(
    "./app/_generated/admin-manifest.json",
    JSON.stringify(manifest, null, 2)
  );
}

generateManifest();
```

### 3. Admin UI Generation (Next.js)

The dynamic Admin UI is implemented as a catch-all route in Next.js:

```typescript
// app/admin/[[...segments]]/page.tsx
import { Suspense } from "react";
import { notFound } from "next/navigation";
import adminManifest from "@/_generated/admin-manifest.json";
import { AdminLayout } from "@/components/admin/Layout";
import { ListView, EditView, CreateView } from "@/components/admin/views";

export default async function AdminPage({ params: { segments = [] } }) {
  const [collection, action, id] = segments;

  if (!collection && !action) {
    return <AdminDashboard />;
  }

  const collectionConfig = adminManifest.collections[collection];
  if (!collectionConfig) {
    return notFound();
  }

  // Determine view based on action
  const View = {
    undefined: ListView,
    edit: EditView,
    new: CreateView,
  }[action];

  return (
    <AdminLayout>
      <Suspense fallback={<Loading />}>
        <View collection={collection} config={collectionConfig} id={id} />
      </Suspense>
    </AdminLayout>
  );
}
```

### 4. Core Components

#### Dynamic Form Generation

```typescript
// components/admin/DynamicForm.tsx
import { useForm } from "react-hook-form";
import { useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { FieldComponents } from "./fields";

export function DynamicForm({ collection, config, initialData }) {
  const { register, handleSubmit } = useForm({
    defaultValues: initialData,
  });

  const save = useMutation(api[collection].update);

  return (
    <form onSubmit={handleSubmit((data) => save({ ...data }))}>
      {Object.entries(config.fields).map(([name, field]) => {
        const Component = FieldComponents[field.type];
        return (
          <Component
            key={name}
            name={name}
            config={field}
            register={register}
          />
        );
      })}
    </form>
  );
}
```

#### Field Components

```typescript
// components/admin/fields/index.tsx
import { RichTextEditor } from "./RichText";
import { RelationshipField } from "./Relationship";
// ... other field components

export const FieldComponents = {
  string: TextField,
  number: NumberField,
  boolean: CheckboxField,
  id: RelationshipField,
  richText: RichTextEditor,
  // ... map other Convex types to components
};
```

### 5. Convex Backend Functions

```typescript
// convex/posts.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const list = query({
  args: {
    skip: v.optional(v.number()),
    limit: v.optional(v.number()),
    sort: v.optional(
      v.object({
        field: v.string(),
        order: v.union(v.literal("asc"), v.literal("desc")),
      })
    ),
  },
  handler: async (ctx, args) => {
    const { skip = 0, limit = 50, sort } = args;

    let query = ctx.db.query("posts");

    if (sort) {
      query = query.order(sort.field, sort.order);
    }

    return query.skip(skip).take(limit);
  },
});

export const update = mutation({
  args: {
    id: v.id("posts"),
    data: v.object({
      title: v.optional(v.string()),
      content: v.optional(v.string()),
      // ... other fields
    }),
  },
  handler: async (ctx, args) => {
    const { id, data } = args;
    return ctx.db.patch(id, {
      ...data,
      updatedAt: new Date().toISOString(),
    });
  },
});
```

## Key Features & Benefits

1.  **Real-Time by Default:**

    - Admin UI automatically updates when data changes via `useQuery`.
    - Multiple editors see changes instantly.
    - No need for manual refresh or webhook-based invalidation.

2.  **Type Safety:**

    - End-to-end type safety from schema to UI.
    - Auto-generated types for all operations.
    - TypeScript validation during development.

3.  **Simplified Architecture:**

    - No separate backend process - Convex handles all data operations.
    - Direct integration with Next.js/React via Convex client.
    - Clean separation between data layer (Convex) and UI generation (Next.js).

4.  **Performance:**
    - No unnecessary API calls or data transformation.
    - Efficient real-time updates via Convex's WebSocket connection.
    - Server Components for initial render performance.

## Development Workflow

1.  **Define Schema:**

    - Create/update tables in `convex/schema.ts`.
    - Add UI hints in `convexAppConfig.ts`.

2.  **Generate Manifest:**

    - Run build script to analyze schema and generate Admin UI manifest.
    - Manifest provides type-safe interface between Convex and Admin UI.

3.  **Implement Backend Logic:**

    - Create Convex functions for specific operations.
    - Implement access control, validation, hooks within Convex functions.

4.  **Build UI Components:**
    - Create/customize field components as needed.
    - Implement special views or functionality.
    - Everything uses Convex hooks (`useQuery`, `useMutation`) for data interaction.

## Limitations & Considerations

- **Development Effort:** Significant initial investment to build the Admin UI generator and core components.
- **Complex Fields:** Implementing sophisticated field types (like Payload's Blocks) requires careful design and substantial UI work.
- **Feature Parity:** Some Payload features (like sophisticated versioning) might need different approaches in Convex.
- **Schema Changes:** Need careful handling of schema updates and corresponding UI manifest regeneration.

## Future Enhancements

- **Plugin System:** Allow extending the system with custom field types, views, or behaviors.
- **Versioning:** Implement document versioning using additional Convex tables.
- **Preview:** Add live preview capabilities leveraging Convex's real-time features.
- **Import/Export:** Build tools for data migration and backup.
- **Workflow:** Add publishing workflows, approvals, etc.

This architecture provides a foundation for building a modern, real-time-first content management system that leverages Convex's strengths while providing a familiar, Payload-inspired developer experience.
</file>

<file path="docs/repomix-output-payloadcms-payload.xml">
This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/payload
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  payload/
    src/
      admin/
        elements/
          Cell.ts
          DatePicker.ts
          Nav.ts
          PreviewButton.ts
          PublishButton.ts
          SaveButton.ts
          SaveDraftButton.ts
          Table.ts
          Upload.ts
          WithServerSideProps.ts
        fields/
          Array.ts
          Blocks.ts
          Checkbox.ts
          Code.ts
          Collapsible.ts
          Date.ts
          Email.ts
          Group.ts
          Hidden.ts
          Join.ts
          JSON.ts
          Number.ts
          Point.ts
          Radio.ts
          Relationship.ts
          RichText.ts
          Row.ts
          Select.ts
          Tabs.ts
          Text.ts
          Textarea.ts
          UI.ts
          Upload.ts
        forms/
          Description.ts
          Diff.ts
          Error.ts
          Field.ts
          Form.ts
          Label.ts
          RowLabel.ts
        functions/
          index.ts
        views/
          document.ts
          index.ts
          list.ts
        LanguageOptions.ts
        RichText.ts
        types.ts
      assets/
        images/
          generic-block-image.svg
        assets.d.ts
      auth/
        baseFields/
          accountLock.ts
          apiKey.ts
          auth.ts
          email.ts
          username.ts
          verification.ts
        endpoints/
          access.ts
          forgotPassword.ts
          index.ts
          init.ts
          login.ts
          logout.ts
          me.ts
          refresh.ts
          registerFirstUser.ts
          resetPassword.ts
          unlock.ts
          verifyEmail.ts
        operations/
          local/
            auth.ts
            forgotPassword.ts
            index.ts
            login.ts
            resetPassword.ts
            unlock.ts
            verifyEmail.ts
          access.ts
          auth.ts
          forgotPassword.ts
          init.ts
          login.ts
          logout.ts
          me.ts
          refresh.ts
          registerFirstUser.ts
          resetPassword.ts
          unlock.ts
          verifyEmail.ts
        strategies/
          local/
            authenticate.ts
            generatePasswordSaltHash.ts
            incrementLoginAttempts.ts
            register.ts
            resetLoginAttempts.ts
          apiKey.ts
          jwt.ts
        cookies.ts
        crypto.ts
        defaultAccess.ts
        defaultUser.ts
        ensureUsernameOrEmail.ts
        executeAccess.ts
        executeAuthStrategies.ts
        extractAccessFromPermission.ts
        extractJWT.ts
        getAccessResults.ts
        getAuthFields.ts
        getFieldsToSign.ts
        getLoginOptions.ts
        index.ts
        isLocked.ts
        jwt.ts
        sendVerificationEmail.ts
        types.ts
      bin/
        generateImportMap/
          utilities/
            addPayloadComponentToImportMap.ts
            getFromImportMap.ts
            getImportMapToBaseDirPath.ts
            parsePayloadComponent.ts
            resolveImportMapFilePath.ts
          generateImportMap.spec.ts
          index.ts
          iterateCollections.ts
          iterateConfig.ts
          iterateFields.ts
          iterateGlobals.ts
        generateTypes.ts
        index.ts
        info.ts
        loadEnv.ts
        migrate.ts
      collections/
        config/
          build.ts
          client.ts
          defaults.ts
          reservedFieldNames.spec.ts
          reservedFieldNames.ts
          sanitize.ts
          sanitizeCompoundIndexes.ts
          types.ts
          useAsTitle.spec.ts
          useAsTitle.ts
        endpoints/
          count.ts
          create.ts
          delete.ts
          deleteByID.ts
          docAccess.ts
          duplicate.ts
          find.ts
          findByID.ts
          findVersionByID.ts
          findVersions.ts
          index.ts
          preview.ts
          restoreVersion.ts
          update.ts
          updateByID.ts
        operations/
          local/
            count.ts
            countVersions.ts
            create.ts
            delete.ts
            duplicate.ts
            find.ts
            findByID.ts
            findVersionByID.ts
            findVersions.ts
            index.ts
            restoreVersion.ts
            update.ts
          utilities/
            update.ts
          count.ts
          countVersions.ts
          create.ts
          delete.ts
          deleteByID.ts
          docAccess.ts
          duplicate.ts
          find.ts
          findByID.ts
          findVersionByID.ts
          findVersions.ts
          restoreVersion.ts
          update.ts
          updateByID.ts
          utils.ts
        dataloader.ts
      config/
        orderable/
          fractional-indexing.js
          index.ts
        build.ts
        client.ts
        defaults.ts
        find.ts
        sanitize.ts
        types.ts
      database/
        migrations/
          createMigration.ts
          getMigrations.ts
          getPredefinedMigration.ts
          migrate.ts
          migrateDown.ts
          migrateRefresh.ts
          migrateReset.ts
          migrateStatus.ts
          migrationsCollection.ts
          migrationTemplate.ts
          readMigrationFiles.ts
          writeMigrationIndex.ts
        queryValidation/
          types.ts
          validateQueryPaths.ts
          validateSearchParams.ts
        combineQueries.ts
        createDatabaseAdapter.ts
        defaultBeginTransaction.ts
        defaultUpdateJobs.ts
        flattenWhereToOperators.ts
        getLocalizedPaths.ts
        sanitizeJoinQuery.ts
        types.ts
      duplicateDocument/
        index.ts
      email/
        consoleEmailAdapter.ts
        defaults.ts
        getStringifiedToAddress.ts
        sendEmail.ts
        types.ts
      errors/
        APIError.ts
        AuthenticationError.ts
        DuplicateCollection.ts
        DuplicateFieldName.ts
        DuplicateGlobal.ts
        ErrorDeletingFile.ts
        FileRetrievalError.ts
        FileUploadError.ts
        Forbidden.ts
        index.ts
        InvalidConfiguration.ts
        InvalidFieldJoin.ts
        InvalidFieldName.ts
        InvalidFieldRelationship.ts
        InvalidSchema.ts
        Locked.ts
        LockedAuth.ts
        MissingCollectionLabel.ts
        MissingEditorProp.ts
        MissingFieldInputOptions.ts
        MissingFieldType.ts
        MissingFile.ts
        NotFound.ts
        QueryError.ts
        ReservedFieldName.ts
        TimestampsRequired.ts
        types.ts
        UnauthorizedError.ts
        UnverifiedEmail.ts
        ValidationError.ts
      exports/
        i18n/
          ar.ts
          az.ts
          bg.ts
          ca.ts
          cs.ts
          da.ts
          de.ts
          en.ts
          es.ts
          et.ts
          fa.ts
          fr.ts
          he.ts
          hr.ts
          hu.ts
          hy.ts
          it.ts
          ja.ts
          ko.ts
          lt.ts
          my.ts
          nb.ts
          nl.ts
          pl.ts
          pt.ts
          ro.ts
          rs.ts
          rsLatin.ts
          ru.ts
          sl.ts
          sv.ts
          th.ts
          tr.ts
          uk.ts
          vi.ts
          zh.ts
          zhTw.ts
        node.ts
        README.md
        shared.ts
      fields/
        baseFields/
          timezone/
            baseField.ts
            defaultTimezones.ts
          baseBlockFields.ts
          baseIDField.ts
        config/
          client.ts
          sanitize.spec.ts
          sanitize.ts
          sanitizeJoinField.ts
          types.ts
        hooks/
          afterChange/
            index.ts
            promise.ts
            traverseFields.ts
          afterRead/
            index.ts
            promise.ts
            relationshipPopulationPromise.ts
            traverseFields.ts
          beforeChange/
            cloneDataFromOriginalDoc.ts
            getExistingRowDoc.ts
            index.ts
            promise.ts
            traverseFields.ts
          beforeDuplicate/
            index.ts
            promise.ts
            traverseFields.ts
          beforeValidate/
            getFallbackValue.ts
            index.ts
            promise.ts
            traverseFields.ts
        getDefaultValue.ts
        getFieldPaths.ts
        mergeBaseFields.ts
        setDefaultBeforeDuplicate.ts
        sortableFieldTypes.ts
        validations.spec.ts
        validations.ts
      globals/
        config/
          client.ts
          sanitize.ts
          types.ts
        endpoints/
          docAccess.ts
          findOne.ts
          findVersionByID.ts
          findVersions.ts
          index.ts
          preview.ts
          restoreVersion.ts
          update.ts
        operations/
          local/
            countGlobalVersions.ts
            findOne.ts
            findVersionByID.ts
            findVersions.ts
            index.ts
            restoreVersion.ts
            update.ts
          countGlobalVersions.ts
          docAccess.ts
          findOne.ts
          findVersionByID.ts
          findVersions.ts
          restoreVersion.ts
          update.ts
      locked-documents/
        config.ts
      preferences/
        operations/
          delete.ts
          findOne.ts
          update.ts
        requestHandlers/
          delete.ts
          findOne.ts
          update.ts
        config.ts
        deleteUserPreferences.ts
        types.ts
      query-presets/
        access.ts
        config.ts
        constraints.ts
        types.ts
      queues/
        config/
          types/
            index.ts
            taskTypes.ts
            workflowJSONTypes.ts
            workflowTypes.ts
          generateJobsJSONSchemas.ts
          index.ts
        operations/
          runJobs/
            runJob/
              calculateBackoffWaitUntil.ts
              getRunTaskFunction.ts
              getUpdateJobFunction.ts
              handleWorkflowError.ts
              importHandlerPath.ts
              index.ts
            runJSONJob/
              index.ts
            index.ts
        utilities/
          getJobTaskStatus.ts
          updateJob.ts
        localAPI.ts
        restEndpointRun.ts
      translations/
        getLocalI18n.ts
      types/
        constants.ts
        index.ts
      uploads/
        endpoints/
          getFile.ts
          getFileFromURL.ts
          index.ts
        fetchAPI-multipart/
          fileFactory.ts
          handlers.ts
          index.ts
          isEligibleRequest.ts
          LICENSE.md
          processMultipart.ts
          processNested.ts
          uploadTimer.ts
          utilities.ts
        fetchAPI-stream-file/
          index.ts
        canResizeImage.ts
        checkFileAccess.ts
        cropImage.ts
        deleteAssociatedFiles.ts
        docWithFilenameExists.ts
        fileExists.ts
        formatFilesize.ts
        generateFileData.ts
        getBaseFields.ts
        getExternalFile.ts
        getFileByPath.ts
        getFileTypeFallback.ts
        getImageSize.ts
        getSafeFilename.ts
        imageResizer.ts
        isImage.ts
        mimeTypeValidator.spec.ts
        mimeTypeValidator.ts
        optionallyAppendMetadata.ts
        saveBufferToFile.ts
        tempFile.ts
        types.ts
        unlinkTempFiles.ts
        uploadFiles.ts
      utilities/
        dependencies/
          dependencyChecker.ts
          getDependencies.ts
          isError.ts
          realPath.ts
          resolveFrom.ts
          versionUtils.ts
        telemetry/
          conf/
            envPaths.ts
            index.ts
          events/
            adminInit.ts
            serverInit.ts
          index.ts
          oneWayHash.ts
        addDataAndFileToRequest.ts
        addLocalesToRequest.ts
        addSelectGenericsToGeneratedTypes.spec.ts
        addSelectGenericsToGeneretedTypes.ts
        checkDocumentLockStatus.ts
        commitTransaction.ts
        configToJSONSchema.spec.ts
        configToJSONSchema.ts
        createArrayFromCommaDelineated.ts
        createLocalReq.ts
        createPayloadRequest.ts
        deepCopyObject.ts
        deepMerge.ts
        fieldSchemaToJSON.ts
        findUp.ts
        flattenAllFields.ts
        flattenTopLevelFields.ts
        formatAdminURL.ts
        formatErrors.ts
        formatLabels.spec.ts
        formatLabels.ts
        getBlockSelect.ts
        getCollectionIDFieldTypes.ts
        getDataByPath.ts
        getEntityPolicies.ts
        getFieldByPath.spec.ts
        getFieldByPath.ts
        getFieldPermissions.ts
        getObjectDotNotation.ts
        getRequestEntity.ts
        getRequestLanguage.ts
        getSelectMode.ts
        getSiblingData.ts
        getTranslatedLabel.ts
        getUniqueListBy.ts
        handleEndpoints.ts
        headersWithCors.ts
        initTransaction.ts
        isEntityHidden.ts
        isNextBuild.ts
        isNumber.ts
        isolateObjectProperty.ts
        isPlainObject.ts
        isReactComponent.ts
        isURLAllowed.ts
        isValidID.ts
        killTransaction.ts
        logError.ts
        logger.ts
        mapAsync.ts
        mergeHeaders.ts
        mergeListSearchAndWhere.ts
        parseCookies.ts
        reduceFieldsToValues.ts
        removeUndefined.ts
        routeError.ts
        sanitizeFallbackLocale.ts
        sanitizeInternalFields.ts
        sanitizeJoinParams.ts
        sanitizePermissions.spec.ts
        sanitizePermissions.ts
        sanitizePopulateParam.ts
        sanitizeSelect.ts
        sanitizeSelectParam.ts
        setsAreEqual.ts
        stripUnselectedFields.ts
        timestamp.ts
        toKebabCase.ts
        transformColumnPreferences.ts
        transformWhereQuery.ts
        traverseFields.ts
        unflatten.ts
        validateMimeType.ts
        validateWhereQuery.ts
        wait.ts
        wordBoundariesRegex.ts
        wrapInternalEndpoints.ts
      versions/
        drafts/
          appendVersionToQueryKey.ts
          getQueryDraftsSelect.ts
          getQueryDraftsSort.ts
          replaceWithDraftIfAvailable.ts
        schedule/
          job.ts
          types.ts
        baseFields.ts
        buildCollectionFields.ts
        buildGlobalFields.ts
        buildVersionCompoundIndexes.ts
        defaults.ts
        deleteCollectionVersions.ts
        deleteScheduledPublishJobs.ts
        enforceMaxVersions.ts
        getLatestCollectionVersion.ts
        getLatestGlobalVersion.ts
        payloadPackageList.ts
        saveVersion.ts
        types.ts
      checkPayloadDependencies.ts
      index.ts
    .prettierignore
    .swcrc
    bin.js
    bundle.js
    eslint.config.js
    LICENSE.md
    package.json
    README.md
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/payload/src/admin/elements/Cell.ts">
import type { I18nClient } from '@convexcms/translations'

import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type {
  ArrayFieldClient,
  BlocksFieldClient,
  CheckboxFieldClient,
  ClientField,
  CodeFieldClient,
  DateFieldClient,
  EmailFieldClient,
  Field,
  GroupFieldClient,
  JSONFieldClient,
  NumberFieldClient,
  PointFieldClient,
  RadioFieldClient,
  RelationshipFieldClient,
  SelectFieldClient,
  TextareaFieldClient,
  TextFieldClient,
  UploadFieldClient,
} from '../../fields/config/types.js'
import type { Payload } from '../../types/index.js'

export type RowData = Record<string, any>

export type DefaultCellComponentProps<
  TField extends ClientField = ClientField,
  TCellData = undefined,
> = {
  readonly cellData: TCellData extends undefined
    ? TField extends RelationshipFieldClient
      ? number | Record<string, any> | string
      : TField extends NumberFieldClient
        ? TField['hasMany'] extends true
          ? number[]
          : number
        : TField extends TextFieldClient
          ? TField['hasMany'] extends true
            ? string[]
            : string
          : TField extends
                | CodeFieldClient
                | EmailFieldClient
                | JSONFieldClient
                | RadioFieldClient
                | TextareaFieldClient
            ? string
            : TField extends BlocksFieldClient
              ? {
                  [key: string]: any
                  blockType: string
                }[]
              : TField extends CheckboxFieldClient
                ? boolean
                : TField extends DateFieldClient
                  ? Date | number | string
                  : TField extends GroupFieldClient
                    ? Record<string, any>
                    : TField extends UploadFieldClient
                      ? File | string
                      : TField extends ArrayFieldClient
                        ? Record<string, unknown>[]
                        : TField extends SelectFieldClient
                          ? TField['hasMany'] extends true
                            ? string[]
                            : string
                          : TField extends PointFieldClient
                            ? { x: number; y: number }
                            : any
    : TCellData
  className?: string
  collectionSlug: SanitizedCollectionConfig['slug']
  columnIndex?: number
  customCellProps?: Record<string, any>
  field: TField
  link?: boolean
  onClick?: (args: {
    cellData: unknown
    collectionSlug: SanitizedCollectionConfig['slug']
    rowData: RowData
  }) => void
  rowData: RowData
}

export type DefaultServerCellComponentProps<
  TField extends ClientField = ClientField,
  TCellData = any,
> = {
  collectionConfig: SanitizedCollectionConfig
  field: Field
  i18n: I18nClient
  payload: Payload
} & Omit<DefaultCellComponentProps<TField, TCellData>, 'field'>
</file>

<file path="packages/payload/src/admin/elements/DatePicker.ts">
import type { DatePickerProps } from 'react-datepicker'

export type SharedProps = {
  displayFormat?: string
  overrides?: DatePickerProps
  pickerAppearance?: 'dayAndTime' | 'dayOnly' | 'default' | 'monthOnly' | 'timeOnly'
}

export type TimePickerProps = {
  maxTime?: Date
  minTime?: Date
  timeFormat?: string
  timeIntervals?: number
}

export type DayPickerProps = {
  maxDate?: Date
  minDate?: Date
  monthsToShow?: 1 | 2
}

export type MonthPickerProps = {
  maxDate?: Date
  minDate?: Date
}

export type ConditionalDateProps =
  | ({
      pickerAppearance: 'dayOnly'
    } & DayPickerProps &
      SharedProps)
  | ({
      pickerAppearance: 'monthOnly'
    } & MonthPickerProps &
      SharedProps)
  | ({
      pickerAppearance: 'timeOnly'
    } & SharedProps &
      TimePickerProps)
  | ({
      pickerAppearance?: 'dayAndTime'
    } & DayPickerProps &
      SharedProps &
      TimePickerProps)
  | ({
      pickerAppearance?: 'default'
    } & SharedProps)
</file>

<file path="packages/payload/src/admin/elements/Nav.ts">
export type NavPreferences = {
  groups: NavGroupPreferences
  open: boolean
}

export type NavGroupPreferences = {
  [key: string]: {
    open: boolean
  }
}
</file>

<file path="packages/payload/src/admin/elements/PreviewButton.ts">
import type { ServerProps } from '../../config/types.js'

export type PreviewButtonClientProps = {}

export type PreviewButtonServerPropsOnly = {} & ServerProps

export type PreviewButtonServerProps = PreviewButtonClientProps & PreviewButtonServerPropsOnly
</file>

<file path="packages/payload/src/admin/elements/PublishButton.ts">
import type { ServerProps } from '../../config/types.js'

export type PublishButtonClientProps = {
  label?: string
}

export type PublishButtonServerPropsOnly = {} & ServerProps

export type PublishButtonServerProps = PublishButtonClientProps & PublishButtonServerPropsOnly
</file>

<file path="packages/payload/src/admin/elements/SaveButton.ts">
import type { ServerProps } from '../../config/types.js'

export type SaveButtonClientProps = {
  label?: string
}

export type SaveButtonServerPropsOnly = {} & ServerProps

export type SaveButtonServerProps = SaveButtonClientProps & SaveButtonServerPropsOnly
</file>

<file path="packages/payload/src/admin/elements/SaveDraftButton.ts">
import type { ServerProps } from '../../config/types.js'

export type SaveDraftButtonClientProps = {}

export type SaveDraftButtonServerPropsOnly = {} & ServerProps

export type SaveDraftButtonServerProps = SaveDraftButtonClientProps & SaveDraftButtonServerPropsOnly
</file>

<file path="packages/payload/src/admin/elements/Table.ts">
import type { ClientField } from '../../fields/config/types.js'

export type Column = {
  readonly accessor: string
  readonly active: boolean
  readonly CustomLabel?: React.ReactNode
  readonly field: ClientField
  readonly Heading: React.ReactNode
  readonly renderedCells: React.ReactNode[]
}
</file>

<file path="packages/payload/src/admin/elements/Upload.ts">
import type { CustomComponent } from '../../config/types.js'

export type CustomUpload = CustomComponent
</file>

<file path="packages/payload/src/admin/elements/WithServerSideProps.ts">
import type React from 'react'

import type { ServerProps } from '../../config/types.js'

export type WithServerSidePropsComponentProps = {
  [key: string]: any
  Component: React.ComponentType<any>
  serverOnlyProps: ServerProps
}

export type WithServerSidePropsComponent = React.FC<WithServerSidePropsComponentProps>
</file>

<file path="packages/payload/src/admin/fields/Array.ts">
import type { MarkOptional } from 'ts-essentials'

import type { ArrayField, ArrayFieldClient } from '../../fields/config/types.js'
import type { ArrayFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type ArrayFieldClientWithoutType = MarkOptional<ArrayFieldClient, 'type'>

type ArrayFieldBaseClientProps = {
  readonly validate?: ArrayFieldValidation
} & FieldPaths

type ArrayFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type ArrayFieldClientProps = ArrayFieldBaseClientProps &
  ClientFieldBase<ArrayFieldClientWithoutType>

export type ArrayFieldServerProps = ArrayFieldBaseServerProps &
  ServerFieldBase<ArrayField, ArrayFieldClientWithoutType>

export type ArrayFieldServerComponent = FieldServerComponent<
  ArrayField,
  ArrayFieldClientWithoutType,
  ArrayFieldBaseServerProps
>

export type ArrayFieldClientComponent = FieldClientComponent<
  ArrayFieldClientWithoutType,
  ArrayFieldBaseClientProps
>

export type ArrayFieldLabelServerComponent = FieldLabelServerComponent<
  ArrayField,
  ArrayFieldClientWithoutType
>

export type ArrayFieldLabelClientComponent = FieldLabelClientComponent<ArrayFieldClientWithoutType>

export type ArrayFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  ArrayField,
  ArrayFieldClientWithoutType
>
export type ArrayFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<ArrayFieldClientWithoutType>

export type ArrayFieldErrorServerComponent = FieldErrorServerComponent<
  ArrayField,
  ArrayFieldClientWithoutType
>
export type ArrayFieldErrorClientComponent = FieldErrorClientComponent<ArrayFieldClientWithoutType>

export type ArrayFieldDiffServerComponent = FieldDiffServerComponent<ArrayField, ArrayFieldClient>
export type ArrayFieldDiffClientComponent = FieldDiffClientComponent<ArrayFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Blocks.ts">
import type React from 'react'
import type { MarkOptional } from 'ts-essentials'

import type { BlocksField, BlocksFieldClient } from '../../fields/config/types.js'
import type { BlocksFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type BlocksFieldClientWithoutType = MarkOptional<BlocksFieldClient, 'type'>

type BlocksFieldBaseClientProps = {
  readonly validate?: BlocksFieldValidation
} & FieldPaths

type BlocksFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type BlocksFieldClientProps = BlocksFieldBaseClientProps &
  ClientFieldBase<BlocksFieldClientWithoutType>

export type BlocksFieldServerProps = BlocksFieldBaseServerProps &
  ServerFieldBase<BlocksField, BlocksFieldClientWithoutType>

export type BlocksFieldServerComponent = FieldServerComponent<
  BlocksField,
  BlocksFieldClientWithoutType,
  BlocksFieldBaseServerProps
>

export type BlocksFieldClientComponent = FieldClientComponent<
  BlocksFieldClientWithoutType,
  BlocksFieldBaseClientProps
>

export type BlocksFieldLabelServerComponent = FieldLabelServerComponent<
  BlocksField,
  BlocksFieldClientWithoutType
>

export type BlocksFieldLabelClientComponent =
  FieldLabelClientComponent<BlocksFieldClientWithoutType>

type BlockRowLabelBase = {
  blockType: string
  rowLabel: string
  rowNumber: number
}

export type BlockRowLabelClientComponent = React.ComponentType<
  BlockRowLabelBase & ClientFieldBase<BlocksFieldClientWithoutType>
>

export type BlockRowLabelServerComponent = React.ComponentType<
  BlockRowLabelBase & ServerFieldBase<BlocksField, BlocksFieldClientWithoutType>
>

export type BlocksFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  BlocksField,
  BlocksFieldClientWithoutType
>

export type BlocksFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<BlocksFieldClientWithoutType>

export type BlocksFieldErrorServerComponent = FieldErrorServerComponent<
  BlocksField,
  BlocksFieldClientWithoutType
>

export type BlocksFieldErrorClientComponent =
  FieldErrorClientComponent<BlocksFieldClientWithoutType>

export type BlocksFieldDiffServerComponent = FieldDiffServerComponent<
  BlocksField,
  BlocksFieldClient
>

export type BlocksFieldDiffClientComponent = FieldDiffClientComponent<BlocksFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Checkbox.ts">
import type { MarkOptional } from 'ts-essentials'

import type { CheckboxField, CheckboxFieldClient } from '../../fields/config/types.js'
import type { CheckboxFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type CheckboxFieldClientWithoutType = MarkOptional<CheckboxFieldClient, 'type'>

type CheckboxFieldBaseClientProps = {
  readonly checked?: boolean
  readonly disableFormData?: boolean
  readonly id?: string
  readonly onChange?: (value: boolean) => void
  readonly partialChecked?: boolean
  readonly path: string
  readonly validate?: CheckboxFieldValidation
}

type CheckboxFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type CheckboxFieldClientProps = CheckboxFieldBaseClientProps &
  ClientFieldBase<CheckboxFieldClientWithoutType>

export type CheckboxFieldServerProps = CheckboxFieldBaseServerProps &
  ServerFieldBase<CheckboxField, CheckboxFieldClientWithoutType>

export type CheckboxFieldServerComponent = FieldServerComponent<
  CheckboxField,
  CheckboxFieldClientWithoutType,
  CheckboxFieldBaseServerProps
>

export type CheckboxFieldClientComponent = FieldClientComponent<
  CheckboxFieldClientWithoutType,
  CheckboxFieldBaseClientProps
>

export type CheckboxFieldLabelServerComponent = FieldLabelServerComponent<
  CheckboxField,
  CheckboxFieldClientWithoutType
>

export type CheckboxFieldLabelClientComponent =
  FieldLabelClientComponent<CheckboxFieldClientWithoutType>

export type CheckboxFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  CheckboxField,
  CheckboxFieldClientWithoutType
>

export type CheckboxFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<CheckboxFieldClientWithoutType>

export type CheckboxFieldErrorServerComponent = FieldErrorServerComponent<
  CheckboxField,
  CheckboxFieldClientWithoutType
>

export type CheckboxFieldErrorClientComponent =
  FieldErrorClientComponent<CheckboxFieldClientWithoutType>

export type CheckboxFieldDiffServerComponent = FieldDiffServerComponent<
  CheckboxField,
  CheckboxFieldClient
>

export type CheckboxFieldDiffClientComponent = FieldDiffClientComponent<CheckboxFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Code.ts">
import type { EditorProps } from '@monaco-editor/react'
import type { MarkOptional } from 'ts-essentials'

import type { CodeField, CodeFieldClient } from '../../fields/config/types.js'
import type { CodeFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type CodeFieldClientWithoutType = MarkOptional<CodeFieldClient, 'type'>

type CodeFieldBaseClientProps = {
  readonly autoComplete?: string
  readonly onMount?: EditorProps['onMount']
  readonly path: string
  readonly validate?: CodeFieldValidation
}

type CodeFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type CodeFieldClientProps = ClientFieldBase<CodeFieldClientWithoutType> &
  CodeFieldBaseClientProps

export type CodeFieldServerProps = CodeFieldBaseServerProps &
  ServerFieldBase<CodeField, CodeFieldClientWithoutType>

export type CodeFieldServerComponent = FieldServerComponent<
  CodeField,
  CodeFieldClientWithoutType,
  CodeFieldBaseServerProps
>

export type CodeFieldClientComponent = FieldClientComponent<
  CodeFieldClientWithoutType,
  CodeFieldBaseClientProps
>

export type CodeFieldLabelServerComponent = FieldLabelServerComponent<
  CodeField,
  CodeFieldClientWithoutType
>

export type CodeFieldLabelClientComponent = FieldLabelClientComponent<CodeFieldClientWithoutType>

export type CodeFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  CodeField,
  CodeFieldClientWithoutType
>

export type CodeFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<CodeFieldClientWithoutType>

export type CodeFieldErrorServerComponent = FieldErrorServerComponent<
  CodeField,
  CodeFieldClientWithoutType
>

export type CodeFieldErrorClientComponent = FieldErrorClientComponent<CodeFieldClientWithoutType>

export type CodeFieldDiffServerComponent = FieldDiffServerComponent<CodeField, CodeFieldClient>

export type CodeFieldDiffClientComponent = FieldDiffClientComponent<CodeFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Collapsible.ts">
import type { MarkOptional } from 'ts-essentials'

import type { CollapsibleField, CollapsibleFieldClient } from '../../fields/config/types.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type CollapsibleFieldBaseClientProps = FieldPaths

type CollapsibleFieldClientWithoutType = MarkOptional<CollapsibleFieldClient, 'type'>

export type CollapsibleFieldClientProps = ClientFieldBase<CollapsibleFieldClientWithoutType> &
  CollapsibleFieldBaseClientProps

export type CollapsibleFieldServerProps = ServerFieldBase<
  CollapsibleField,
  CollapsibleFieldClientWithoutType
>

export type CollapsibleFieldServerComponent = FieldServerComponent<
  CollapsibleField,
  CollapsibleFieldClientWithoutType
>

export type CollapsibleFieldClientComponent = FieldClientComponent<
  CollapsibleFieldClientWithoutType,
  CollapsibleFieldBaseClientProps
>

export type CollapsibleFieldLabelServerComponent = FieldLabelServerComponent<
  CollapsibleField,
  CollapsibleFieldClientWithoutType
>

export type CollapsibleFieldLabelClientComponent =
  FieldLabelClientComponent<CollapsibleFieldClientWithoutType>

export type CollapsibleFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  CollapsibleField,
  CollapsibleFieldClientWithoutType
>

export type CollapsibleFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<CollapsibleFieldClientWithoutType>

export type CollapsibleFieldErrorServerComponent = FieldErrorServerComponent<
  CollapsibleField,
  CollapsibleFieldClientWithoutType
>

export type CollapsibleFieldErrorClientComponent =
  FieldErrorClientComponent<CollapsibleFieldClientWithoutType>

export type CollapsibleFieldDiffServerComponent = FieldDiffServerComponent<
  CollapsibleField,
  CollapsibleFieldClient
>

export type CollapsibleFieldDiffClientComponent = FieldDiffClientComponent<CollapsibleFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Date.ts">
import type { MarkOptional } from 'ts-essentials'

import type { DateField, DateFieldClient } from '../../fields/config/types.js'
import type { DateFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type DateFieldClientWithoutType = MarkOptional<DateFieldClient, 'type'>

type DateFieldBaseClientProps = {
  readonly path: string
  readonly validate?: DateFieldValidation
}

type DateFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type DateFieldClientProps = ClientFieldBase<DateFieldClientWithoutType> &
  DateFieldBaseClientProps

export type DateFieldServerProps = DateFieldBaseServerProps &
  ServerFieldBase<DateField, DateFieldClientWithoutType>

export type DateFieldServerComponent = FieldServerComponent<
  DateField,
  DateFieldClientWithoutType,
  DateFieldBaseServerProps
>

export type DateFieldClientComponent = FieldClientComponent<
  DateFieldClientWithoutType,
  DateFieldBaseClientProps
>

export type DateFieldLabelServerComponent = FieldLabelServerComponent<
  DateField,
  DateFieldClientWithoutType
>

export type DateFieldLabelClientComponent = FieldLabelClientComponent<DateFieldClientWithoutType>

export type DateFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  DateField,
  DateFieldClientWithoutType
>

export type DateFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<DateFieldClientWithoutType>

export type DateFieldErrorServerComponent = FieldErrorServerComponent<
  DateField,
  DateFieldClientWithoutType
>

export type DateFieldErrorClientComponent = FieldErrorClientComponent<DateFieldClientWithoutType>

export type DateFieldDiffServerComponent = FieldDiffServerComponent<DateField, DateFieldClient>

export type DateFieldDiffClientComponent = FieldDiffClientComponent<DateFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Email.ts">
import type { MarkOptional } from 'ts-essentials'

import type { EmailField, EmailFieldClient } from '../../fields/config/types.js'
import type { EmailFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type EmailFieldClientWithoutType = MarkOptional<EmailFieldClient, 'type'>

type EmailFieldBaseClientProps = {
  readonly path: string
  readonly validate?: EmailFieldValidation
}

type EmailFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type EmailFieldClientProps = ClientFieldBase<EmailFieldClientWithoutType> &
  EmailFieldBaseClientProps

export type EmailFieldServerProps = EmailFieldBaseServerProps &
  ServerFieldBase<EmailField, EmailFieldClientWithoutType>

export type EmailFieldServerComponent = FieldServerComponent<
  EmailField,
  EmailFieldClientWithoutType,
  EmailFieldBaseServerProps
>

export type EmailFieldClientComponent = FieldClientComponent<
  EmailFieldClientWithoutType,
  EmailFieldBaseClientProps
>

export type EmailFieldLabelServerComponent = FieldLabelServerComponent<
  EmailField,
  EmailFieldClientWithoutType
>

export type EmailFieldLabelClientComponent = FieldLabelClientComponent<EmailFieldClientWithoutType>

export type EmailFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  EmailField,
  EmailFieldClientWithoutType
>

export type EmailFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<EmailFieldClientWithoutType>

export type EmailFieldErrorServerComponent = FieldErrorServerComponent<
  EmailField,
  EmailFieldClientWithoutType
>

export type EmailFieldErrorClientComponent = FieldErrorClientComponent<EmailFieldClientWithoutType>

export type EmailFieldDiffServerComponent = FieldDiffServerComponent<EmailField, EmailFieldClient>

export type EmailFieldDiffClientComponent = FieldDiffClientComponent<EmailFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Group.ts">
import type { MarkOptional } from 'ts-essentials'

import type { GroupField, GroupFieldClient } from '../../fields/config/types.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type GroupFieldClientWithoutType = MarkOptional<GroupFieldClient, 'type'>

type GroupFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type GroupFieldBaseClientProps = FieldPaths

export type GroupFieldClientProps = ClientFieldBase<GroupFieldClientWithoutType> &
  GroupFieldBaseClientProps

export type GroupFieldServerProps = GroupFieldBaseServerProps &
  ServerFieldBase<GroupField, GroupFieldClientWithoutType>

export type GroupFieldServerComponent = FieldServerComponent<
  GroupField,
  GroupFieldClientWithoutType,
  GroupFieldBaseServerProps
>

export type GroupFieldClientComponent = FieldClientComponent<
  GroupFieldClientWithoutType,
  GroupFieldBaseClientProps
>

export type GroupFieldLabelServerComponent = FieldLabelServerComponent<
  GroupField,
  GroupFieldClientWithoutType
>

export type GroupFieldLabelClientComponent = FieldLabelClientComponent<GroupFieldClientWithoutType>

export type GroupFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  GroupField,
  GroupFieldClientWithoutType
>

export type GroupFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<GroupFieldClientWithoutType>

export type GroupFieldErrorServerComponent = FieldErrorServerComponent<
  GroupField,
  GroupFieldClientWithoutType
>

export type GroupFieldErrorClientComponent = FieldErrorClientComponent<GroupFieldClientWithoutType>

export type GroupFieldDiffServerComponent = FieldDiffServerComponent<GroupField, GroupFieldClient>

export type GroupFieldDiffClientComponent = FieldDiffClientComponent<GroupFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Hidden.ts">
import type { ClientFieldBase } from '../types.js'

type HiddenFieldBaseClientProps = {
  readonly disableModifyingForm?: false
  readonly field?: never
  readonly path: string
  readonly value?: unknown
}

export type HiddenFieldProps = HiddenFieldBaseClientProps &
  Pick<ClientFieldBase, 'forceRender' | 'schemaPath'>
</file>

<file path="packages/payload/src/admin/fields/Join.ts">
import type { MarkOptional } from 'ts-essentials'

import type { JoinField, JoinFieldClient } from '../../fields/config/types.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type JoinFieldClientWithoutType = MarkOptional<JoinFieldClient, 'type'>

type JoinFieldBaseClientProps = {
  readonly path: string
}

type JoinFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type JoinFieldClientProps = ClientFieldBase<JoinFieldClientWithoutType> &
  JoinFieldBaseClientProps

export type JoinFieldServerProps = JoinFieldBaseServerProps & ServerFieldBase<JoinField>

export type JoinFieldServerComponent = FieldServerComponent<
  JoinField,
  JoinFieldClientWithoutType,
  JoinFieldBaseServerProps
>

export type JoinFieldClientComponent = FieldClientComponent<
  JoinFieldClientWithoutType,
  JoinFieldBaseClientProps
>

export type JoinFieldLabelServerComponent = FieldLabelServerComponent<JoinField>

export type JoinFieldLabelClientComponent = FieldLabelClientComponent<JoinFieldClientWithoutType>

export type JoinFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  JoinField,
  JoinFieldClientWithoutType
>

export type JoinFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<JoinFieldClientWithoutType>

export type JoinFieldErrorServerComponent = FieldErrorServerComponent<
  JoinField,
  JoinFieldClientWithoutType
>

export type JoinFieldErrorClientComponent = FieldErrorClientComponent<JoinFieldClientWithoutType>

export type JoinFieldDiffServerComponent = FieldDiffServerComponent<JoinField, JoinFieldClient>

export type JoinFieldDiffClientComponent = FieldDiffClientComponent<JoinFieldClient>
</file>

<file path="packages/payload/src/admin/fields/JSON.ts">
import type { MarkOptional } from 'ts-essentials'

import type { JSONField, JSONFieldClient } from '../../fields/config/types.js'
import type { JSONFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type JSONFieldClientWithoutType = MarkOptional<JSONFieldClient, 'type'>

type JSONFieldBaseClientProps = {
  readonly path: string
  readonly validate?: JSONFieldValidation
}

type JSONFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type JSONFieldClientProps = ClientFieldBase<JSONFieldClientWithoutType> &
  JSONFieldBaseClientProps

export type JSONFieldServerProps = JSONFieldBaseServerProps &
  ServerFieldBase<JSONField, JSONFieldClientWithoutType>

export type JSONFieldServerComponent = FieldServerComponent<
  JSONField,
  JSONFieldClientWithoutType,
  JSONFieldBaseServerProps
>

export type JSONFieldClientComponent = FieldClientComponent<
  JSONFieldClientWithoutType,
  JSONFieldBaseClientProps
>

export type JSONFieldLabelServerComponent = FieldLabelServerComponent<
  JSONField,
  JSONFieldClientWithoutType
>

export type JSONFieldLabelClientComponent = FieldLabelClientComponent<JSONFieldClientWithoutType>

export type JSONFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  JSONField,
  JSONFieldClientWithoutType
>

export type JSONFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<JSONFieldClientWithoutType>

export type JSONFieldErrorServerComponent = FieldErrorServerComponent<
  JSONField,
  JSONFieldClientWithoutType
>

export type JSONFieldErrorClientComponent = FieldErrorClientComponent<JSONFieldClientWithoutType>

export type JSONFieldDiffServerComponent = FieldDiffServerComponent<JSONField, JSONFieldClient>

export type JSONFieldDiffClientComponent = FieldDiffClientComponent<JSONFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Number.ts">
import type { MarkOptional } from 'ts-essentials'

import type { NumberField, NumberFieldClient } from '../../fields/config/types.js'
import type { NumberFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type NumberFieldClientWithoutType = MarkOptional<NumberFieldClient, 'type'>

type NumberFieldBaseClientProps = {
  readonly onChange?: (e: number) => void
  readonly path: string
  readonly validate?: NumberFieldValidation
}

type NumberFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type NumberFieldClientProps = ClientFieldBase<NumberFieldClientWithoutType> &
  NumberFieldBaseClientProps

export type NumberFieldServerProps = NumberFieldBaseServerProps &
  ServerFieldBase<NumberField, NumberFieldClientWithoutType>

export type NumberFieldServerComponent = FieldServerComponent<
  NumberField,
  NumberFieldClientWithoutType,
  NumberFieldBaseServerProps
>

export type NumberFieldClientComponent = FieldClientComponent<
  NumberFieldClientWithoutType,
  NumberFieldBaseClientProps
>

export type NumberFieldLabelServerComponent = FieldLabelServerComponent<
  NumberField,
  NumberFieldClientWithoutType
>

export type NumberFieldLabelClientComponent =
  FieldLabelClientComponent<NumberFieldClientWithoutType>

export type NumberFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  NumberField,
  NumberFieldClientWithoutType
>

export type NumberFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<NumberFieldClientWithoutType>

export type NumberFieldErrorServerComponent = FieldErrorServerComponent<
  NumberField,
  NumberFieldClientWithoutType
>

export type NumberFieldErrorClientComponent =
  FieldErrorClientComponent<NumberFieldClientWithoutType>

export type NumberFieldDiffServerComponent = FieldDiffServerComponent<
  NumberField,
  NumberFieldClient
>

export type NumberFieldDiffClientComponent = FieldDiffClientComponent<NumberFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Point.ts">
import type { MarkOptional } from 'ts-essentials'

import type { PointField, PointFieldClient } from '../../fields/config/types.js'
import type { PointFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type PointFieldClientWithoutType = MarkOptional<PointFieldClient, 'type'>

type PointFieldBaseClientProps = {
  readonly path: string
  readonly validate?: PointFieldValidation
}

type PointFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type PointFieldClientProps = ClientFieldBase<PointFieldClientWithoutType> &
  PointFieldBaseClientProps

export type PointFieldServerProps = PointFieldBaseServerProps &
  ServerFieldBase<PointField, PointFieldClientWithoutType>

export type PointFieldServerComponent = FieldServerComponent<
  PointField,
  PointFieldClientWithoutType,
  PointFieldBaseServerProps
>

export type PointFieldClientComponent = FieldClientComponent<
  PointFieldClientWithoutType,
  PointFieldBaseClientProps
>

export type PointFieldLabelServerComponent = FieldLabelServerComponent<
  PointField,
  PointFieldClientWithoutType
>

export type PointFieldLabelClientComponent = FieldLabelClientComponent<PointFieldClientWithoutType>

export type PointFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  PointField,
  PointFieldClientWithoutType
>

export type PointFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<PointFieldClientWithoutType>

export type PointFieldErrorServerComponent = FieldErrorServerComponent<
  PointField,
  PointFieldClientWithoutType
>

export type PointFieldErrorClientComponent = FieldErrorClientComponent<PointFieldClientWithoutType>

export type PointFieldDiffServerComponent = FieldDiffServerComponent<PointField, PointFieldClient>

export type PointFieldDiffClientComponent = FieldDiffClientComponent<PointFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Radio.ts">
import type { MarkOptional } from 'ts-essentials'

import type { RadioField, RadioFieldClient } from '../../fields/config/types.js'
import type { RadioFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type RadioFieldClientWithoutType = MarkOptional<RadioFieldClient, 'type'>

type RadioFieldBaseClientProps = {
  /**
   * Threaded through to the setValue function from the form context when the value changes
   */
  readonly disableModifyingForm?: boolean
  readonly onChange?: OnChange
  readonly path: string
  readonly validate?: RadioFieldValidation
  readonly value?: string
}

type RadioFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type RadioFieldClientProps = ClientFieldBase<RadioFieldClientWithoutType> &
  RadioFieldBaseClientProps

export type RadioFieldServerProps = RadioFieldBaseServerProps &
  ServerFieldBase<RadioField, RadioFieldClientWithoutType>

export type RadioFieldServerComponent = FieldServerComponent<
  RadioField,
  RadioFieldClientWithoutType,
  RadioFieldBaseServerProps
>

export type RadioFieldClientComponent = FieldClientComponent<
  RadioFieldClientWithoutType,
  RadioFieldBaseClientProps
>

type OnChange<T = string> = (value: T) => void

export type RadioFieldLabelServerComponent = FieldLabelServerComponent<
  RadioField,
  RadioFieldClientWithoutType
>

export type RadioFieldLabelClientComponent = FieldLabelClientComponent<RadioFieldClientWithoutType>

export type RadioFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  RadioField,
  RadioFieldClientWithoutType
>

export type RadioFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<RadioFieldClientWithoutType>

export type RadioFieldErrorServerComponent = FieldErrorServerComponent<
  RadioField,
  RadioFieldClientWithoutType
>

export type RadioFieldErrorClientComponent = FieldErrorClientComponent<RadioFieldClientWithoutType>

export type RadioFieldDiffServerComponent = FieldDiffServerComponent<RadioField, RadioFieldClient>

export type RadioFieldDiffClientComponent = FieldDiffClientComponent<RadioFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Relationship.ts">
import type { MarkOptional } from 'ts-essentials'

import type { RelationshipField, RelationshipFieldClient } from '../../fields/config/types.js'
import type { RelationshipFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type RelationshipFieldClientWithoutType = MarkOptional<RelationshipFieldClient, 'type'>

type RelationshipFieldBaseClientProps = {
  readonly path: string
  readonly validate?: RelationshipFieldValidation
}

type RelationshipFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type RelationshipFieldClientProps = ClientFieldBase<RelationshipFieldClientWithoutType> &
  RelationshipFieldBaseClientProps

export type RelationshipFieldServerProps = RelationshipFieldBaseServerProps &
  ServerFieldBase<RelationshipField, RelationshipFieldClientWithoutType>

export type RelationshipFieldServerComponent = FieldServerComponent<
  RelationshipField,
  RelationshipFieldClientWithoutType,
  RelationshipFieldBaseServerProps
>

export type RelationshipFieldClientComponent = FieldClientComponent<
  RelationshipFieldClientWithoutType,
  RelationshipFieldBaseClientProps
>

export type RelationshipFieldLabelServerComponent = FieldLabelServerComponent<
  RelationshipField,
  RelationshipFieldClientWithoutType
>

export type RelationshipFieldLabelClientComponent =
  FieldLabelClientComponent<RelationshipFieldClientWithoutType>

export type RelationshipFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  RelationshipField,
  RelationshipFieldClientWithoutType
>

export type RelationshipFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<RelationshipFieldClientWithoutType>

export type RelationshipFieldErrorServerComponent = FieldErrorServerComponent<
  RelationshipField,
  RelationshipFieldClientWithoutType
>

export type RelationshipFieldErrorClientComponent =
  FieldErrorClientComponent<RelationshipFieldClientWithoutType>

export type RelationshipFieldDiffServerComponent = FieldDiffServerComponent<
  RelationshipField,
  RelationshipFieldClient
>

export type RelationshipFieldDiffClientComponent = FieldDiffClientComponent<RelationshipFieldClient>
</file>

<file path="packages/payload/src/admin/fields/RichText.ts">
import type { MarkOptional } from 'ts-essentials'

import type { RichTextField, RichTextFieldClient } from '../../fields/config/types.js'
import type { RichTextFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type RichTextFieldClientWithoutType<
  TValue extends object = any,
  TAdapterProps = any,
  TExtraProperties = object,
> = MarkOptional<RichTextFieldClient<TValue, TAdapterProps, TExtraProperties>, 'type'>

type RichTextFieldBaseClientProps<
  TValue extends object = any,
  TAdapterProps = any,
  TExtraProperties = object,
> = {
  readonly path: string
  readonly validate?: RichTextFieldValidation
}

type RichTextFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type RichTextFieldClientProps<
  TValue extends object = any,
  TAdapterProps = any,
  TExtraProperties = object,
> = ClientFieldBase<RichTextFieldClientWithoutType<TValue, TAdapterProps, TExtraProperties>> &
  RichTextFieldBaseClientProps<TValue, TAdapterProps, TExtraProperties>

export type RichTextFieldServerProps = RichTextFieldBaseServerProps &
  ServerFieldBase<RichTextField, RichTextFieldClientWithoutType>

export type RichTextFieldServerComponent = FieldServerComponent<
  RichTextField,
  RichTextFieldClientWithoutType,
  RichTextFieldBaseServerProps
>

export type RichTextFieldClientComponent = FieldClientComponent<
  RichTextFieldClientWithoutType,
  RichTextFieldBaseClientProps
>

export type RichTextFieldLabelServerComponent = FieldLabelServerComponent<
  RichTextField,
  RichTextFieldClientWithoutType
>

export type RichTextFieldLabelClientComponent =
  FieldLabelClientComponent<RichTextFieldClientWithoutType>

export type RichTextFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  RichTextField,
  RichTextFieldClientWithoutType
>

export type RichTextFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<RichTextFieldClientWithoutType>

export type RichTextFieldErrorServerComponent = FieldErrorServerComponent<
  RichTextField,
  RichTextFieldClientWithoutType
>

export type RichTextFieldErrorClientComponent =
  FieldErrorClientComponent<RichTextFieldClientWithoutType>

export type RichTextFieldDiffServerComponent = FieldDiffServerComponent<
  RichTextField,
  RichTextFieldClient
>

export type RichTextFieldDiffClientComponent = FieldDiffClientComponent<RichTextFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Row.ts">
import type { MarkOptional } from 'ts-essentials'

import type { RowField, RowFieldClient } from '../../fields/config/types.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldErrorClientComponent,
  FieldErrorServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type RowFieldClientWithoutType = MarkOptional<RowFieldClient, 'type'>

type RowFieldBaseClientProps = {
  readonly forceRender?: boolean
} & Omit<FieldPaths, 'path'>

export type RowFieldClientProps = Omit<ClientFieldBase<RowFieldClientWithoutType>, 'path'> &
  RowFieldBaseClientProps

export type RowFieldServerProps = ServerFieldBase<RowField, RowFieldClientWithoutType>

export type RowFieldServerComponent = FieldServerComponent<RowField, RowFieldClientWithoutType>

export type RowFieldClientComponent = FieldClientComponent<
  RowFieldClientWithoutType,
  RowFieldBaseClientProps
>

export type RowFieldLabelServerComponent = FieldLabelServerComponent<
  RowField,
  RowFieldClientWithoutType
>

export type RowFieldLabelClientComponent = FieldLabelClientComponent<RowFieldClientWithoutType>

export type RowFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  RowField,
  RowFieldClientWithoutType
>

export type RowFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<RowFieldClientWithoutType>

export type RowFieldErrorServerComponent = FieldErrorServerComponent<
  RowField,
  RowFieldClientWithoutType
>

export type RowFieldErrorClientComponent = FieldErrorClientComponent<RowFieldClientWithoutType>

export type RowFieldDiffServerComponent = FieldDiffServerComponent<RowField, RowFieldClient>

export type RowFieldDiffClientComponent = FieldDiffClientComponent<RowFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Select.ts">
import type { MarkOptional } from 'ts-essentials'

import type { SelectField, SelectFieldClient } from '../../fields/config/types.js'
import type { SelectFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type SelectFieldClientWithoutType = MarkOptional<SelectFieldClient, 'type'>

type SelectFieldBaseClientProps = {
  readonly onChange?: (e: string | string[]) => void
  readonly path: string
  readonly validate?: SelectFieldValidation
  readonly value?: string
}

type SelectFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type SelectFieldClientProps = ClientFieldBase<SelectFieldClientWithoutType> &
  SelectFieldBaseClientProps

export type SelectFieldServerProps = SelectFieldBaseServerProps &
  ServerFieldBase<SelectField, SelectFieldClientWithoutType>

export type SelectFieldServerComponent = FieldServerComponent<
  SelectField,
  SelectFieldClientWithoutType,
  SelectFieldBaseServerProps
>

export type SelectFieldClientComponent = FieldClientComponent<
  SelectFieldClientWithoutType,
  SelectFieldBaseClientProps
>

export type SelectFieldLabelServerComponent = FieldLabelServerComponent<
  SelectField,
  SelectFieldClientWithoutType
>

export type SelectFieldLabelClientComponent =
  FieldLabelClientComponent<SelectFieldClientWithoutType>

export type SelectFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  SelectField,
  SelectFieldClientWithoutType
>

export type SelectFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<SelectFieldClientWithoutType>

export type SelectFieldErrorServerComponent = FieldErrorServerComponent<
  SelectField,
  SelectFieldClientWithoutType
>

export type SelectFieldErrorClientComponent =
  FieldErrorClientComponent<SelectFieldClientWithoutType>

export type SelectFieldDiffServerComponent = FieldDiffServerComponent<
  SelectField,
  SelectFieldClient
>

export type SelectFieldDiffClientComponent = FieldDiffClientComponent<SelectFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Tabs.ts">
import type { MarkOptional } from 'ts-essentials'

import type {
  ClientField,
  NamedTab,
  TabsField,
  TabsFieldClient,
  UnnamedTab,
} from '../../fields/config/types.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

export type ClientTab =
  | ({ fields: ClientField[]; passesCondition?: boolean; readonly path?: string } & Omit<
      NamedTab,
      'fields'
    >)
  | ({ fields: ClientField[]; passesCondition?: boolean } & Omit<UnnamedTab, 'fields'>)

type TabsFieldBaseClientProps = FieldPaths

type TabsFieldClientWithoutType = MarkOptional<TabsFieldClient, 'type'>

export type TabsFieldClientProps = ClientFieldBase<TabsFieldClientWithoutType> &
  TabsFieldBaseClientProps

export type TabsFieldServerProps = ServerFieldBase<TabsField, TabsFieldClientWithoutType>

export type TabsFieldServerComponent = FieldServerComponent<TabsField, TabsFieldClientWithoutType>

export type TabsFieldClientComponent = FieldClientComponent<
  TabsFieldClientWithoutType,
  TabsFieldBaseClientProps
>

export type TabsFieldLabelServerComponent = FieldLabelServerComponent<
  TabsField,
  TabsFieldClientWithoutType
>

export type TabsFieldLabelClientComponent = FieldLabelClientComponent<TabsFieldClientWithoutType>

export type TabsFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  TabsField,
  TabsFieldClientWithoutType
>

export type TabsFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<TabsFieldClientWithoutType>

export type TabsFieldErrorServerComponent = FieldErrorServerComponent<
  TabsField,
  TabsFieldClientWithoutType
>

export type TabsFieldErrorClientComponent = FieldErrorClientComponent<TabsFieldClientWithoutType>

export type TabsFieldDiffServerComponent = FieldDiffServerComponent<TabsField, TabsFieldClient>

export type TabsFieldDiffClientComponent = FieldDiffClientComponent<TabsFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Text.ts">
import type React from 'react'
import type { MarkOptional } from 'ts-essentials'

import type { TextField, TextFieldClient } from '../../fields/config/types.js'
import type { TextFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type TextFieldClientWithoutType = MarkOptional<TextFieldClient, 'type'>

type TextFieldBaseClientProps = {
  readonly inputRef?: React.RefObject<HTMLInputElement>
  readonly onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>
  readonly path: string
  readonly validate?: TextFieldValidation
}

type TextFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type TextFieldClientProps = ClientFieldBase<TextFieldClientWithoutType> &
  TextFieldBaseClientProps

export type TextFieldServerProps = ServerFieldBase<TextField, TextFieldClientWithoutType> &
  TextFieldBaseServerProps

export type TextFieldServerComponent = FieldServerComponent<
  TextField,
  TextFieldClientWithoutType,
  TextFieldBaseServerProps
>

export type TextFieldClientComponent = FieldClientComponent<
  TextFieldClientWithoutType,
  TextFieldBaseClientProps
>

export type TextFieldLabelServerComponent = FieldLabelServerComponent<
  TextField,
  TextFieldClientWithoutType
>

export type TextFieldLabelClientComponent = FieldLabelClientComponent<TextFieldClientWithoutType>

export type TextFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  TextField,
  TextFieldClientWithoutType
>

export type TextFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<TextFieldClientWithoutType>

export type TextFieldErrorServerComponent = FieldErrorServerComponent<
  TextField,
  TextFieldClientWithoutType
>

export type TextFieldErrorClientComponent = FieldErrorClientComponent<TextFieldClientWithoutType>

export type TextFieldDiffServerComponent = FieldDiffServerComponent<TextField, TextFieldClient>

export type TextFieldDiffClientComponent = FieldDiffClientComponent<TextFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Textarea.ts">
import type React from 'react'
import type { MarkOptional } from 'ts-essentials'

import type { TextareaField, TextareaFieldClient } from '../../fields/config/types.js'
import type { TextareaFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type TextareaFieldClientWithoutType = MarkOptional<TextareaFieldClient, 'type'>

type TextareaFieldBaseClientProps = {
  readonly inputRef?: React.Ref<HTMLInputElement>
  readonly onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>
  readonly path: string
  readonly validate?: TextareaFieldValidation
}

type TextareaFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type TextareaFieldClientProps = ClientFieldBase<TextareaFieldClientWithoutType> &
  TextareaFieldBaseClientProps

export type TextareaFieldServerProps = ServerFieldBase<
  TextareaField,
  TextareaFieldClientWithoutType
> &
  TextareaFieldBaseServerProps

export type TextareaFieldServerComponent = FieldServerComponent<
  TextareaField,
  TextareaFieldClientWithoutType,
  TextareaFieldBaseServerProps
>

export type TextareaFieldClientComponent = FieldClientComponent<
  TextareaFieldClientWithoutType,
  TextareaFieldBaseClientProps
>

export type TextareaFieldLabelServerComponent = FieldLabelServerComponent<
  TextareaField,
  TextareaFieldClientWithoutType
>

export type TextareaFieldLabelClientComponent =
  FieldLabelClientComponent<TextareaFieldClientWithoutType>

export type TextareaFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  TextareaField,
  TextareaFieldClientWithoutType
>

export type TextareaFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<TextareaFieldClientWithoutType>

export type TextareaFieldErrorServerComponent = FieldErrorServerComponent<
  TextareaField,
  TextareaFieldClientWithoutType
>

export type TextareaFieldErrorClientComponent =
  FieldErrorClientComponent<TextareaFieldClientWithoutType>

export type TextareaFieldDiffServerComponent = FieldDiffServerComponent<
  TextareaField,
  TextareaFieldClient
>

export type TextareaFieldDiffClientComponent = FieldDiffClientComponent<TextareaFieldClient>
</file>

<file path="packages/payload/src/admin/fields/UI.ts">
import type { MarkOptional } from 'ts-essentials'

import type { UIField, UIFieldClient } from '../../fields/config/types.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../types.js'

type UIFieldClientWithoutType = MarkOptional<UIFieldClient, 'type'>

type UIFieldBaseClientProps = {
  readonly path: string
}

type UIFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type UIFieldClientProps = ClientFieldBase<UIFieldClientWithoutType> & UIFieldBaseClientProps

export type UIFieldServerProps = ServerFieldBase<UIField, UIFieldClientWithoutType> &
  UIFieldBaseServerProps

export type UIFieldClientComponent = FieldClientComponent<
  UIFieldClientWithoutType,
  UIFieldBaseClientProps
>

export type UIFieldServerComponent = FieldServerComponent<
  UIField,
  UIFieldClientWithoutType,
  UIFieldBaseServerProps
>

export type UIFieldDiffServerComponent = FieldDiffServerComponent<UIField, UIFieldClient>

export type UIFieldDiffClientComponent = FieldDiffClientComponent<UIFieldClient>
</file>

<file path="packages/payload/src/admin/fields/Upload.ts">
import type { MarkOptional } from 'ts-essentials'

import type { UploadField, UploadFieldClient } from '../../fields/config/types.js'
import type { UploadFieldValidation } from '../../fields/validations.js'
import type { FieldErrorClientComponent, FieldErrorServerComponent } from '../forms/Error.js'
import type {
  ClientFieldBase,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerFieldBase,
} from '../forms/Field.js'
import type {
  FieldDescriptionClientComponent,
  FieldDescriptionServerComponent,
  FieldDiffClientComponent,
  FieldDiffServerComponent,
  FieldLabelClientComponent,
  FieldLabelServerComponent,
} from '../types.js'

type UploadFieldClientWithoutType = MarkOptional<UploadFieldClient, 'type'>

type UploadFieldBaseClientProps = {
  readonly path: string
  readonly validate?: UploadFieldValidation
}

type UploadFieldBaseServerProps = Pick<FieldPaths, 'path'>

export type UploadFieldClientProps = ClientFieldBase<UploadFieldClientWithoutType> &
  UploadFieldBaseClientProps

export type UploadFieldServerProps = ServerFieldBase<UploadField, UploadFieldClientWithoutType> &
  UploadFieldBaseServerProps

export type UploadFieldServerComponent = FieldServerComponent<
  UploadField,
  UploadFieldClientWithoutType,
  UploadFieldBaseServerProps
>

export type UploadFieldClientComponent = FieldClientComponent<
  UploadFieldClientWithoutType,
  UploadFieldBaseClientProps
>

export type UploadFieldLabelServerComponent = FieldLabelServerComponent<
  UploadField,
  UploadFieldClientWithoutType
>

export type UploadFieldLabelClientComponent =
  FieldLabelClientComponent<UploadFieldClientWithoutType>

export type UploadFieldDescriptionServerComponent = FieldDescriptionServerComponent<
  UploadField,
  UploadFieldClientWithoutType
>

export type UploadFieldDescriptionClientComponent =
  FieldDescriptionClientComponent<UploadFieldClientWithoutType>

export type UploadFieldErrorServerComponent = FieldErrorServerComponent<
  UploadField,
  UploadFieldClientWithoutType
>

export type UploadFieldErrorClientComponent =
  FieldErrorClientComponent<UploadFieldClientWithoutType>

export type UploadFieldDiffServerComponent = FieldDiffServerComponent<
  UploadField,
  UploadFieldClient
>

export type UploadFieldDiffClientComponent = FieldDiffClientComponent<UploadFieldClient>
</file>

<file path="packages/payload/src/admin/forms/Description.ts">
import type { I18nClient, TFunction } from '@convexcms/translations'

import type { Field } from '../../fields/config/types.js'
import type { ClientFieldWithOptionalType, ServerComponentProps } from './Field.js'

export type DescriptionFunction = (args: { i18n: I18nClient; t: TFunction }) => string

export type FieldDescriptionClientComponent<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldDescriptionClientProps<TFieldClient>>

export type FieldDescriptionServerComponent<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldDescriptionServerProps<TFieldServer, TFieldClient>>

export type StaticDescription = Record<string, string> | string

export type Description = DescriptionFunction | StaticDescription

export type GenericDescriptionProps = {
  readonly className?: string
  readonly description?: StaticDescription
  readonly marginPlacement?: 'bottom' | 'top'
  readonly path: string
}

export type FieldDescriptionServerProps<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  clientField: TFieldClient
  readonly field: TFieldServer
} & GenericDescriptionProps &
  ServerComponentProps

export type FieldDescriptionClientProps<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  field: TFieldClient
} & GenericDescriptionProps
</file>

<file path="packages/payload/src/admin/forms/Diff.ts">
// @ts-strict-ignore

import type { I18nClient } from '@convexcms/translations'

import type { ClientField, Field, FieldTypes, Tab } from '../../fields/config/types.js'
import type {
  ClientFieldWithOptionalType,
  PayloadRequest,
  SanitizedFieldPermissions,
  TypedLocale,
} from '../../index.js'

export type VersionTab = {
  fields: VersionField[]
  name?: string
} & Pick<Tab, 'label'>

export type BaseVersionField = {
  CustomComponent?: React.ReactNode
  fields: VersionField[]
  path: string
  rows?: VersionField[][]
  schemaPath: string
  tabs?: VersionTab[]
  type: FieldTypes
}

export type VersionField = {
  field?: BaseVersionField
  fieldByLocale?: Record<TypedLocale, BaseVersionField>
}

/**
 * Taken from react-diff-viewer-continued
 */
export declare enum DiffMethod {
  CHARS = 'diffChars',
  CSS = 'diffCss',
  JSON = 'diffJson',
  LINES = 'diffLines',
  SENTENCES = 'diffSentences',
  TRIMMED_LINES = 'diffTrimmedLines',
  WORDS = 'diffWords',
  WORDS_WITH_SPACE = 'diffWordsWithSpace',
}

export type FieldDiffClientProps<TClientField extends ClientFieldWithOptionalType = ClientField> = {
  baseVersionField: BaseVersionField
  /**
   * Field value from the version being compared
   */
  comparisonValue: unknown
  diffMethod: DiffMethod
  field: TClientField
  fieldPermissions:
    | {
        [key: string]: SanitizedFieldPermissions
      }
    | true
  /**
   * If this field is localized, this will be the locale of the field
   */
  locale?: string
  parentIsLocalized: boolean
  /**
   * Field value from the current version
   */
  versionValue: unknown
}

export type FieldDiffServerProps<
  TField extends Field = Field,
  TClientField extends ClientFieldWithOptionalType = ClientField,
> = {
  clientField: TClientField
  field: TField
  i18n: I18nClient
  req: PayloadRequest
  selectedLocales: string[]
} & Omit<FieldDiffClientProps, 'field'>

export type FieldDiffClientComponent<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldDiffClientProps<TFieldClient>>

export type FieldDiffServerComponent<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldDiffServerProps<TFieldServer, TFieldClient>>
</file>

<file path="packages/payload/src/admin/forms/Error.ts">
import type { Field } from '../../fields/config/types.js'
import type { ClientFieldWithOptionalType, ServerComponentProps } from './Field.js'

export type GenericErrorProps = {
  readonly alignCaret?: 'center' | 'left' | 'right'
  readonly message?: string
  readonly path?: string
  readonly showError?: boolean
}

export type FieldErrorClientProps<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  field: TFieldClient
} & GenericErrorProps

export type FieldErrorServerProps<
  TFieldServer extends Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  clientField: TFieldClient
  readonly field: TFieldServer
} & GenericErrorProps &
  ServerComponentProps

export type FieldErrorClientComponent<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldErrorClientProps<TFieldClient>>

export type FieldErrorServerComponent<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldErrorServerProps<TFieldServer, TFieldClient>>
</file>

<file path="packages/payload/src/admin/forms/Field.ts">
import type { I18nClient } from '@convexcms/translations'
import type { MarkOptional } from 'ts-essentials'

import type { SanitizedFieldPermissions, User } from '../../auth/types.js'
import type { ClientBlock, ClientField, Field } from '../../fields/config/types.js'
import type { DocumentPreferences } from '../../preferences/types.js'
import type { Operation, Payload, PayloadRequest } from '../../types/index.js'
import type {
  ClientFieldSchemaMap,
  ClientTab,
  Data,
  FieldSchemaMap,
  FormField,
  FormState,
  RenderedField,
} from '../types.js'

export type ClientFieldWithOptionalType = MarkOptional<ClientField, 'type'>

export type ClientComponentProps = {
  customComponents?: FormField['customComponents']
  field: ClientBlock | ClientField | ClientTab
  forceRender?: boolean
  permissions?: SanitizedFieldPermissions
  readOnly?: boolean
  renderedBlocks?: RenderedField[]
  /**
   * Used to extract field configs from a schemaMap.
   * Does not include indexes.
   *
   * @default field.name
   **/
  schemaPath?: string
}

// TODO: maybe we can come up with a better name?
export type FieldPaths = {
  /**
   * @default ''
   */
  indexPath?: string
  /**
   * @default ''
   */
  parentPath?: string
  /**
   * The path built up to the point of the field
   * excluding the field name.
   *
   * @default ''
   */
  parentSchemaPath?: string
  /**
   * A built up path to access FieldState in the form state.
   * Nested fields will have a path that includes the parent field names
   * if they are nested within a group, array, block or named tab.
   *
   * Collapsibles and unnamed tabs will have arbitrary paths
   * that look like _index-0, _index-1, etc.
   *
   * Row fields will not have a path.
   *
   * @example 'parentGroupField.childTextField'
   *
   * @default field.name
   */
  path: string
}

export type ServerComponentProps = {
  clientField: ClientFieldWithOptionalType
  clientFieldSchemaMap: ClientFieldSchemaMap
  collectionSlug: string
  data: Data
  field: Field
  /**
   * The fieldSchemaMap that is created before form state is built is made available here.
   */
  fieldSchemaMap: FieldSchemaMap
  /**
   * Server Components will also have available to the entire form state.
   * We cannot add it to ClientComponentProps as that would blow up the size of the props sent to the client.
   */
  formState: FormState
  i18n: I18nClient
  id?: number | string
  operation: Operation
  payload: Payload
  permissions: SanitizedFieldPermissions
  preferences: DocumentPreferences
  req: PayloadRequest
  siblingData: Data
  user: User
}

export type ClientFieldBase<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  readonly field: TFieldClient
} & Omit<ClientComponentProps, 'customComponents' | 'field'>

export type ServerFieldBase<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  readonly clientField: TFieldClient
  readonly field: TFieldServer
} & Omit<ClientComponentProps, 'field'> &
  Omit<ServerComponentProps, 'clientField' | 'field'>

export type FieldClientComponent<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
  AdditionalProps extends Record<string, unknown> = Record<string, unknown>,
> = React.ComponentType<AdditionalProps & ClientFieldBase<TFieldClient>>

export type FieldServerComponent<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
  AdditionalProps extends Record<string, unknown> = Record<string, unknown>,
> = React.ComponentType<AdditionalProps & ServerFieldBase<TFieldServer, TFieldClient>>
</file>

<file path="packages/payload/src/admin/forms/Form.ts">
import { type SupportedLanguages } from '@convexcms/translations'

import type { SanitizedDocumentPermissions } from '../../auth/types.js'
import type { Field, Validate } from '../../fields/config/types.js'
import type { TypedLocale } from '../../index.js'
import type { DocumentPreferences } from '../../preferences/types.js'
import type { PayloadRequest, SelectType, Where } from '../../types/index.js'

export type Data = {
  [key: string]: any
}

export type Row = {
  blockType?: string
  collapsed?: boolean
  customComponents?: {
    RowLabel?: React.ReactNode
  }
  id: string
  isLoading?: boolean
  lastRenderedPath?: string
}

export type FilterOptionsResult = {
  [relation: string]: boolean | Where
}

export type FieldState = {
  /**
   * This is used to determine if the field was added by the server.
   * This ensures the field is not ignored by the client when merging form state.
   * This can happen because the current local state is treated as the source of truth.
   * See `mergeServerFormState` for more details.
   */
  addedByServer?: boolean
  customComponents?: {
    /**
     * This is used by UI fields, as they can have arbitrary components defined if used
     * as a vessel to bring in custom components.
     */
    [key: string]: React.ReactNode | React.ReactNode[] | undefined
    AfterInput?: React.ReactNode
    BeforeInput?: React.ReactNode
    Description?: React.ReactNode
    Error?: React.ReactNode
    Field?: React.ReactNode
    Label?: React.ReactNode
  }
  disableFormData?: boolean
  errorMessage?: string
  errorPaths?: string[]
  /**
   * The fieldSchema may be part of the form state if `includeSchema: true` is passed to buildFormState.
   * This will never be in the form state of the client.
   */
  fieldSchema?: Field
  filterOptions?: FilterOptionsResult
  initialValue?: unknown
  /**
   * The path of the field when its custom components were last rendered.
   * This is used to denote if a field has been rendered, and if so,
   * what path it was rendered under last.
   *
   * If this path is undefined, or, if it is different
   * from the current path of a given field, the field's components will be re-rendered.
   */
  lastRenderedPath?: string
  passesCondition?: boolean
  rows?: Row[]
  valid?: boolean
  validate?: Validate
  value?: unknown
}

export type FieldStateWithoutComponents = Omit<FieldState, 'customComponents'>

export type FormState = {
  [path: string]: FieldState
}

export type FormStateWithoutComponents = {
  [path: string]: FieldStateWithoutComponents
}

export type BuildFormStateArgs = {
  data?: Data
  docPermissions: SanitizedDocumentPermissions | undefined
  docPreferences: DocumentPreferences
  /**
   * In case `formState` is not the top-level, document form state, this can be passed to
   * provide the top-level form state.
   */
  documentFormState?: FormState
  fallbackLocale?: false | TypedLocale
  formState?: FormState
  id?: number | string
  initialBlockData?: Data
  initialBlockFormState?: FormState
  /*
    If not i18n was passed, the language can be passed to init i18n
  */
  language?: keyof SupportedLanguages
  locale?: string
  /**
   * If true, will not render RSCs and instead return a simple string in their place.
   * This is useful for environments that lack RSC support, such as Jest.
   * Form state can still be built, but any server components will be omitted.
   * @default false
   */
  mockRSCs?: boolean
  operation?: 'create' | 'update'
  /*
    If true, will render field components within their state object
  */
  renderAllFields?: boolean
  req: PayloadRequest
  returnLockStatus?: boolean
  schemaPath: string
  select?: SelectType
  skipValidation?: boolean
  updateLastEdited?: boolean
} & (
  | {
      collectionSlug: string
      // Do not type it as never. This still makes it so that either collectionSlug or globalSlug is required, but makes it easier to provide both collectionSlug and globalSlug if it's
      // unclear which one is actually available.
      globalSlug?: string
    }
  | {
      collectionSlug?: string
      globalSlug: string
    }
)
</file>

<file path="packages/payload/src/admin/forms/Label.ts">
import type { StaticLabel } from '../../config/types.js'
import type { Field } from '../../fields/config/types.js'
import type { ClientFieldWithOptionalType, ServerComponentProps } from './Field.js'

export type GenericLabelProps = {
  readonly as?: 'h3' | 'label' | 'span'
  readonly hideLocale?: boolean
  readonly htmlFor?: string
  readonly label?: StaticLabel
  readonly localized?: boolean
  readonly path?: string
  readonly required?: boolean
  readonly unstyled?: boolean
}

export type FieldLabelClientProps<
  TFieldClient extends Partial<ClientFieldWithOptionalType> = Partial<ClientFieldWithOptionalType>,
> = {
  field?: TFieldClient
} & GenericLabelProps

export type FieldLabelServerProps<
  TFieldServer extends Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = {
  clientField: TFieldClient
  readonly field: TFieldServer
} & GenericLabelProps &
  ServerComponentProps

export type SanitizedLabelProps<TFieldClient extends ClientFieldWithOptionalType> = Omit<
  FieldLabelClientProps<TFieldClient>,
  'label' | 'required'
>

export type FieldLabelClientComponent<
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldLabelClientProps<TFieldClient>>

export type FieldLabelServerComponent<
  TFieldServer extends Field = Field,
  TFieldClient extends ClientFieldWithOptionalType = ClientFieldWithOptionalType,
> = React.ComponentType<FieldLabelServerProps<TFieldServer, TFieldClient>>
</file>

<file path="packages/payload/src/admin/forms/RowLabel.ts">
import type { CustomComponent } from '../../config/types.js'

export type RowLabelComponent = CustomComponent

export type RowLabel = Record<string, string> | string
</file>

<file path="packages/payload/src/admin/functions/index.ts">
import type { ImportMap } from '../../bin/generateImportMap/index.js'
import type { SanitizedConfig } from '../../config/types.js'
import type { PaginatedDocs } from '../../database/types.js'
import type { CollectionSlug, ColumnPreference } from '../../index.js'
import type { PayloadRequest, Sort, Where } from '../../types/index.js'
import type { ColumnsFromURL } from '../../utilities/transformColumnPreferences.js'

export type DefaultServerFunctionArgs = {
  importMap: ImportMap
  req: PayloadRequest
}

export type ServerFunctionArgs = {
  args: Record<string, unknown>
  name: string
}

export type ServerFunctionClientArgs = {
  args: Record<string, unknown>
  name: string
}

export type ServerFunctionClient = (args: ServerFunctionClientArgs) => Promise<unknown> | unknown

export type ServerFunction = (
  args: DefaultServerFunctionArgs & ServerFunctionClientArgs['args'],
) => Promise<unknown> | unknown

export type ServerFunctionConfig = {
  fn: ServerFunction
  name: string
}

export type ServerFunctionHandler = (
  args: {
    config: Promise<SanitizedConfig> | SanitizedConfig
    importMap: ImportMap
  } & ServerFunctionClientArgs,
) => Promise<unknown>

export type ListQuery = {
  /*
   * This is an of strings, i.e. `['title', '-slug']`
   * Use `transformColumnsToPreferences` and `transformColumnsToSearchParams` to convert it back and forth
   */
  columns?: ColumnsFromURL
  limit?: string
  page?: string
  preset?: number | string
  /*
    When provided, is automatically injected into the `where` object
  */
  search?: string
  sort?: Sort
  where?: Where
}

export type BuildTableStateArgs = {
  collectionSlug: string | string[]
  columns?: ColumnPreference[]
  docs?: PaginatedDocs['docs']
  enableRowSelections?: boolean
  orderableFieldName: string
  parent?: {
    collectionSlug: CollectionSlug
    id: number | string
    joinPath: string
  }
  query?: ListQuery
  renderRowTypes?: boolean
  req: PayloadRequest
  tableAppearance?: 'condensed' | 'default'
}
</file>

<file path="packages/payload/src/admin/views/document.ts">
import type { SanitizedPermissions } from '../../auth/types.js'
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { PayloadComponent, SanitizedConfig, ServerProps } from '../../config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { Data, DocumentSlots, FormState } from '../types.js'
import type { InitPageResult, ViewTypes } from './index.js'

export type EditViewProps = {
  readonly collectionSlug?: string
  readonly globalSlug?: string
}

export type DocumentViewServerPropsOnly = {
  readonly doc: Data
  readonly initPageResult: InitPageResult
  readonly routeSegments: string[]
} & ServerProps

export type DocumentViewServerProps = DocumentViewClientProps & DocumentViewServerPropsOnly

export type DocumentViewClientProps = {
  documentSubViewType: DocumentSubViewTypes
  formState: FormState
  viewType: ViewTypes
} & DocumentSlots

/**
 * @todo: This should be renamed to `DocumentSubViewType` (singular)
 */
export type DocumentSubViewTypes = 'api' | 'default' | 'livePreview' | 'version' | 'versions'

export type DocumentTabServerPropsOnly = {
  readonly apiURL?: string
  readonly collectionConfig?: SanitizedCollectionConfig
  readonly globalConfig?: SanitizedGlobalConfig
  readonly permissions: SanitizedPermissions
} & ServerProps

export type DocumentTabServerProps = DocumentTabClientProps & DocumentTabServerPropsOnly

export type DocumentTabClientProps = {
  path: string
}

export type DocumentTabCondition = (args: {
  collectionConfig: SanitizedCollectionConfig
  config: SanitizedConfig
  globalConfig: SanitizedGlobalConfig
  permissions: SanitizedPermissions
}) => boolean

// Everything is optional because we merge in the defaults
// i.e. the config may override the `Default` view with a `label` but not an `href`
export type DocumentTabConfig = {
  readonly Component?: DocumentTabComponent
  readonly condition?: DocumentTabCondition
  readonly href?:
    | ((args: {
        apiURL: string
        collection: SanitizedCollectionConfig
        global: SanitizedGlobalConfig
        id?: string
        routes: SanitizedConfig['routes']
      }) => string)
    | string
  readonly isActive?: ((args: { href: string }) => boolean) | boolean
  readonly label?: ((args: { t: (key: string) => string }) => string) | string
  readonly newTab?: boolean
  readonly Pill?: PayloadComponent
}

/**
 * @todo: Remove this type as it's only used internally for the config (above)
 */
export type DocumentTabComponent = PayloadComponent<{
  path: string
}>
</file>

<file path="packages/payload/src/admin/views/index.ts">
import type { ClientTranslationsObject, I18n } from '@convexcms/translations'

import type { SanitizedPermissions } from '../../auth/index.js'
import type { ImportMap } from '../../bin/generateImportMap/index.js'
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { ClientConfig } from '../../config/client.js'
import type {
  CustomComponent,
  Locale,
  MetaConfig,
  Params,
  PayloadComponent,
  SanitizedConfig,
  ServerProps,
} from '../../config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { Payload, PayloadRequest } from '../../types/index.js'
import type { LanguageOptions } from '../LanguageOptions.js'
import type { Data, StaticDescription } from '../types.js'
import type { DocumentSubViewTypes } from './document.js'

export type AdminViewConfig = {
  Component: PayloadComponent
  /** Whether the path should be matched exactly or as a prefix */
  exact?: boolean
  meta?: MetaConfig
  path?: string
  sensitive?: boolean
  strict?: boolean
}

export type AdminViewClientProps = {
  clientConfig: ClientConfig
  documentSubViewType?: DocumentSubViewTypes
  viewType: ViewTypes
}

export type AdminViewServerPropsOnly = {
  readonly clientConfig: ClientConfig
  readonly disableActions?: boolean
  /**
   * @todo remove `docID` here as it is already contained in `initPageResult`
   */
  readonly docID?: number | string
  readonly importMap: ImportMap
  readonly initialData?: Data
  readonly initPageResult: InitPageResult
} & ServerProps

export type AdminViewServerProps = AdminViewClientProps & AdminViewServerPropsOnly

/**
 * @deprecated This should be removed in favor of direct props
 */
export type AdminViewComponent = PayloadComponent<AdminViewServerProps>

export type VisibleEntities = {
  collections: SanitizedCollectionConfig['slug'][]
  globals: SanitizedGlobalConfig['slug'][]
}

export type InitPageResult = {
  collectionConfig?: SanitizedCollectionConfig
  cookies: Map<string, string>
  docID?: number | string
  globalConfig?: SanitizedGlobalConfig
  languageOptions: LanguageOptions
  locale?: Locale
  permissions: SanitizedPermissions
  redirectTo?: string
  req: PayloadRequest
  translations: ClientTranslationsObject
  visibleEntities: VisibleEntities
}

/**
 * @todo This should be renamed to `ViewType` (singular)
 */
export type ViewTypes =
  | 'account'
  | 'dashboard'
  | 'document'
  | 'list'
  | 'reset'
  | 'verify'
  | 'version'

export type ServerPropsFromView = {
  collectionConfig?: SanitizedConfig['collections'][number]
  globalConfig?: SanitizedConfig['globals'][number]
  viewActions: CustomComponent[]
}

// Description
export type ViewDescriptionClientProps = {
  collectionSlug?: SanitizedCollectionConfig['slug']
  description: StaticDescription
}

export type ViewDescriptionServerPropsOnly = {} & ServerProps

export type ViewDescriptionServerProps = ViewDescriptionClientProps & ViewDescriptionServerPropsOnly
</file>

<file path="packages/payload/src/admin/views/list.ts">
import type { SanitizedCollectionPermission } from '../../auth/types.js'
import type {
  CollectionAdminOptions,
  SanitizedCollectionConfig,
} from '../../collections/config/types.js'
import type { ServerProps } from '../../config/types.js'
import type { ListPreferences } from '../../preferences/types.js'
import type { QueryPreset } from '../../query-presets/types.js'
import type { ResolvedFilterOptions } from '../../types/index.js'
import type { Column } from '../elements/Table.js'
import type { Data } from '../types.js'

export type ListViewSlots = {
  AfterList?: React.ReactNode
  AfterListTable?: React.ReactNode
  BeforeList?: React.ReactNode
  BeforeListTable?: React.ReactNode
  Description?: React.ReactNode
  listMenuItems?: React.ReactNode[]
  Table: React.ReactNode
}

/**
 * The `ListViewServerPropsOnly` approach is needed to ensure type strictness when injecting component props
 * There is no way to do something like `Omit<ListViewServerProps, keyof ListViewClientProps>`
 * This is because `ListViewClientProps` is a union which is impossible to exclude from
 * Exporting explicitly defined `ListViewServerPropsOnly`, etc. allows for the strictest typing
 */
export type ListViewServerPropsOnly = {
  collectionConfig: SanitizedCollectionConfig
  data: Data
  limit: number
  listPreferences: ListPreferences
  listSearchableFields: CollectionAdminOptions['listSearchableFields']
} & ServerProps

export type ListViewServerProps = ListViewClientProps & ListViewServerPropsOnly

export type ListViewClientProps = {
  beforeActions?: React.ReactNode[]
  collectionSlug: SanitizedCollectionConfig['slug']
  columnState: Column[]
  disableBulkDelete?: boolean
  disableBulkEdit?: boolean
  disableQueryPresets?: boolean
  enableRowSelections?: boolean
  hasCreatePermission: boolean
  /**
   * @deprecated
   */
  listPreferences?: ListPreferences
  newDocumentURL: string
  /**
   * @deprecated
   */
  preferenceKey?: string
  queryPreset?: QueryPreset
  queryPresetPermissions?: SanitizedCollectionPermission
  renderedFilters?: Map<string, React.ReactNode>
  resolvedFilterOptions?: Map<string, ResolvedFilterOptions>
} & ListViewSlots

export type ListViewSlotSharedClientProps = {
  collectionSlug: SanitizedCollectionConfig['slug']
  hasCreatePermission: boolean
  newDocumentURL: string
}

// BeforeList
export type BeforeListClientProps = ListViewSlotSharedClientProps
export type BeforeListServerPropsOnly = {} & ListViewServerPropsOnly
export type BeforeListServerProps = BeforeListClientProps & BeforeListServerPropsOnly

// BeforeListTable
export type BeforeListTableClientProps = ListViewSlotSharedClientProps
export type BeforeListTableServerPropsOnly = {} & ListViewServerPropsOnly
export type BeforeListTableServerProps = BeforeListTableClientProps & BeforeListTableServerPropsOnly

// AfterList
export type AfterListClientProps = ListViewSlotSharedClientProps
export type AfterListServerPropsOnly = {} & ListViewServerPropsOnly
export type AfterListServerProps = AfterListClientProps & AfterListServerPropsOnly

// AfterListTable
export type AfterListTableClientProps = ListViewSlotSharedClientProps
export type AfterListTableServerPropsOnly = {} & ListViewServerPropsOnly
export type AfterListTableServerProps = AfterListTableClientProps & AfterListTableServerPropsOnly
</file>

<file path="packages/payload/src/admin/LanguageOptions.ts">
import type { AcceptedLanguages } from '@convexcms/translations'

export type LanguageOptions = {
  label: string
  value: AcceptedLanguages
}[]
</file>

<file path="packages/payload/src/admin/RichText.ts">
// @ts-strict-ignore
import type { GenericLanguages, I18n } from '@convexcms/translations'
import type { JSONSchema4 } from 'json-schema'

import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'
import type { Config, PayloadComponent, SanitizedConfig } from '../config/types.js'
import type { ValidationFieldError } from '../errors/ValidationError.js'
import type {
  FieldAffectingData,
  RichTextField,
  RichTextFieldClient,
  Validate,
} from '../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { RequestContext } from '../index.js'
import type { JsonObject, PayloadRequest, PopulateType } from '../types/index.js'
import type { RichTextFieldClientProps, RichTextFieldServerProps } from './fields/RichText.js'
import type { FieldDiffClientProps, FieldDiffServerProps, FieldSchemaMap } from './types.js'

export type AfterReadRichTextHookArgs<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = {
  currentDepth?: number

  depth?: number

  draft?: boolean

  fallbackLocale?: string
  fieldPromises?: Promise<void>[]

  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */
  findMany?: boolean

  flattenLocales?: boolean

  locale?: string

  /** A string relating to which operation the field type is currently executing within. */
  operation?: 'create' | 'delete' | 'read' | 'update'

  overrideAccess?: boolean

  populate?: PopulateType

  populationPromises?: Promise<void>[]
  showHiddenFields?: boolean
  triggerAccessControl?: boolean
  triggerHooks?: boolean
}

export type AfterChangeRichTextHookArgs<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = {
  /** A string relating to which operation the field type is currently executing within. */
  operation: 'create' | 'update'
  /** The document before changes were applied. */
  previousDoc?: TData
  /** The sibling data of the document before changes being applied. */
  previousSiblingDoc?: TData
  /** The previous value of the field, before changes */
  previousValue?: TValue
}
export type BeforeValidateRichTextHookArgs<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = {
  /** A string relating to which operation the field type is currently executing within. */
  operation: 'create' | 'update'
  overrideAccess?: boolean
  /** The sibling data of the document before changes being applied. */
  previousSiblingDoc?: TData
  /** The previous value of the field, before changes */
  previousValue?: TValue
}

export type BeforeChangeRichTextHookArgs<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = {
  /**
   * The original data with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.
   */
  docWithLocales?: JsonObject

  duplicate?: boolean

  errors?: ValidationFieldError[]
  /**
   * Built up field label
   *
   * @example "Group Field > Tab Field > Rich Text Field"
   */
  fieldLabelPath: string
  /** Only available in `beforeChange` field hooks */
  mergeLocaleActions?: (() => Promise<void> | void)[]
  /** A string relating to which operation the field type is currently executing within. */
  operation?: 'create' | 'delete' | 'read' | 'update'
  /** The sibling data of the document before changes being applied. */
  previousSiblingDoc?: TData
  /** The previous value of the field, before changes */
  previousValue?: TValue

  /**
   * The original siblingData with locales (not modified by any hooks).
   */
  siblingDocWithLocales?: JsonObject
  skipValidation?: boolean
}

export type BaseRichTextHookArgs<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = {
  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */
  data?: Partial<TData>
  /** The field which the hook is running against. */
  field: FieldAffectingData
  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */
  global: null | SanitizedGlobalConfig
  indexPath: number[]
  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */
  originalDoc?: TData
  parentIsLocalized: boolean
  /**
   * The path of the field, e.g. ["group", "myArray", 1, "textField"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.
   */
  path: (number | string)[]
  /** The Express request object. It is mocked for Local API operations. */
  req: PayloadRequest
  /**
   * The schemaPath of the field, e.g. ["group", "myArray", "textField"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.
   */
  schemaPath: string[]
  /** The sibling data passed to a field that the hook is running against. */
  siblingData: Partial<TSiblingData>
  /** The value of the field. */
  value?: TValue
}

export type AfterReadRichTextHook<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = (
  args: AfterReadRichTextHookArgs<TData, TValue, TSiblingData> &
    BaseRichTextHookArgs<TData, TValue, TSiblingData>,
) => Promise<TValue> | TValue

export type AfterChangeRichTextHook<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = (
  args: AfterChangeRichTextHookArgs<TData, TValue, TSiblingData> &
    BaseRichTextHookArgs<TData, TValue, TSiblingData>,
) => Promise<TValue> | TValue

export type BeforeChangeRichTextHook<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = (
  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &
    BeforeChangeRichTextHookArgs<TData, TValue, TSiblingData>,
) => Promise<TValue> | TValue

export type BeforeValidateRichTextHook<
  TData extends TypeWithID = any,
  TValue = any,
  TSiblingData = any,
> = (
  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &
    BeforeValidateRichTextHookArgs<TData, TValue, TSiblingData>,
) => Promise<TValue> | TValue

export type RichTextHooks = {
  afterChange?: AfterChangeRichTextHook[]
  afterRead?: AfterReadRichTextHook[]
  beforeChange?: BeforeChangeRichTextHook[]
  beforeValidate?: BeforeValidateRichTextHook[]
}
type RichTextAdapterBase<
  Value extends object = object,
  AdapterProps = any,
  ExtraFieldProperties = {},
> = {
  generateImportMap?: Config['admin']['importMap']['generators'][0]
  generateSchemaMap?: (args: {
    config: SanitizedConfig
    field: RichTextField
    i18n: I18n<any, any>
    schemaMap: FieldSchemaMap
    schemaPath: string
  }) => FieldSchemaMap
  /**
   * Like an afterRead hook, but runs only for the GraphQL resolver. For populating data, this should be used, as afterRead hooks do not have a depth in graphQL.
   *
   * To populate stuff / resolve field hooks, mutate the incoming populationPromises or fieldPromises array. They will then be awaited in the correct order within payload itself.
   * @param data
   */
  graphQLPopulationPromises?: (data: {
    context: RequestContext
    currentDepth?: number
    depth: number
    draft: boolean
    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>
    fieldPromises: Promise<void>[]
    findMany: boolean
    flattenLocales: boolean
    overrideAccess?: boolean
    parentIsLocalized: boolean
    populateArg?: PopulateType
    populationPromises: Promise<void>[]
    req: PayloadRequest
    showHiddenFields: boolean
    siblingDoc: JsonObject
  }) => void
  hooks?: RichTextHooks
  i18n?: Partial<GenericLanguages>
  outputSchema?: (args: {
    collectionIDFieldTypes: { [key: string]: 'number' | 'string' }
    config?: SanitizedConfig
    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>
    i18n?: I18n
    /**
     * Allows you to define new top-level interfaces that can be re-used in the output schema.
     */
    interfaceNameDefinitions: Map<string, JSONSchema4>
    isRequired: boolean
  }) => JSONSchema4
  validate: Validate<
    Value,
    Value,
    unknown,
    RichTextField<Value, AdapterProps, ExtraFieldProperties>
  >
}

export type RichTextAdapter<
  Value extends object = any,
  AdapterProps = any,
  ExtraFieldProperties = any,
> = {
  CellComponent: PayloadComponent<never>
  /**
   * Component that will be displayed in the version diff view.
   * If not provided, richtext content will be diffed as JSON.
   */
  DiffComponent?: PayloadComponent<
    FieldDiffServerProps<RichTextField, RichTextFieldClient>,
    FieldDiffClientProps<RichTextFieldClient>
  >
  FieldComponent: PayloadComponent<RichTextFieldServerProps, RichTextFieldClientProps>
} & RichTextAdapterBase<Value, AdapterProps, ExtraFieldProperties>

export type RichTextAdapterProvider<
  Value extends object = object,
  AdapterProps = any,
  ExtraFieldProperties = {},
> = ({
  config,
  isRoot,
  parentIsLocalized,
}: {
  config: SanitizedConfig
  /**
   * Whether or not this is the root richText editor, defined in the payload.config.ts.
   *
   * @default false
   */
  isRoot?: boolean
  parentIsLocalized: boolean
}) =>
  | Promise<RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>>
  | RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>
</file>

<file path="packages/payload/src/admin/types.ts">
import type { AcceptedLanguages, I18nClient } from '@convexcms/translations'
import type React from 'react'

import type { ImportMap } from '../bin/generateImportMap/index.js'
import type { SanitizedConfig } from '../config/types.js'
import type {
  Block,
  ClientBlock,
  ClientField,
  Field,
  FieldTypes,
  Tab,
} from '../fields/config/types.js'
import type { JsonObject } from '../types/index.js'
import type { ClientTab } from './fields/Tabs.js'
import type {
  BuildFormStateArgs,
  Data,
  FieldState,
  FieldStateWithoutComponents,
  FilterOptionsResult,
  FormState,
  FormStateWithoutComponents,
  Row,
} from './forms/Form.js'

export type {
  /**
   * @deprecated
   * The `CustomPreviewButton` type is deprecated and will be removed in the next major version.
   * This type is only used for the Payload Config. Use `PreviewButtonClientProps` instead.
   */
  CustomComponent as CustomPreviewButton,
  /**
   * @deprecated
   * The `CustomPublishButton` type is deprecated and will be removed in the next major version.
   * This type is only used for the Payload Config. Use `PreviewButtonClientProps` instead.
   */
  CustomComponent as CustomPublishButton,
  /**
   * @deprecated
   * The `CustomSaveButton` type is deprecated and will be removed in the next major version.
   * This type is only used for the Payload Config. Use `PreviewButtonClientProps` instead.
   */
  CustomComponent as CustomSaveButton,
  /**
   * @deprecated
   * The `CustomSaveDraftButton` type is deprecated and will be removed in the next major version.
   * This type is only used for the Payload Config. Use `PreviewButtonClientProps` instead.
   */
  CustomComponent as CustomSaveDraftButton,
} from '../config/types.js'
export type { DefaultCellComponentProps, DefaultServerCellComponentProps } from './elements/Cell.js'
export type { ConditionalDateProps } from './elements/DatePicker.js'
export type { DayPickerProps, SharedProps, TimePickerProps } from './elements/DatePicker.js'
export type { NavGroupPreferences, NavPreferences } from './elements/Nav.js'
export type {
  PreviewButtonClientProps,
  PreviewButtonServerProps,
  PreviewButtonServerPropsOnly,
} from './elements/PreviewButton.js'
export type {
  PublishButtonClientProps,
  PublishButtonServerProps,
  PublishButtonServerPropsOnly,
} from './elements/PublishButton.js'
export type {
  SaveButtonClientProps,
  SaveButtonServerProps,
  SaveButtonServerPropsOnly,
} from './elements/SaveButton.js'
export type {
  SaveDraftButtonClientProps,
  SaveDraftButtonServerProps,
  SaveDraftButtonServerPropsOnly,
} from './elements/SaveDraftButton.js'

export type { Column } from './elements/Table.js'

export type { CustomUpload } from './elements/Upload.js'

export type {
  WithServerSidePropsComponent,
  WithServerSidePropsComponentProps,
} from './elements/WithServerSideProps.js'

export type {
  ArrayFieldClientComponent,
  ArrayFieldClientProps,
  ArrayFieldDescriptionClientComponent,
  ArrayFieldDescriptionServerComponent,
  ArrayFieldDiffClientComponent,
  ArrayFieldDiffServerComponent,
  ArrayFieldErrorClientComponent,
  ArrayFieldErrorServerComponent,
  ArrayFieldLabelClientComponent,
  ArrayFieldLabelServerComponent,
  ArrayFieldServerComponent,
  ArrayFieldServerProps,
} from './fields/Array.js'

export type {
  BlockRowLabelClientComponent,
  BlockRowLabelServerComponent,
  BlocksFieldClientComponent,
  BlocksFieldClientProps,
  BlocksFieldDescriptionClientComponent,
  BlocksFieldDescriptionServerComponent,
  BlocksFieldDiffClientComponent,
  BlocksFieldDiffServerComponent,
  BlocksFieldErrorClientComponent,
  BlocksFieldErrorServerComponent,
  BlocksFieldLabelClientComponent,
  BlocksFieldLabelServerComponent,
  BlocksFieldServerComponent,
  BlocksFieldServerProps,
} from './fields/Blocks.js'

export type {
  CheckboxFieldClientComponent,
  CheckboxFieldClientProps,
  CheckboxFieldDescriptionClientComponent,
  CheckboxFieldDescriptionServerComponent,
  CheckboxFieldDiffClientComponent,
  CheckboxFieldDiffServerComponent,
  CheckboxFieldErrorClientComponent,
  CheckboxFieldErrorServerComponent,
  CheckboxFieldLabelClientComponent,
  CheckboxFieldLabelServerComponent,
  CheckboxFieldServerComponent,
  CheckboxFieldServerProps,
} from './fields/Checkbox.js'

export type {
  CodeFieldClientComponent,
  CodeFieldClientProps,
  CodeFieldDescriptionClientComponent,
  CodeFieldDescriptionServerComponent,
  CodeFieldDiffClientComponent,
  CodeFieldDiffServerComponent,
  CodeFieldErrorClientComponent,
  CodeFieldErrorServerComponent,
  CodeFieldLabelClientComponent,
  CodeFieldLabelServerComponent,
  CodeFieldServerComponent,
  CodeFieldServerProps,
} from './fields/Code.js'

export type {
  CollapsibleFieldClientComponent,
  CollapsibleFieldClientProps,
  CollapsibleFieldDescriptionClientComponent,
  CollapsibleFieldDescriptionServerComponent,
  CollapsibleFieldDiffClientComponent,
  CollapsibleFieldDiffServerComponent,
  CollapsibleFieldErrorClientComponent,
  CollapsibleFieldErrorServerComponent,
  CollapsibleFieldLabelClientComponent,
  CollapsibleFieldLabelServerComponent,
  CollapsibleFieldServerComponent,
  CollapsibleFieldServerProps,
} from './fields/Collapsible.js'

export type {
  DateFieldClientComponent,
  DateFieldClientProps,
  DateFieldDescriptionClientComponent,
  DateFieldDescriptionServerComponent,
  DateFieldDiffClientComponent,
  DateFieldDiffServerComponent,
  DateFieldErrorClientComponent,
  DateFieldErrorServerComponent,
  DateFieldLabelClientComponent,
  DateFieldLabelServerComponent,
  DateFieldServerComponent,
  DateFieldServerProps,
} from './fields/Date.js'

export type {
  EmailFieldClientComponent,
  EmailFieldClientProps,
  EmailFieldDescriptionClientComponent,
  EmailFieldDescriptionServerComponent,
  EmailFieldDiffClientComponent,
  EmailFieldDiffServerComponent,
  EmailFieldErrorClientComponent,
  EmailFieldErrorServerComponent,
  EmailFieldLabelClientComponent,
  EmailFieldLabelServerComponent,
  EmailFieldServerComponent,
  EmailFieldServerProps,
} from './fields/Email.js'

export type {
  GroupFieldClientComponent,
  GroupFieldClientProps,
  GroupFieldDescriptionClientComponent,
  GroupFieldDescriptionServerComponent,
  GroupFieldDiffClientComponent,
  GroupFieldDiffServerComponent,
  GroupFieldErrorClientComponent,
  GroupFieldErrorServerComponent,
  GroupFieldLabelClientComponent,
  GroupFieldLabelServerComponent,
  GroupFieldServerComponent,
  GroupFieldServerProps,
} from './fields/Group.js'

export type { HiddenFieldProps } from './fields/Hidden.js'

export type {
  JoinFieldClientComponent,
  JoinFieldClientProps,
  JoinFieldDescriptionClientComponent,
  JoinFieldDescriptionServerComponent,
  JoinFieldDiffClientComponent,
  JoinFieldDiffServerComponent,
  JoinFieldErrorClientComponent,
  JoinFieldErrorServerComponent,
  JoinFieldLabelClientComponent,
  JoinFieldLabelServerComponent,
  JoinFieldServerComponent,
  JoinFieldServerProps,
} from './fields/Join.js'

export type {
  JSONFieldClientComponent,
  JSONFieldClientProps,
  JSONFieldDescriptionClientComponent,
  JSONFieldDescriptionServerComponent,
  JSONFieldDiffClientComponent,
  JSONFieldDiffServerComponent,
  JSONFieldErrorClientComponent,
  JSONFieldErrorServerComponent,
  JSONFieldLabelClientComponent,
  JSONFieldLabelServerComponent,
  JSONFieldServerComponent,
  JSONFieldServerProps,
} from './fields/JSON.js'

export type {
  NumberFieldClientComponent,
  NumberFieldClientProps,
  NumberFieldDescriptionClientComponent,
  NumberFieldDescriptionServerComponent,
  NumberFieldDiffClientComponent,
  NumberFieldDiffServerComponent,
  NumberFieldErrorClientComponent,
  NumberFieldErrorServerComponent,
  NumberFieldLabelClientComponent,
  NumberFieldLabelServerComponent,
  NumberFieldServerComponent,
  NumberFieldServerProps,
} from './fields/Number.js'

export type {
  PointFieldClientComponent,
  PointFieldClientProps,
  PointFieldDescriptionClientComponent,
  PointFieldDescriptionServerComponent,
  PointFieldDiffClientComponent,
  PointFieldDiffServerComponent,
  PointFieldErrorClientComponent,
  PointFieldErrorServerComponent,
  PointFieldLabelClientComponent,
  PointFieldLabelServerComponent,
  PointFieldServerComponent,
  PointFieldServerProps,
} from './fields/Point.js'

export type {
  RadioFieldClientComponent,
  RadioFieldClientProps,
  RadioFieldDescriptionClientComponent,
  RadioFieldDescriptionServerComponent,
  RadioFieldDiffClientComponent,
  RadioFieldDiffServerComponent,
  RadioFieldErrorClientComponent,
  RadioFieldErrorServerComponent,
  RadioFieldLabelClientComponent,
  RadioFieldLabelServerComponent,
  RadioFieldServerComponent,
  RadioFieldServerProps,
} from './fields/Radio.js'

export type {
  RelationshipFieldClientComponent,
  RelationshipFieldClientProps,
  RelationshipFieldDescriptionClientComponent,
  RelationshipFieldDescriptionServerComponent,
  RelationshipFieldDiffClientComponent,
  RelationshipFieldDiffServerComponent,
  RelationshipFieldErrorClientComponent,
  RelationshipFieldErrorServerComponent,
  RelationshipFieldLabelClientComponent,
  RelationshipFieldLabelServerComponent,
  RelationshipFieldServerComponent,
  RelationshipFieldServerProps,
} from './fields/Relationship.js'

export type {
  RichTextFieldClientComponent,
  RichTextFieldClientProps,
  RichTextFieldDescriptionClientComponent,
  RichTextFieldDescriptionServerComponent,
  RichTextFieldDiffClientComponent,
  RichTextFieldDiffServerComponent,
  RichTextFieldErrorClientComponent,
  RichTextFieldErrorServerComponent,
  RichTextFieldLabelClientComponent,
  RichTextFieldLabelServerComponent,
  RichTextFieldServerComponent,
  RichTextFieldServerProps,
} from './fields/RichText.js'

export type {
  RowFieldClientComponent,
  RowFieldClientProps,
  RowFieldDescriptionClientComponent,
  RowFieldDescriptionServerComponent,
  RowFieldDiffClientComponent,
  RowFieldDiffServerComponent,
  RowFieldErrorClientComponent,
  RowFieldErrorServerComponent,
  RowFieldLabelClientComponent,
  RowFieldLabelServerComponent,
  RowFieldServerComponent,
  RowFieldServerProps,
} from './fields/Row.js'

export type {
  SelectFieldClientComponent,
  SelectFieldClientProps,
  SelectFieldDescriptionClientComponent,
  SelectFieldDescriptionServerComponent,
  SelectFieldDiffClientComponent,
  SelectFieldDiffServerComponent,
  SelectFieldErrorClientComponent,
  SelectFieldErrorServerComponent,
  SelectFieldLabelClientComponent,
  SelectFieldLabelServerComponent,
  SelectFieldServerComponent,
  SelectFieldServerProps,
} from './fields/Select.js'

export type {
  ClientTab,
  TabsFieldClientComponent,
  TabsFieldClientProps,
  TabsFieldDescriptionClientComponent,
  TabsFieldDescriptionServerComponent,
  TabsFieldDiffClientComponent,
  TabsFieldDiffServerComponent,
  TabsFieldErrorClientComponent,
  TabsFieldErrorServerComponent,
  TabsFieldLabelClientComponent,
  TabsFieldLabelServerComponent,
  TabsFieldServerComponent,
  TabsFieldServerProps,
} from './fields/Tabs.js'

export type {
  TextFieldClientComponent,
  TextFieldClientProps,
  TextFieldDescriptionClientComponent,
  TextFieldDescriptionServerComponent,
  TextFieldDiffClientComponent,
  TextFieldDiffServerComponent,
  TextFieldErrorClientComponent,
  TextFieldErrorServerComponent,
  TextFieldLabelClientComponent,
  TextFieldLabelServerComponent,
  TextFieldServerComponent,
  TextFieldServerProps,
} from './fields/Text.js'

export type {
  TextareaFieldClientComponent,
  TextareaFieldClientProps,
  TextareaFieldDescriptionClientComponent,
  TextareaFieldDescriptionServerComponent,
  TextareaFieldDiffClientComponent,
  TextareaFieldDiffServerComponent,
  TextareaFieldErrorClientComponent,
  TextareaFieldErrorServerComponent,
  TextareaFieldLabelClientComponent,
  TextareaFieldLabelServerComponent,
  TextareaFieldServerComponent,
  TextareaFieldServerProps,
} from './fields/Textarea.js'

export type {
  UIFieldClientComponent,
  UIFieldClientProps,
  UIFieldDiffClientComponent,
  UIFieldDiffServerComponent,
  UIFieldServerComponent,
  UIFieldServerProps,
} from './fields/UI.js'

export type {
  UploadFieldClientComponent,
  UploadFieldClientProps,
  UploadFieldDescriptionClientComponent,
  UploadFieldDescriptionServerComponent,
  UploadFieldDiffClientComponent,
  UploadFieldDiffServerComponent,
  UploadFieldErrorClientComponent,
  UploadFieldErrorServerComponent,
  UploadFieldLabelClientComponent,
  UploadFieldLabelServerComponent,
  UploadFieldServerComponent,
  UploadFieldServerProps,
} from './fields/Upload.js'

export type {
  Description,
  DescriptionFunction,
  FieldDescriptionClientComponent,
  FieldDescriptionClientProps,
  FieldDescriptionServerComponent,
  FieldDescriptionServerProps,
  GenericDescriptionProps,
  StaticDescription,
} from './forms/Description.js'

export type {
  BaseVersionField,
  DiffMethod,
  FieldDiffClientComponent,
  FieldDiffClientProps,
  FieldDiffServerComponent,
  FieldDiffServerProps,
  VersionField,
  VersionTab,
} from './forms/Diff.js'

export type {
  BuildFormStateArgs,
  Data,
  FieldState as FormField,
  FieldStateWithoutComponents as FormFieldWithoutComponents,
  FilterOptionsResult,
  FormState,
  FormStateWithoutComponents,
  Row,
}

export type {
  FieldErrorClientComponent,
  FieldErrorClientProps,
  FieldErrorServerComponent,
  FieldErrorServerProps,
  GenericErrorProps,
} from './forms/Error.js'

export type {
  ClientComponentProps,
  ClientFieldBase,
  ClientFieldWithOptionalType,
  FieldClientComponent,
  FieldPaths,
  FieldServerComponent,
  ServerComponentProps,
  ServerFieldBase,
} from './forms/Field.js'

export type {
  FieldLabelClientComponent,
  FieldLabelClientProps,
  FieldLabelServerComponent,
  FieldLabelServerProps,
  GenericLabelProps,
  SanitizedLabelProps,
} from './forms/Label.js'

export type { RowLabel, RowLabelComponent } from './forms/RowLabel.js'

export type MappedServerComponent<TComponentClientProps extends JsonObject = JsonObject> = {
  Component?: React.ComponentType<TComponentClientProps>
  props?: Partial<any>
  RenderedComponent: React.ReactNode
  type: 'server'
}

export type MappedClientComponent<TComponentClientProps extends JsonObject = JsonObject> = {
  Component?: React.ComponentType<TComponentClientProps>
  props?: Partial<TComponentClientProps>
  RenderedComponent?: React.ReactNode
  type: 'client'
}

export type MappedEmptyComponent = {
  type: 'empty'
}

export enum Action {
  RenderConfig = 'render-config',
}

export type RenderEntityConfigArgs = {
  collectionSlug?: string
  data?: Data
  globalSlug?: string
}

export type RenderRootConfigArgs = {}

export type RenderFieldConfigArgs = {
  collectionSlug?: string
  formState?: FormState
  globalSlug?: string
  schemaPath: string
}

export type RenderConfigArgs = {
  action: Action.RenderConfig
  config: Promise<SanitizedConfig> | SanitizedConfig
  i18n: I18nClient
  importMap: ImportMap
  languageCode: AcceptedLanguages
  serverProps?: any
} & (RenderEntityConfigArgs | RenderFieldConfigArgs | RenderRootConfigArgs)

export type PayloadServerAction = (
  args:
    | {
        [key: string]: any
        action: Action
        i18n: I18nClient
      }
    | RenderConfigArgs,
) => Promise<string>

export type RenderedField = {
  Field: React.ReactNode
  indexPath?: string
  initialSchemaPath?: string
  /**
   * @deprecated
   * This is a legacy property that will be removed in v4.
   * Please use `fieldIsSidebar(field)` from `payload` instead.
   * Or check `field.admin.position === 'sidebar'` directly.
   */
  isSidebar: boolean
  path: string
  schemaPath: string
  type: FieldTypes
}

export type FieldRow = {
  RowLabel?: React.ReactNode
}

export type DocumentSlots = {
  Description?: React.ReactNode
  PreviewButton?: React.ReactNode
  PublishButton?: React.ReactNode
  SaveButton?: React.ReactNode
  SaveDraftButton?: React.ReactNode
  Upload?: React.ReactNode
}

export type {
  BuildTableStateArgs,
  DefaultServerFunctionArgs,
  ListQuery,
  ServerFunction,
  ServerFunctionArgs,
  ServerFunctionClient,
  ServerFunctionClientArgs,
  ServerFunctionConfig,
  ServerFunctionHandler,
} from './functions/index.js'

export type { LanguageOptions } from './LanguageOptions.js'

export type { RichTextAdapter, RichTextAdapterProvider, RichTextHooks } from './RichText.js'

export type {
  DocumentSubViewTypes,
  DocumentTabClientProps,
  /**
   * @deprecated
   * The `DocumentTabComponent` type is deprecated and will be removed in the next major version.
   * Use `DocumentTabServerProps`or `DocumentTabClientProps` instead.
   */
  DocumentTabComponent,
  DocumentTabCondition,
  DocumentTabConfig,
  /**
   * @deprecated
   * The `DocumentTabProps` type is deprecated and will be removed in the next major version.
   * Use `DocumentTabServerProps` instead.
   */
  DocumentTabServerProps as DocumentTabProps,
  DocumentTabServerProps,
  DocumentTabServerPropsOnly,
  /**
   * @deprecated
   * The `ClientSideEditViewProps` type is deprecated and will be removed in the next major version.
   * Use `DocumentViewClientProps` instead.
   */
  DocumentViewClientProps as ClientSideEditViewProps,
  DocumentViewClientProps,
  /**
   * @deprecated
   * The `ServerSideEditViewProps` is deprecated and will be removed in the next major version.
   * Use `DocumentViewServerProps` instead.
   */
  DocumentViewServerProps as ServerSideEditViewProps,
  DocumentViewServerProps,
  DocumentViewServerPropsOnly,
  EditViewProps,
} from './views/document.js'

export type {
  AdminViewClientProps,
  /**
   * @deprecated
   * The `AdminViewComponent` type is deprecated and will be removed in the next major version.
   * Type your component props directly instead.
   */
  AdminViewComponent,
  AdminViewConfig,
  /**
   * @deprecated
   * The `AdminViewProps` type is deprecated and will be removed in the next major version.
   * Use `AdminViewServerProps` instead.
   */
  AdminViewServerProps as AdminViewProps,
  AdminViewServerProps,
  AdminViewServerPropsOnly,
  InitPageResult,
  ServerPropsFromView,
  ViewDescriptionClientProps,
  ViewDescriptionServerProps,
  ViewDescriptionServerPropsOnly,
  ViewTypes,
  VisibleEntities,
} from './views/index.js'

export type {
  AfterListClientProps,
  AfterListServerProps,
  AfterListServerPropsOnly,
  AfterListTableClientProps,
  AfterListTableServerProps,
  AfterListTableServerPropsOnly,
  BeforeListClientProps,
  BeforeListServerProps,
  BeforeListServerPropsOnly,
  BeforeListTableClientProps,
  BeforeListTableServerProps,
  BeforeListTableServerPropsOnly,
  ListViewClientProps,
  ListViewServerProps,
  ListViewServerPropsOnly,
  ListViewSlots,
  ListViewSlotSharedClientProps,
} from './views/list.js'

type SchemaPath = {} & string
export type FieldSchemaMap = Map<
  SchemaPath,
  | {
      fields: Field[]
    }
  | Block
  | Field
  | Tab
>

export type ClientFieldSchemaMap = Map<
  SchemaPath,
  | {
      fields: ClientField[]
    }
  | ClientBlock
  | ClientField
  | ClientTab
>

export type DocumentEvent = {
  entitySlug: string
  id?: number | string
  updatedAt: string
}
</file>

<file path="packages/payload/src/assets/images/generic-block-image.svg">
<svg width="82" height="53" viewBox="0 0 82 53" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<rect x="0.713013" width="80.574" height="52.7791" fill="url(#pattern0)"/>
<defs>
<pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0" transform="scale(0.00387597 0.00591716)"/>
</pattern>
<image id="image0" width="258" height="169" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQIAAACpCAYAAADA4zPJAAALpklEQVR4Ae2dSY/UOhSF+///DCSGHQuEgAVI7BBITAI2zCCGZuhmpqEBP53W8yOvK1UdO3Zyr/NFilJdXalyTo4/X984zlZgQQEUWLwCW4tXAAFQAAUCIMAEKIACgAAPoAAKBECACVAABQABHkABFAiAABOgAAoAAjyAAiggBbhqgA9QAAUAAR5AARQgIsADKIACdA3wAAqggBQgR4APUAAFAAEeQAEUICLAAyiAAnQN8AAKoIAUIEeAD1AABQABHkABFCAiwAMogAJ0DfAACqCAFCBHgA9QAAUAAR5AARQgIsADKIACdA3wAAqggBQgR4APUAAFAAEeQAEUICLAAyiAAnQN8AAKoIAUIEeAD1AABQABHkABFCAiwAMogAJ0DfAACqCAFCBHgA9QAAUAAR5AARQgIsADKIACdA3wAAqggBQgR4APUAAFAAEeQAEUICLAAyiAAnQN8AAKoIAUIEeAD1AABQABHkABFCAiwAMLVmB/fz98+/YtfPr0KXz48CHs7u6GnZ2dg+3Hjx/D169fw48fP8KfP3+aV4muQfOnmAPsKqDKr4r/9u3bsL29PXgVKPb29pqFAiDouoTXzSrw8+fPg5Y+pfL3ffbdu3fh+/fvzekECJo7pRxQVwGF9YoA+ir1mPfUhVB00coCCFo5kxzHigKqqGrBx1T4Tfu+efOmmegAEKzYhzdaUEBdAVXUTRW51P+UVPS+AALvZ5DyryigSGAqCESYeIcBIFixEW94VuDXr1/JVwRiZR671VUFrwsg8HrmKPeKAkoMKok3tkLn7q8oRCDyuAACj2eNMvcqoMFBuZW41H4alORxAQQezxplXlHg9+/fk+cF1sHDYxcBEKxYijc8KvDly5fZo4EIhvfv37uTEBC4O2UU+LACyg2kDhmOlbbWVpcvPS2AwNPZoqy9CigUr1Whc79Xoxk9LYDA09mirL0K1BhCnAuAuJ8iFE8LIPB0tihrrwI1hxHHip2z9XQpERD0Wos3vSig/EBOJZ1iH09XDwCBF8dTzl4FNJx4ikqd8xu6kuFlAQRezhTl7FVAMwjlVNIp9vn8+XNvmS2+aR4E6md56mtZPMktl8niFYMIGU9XDkyDQCdZ47e1eupvtVzxrB0bEUGZM2ISBEoAafLISNa4FWH1PxYUiApo4E70h7UtOYJ4ljK2OrGbLgfpfy1NEZUhEbt0FNA9BtYAEMvjaW5DMxGBWnpN7hBFPGrrfSKIjpd5OVIBa8OLo3c9DTM2AQJRXbdvRgGHbrWP9mVZtgKaanyoZ6b6nPJanrqxs4MgJgRzTxCJxGVDQEevEDzXP7X2E5w8LbOBQLQsOUZ8TCLx9evX4fHjx+HRo0esTjW4efNmKL3eu3cvyBs5sPB2lWsWENSaZlr3gacmEi9fvhyOHTvGiga9Hjh79mwyDJSz8NQtUOQyOQhSEoI5JNY+mrJqyPLy5cvekw8YAGPXA7du3UqKCob6b4hHp/rMZCDITQjmwmBIIvH+/fuAgEjgSA9cuXJlMAh0edtbNCDYTAICjf6a4xKPflO/vW4BBLT83ZZ/3esUEHi6ZNitF1VBIDLqxovcVr3UfipDH6UBASBYV/m77w8FgaeRhF0I6HU1EChpp+Rdqco89nv6EomAABB0K/y610NAoCHxfY3N4Qpn9e8qILAwv3wfODTmoJvIef78+ZH9w3Xm4P3lQOTGjRsbGzSNGfAMgeIRgRKCFkd5HYaCyqiyaj1//jwwIGG41gOnT58Ourp02EPx7zHjVyxFB8UigrkSgvGEpG5jIlEw0ECiO3fusDaowe3bt8PVq1eDwvvU9fr162sh0NqI1tEgsJIQTAVB/Py6RKIlWlOWcQrIo+oSlrpypShADUhLyygQaOYgSwnBWLlTtzoGZkFqydb9xxKBkONZQUSNRqs+yQaBbvRQeJRa6ax+Xsfi6f7xfqvz7lAFVKEVJSjbLzCookc/a6uBQcol6ZKgxgZ4TwYepUsyCBQSeUgI5gJHxmgt7DvKBPwfBZJAIDKW6mflVtQp9tMxeh0hhqVRIEeBQSBQWKQQaYpKaOk3dMyth4Q5pmGf9hQ4EgTqS+3s7CwOAhFIOvZWE0Tt2ZkjylVgIwhaSwjGyp26JZGYay/286JALwiULOubTjy1ArX2ee/jyb2YknJOr8AKCJQk06WT1ipxqeORNiQSpzcqv1hXgf9AsNSEYC4gSCTWNSbfPq0CByBYekIwFwYkEqc1K79WT4GtsdOJ51aiVvZTItHbjLX17MQ3e1Vgq5UKOfdxtHI7ajSy7iYlFxLVaH8LCLa3iyVGlUhMnU7dmsWUK+pOL6dZpxlUZe0slS8PICgIghiV6F4M3ct+6dIlV+vFixcPJmo5d+5c6K4XLlwI+p/l47l27RpdtBF8AAQVQHDmzJm1M94wxVm9Kc6kOzeM5dEAEBQGgR6dRmWvV9mP0lbdM5Z0BQBBYRA8ePAAEMw4B6KeVciSrgAgAARNgQsQpENAewACQAAI8upOU3sBgsIgePjwYVMV66g+ubX/ExHk8QkQFAaB5sA/ceIEMJghT3D8+HHmnczjAF2DeO2/5Pbu3bvh1KlTwGBCGJw8eTI8efIksxqwGxFB4YggAuXVq1fh2bNn4enTp0euL168OJj/QaP4Sq26O1JzLw75/Rqf0czApY5lyPcwfmAczABBJRBEIAzd6ual7nMZx5xWK3eTxkfLjTkW9p1GAUBgBAQRGGMrj7W7SRWV6AYmFtsKAAJjIBAQciqPbgyyPL0cj5YDBMXu7out5lK2QyuPl+nleLScXRgQERiMCLqg2zQLkqIAJdK6n7f+mhmhbcIAEBgHgSp2X+VRlnx3d9cVBLqQGpsLsVmd/JYKEDgAQaxA8bmM1hKCsXypWx4tZwccgMARCFTRFB2kVjjrn2dG6PmBAAicgcB6pc4t36ZcyPzVpP0SAAJAYCbC6MuFtF8FbRwhIAAEZkAQowkeLTc9HAABIDAHAgGBR8tNCwNAAAhMgiBGByQSpwECIAAEpkEgIJBIrA8DQAAIzINAMFAikUfL1QMCIAAELkAQuwqtPVquXtVO+2ZAAAhcgUBAaOHRcmnVtP6nAQEgcAeCGB3ohiuWMgoAAkDgFgQCgm68Ypqy8TAABIDANQgEAxKJgMC9iWOYy3b84+lJJOYDgYiAiKApmGoWpP39/fwasdA9AQEgaAoEMbIqNSP0UrgACABBkyAQEEgkDscYIAAEzYJAMMiZEXp49Wnnk4AAEDQNgthVGDojdDtVO+1IAAEgWAQIBAQSievhAAgAwWJAIBhozAGJxFUgAAJAsCgQxK4C06n/HwaAABAsEgQCAonEvzAABIBgsSCI0QGJxBAAASBYPAgEhKU/lxEQAAJA8K8HljydOiAABIDgkAfio+X+9qDbfwUIDpkg9hvZjr8b0LOGS3suIyAABEQEGzywlOnUAcEGE3hu0Sh7uYhmCdOpAwJAQEQwwAOtJxIBwQAT0LqWa129a9nqcxkBASAgIkj0QIvPZQQEiSbw3qJR/nLRTUuJREAACIgIRniglUQiIBhhAlrXcq2rZy1bmE4dEAACIoJCHvA8nTogKGQCzy0aZS8X2Xh9LiMgAAREBBU84O25jICgggloYcu1sJ619DSdOiAABEQEFT3gJZEICCqawHNrRtnLRjXWE4mAABAQEUzkAcvTqQOCiUxAC1u2hfWsp8Xp1AEBICAimMED1hKJgGAGE3huzSh7ucjG0nTqgAAQEBHM7AEL06kDgplNQAtbroX1rOXciURAAAiICIx4QGMO5kokAgIjJvDcmlH2slHNHM9lBASAgIjAoAemTiQCAoMmoIUt28J61nOqRCIgAAREBMY9MMUsSIDAuAk8t2aUvVxkU3s6dUAACIgIHHmg1nMZAYEjE9DClmthPWtZYzp1QAAIiAiceqDkdOqAwKkJPLdolL1cZFMqkbilkUysaIAH/Hpgb28vjF3+AbSb48mcXO9tAAAAAElFTkSuQmCC"/>
</defs>
</svg>
</file>

<file path="packages/payload/src/assets/assets.d.ts">
declare module '*.svg' {
  import React = require('react')

  export const ReactComponent: React.SFC<React.SVGProps<SVGSVGElement>>
  const src: string
  export default src
}

declare module '*.jpg' {
  const content: string
  export default content
}

declare module '*.png' {
  const content: string
  export default content
}

declare module '*.json' {
  const content: string
  export default content
}
</file>

<file path="packages/payload/src/auth/baseFields/accountLock.ts">
import type { Field } from '../../fields/config/types.js'

export const accountLockFields: Field[] = [
  {
    name: 'loginAttempts',
    type: 'number',
    defaultValue: 0,
    hidden: true,
  },
  {
    name: 'lockUntil',
    type: 'date',
    hidden: true,
  },
] as Field[]
</file>

<file path="packages/payload/src/auth/baseFields/apiKey.ts">
import crypto from 'crypto'

import type { Field, FieldHook } from '../../fields/config/types.js'

const encryptKey: FieldHook = ({ req, value }) =>
  value ? req.payload.encrypt(value as string) : null
const decryptKey: FieldHook = ({ req, value }) =>
  value ? req.payload.decrypt(value as string) : undefined

export const apiKeyFields = [
  {
    name: 'enableAPIKey',
    type: 'checkbox',
    admin: {
      components: {
        Field: false,
      },
    },
    label: ({ t }) => t('authentication:enableAPIKey'),
  },
  {
    name: 'apiKey',
    type: 'text',
    admin: {
      components: {
        Field: false,
      },
    },
    hooks: {
      afterRead: [decryptKey],
      beforeChange: [encryptKey],
    },
    label: ({ t }) => t('authentication:apiKey'),
  },
  {
    name: 'apiKeyIndex',
    type: 'text',
    admin: {
      disabled: true,
    },
    hidden: true,
    hooks: {
      beforeValidate: [
        ({ data, req, value }) => {
          if (data?.apiKey === false || data?.apiKey === null) {
            return null
          }
          if (data?.enableAPIKey === false || data?.enableAPIKey === null) {
            return null
          }
          if (data?.apiKey) {
            return crypto
              .createHmac('sha1', req.payload.secret)
              .update(data.apiKey as string)
              .digest('hex')
          }
          return value
        },
      ],
    },
  },
] as Field[]
</file>

<file path="packages/payload/src/auth/baseFields/auth.ts">
import type { Field } from '../../fields/config/types.js'

export const baseAuthFields: Field[] = [
  {
    name: 'resetPasswordToken',
    type: 'text',
    hidden: true,
  },
  {
    name: 'resetPasswordExpiration',
    type: 'date',
    hidden: true,
  },
  {
    name: 'salt',
    type: 'text',
    hidden: true,
  },
  {
    name: 'hash',
    type: 'text',
    hidden: true,
  },
]
</file>

<file path="packages/payload/src/auth/baseFields/email.ts">
import type { EmailField } from '../../fields/config/types.js'

import { email } from '../../fields/validations.js'

export const emailFieldConfig: EmailField = {
  name: 'email',
  type: 'email',
  admin: {
    components: {
      Field: false,
    },
  },
  hooks: {
    beforeChange: [
      ({ value }) => {
        if (value) {
          return value.toLowerCase().trim()
        }
      },
    ],
  },
  label: ({ t }) => t('general:email'),
  required: true,
  unique: true,
  validate: email,
}
</file>

<file path="packages/payload/src/auth/baseFields/username.ts">
import type { TextField } from '../../fields/config/types.js'

import { username } from '../../fields/validations.js'

export const usernameFieldConfig: TextField = {
  name: 'username',
  type: 'text',
  admin: {
    components: {
      Field: false,
    },
  },
  hooks: {
    beforeChange: [
      ({ value }) => {
        if (value) {
          return value.toLowerCase().trim()
        }
      },
    ],
  },
  label: ({ t }) => t('authentication:username'),
  required: true,
  unique: true,
  validate: username,
}
</file>

<file path="packages/payload/src/auth/baseFields/verification.ts">
import type { Field, FieldHook } from '../../fields/config/types.js'

const autoRemoveVerificationToken: FieldHook = ({ data, operation, originalDoc, value }) => {
  // If a user manually sets `_verified` to true,
  // and it was `false`, set _verificationToken to `null`.
  // This is useful because the admin panel
  // allows users to set `_verified` to true manually

  if (operation === 'update') {
    if (data?._verified === true && originalDoc?._verified === false) {
      return null
    }
  }

  return value
}

export const verificationFields: Field[] = [
  {
    name: '_verified',
    type: 'checkbox',
    access: {
      create: ({ req: { user } }) => Boolean(user),
      read: ({ req: { user } }) => Boolean(user),
      update: ({ req: { user } }) => Boolean(user),
    },
    admin: {
      components: {
        Field: false,
      },
    },
    label: ({ t }) => t('authentication:verified'),
  },
  {
    name: '_verificationToken',
    type: 'text',
    hidden: true,
    hooks: {
      beforeChange: [autoRemoveVerificationToken],
    },
  },
] as Field[]
</file>

<file path="packages/payload/src/auth/endpoints/access.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { headersWithCors } from '../../utilities/headersWithCors.js'
import { accessOperation } from '../operations/access.js'

export const accessHandler: PayloadHandler = async (req) => {
  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  try {
    const results = await accessOperation({
      req,
    })

    return Response.json(results, {
      headers,
      status: httpStatus.OK,
    })
  } catch (e: unknown) {
    return Response.json(
      {
        error: e,
      },
      {
        headers,
        status: httpStatus.INTERNAL_SERVER_ERROR,
      },
    )
  }
}
</file>

<file path="packages/payload/src/auth/endpoints/forgotPassword.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { forgotPasswordOperation } from '../operations/forgotPassword.js'

export const forgotPasswordHandler: PayloadHandler = async (req) => {
  const { t } = req

  const collection = getRequestCollection(req)

  const authData = collection.config.auth?.loginWithUsername
    ? {
        email: typeof req.data?.email === 'string' ? req.data.email : '',
        username: typeof req.data?.username === 'string' ? req.data.username : '',
      }
    : {
        email: typeof req.data?.email === 'string' ? req.data.email : '',
      }

  await forgotPasswordOperation({
    collection,
    data: authData,
    disableEmail: Boolean(req.data?.disableEmail),
    expiration: typeof req.data.expiration === 'number' ? req.data.expiration : undefined,
    req,
  })

  return Response.json(
    {
      message: t('general:success'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/index.ts">
import type { Endpoint } from '../../config/types.js'

import { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'
import { accessHandler } from './access.js'
import { forgotPasswordHandler } from './forgotPassword.js'
import { initHandler } from './init.js'
import { loginHandler } from './login.js'
import { logoutHandler } from './logout.js'
import { meHandler } from './me.js'
import { refreshHandler } from './refresh.js'
import { registerFirstUserHandler } from './registerFirstUser.js'
import { resetPasswordHandler } from './resetPassword.js'
import { unlockHandler } from './unlock.js'
import { verifyEmailHandler } from './verifyEmail.js'

export const authRootEndpoints: Endpoint[] = wrapInternalEndpoints([
  {
    handler: accessHandler,
    method: 'get',
    path: '/access',
  },
])

export const authCollectionEndpoints: Endpoint[] = wrapInternalEndpoints([
  {
    handler: forgotPasswordHandler,
    method: 'post',
    path: '/forgot-password',
  },
  {
    handler: initHandler,
    method: 'get',
    path: '/init',
  },
  {
    handler: loginHandler,
    method: 'post',
    path: '/login',
  },
  {
    handler: logoutHandler,
    method: 'post',
    path: '/logout',
  },
  {
    handler: meHandler,
    method: 'get',
    path: '/me',
  },
  {
    handler: refreshHandler,
    method: 'post',
    path: '/refresh-token',
  },
  {
    handler: registerFirstUserHandler,
    method: 'post',
    path: '/first-register',
  },
  {
    handler: resetPasswordHandler,
    method: 'post',
    path: '/reset-password',
  },
  {
    handler: unlockHandler,
    method: 'post',
    path: '/unlock',
  },
  {
    handler: verifyEmailHandler,
    method: 'post',
    path: '/verify/:id',
  },
])
</file>

<file path="packages/payload/src/auth/endpoints/init.ts">
import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { initOperation } from '../operations/init.js'

export const initHandler: PayloadHandler = async (req) => {
  const initialized = await initOperation({
    collection: getRequestCollection(req).config.slug,
    req,
  })

  return Response.json(
    { initialized },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/login.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { generatePayloadCookie } from '../cookies.js'
import { loginOperation } from '../operations/login.js'

export const loginHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { searchParams, t } = req
  const depth = searchParams.get('depth')
  const authData =
    collection.config.auth?.loginWithUsername !== false
      ? {
          email: typeof req.data?.email === 'string' ? req.data.email : '',
          password: typeof req.data?.password === 'string' ? req.data.password : '',
          username: typeof req.data?.username === 'string' ? req.data.username : '',
        }
      : {
          email: typeof req.data?.email === 'string' ? req.data.email : '',
          password: typeof req.data?.password === 'string' ? req.data.password : '',
        }

  const result = await loginOperation({
    collection,
    data: authData,
    depth: isNumber(depth) ? Number(depth) : undefined,
    req,
  })

  const cookie = generatePayloadCookie({
    collectionAuthConfig: collection.config.auth,
    cookiePrefix: req.payload.config.cookiePrefix,
    token: result.token,
  })

  if (collection.config.auth.removeTokenFromResponses) {
    delete result.token
  }

  return Response.json(
    {
      message: t('authentication:passed'),
      ...result,
    },
    {
      headers: headersWithCors({
        headers: new Headers({
          'Set-Cookie': cookie,
        }),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/logout.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { generateExpiredPayloadCookie } from '../cookies.js'
import { logoutOperation } from '../operations/logout.js'

export const logoutHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { t } = req
  const result = await logoutOperation({
    collection,
    req,
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (!result) {
    return Response.json(
      {
        message: t('error:logoutFailed'),
      },
      {
        headers,
        status: httpStatus.BAD_REQUEST,
      },
    )
  }

  const expiredCookie = generateExpiredPayloadCookie({
    collectionAuthConfig: collection.config.auth,
    config: req.payload.config,
    cookiePrefix: req.payload.config.cookiePrefix,
  })

  headers.set('Set-Cookie', expiredCookie)

  return Response.json(
    {
      message: t('authentication:logoutSuccessful'),
    },
    {
      headers,
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/me.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { extractJWT } from '../extractJWT.js'
import { meOperation } from '../operations/me.js'

export const meHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const currentToken = extractJWT(req)

  const result = await meOperation({
    collection,
    currentToken,
    req,
  })

  if (collection.config.auth.removeTokenFromResponses) {
    delete result.token
  }

  return Response.json(
    {
      ...result,
      message: req.t('authentication:account'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/refresh.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { generatePayloadCookie } from '../cookies.js'
import { refreshOperation } from '../operations/refresh.js'

export const refreshHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { t } = req

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  const result = await refreshOperation({
    collection,
    req,
  })

  if (result.setCookie) {
    const cookie = generatePayloadCookie({
      collectionAuthConfig: collection.config.auth,
      cookiePrefix: req.payload.config.cookiePrefix,
      token: result.refreshedToken,
    })

    if (collection.config.auth.removeTokenFromResponses) {
      delete result.refreshedToken
    }

    headers.set('Set-Cookie', cookie)
  }

  return Response.json(
    {
      message: t('authentication:tokenRefreshSuccessful'),
      ...result,
    },
    {
      headers,
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/registerFirstUser.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { generatePayloadCookie } from '../cookies.js'
import { registerFirstUserOperation } from '../operations/registerFirstUser.js'

export const registerFirstUserHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { data, t } = req
  const authData = collection.config.auth?.loginWithUsername
    ? {
        email: typeof req.data?.email === 'string' ? req.data.email : '',
        password: typeof req.data?.password === 'string' ? req.data.password : '',
        username: typeof req.data?.username === 'string' ? req.data.username : '',
      }
    : {
        email: typeof req.data?.email === 'string' ? req.data.email : '',
        password: typeof req.data?.password === 'string' ? req.data.password : '',
      }

  const result = await registerFirstUserOperation({
    collection,
    data: {
      ...data,
      ...authData,
    },
    req,
  })

  const cookie = generatePayloadCookie({
    collectionAuthConfig: collection.config.auth,
    cookiePrefix: req.payload.config.cookiePrefix,
    token: result.token,
  })

  return Response.json(
    {
      exp: result.exp,
      message: t('authentication:successfullyRegisteredFirstUser'),
      token: result.token,
      user: result.user,
    },
    {
      headers: headersWithCors({
        headers: new Headers({
          'Set-Cookie': cookie,
        }),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/resetPassword.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { generatePayloadCookie } from '../cookies.js'
import { resetPasswordOperation } from '../operations/resetPassword.js'

export const resetPasswordHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { searchParams, t } = req
  const depth = searchParams.get('depth')

  const result = await resetPasswordOperation({
    collection,
    data: {
      password: typeof req.data?.password === 'string' ? req.data.password : '',
      token: typeof req.data?.token === 'string' ? req.data.token : '',
    },
    depth: depth ? Number(depth) : undefined,
    req,
  })

  const cookie = generatePayloadCookie({
    collectionAuthConfig: collection.config.auth,
    cookiePrefix: req.payload.config.cookiePrefix,
    token: result.token,
  })

  if (collection.config.auth.removeTokenFromResponses) {
    delete result.token
  }

  return Response.json(
    {
      message: t('authentication:passwordResetSuccessfully'),
      ...result,
    },
    {
      headers: headersWithCors({
        headers: new Headers({
          'Set-Cookie': cookie,
        }),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/unlock.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { unlockOperation } from '../operations/unlock.js'

export const unlockHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { t } = req

  const authData =
    collection.config.auth?.loginWithUsername !== false
      ? {
          email: typeof req.data?.email === 'string' ? req.data.email : '',
          username: typeof req.data?.username === 'string' ? req.data.username : '',
        }
      : {
          email: typeof req.data?.email === 'string' ? req.data.email : '',
        }

  await unlockOperation({
    collection,
    data: authData,
    req,
  })

  return Response.json(
    {
      message: t('general:success'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/endpoints/verifyEmail.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import verifyEmailOperation from '../operations/verifyEmail.js'

export const verifyEmailHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req, { disableSanitize: true })
  const { t } = req
  await verifyEmailOperation({
    collection,
    req,
    token: id,
  })

  return Response.json(
    {
      message: t('authentication:accountVerified'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/auth/operations/local/auth.ts">
import type { Payload } from '../../../index.js'
import type { AuthArgs, AuthResult } from '../auth.js'

import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { auth as authOperation } from '../auth.js'

export const auth = async (payload: Payload, options: AuthArgs): Promise<AuthResult> => {
  const { headers, req } = options

  return await authOperation({
    headers,
    req: await createLocalReq({ req }, payload),
  })
}
</file>

<file path="packages/payload/src/auth/operations/local/forgotPassword.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'
import type { Result } from '../forgotPassword.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { forgotPasswordOperation } from '../forgotPassword.js'

export type Options<T extends CollectionSlug> = {
  collection: T
  context?: RequestContext
  data: {
    email: string
  }
  disableEmail?: boolean
  expiration?: number
  req?: Partial<PayloadRequest>
}

async function localForgotPassword<T extends CollectionSlug>(
  payload: Payload,
  options: Options<T>,
): Promise<Result> {
  const { collection: collectionSlug, data, disableEmail, expiration } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Forgot Password Operation.`,
    )
  }

  return forgotPasswordOperation({
    collection,
    data,
    disableEmail,
    expiration,
    req: await createLocalReq(options, payload),
  })
}

export const forgotPassword = localForgotPassword
</file>

<file path="packages/payload/src/auth/operations/local/index.ts">
import { auth } from './auth.js'
import { forgotPassword } from './forgotPassword.js'
import { login } from './login.js'
import { resetPassword } from './resetPassword.js'
import { unlock } from './unlock.js'
import { verifyEmail } from './verifyEmail.js'

export { auth, forgotPassword, login, resetPassword, unlock, verifyEmail }
</file>

<file path="packages/payload/src/auth/operations/local/login.ts">
import type {
  AuthOperationsFromCollectionSlug,
  CollectionSlug,
  DataFromCollectionSlug,
  Payload,
  RequestContext,
} from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'
import type { Result } from '../login.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { loginOperation } from '../login.js'

export type Options<TSlug extends CollectionSlug> = {
  collection: TSlug
  context?: RequestContext
  data: AuthOperationsFromCollectionSlug<TSlug>['login']
  depth?: number
  fallbackLocale?: string
  locale?: string
  overrideAccess?: boolean
  req?: Partial<PayloadRequest>
  showHiddenFields?: boolean
}

export async function localLogin<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> {
  const {
    collection: collectionSlug,
    data,
    depth,
    overrideAccess = true,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Login Operation.`,
    )
  }

  const args = {
    collection,
    data,
    depth,
    overrideAccess,
    req: await createLocalReq(options, payload),
    showHiddenFields,
  }

  const result = await loginOperation<TSlug>(args)

  if (collection.config.auth.removeTokenFromResponses) {
    delete result.token
  }

  return result
}

export const login = localLogin
</file>

<file path="packages/payload/src/auth/operations/local/resetPassword.ts">
import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'
import type { Result } from '../resetPassword.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { resetPasswordOperation } from '../resetPassword.js'

export type Options<T extends CollectionSlug> = {
  collection: T
  context?: RequestContext
  data: {
    password: string
    token: string
  }
  overrideAccess: boolean
  req?: Partial<PayloadRequest>
}

async function localResetPassword<T extends CollectionSlug>(
  payload: Payload,
  options: Options<T>,
): Promise<Result> {
  const { collection: collectionSlug, data, overrideAccess } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Reset Password Operation.`,
    )
  }

  const result = await resetPasswordOperation({
    collection,
    data,
    overrideAccess,
    req: await createLocalReq(options, payload),
  })

  if (collection.config.auth.removeTokenFromResponses) {
    delete result.token
  }

  return result
}

export const resetPassword = localResetPassword
</file>

<file path="packages/payload/src/auth/operations/local/unlock.ts">
import type {
  AuthOperationsFromCollectionSlug,
  CollectionSlug,
  Payload,
  RequestContext,
} from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { unlockOperation } from '../unlock.js'

export type Options<TSlug extends CollectionSlug> = {
  collection: TSlug
  context?: RequestContext
  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']
  overrideAccess: boolean
  req?: Partial<PayloadRequest>
}

async function localUnlock<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<boolean> {
  const { collection: collectionSlug, data, overrideAccess = true } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Unlock Operation.`,
    )
  }

  return unlockOperation<TSlug>({
    collection,
    data,
    overrideAccess,
    req: await createLocalReq(options, payload),
  })
}

export const unlock = localUnlock
</file>

<file path="packages/payload/src/auth/operations/local/verifyEmail.ts">
import type { CollectionSlug, Payload, RequestContext } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { verifyEmailOperation } from '../verifyEmail.js'

export type Options<T extends CollectionSlug> = {
  collection: T
  context?: RequestContext
  req?: Partial<PayloadRequest>
  token: string
}

async function localVerifyEmail<T extends CollectionSlug>(
  payload: Payload,
  options: Options<T>,
): Promise<boolean> {
  const { collection: collectionSlug, token } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Verify Email Operation.`,
    )
  }

  return verifyEmailOperation({
    collection,
    req: await createLocalReq(options, payload),
    token,
  })
}

export const verifyEmail = localVerifyEmail
</file>

<file path="packages/payload/src/auth/operations/access.ts">
import type { PayloadRequest } from '../../types/index.js'
import type { SanitizedPermissions } from '../types.js'

import { killTransaction } from '../../utilities/killTransaction.js'
import { adminInit as adminInitTelemetry } from '../../utilities/telemetry/events/adminInit.js'
import { getAccessResults } from '../getAccessResults.js'

type Arguments = {
  req: PayloadRequest
}

export const accessOperation = async (args: Arguments): Promise<SanitizedPermissions> => {
  const { req } = args

  adminInitTelemetry(req)

  try {
    return getAccessResults({ req })
  } catch (e: unknown) {
    await killTransaction(req)
    throw e
  }
}
</file>

<file path="packages/payload/src/auth/operations/auth.ts">
import type { SanitizedPermissions, TypedUser } from '../../index.js'
import type { PayloadRequest } from '../../types/index.js'

import { killTransaction } from '../../utilities/killTransaction.js'
import { executeAuthStrategies } from '../executeAuthStrategies.js'
import { getAccessResults } from '../getAccessResults.js'

export type AuthArgs = {
  headers: Request['headers']
  req?: Omit<PayloadRequest, 'user'>
}

export type AuthResult = {
  permissions: SanitizedPermissions
  responseHeaders?: Headers
  user: null | TypedUser
}

export const auth = async (args: Required<AuthArgs>): Promise<AuthResult> => {
  const { headers } = args
  const req = args.req as PayloadRequest
  const { payload } = req

  try {
    const { responseHeaders, user } = await executeAuthStrategies({
      headers,
      payload,
    })

    req.user = user
    req.responseHeaders = responseHeaders

    const permissions = await getAccessResults({
      req,
    })

    return {
      permissions,
      responseHeaders,
      user,
    }
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/forgotPassword.ts">
// @ts-strict-ignore
import crypto from 'crypto'
import { status as httpStatus } from 'http-status'
import { URL } from 'url'

import type {
  AuthOperationsFromCollectionSlug,
  Collection,
} from '../../collections/config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, Where } from '../../types/index.js'

import { buildAfterOperation } from '../../collections/operations/utils.js'
import { APIError } from '../../errors/index.js'
import { Forbidden } from '../../index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { formatAdminURL } from '../../utilities/formatAdminURL.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getLoginOptions } from '../getLoginOptions.js'

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: {
    [key: string]: unknown
  } & AuthOperationsFromCollectionSlug<TSlug>['forgotPassword']
  disableEmail?: boolean
  expiration?: number
  req: PayloadRequest
}

export type Result = string

export const forgotPasswordOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments<TSlug>,
): Promise<null | string> => {
  const loginWithUsername = incomingArgs.collection.config.auth.loginWithUsername
  const { data } = incomingArgs

  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)

  const sanitizedEmail =
    (canLoginWithEmail && (incomingArgs.data.email || '').toLowerCase().trim()) || null
  const sanitizedUsername =
    'username' in data && typeof data?.username === 'string'
      ? data.username.toLowerCase().trim()
      : null

  let args = incomingArgs

  if (incomingArgs.collection.config.auth.disableLocalStrategy) {
    throw new Forbidden(incomingArgs.req.t)
  }
  if (!sanitizedEmail && !sanitizedUsername) {
    throw new APIError(
      `Missing ${loginWithUsername ? 'username' : 'email'}.`,
      httpStatus.BAD_REQUEST,
    )
  }

  try {
    const shouldCommit = await initTransaction(args.req)

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection?.config,
            context: args.req.context,
            operation: 'forgotPassword',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      disableEmail,
      expiration,
      req: {
        payload: { config, email },
        payload,
      },
      req,
    } = args

    // /////////////////////////////////////
    // Forget password
    // /////////////////////////////////////

    let token: string = crypto.randomBytes(20).toString('hex')
    type UserDoc = {
      email?: string
      id: number | string
      resetPasswordExpiration?: string
      resetPasswordToken?: string
    }

    if (!sanitizedEmail && !sanitizedUsername) {
      throw new APIError(
        `Missing ${loginWithUsername ? 'username' : 'email'}.`,
        httpStatus.BAD_REQUEST,
      )
    }

    let whereConstraint: Where = {}

    if (canLoginWithEmail && sanitizedEmail) {
      whereConstraint = {
        email: {
          equals: sanitizedEmail,
        },
      }
    } else if (canLoginWithUsername && sanitizedUsername) {
      whereConstraint = {
        username: {
          equals: sanitizedUsername,
        },
      }
    }

    let user = await payload.db.findOne<UserDoc>({
      collection: collectionConfig.slug,
      req,
      where: whereConstraint,
    })

    // We don't want to indicate specifically that an email was not found,
    // as doing so could lead to the exposure of registered emails.
    // Therefore, we prefer to fail silently.
    if (!user) {
      await commitTransaction(args.req)
      return null
    }

    user.resetPasswordToken = token
    user.resetPasswordExpiration = new Date(
      Date.now() + (collectionConfig.auth?.forgotPassword?.expiration ?? expiration ?? 3600000),
    ).toISOString()

    user = await payload.update({
      id: user.id,
      collection: collectionConfig.slug,
      data: user,
      req,
    })

    if (!disableEmail && user.email) {
      const protocol = new URL(req.url).protocol // includes the final :
      const serverURL =
        config.serverURL !== null && config.serverURL !== ''
          ? config.serverURL
          : `${protocol}//${req.headers.get('host')}`
      const forgotURL = formatAdminURL({
        adminRoute: config.routes.admin,
        path: `${config.admin.routes.reset}/${token}`,
        serverURL,
      })
      let html = `${req.t('authentication:youAreReceivingResetPassword')}
    <a href="${forgotURL}">${forgotURL}</a>
    ${req.t('authentication:youDidNotRequestPassword')}`

      if (typeof collectionConfig.auth.forgotPassword?.generateEmailHTML === 'function') {
        html = await collectionConfig.auth.forgotPassword.generateEmailHTML({
          req,
          token,
          user,
        })
      }

      let subject = req.t('authentication:resetYourPassword')

      if (typeof collectionConfig.auth.forgotPassword?.generateEmailSubject === 'function') {
        subject = await collectionConfig.auth.forgotPassword.generateEmailSubject({
          req,
          token,
          user,
        })
      }

      await email.sendEmail({
        from: `"${email.defaultFromName}" <${email.defaultFromAddress}>`,
        html,
        subject,
        to: user.email,
      })
    }

    // /////////////////////////////////////
    // afterForgotPassword - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterForgotPassword?.length) {
      for (const hook of collectionConfig.hooks.afterForgotPassword) {
        await hook({ args, collection: args.collection?.config, context: req.context })
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    token = await buildAfterOperation({
      args,
      collection: args.collection?.config,
      operation: 'forgotPassword',
      result: token,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return token
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/init.ts">
import type { PayloadRequest } from '../../types/index.js'

export const initOperation = async (args: {
  collection: string
  req: PayloadRequest
}): Promise<boolean> => {
  const { collection: slug, req } = args

  const doc = await req.payload.db.findOne({
    collection: slug,
    req,
  })

  return !!doc
}
</file>

<file path="packages/payload/src/auth/operations/login.ts">
// @ts-strict-ignore
import type {
  AuthOperationsFromCollectionSlug,
  Collection,
  DataFromCollectionSlug,
} from '../../collections/config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, Where } from '../../types/index.js'
import type { User } from '../types.js'

import { buildAfterOperation } from '../../collections/operations/utils.js'
import {
  AuthenticationError,
  LockedAuth,
  UnverifiedEmail,
  ValidationError,
} from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { Forbidden } from '../../index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { getFieldsToSign } from '../getFieldsToSign.js'
import { getLoginOptions } from '../getLoginOptions.js'
import isLocked from '../isLocked.js'
import { jwtSign } from '../jwt.js'
import { authenticateLocalStrategy } from '../strategies/local/authenticate.js'
import { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'
import { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'

export type Result = {
  exp?: number
  token?: string
  user?: User
}

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: AuthOperationsFromCollectionSlug<TSlug>['login']
  depth?: number
  overrideAccess?: boolean
  req: PayloadRequest
  showHiddenFields?: boolean
}

export const loginOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments<TSlug>,
): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {
  let args = incomingArgs

  if (args.collection.config.auth.disableLocalStrategy) {
    throw new Forbidden(args.req.t)
  }

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection?.config,
            context: args.req.context,
            operation: 'login',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      data,
      depth,
      overrideAccess,
      req,
      req: {
        fallbackLocale,
        locale,
        payload,
        payload: { secret },
      },
      showHiddenFields,
    } = args

    // /////////////////////////////////////
    // Login
    // /////////////////////////////////////

    let user
    const { email: unsanitizedEmail, password } = data
    const loginWithUsername = collectionConfig.auth.loginWithUsername

    const sanitizedEmail =
      typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null
    const sanitizedUsername =
      'username' in data && typeof data?.username === 'string'
        ? data.username.toLowerCase().trim()
        : null

    const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)

    // cannot login with email, did not provide username
    if (!canLoginWithEmail && !sanitizedUsername) {
      throw new ValidationError({
        collection: collectionConfig.slug,
        errors: [{ message: req.i18n.t('validation:required'), path: 'username' }],
      })
    }

    // cannot login with username, did not provide email
    if (!canLoginWithUsername && !sanitizedEmail) {
      throw new ValidationError({
        collection: collectionConfig.slug,
        errors: [{ message: req.i18n.t('validation:required'), path: 'email' }],
      })
    }

    // can login with either email or username, did not provide either
    if (!sanitizedUsername && !sanitizedEmail) {
      throw new ValidationError({
        collection: collectionConfig.slug,
        errors: [
          { message: req.i18n.t('validation:required'), path: 'email' },
          { message: req.i18n.t('validation:required'), path: 'username' },
        ],
      })
    }

    // did not provide password for login
    if (typeof password !== 'string' || password.trim() === '') {
      throw new ValidationError({
        collection: collectionConfig.slug,
        errors: [{ message: req.i18n.t('validation:required'), path: 'password' }],
      })
    }

    let whereConstraint: Where = {}
    const emailConstraint: Where = {
      email: {
        equals: sanitizedEmail,
      },
    }
    const usernameConstraint: Where = {
      username: {
        equals: sanitizedUsername,
      },
    }

    if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {
      if (sanitizedUsername) {
        whereConstraint = {
          or: [
            usernameConstraint,
            {
              email: {
                equals: sanitizedUsername,
              },
            },
          ],
        }
      } else {
        whereConstraint = {
          or: [
            emailConstraint,
            {
              username: {
                equals: sanitizedEmail,
              },
            },
          ],
        }
      }
    } else if (canLoginWithEmail && sanitizedEmail) {
      whereConstraint = emailConstraint
    } else if (canLoginWithUsername && sanitizedUsername) {
      whereConstraint = usernameConstraint
    }

    user = await payload.db.findOne<any>({
      collection: collectionConfig.slug,
      req,
      where: whereConstraint,
    })

    if (!user) {
      throw new AuthenticationError(req.t, Boolean(canLoginWithUsername && sanitizedUsername))
    }

    if (args.collection.config.auth.verify && user._verified === false) {
      throw new UnverifiedEmail({ t: req.t })
    }

    user.collection = collectionConfig.slug
    user._strategy = 'local-jwt'

    if (isLocked(new Date(user.lockUntil).getTime())) {
      throw new LockedAuth(req.t)
    }

    const authResult = await authenticateLocalStrategy({ doc: user, password })

    user = sanitizeInternalFields(user)

    const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0

    if (!authResult) {
      if (maxLoginAttemptsEnabled) {
        await incrementLoginAttempts({
          collection: collectionConfig,
          doc: user,
          payload: req.payload,
          req,
        })
      }

      throw new AuthenticationError(req.t)
    }

    if (maxLoginAttemptsEnabled) {
      await resetLoginAttempts({
        collection: collectionConfig,
        doc: user,
        payload: req.payload,
        req,
      })
    }

    const fieldsToSign = getFieldsToSign({
      collectionConfig,
      email: sanitizedEmail,
      user,
    })

    // /////////////////////////////////////
    // beforeLogin - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeLogin?.length) {
      for (const hook of collectionConfig.hooks.beforeLogin) {
        user =
          (await hook({
            collection: args.collection?.config,
            context: args.req.context,
            req: args.req,
            user,
          })) || user
      }
    }

    const { exp, token } = await jwtSign({
      fieldsToSign,
      secret,
      tokenExpiration: collectionConfig.auth.tokenExpiration,
    })

    req.user = user

    // /////////////////////////////////////
    // afterLogin - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterLogin?.length) {
      for (const hook of collectionConfig.hooks.afterLogin) {
        user =
          (await hook({
            collection: args.collection?.config,
            context: args.req.context,
            req: args.req,
            token,
            user,
          })) || user
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    user = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: user,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      req,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        user =
          (await hook({
            collection: args.collection?.config,
            context: req.context,
            doc: user,
            req,
          })) || user
      }
    }

    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {
      exp,
      token,
      user,
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: args.collection?.config,
      operation: 'login',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/logout.ts">
import { status as httpStatus } from 'http-status'

import type { Collection } from '../../collections/config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { APIError } from '../../errors/index.js'

export type Arguments = {
  collection: Collection
  req: PayloadRequest
}

export const logoutOperation = async (incomingArgs: Arguments): Promise<boolean> => {
  let args = incomingArgs
  const {
    collection: { config: collectionConfig },
    req: { user },
    req,
  } = incomingArgs

  if (!user) {
    throw new APIError('No User', httpStatus.BAD_REQUEST)
  }
  if (user.collection !== collectionConfig.slug) {
    throw new APIError('Incorrect collection', httpStatus.FORBIDDEN)
  }

  if (collectionConfig.hooks?.afterLogout?.length) {
    for (const hook of collectionConfig.hooks.afterLogout) {
      args =
        (await hook({
          collection: args.collection?.config,
          context: req.context,
          req,
        })) || args
    }
  }

  return true
}
</file>

<file path="packages/payload/src/auth/operations/me.ts">
// @ts-strict-ignore
import { decodeJwt } from 'jose'

import type { Collection } from '../../collections/config/types.js'
import type { PayloadRequest } from '../../types/index.js'
import type { ClientUser, User } from '../types.js'

export type MeOperationResult = {
  collection?: string
  exp?: number
  /** @deprecated
   * use:
   * ```ts
   * user._strategy
   * ```
   */
  strategy?: string
  token?: string
  user?: ClientUser
}

export type Arguments = {
  collection: Collection
  currentToken?: string
  req: PayloadRequest
}

export const meOperation = async (args: Arguments): Promise<MeOperationResult> => {
  const { collection, currentToken, req } = args

  let result: MeOperationResult = {
    user: null,
  }

  if (req.user) {
    const { pathname } = req
    const isGraphQL = pathname === `/api${req.payload.config.routes.graphQL}`

    const user = (await req.payload.findByID({
      id: req.user.id,
      collection: collection.config.slug,
      depth: isGraphQL ? 0 : collection.config.auth.depth,
      overrideAccess: false,
      req,
      showHiddenFields: false,
    })) as User

    if (user) {
      user.collection = collection.config.slug
      user._strategy = req.user._strategy
    }

    if (req.user.collection !== collection.config.slug) {
      return {
        user: null,
      }
    }

    // /////////////////////////////////////
    // me hook - Collection
    // /////////////////////////////////////

    for (const meHook of collection.config.hooks.me) {
      const hookResult = await meHook({ args, user })

      if (hookResult) {
        result.user = hookResult.user
        result.exp = hookResult.exp

        break
      }
    }

    result.collection = req.user.collection
    /** @deprecated
     * use:
     * ```ts
     * user._strategy
     * ```
     */
    result.strategy = req.user._strategy

    if (!result.user) {
      result.user = user

      if (currentToken) {
        const decoded = decodeJwt(currentToken)
        if (decoded) {
          result.exp = decoded.exp
        }
        if (!collection.config.auth.removeTokenFromResponses) {
          result.token = currentToken
        }
      }
    }
  }

  // /////////////////////////////////////
  // After Me - Collection
  // /////////////////////////////////////

  if (collection.config.hooks?.afterMe?.length) {
    for (const hook of collection.config.hooks.afterMe) {
      result =
        (await hook({
          collection: collection?.config,
          context: req.context,
          req,
          response: result,
        })) || result
    }
  }

  return result
}
</file>

<file path="packages/payload/src/auth/operations/refresh.ts">
// @ts-strict-ignore
import url from 'url'

import type { Collection } from '../../collections/config/types.js'
import type { Document, PayloadRequest } from '../../types/index.js'

import { buildAfterOperation } from '../../collections/operations/utils.js'
import { Forbidden } from '../../errors/index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getFieldsToSign } from '../getFieldsToSign.js'
import { jwtSign } from '../jwt.js'

export type Result = {
  exp: number
  refreshedToken: string
  setCookie?: boolean
  /** @deprecated
   * use:
   * ```ts
   * user._strategy
   * ```
   */
  strategy?: string
  user: Document
}

export type Arguments = {
  collection: Collection
  req: PayloadRequest
}

export const refreshOperation = async (incomingArgs: Arguments): Promise<Result> => {
  let args = incomingArgs

  try {
    const shouldCommit = await initTransaction(args.req)

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection?.config,
            context: args.req.context,
            operation: 'refresh',
            req: args.req,
          })) || args
      }
    }

    // /////////////////////////////////////
    // Refresh
    // /////////////////////////////////////

    const {
      collection: { config: collectionConfig },
      req,
      req: {
        payload: { config, secret },
      },
    } = args

    if (!args.req.user) {
      throw new Forbidden(args.req.t)
    }

    const parsedURL = url.parse(args.req.url)
    const isGraphQL = parsedURL.pathname === config.routes.graphQL

    const user = await args.req.payload.findByID({
      id: args.req.user.id,
      collection: args.req.user.collection,
      depth: isGraphQL ? 0 : args.collection.config.auth.depth,
      req: args.req,
    })

    if (user) {
      user.collection = args.req.user.collection
      user._strategy = args.req.user._strategy
    }

    let result: Result

    // /////////////////////////////////////
    // refresh hook - Collection
    // /////////////////////////////////////

    for (const refreshHook of args.collection.config.hooks.refresh) {
      const hookResult = await refreshHook({ args, user })

      if (hookResult) {
        result = hookResult
        break
      }
    }

    if (!result) {
      const fieldsToSign = getFieldsToSign({
        collectionConfig,
        email: user?.email as string,
        user: args?.req?.user,
      })

      const { exp, token: refreshedToken } = await jwtSign({
        fieldsToSign,
        secret,
        tokenExpiration: collectionConfig.auth.tokenExpiration,
      })

      result = {
        exp,
        refreshedToken,
        setCookie: true,
        /** @deprecated
         * use:
         * ```ts
         * user._strategy
         * ```
         */
        strategy: args.req.user._strategy,
        user,
      }
    }

    // /////////////////////////////////////
    // After Refresh - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRefresh?.length) {
      for (const hook of collectionConfig.hooks.afterRefresh) {
        result =
          (await hook({
            collection: args.collection?.config,
            context: args.req.context,
            exp: result.exp,
            req: args.req,
            token: result.refreshedToken,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: args.collection?.config,
      operation: 'refresh',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/registerFirstUser.ts">
import type {
  AuthOperationsFromCollectionSlug,
  Collection,
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
} from '../../collections/config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, SelectType } from '../../types/index.js'

import { Forbidden } from '../../errors/index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { ensureUsernameOrEmail } from '../ensureUsernameOrEmail.js'

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: AuthOperationsFromCollectionSlug<TSlug>['registerFirstUser'] &
    RequiredDataFromCollectionSlug<TSlug>
  req: PayloadRequest
}

export type Result<TData> = {
  exp?: number
  token?: string
  user?: TData
}

export const registerFirstUserOperation = async <TSlug extends CollectionSlug>(
  args: Arguments<TSlug>,
): Promise<Result<DataFromCollectionSlug<TSlug>>> => {
  const {
    collection: {
      config,
      config: {
        slug,
        auth: { verify },
      },
    },
    data,
    req,
    req: { payload },
  } = args

  if (config.auth.disableLocalStrategy) {
    throw new Forbidden(req.t)
  }

  try {
    const shouldCommit = await initTransaction(req)

    ensureUsernameOrEmail<TSlug>({
      authOptions: config.auth,
      collectionSlug: slug,
      data,
      operation: 'create',
      req,
    })

    const doc = await payload.db.findOne({
      collection: config.slug,
      req,
    })

    if (doc) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // Register first user
    // /////////////////////////////////////

    const result = await payload.create<TSlug, SelectType>({
      collection: slug as TSlug,
      data,
      overrideAccess: true,
      req,
    })

    // auto-verify (if applicable)
    if (verify) {
      await payload.update({
        id: result.id,
        collection: slug,
        data: {
          _verified: true,
        },
        req,
      })
    }

    // /////////////////////////////////////
    // Log in new user
    // /////////////////////////////////////

    const { exp, token } = await payload.login({
      ...args,
      collection: slug,
      req,
    })

    result.collection = slug
    result._strategy = 'local-jwt'

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return {
      exp,
      token,
      user: result,
    }
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/resetPassword.ts">
import { status as httpStatus } from 'http-status'

import type { Collection } from '../../collections/config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { APIError, Forbidden } from '../../errors/index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getFieldsToSign } from '../getFieldsToSign.js'
import { jwtSign } from '../jwt.js'
import { authenticateLocalStrategy } from '../strategies/local/authenticate.js'
import { generatePasswordSaltHash } from '../strategies/local/generatePasswordSaltHash.js'

export type Result = {
  token?: string
  user: Record<string, unknown>
}

export type Arguments = {
  collection: Collection
  data: {
    password: string
    token: string
  }
  depth?: number
  overrideAccess?: boolean
  req: PayloadRequest
}

export const resetPasswordOperation = async (args: Arguments): Promise<Result> => {
  const {
    collection: { config: collectionConfig },
    data,
    depth,
    overrideAccess,
    req: {
      payload: { secret },
      payload,
    },
    req,
  } = args

  if (
    !Object.prototype.hasOwnProperty.call(data, 'token') ||
    !Object.prototype.hasOwnProperty.call(data, 'password')
  ) {
    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)
  }

  if (collectionConfig.auth.disableLocalStrategy) {
    throw new Forbidden(req.t)
  }

  try {
    const shouldCommit = await initTransaction(req)

    // /////////////////////////////////////
    // Reset Password
    // /////////////////////////////////////

    const user = await payload.db.findOne<any>({
      collection: collectionConfig.slug,
      req,
      where: {
        resetPasswordExpiration: { greater_than: new Date().toISOString() },
        resetPasswordToken: { equals: data.token },
      },
    })

    if (!user) {
      throw new APIError('Token is either invalid or has expired.', httpStatus.FORBIDDEN)
    }

    // TODO: replace this method
    const { hash, salt } = await generatePasswordSaltHash({
      collection: collectionConfig,
      password: data.password,
      req,
    })

    user.salt = salt
    user.hash = hash

    user.resetPasswordExpiration = new Date().toISOString()

    if (collectionConfig.auth.verify) {
      user._verified = Boolean(user._verified)
    }
    // /////////////////////////////////////
    // beforeValidate - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeValidate?.length) {
      for (const hook of collectionConfig.hooks.beforeValidate) {
        await hook({
          collection: args.collection?.config,
          context: req.context,
          data: user,
          operation: 'update',
          req,
        })
      }
    }

    // /////////////////////////////////////
    // Update new password
    // /////////////////////////////////////

    const doc = await payload.db.updateOne({
      id: user.id,
      collection: collectionConfig.slug,
      data: user,
      req,
    })

    await authenticateLocalStrategy({ doc, password: data.password })

    const fieldsToSign = getFieldsToSign({
      collectionConfig,
      email: user.email,
      user,
    })

    const { token } = await jwtSign({
      fieldsToSign,
      secret,
      tokenExpiration: collectionConfig.auth.tokenExpiration,
    })

    const fullUser = await payload.findByID({
      id: user.id,
      collection: collectionConfig.slug,
      depth,
      overrideAccess,
      req,
    })
    if (shouldCommit) {
      await commitTransaction(req)
    }

    if (fullUser) {
      fullUser.collection = collectionConfig.slug
      fullUser._strategy = 'local-jwt'
    }

    const result = {
      token,
      user: fullUser,
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/unlock.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type {
  AuthOperationsFromCollectionSlug,
  Collection,
} from '../../collections/config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, Where } from '../../types/index.js'

import { APIError } from '../../errors/index.js'
import { Forbidden } from '../../index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import executeAccess from '../executeAccess.js'
import { getLoginOptions } from '../getLoginOptions.js'
import { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: AuthOperationsFromCollectionSlug<TSlug>['unlock']
  overrideAccess?: boolean
  req: PayloadRequest
}

export const unlockOperation = async <TSlug extends CollectionSlug>(
  args: Arguments<TSlug>,
): Promise<boolean> => {
  const {
    collection: { config: collectionConfig },
    overrideAccess,
    req: { locale },
    req,
  } = args

  const loginWithUsername = collectionConfig.auth.loginWithUsername

  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)

  const sanitizedEmail = canLoginWithEmail && (args.data?.email || '').toLowerCase().trim()
  const sanitizedUsername =
    (canLoginWithUsername &&
      'username' in args.data &&
      typeof args.data.username === 'string' &&
      args.data.username.toLowerCase().trim()) ||
    null

  if (collectionConfig.auth.disableLocalStrategy) {
    throw new Forbidden(req.t)
  }
  if (!sanitizedEmail && !sanitizedUsername) {
    throw new APIError(
      `Missing ${collectionConfig.auth.loginWithUsername ? 'username' : 'email'}.`,
      httpStatus.BAD_REQUEST,
    )
  }

  try {
    const shouldCommit = await initTransaction(req)

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    if (!overrideAccess) {
      await executeAccess({ req }, collectionConfig.access.unlock)
    }

    // /////////////////////////////////////
    // Unlock
    // /////////////////////////////////////

    let whereConstraint: Where = {}

    if (canLoginWithEmail && sanitizedEmail) {
      whereConstraint = {
        email: {
          equals: sanitizedEmail,
        },
      }
    } else if (canLoginWithUsername && sanitizedUsername) {
      whereConstraint = {
        username: {
          equals: sanitizedUsername,
        },
      }
    }

    const user = await req.payload.db.findOne({
      collection: collectionConfig.slug,
      locale,
      req,
      where: whereConstraint,
    })

    let result

    if (user) {
      await resetLoginAttempts({
        collection: collectionConfig,
        doc: user,
        payload: req.payload,
        req,
      })
      result = true
    } else {
      result = null
    }

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/auth/operations/verifyEmail.ts">
import { status as httpStatus } from 'http-status'

import type { Collection } from '../../collections/config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { APIError, Forbidden } from '../../errors/index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'

export type Args = {
  collection: Collection
  req: PayloadRequest
  token: string
}

export const verifyEmailOperation = async (args: Args): Promise<boolean> => {
  const { collection, req, token } = args

  if (collection.config.auth.disableLocalStrategy) {
    throw new Forbidden(req.t)
  }
  if (!Object.prototype.hasOwnProperty.call(args, 'token')) {
    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)
  }

  try {
    const shouldCommit = await initTransaction(req)

    const user = await req.payload.db.findOne<any>({
      collection: collection.config.slug,
      req,
      where: {
        _verificationToken: { equals: token },
      },
    })

    if (!user) {
      throw new APIError('Verification token is invalid.', httpStatus.FORBIDDEN)
    }

    await req.payload.db.updateOne({
      id: user.id,
      collection: collection.config.slug,
      data: {
        ...user,
        _verificationToken: null,
        _verified: true,
      },
      req,
      returning: false,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return true
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}

export default verifyEmailOperation
</file>

<file path="packages/payload/src/auth/strategies/local/authenticate.ts">
// @ts-strict-ignore
import crypto from 'crypto'
import scmp from 'scmp'

import type { TypeWithID } from '../../../collections/config/types.js'

type Doc = Record<string, unknown> & TypeWithID

type Args = {
  doc: Doc
  password: string
}

export const authenticateLocalStrategy = async ({ doc, password }: Args): Promise<Doc | null> => {
  try {
    const { hash, salt } = doc

    if (typeof salt === 'string' && typeof hash === 'string') {
      const res = await new Promise<Doc | null>((resolve, reject) => {
        crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (e, hashBuffer) => {
          if (e) {
            reject(null)
          }

          if (scmp(hashBuffer, Buffer.from(hash, 'hex'))) {
            resolve(doc)
          } else {
            reject(null)
          }
        })
      })

      return res
    }

    return null
  } catch (err) {
    return null
  }
}
</file>

<file path="packages/payload/src/auth/strategies/local/generatePasswordSaltHash.ts">
import crypto from 'crypto'

import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { PayloadRequest } from '../../../types/index.js'

import { ValidationError } from '../../../errors/index.js'
import { password } from '../../../fields/validations.js'

function randomBytes(): Promise<Buffer> {
  return new Promise((resolve, reject) =>
    crypto.randomBytes(32, (err, saltBuffer) => (err ? reject(err) : resolve(saltBuffer))),
  )
}

function pbkdf2Promisified(password: string, salt: string): Promise<Buffer> {
  return new Promise((resolve, reject) =>
    crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (err, hashRaw) =>
      err ? reject(err) : resolve(hashRaw),
    ),
  )
}

type Args = {
  collection: SanitizedCollectionConfig
  password: string
  req: PayloadRequest
}

export const generatePasswordSaltHash = async ({
  collection,
  password: passwordToSet,
  req,
}: Args): Promise<{ hash: string; salt: string }> => {
  const validationResult = password(passwordToSet, {
    name: 'password',
    type: 'text',
    blockData: {},
    data: {},
    event: 'submit',
    path: ['password'],
    preferences: { fields: {} },
    req,
    required: true,
    siblingData: {},
  })

  if (typeof validationResult === 'string') {
    throw new ValidationError({
      collection: collection?.slug,
      errors: [{ message: validationResult, path: 'password' }],
    })
  }

  const saltBuffer = await randomBytes()
  const salt = saltBuffer.toString('hex')

  const hashRaw = await pbkdf2Promisified(passwordToSet, salt)
  const hash = hashRaw.toString('hex')

  return { hash, salt }
}
</file>

<file path="packages/payload/src/auth/strategies/local/incrementLoginAttempts.ts">
import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'
import type { JsonObject, Payload } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'

type Args = {
  collection: SanitizedCollectionConfig
  doc: Record<string, unknown> & TypeWithID
  payload: Payload
  req: PayloadRequest
}

export const incrementLoginAttempts = async ({
  collection,
  doc,
  payload,
  req,
}: Args): Promise<void> => {
  const {
    auth: { lockTime, maxLoginAttempts },
  } = collection

  if ('lockUntil' in doc && typeof doc.lockUntil === 'string') {
    const lockUntil = new Date(doc.lockUntil).getTime()

    // Expired lock, restart count at 1
    if (lockUntil < Date.now()) {
      await payload.update({
        id: doc.id,
        collection: collection.slug,
        data: {
          lockUntil: null,
          loginAttempts: 1,
        },
        depth: 0,
        req,
      })
    }

    return
  }

  const data: JsonObject = {
    loginAttempts: Number(doc.loginAttempts) + 1,
  }

  // Lock the account if at max attempts and not already locked
  if (typeof doc.loginAttempts === 'number' && doc.loginAttempts + 1 >= maxLoginAttempts) {
    const lockUntil = new Date(Date.now() + lockTime).toISOString()
    data.lockUntil = lockUntil
  }

  await payload.update({
    id: doc.id,
    collection: collection.slug,
    data,
    depth: 0,
    req,
  })
}
</file>

<file path="packages/payload/src/auth/strategies/local/register.ts">
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { JsonObject, Payload } from '../../../index.js'
import type { PayloadRequest, SelectType, Where } from '../../../types/index.js'

import { ValidationError } from '../../../errors/index.js'
import { getLoginOptions } from '../../getLoginOptions.js'
import { generatePasswordSaltHash } from './generatePasswordSaltHash.js'

type Args = {
  collection: SanitizedCollectionConfig
  doc: JsonObject
  password: string
  payload: Payload
  req: PayloadRequest
  select?: SelectType
}

export const registerLocalStrategy = async ({
  collection,
  doc,
  password,
  payload,
  req,
  select,
}: Args): Promise<Record<string, unknown>> => {
  const loginWithUsername = collection?.auth?.loginWithUsername

  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)

  let whereConstraint: Where

  if (!canLoginWithUsername) {
    whereConstraint = {
      email: {
        equals: doc.email,
      },
    }
  } else {
    whereConstraint = {
      or: [],
    }

    if (canLoginWithEmail && doc.email) {
      whereConstraint.or?.push({
        email: {
          equals: doc.email,
        },
      })
    }

    if (doc.username) {
      whereConstraint.or?.push({
        username: {
          equals: doc.username,
        },
      })
    }
  }

  const existingUser = await payload.find({
    collection: collection.slug,
    depth: 0,
    limit: 1,
    pagination: false,
    req,
    where: whereConstraint,
  })

  if (existingUser.docs.length > 0) {
    throw new ValidationError({
      collection: collection.slug,
      errors: [
        canLoginWithUsername
          ? {
              message: req.t('error:usernameAlreadyRegistered'),
              path: 'username',
            }
          : { message: req.t('error:userEmailAlreadyRegistered'), path: 'email' },
      ],
    })
  }

  const { hash, salt } = await generatePasswordSaltHash({ collection, password, req })

  const sanitizedDoc = { ...doc }
  if (sanitizedDoc.password) {
    delete sanitizedDoc.password
  }

  return payload.db.create({
    collection: collection.slug,
    data: {
      ...sanitizedDoc,
      hash,
      salt,
    },
    req,
    select,
  })
}
</file>

<file path="packages/payload/src/auth/strategies/local/resetLoginAttempts.ts">
import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'
import type { Payload } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'

type Args = {
  collection: SanitizedCollectionConfig
  doc: Record<string, unknown> & TypeWithID
  payload: Payload
  req: PayloadRequest
}

export const resetLoginAttempts = async ({
  collection,
  doc,
  payload,
  req,
}: Args): Promise<void> => {
  if (!('lockUntil' in doc && typeof doc.lockUntil === 'string') || doc.loginAttempts === 0) {
    return
  }
  await payload.update({
    id: doc.id,
    collection: collection.slug,
    data: {
      lockUntil: null,
      loginAttempts: 0,
    },
    depth: 0,
    overrideAccess: true,
    req,
  })
}
</file>

<file path="packages/payload/src/auth/strategies/apiKey.ts">
// @ts-strict-ignore
import crypto from 'crypto'

import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { Where } from '../../types/index.js'
import type { AuthStrategyFunction, User } from '../index.js'

export const APIKeyAuthentication =
  (collectionConfig: SanitizedCollectionConfig): AuthStrategyFunction =>
  async ({ headers, payload }) => {
    const authHeader = headers.get('Authorization')

    if (authHeader?.startsWith(`${collectionConfig.slug} API-Key `)) {
      const apiKey = authHeader.replace(`${collectionConfig.slug} API-Key `, '')
      const apiKeyIndex = crypto.createHmac('sha1', payload.secret).update(apiKey).digest('hex')

      try {
        const where: Where = {}
        if (collectionConfig.auth?.verify) {
          where.and = [
            {
              apiKeyIndex: {
                equals: apiKeyIndex,
              },
            },
            {
              _verified: {
                not_equals: false,
              },
            },
          ]
        } else {
          where.apiKeyIndex = {
            equals: apiKeyIndex,
          }
        }

        const userQuery = await payload.find({
          collection: collectionConfig.slug,
          depth: collectionConfig.auth.depth,
          limit: 1,
          overrideAccess: true,
          pagination: false,
          where,
        })

        if (userQuery.docs && userQuery.docs.length > 0) {
          const user = userQuery.docs[0]
          user.collection = collectionConfig.slug
          user._strategy = 'api-key'

          return {
            user: user as User,
          }
        }
      } catch (err) {
        return { user: null }
      }
    }

    return { user: null }
  }
</file>

<file path="packages/payload/src/auth/strategies/jwt.ts">
// @ts-strict-ignore
import { jwtVerify } from 'jose'

import type { Payload, Where } from '../../types/index.js'
import type { AuthStrategyFunction, AuthStrategyResult, User } from '../index.js'

import { extractJWT } from '../extractJWT.js'

type JWTToken = {
  collection: string
  id: string
}

async function autoLogin({
  isGraphQL,
  payload,
  strategyName = 'local-jwt',
}: {
  isGraphQL: boolean
  payload: Payload
  strategyName?: string
}): Promise<{
  user: AuthStrategyResult['user']
}> {
  if (
    typeof payload?.config?.admin?.autoLogin !== 'object' ||
    payload.config.admin?.autoLogin.prefillOnly ||
    !payload?.config?.admin?.autoLogin ||
    (!payload.config.admin?.autoLogin.email && !payload.config.admin?.autoLogin.username)
  ) {
    return { user: null }
  }

  const collection = payload.collections[payload.config.admin.user]

  const where: Where = {
    or: [],
  }
  if (payload.config.admin?.autoLogin.email) {
    where.or?.push({
      email: {
        equals: payload.config.admin?.autoLogin.email,
      },
    })
  } else if (payload.config.admin?.autoLogin.username) {
    where.or?.push({
      username: {
        equals: payload.config.admin?.autoLogin.username,
      },
    })
  }

  const user = (
    await payload.find({
      collection: collection.config.slug,
      depth: isGraphQL ? 0 : collection.config.auth.depth,
      limit: 1,
      pagination: false,
      where,
    })
  ).docs[0] as AuthStrategyResult['user']

  if (!user) {
    return { user: null }
  }
  user.collection = collection.config.slug
  user._strategy = strategyName

  return {
    user,
  }
}

/**
 * Authentication strategy function for JWT tokens
 */
export const JWTAuthentication: AuthStrategyFunction = async ({
  headers,
  isGraphQL = false,
  payload,
  strategyName = 'local-jwt',
}) => {
  try {
    const token = extractJWT({ headers, payload })

    if (!token) {
      if (headers.get('DisableAutologin') !== 'true') {
        return await autoLogin({ isGraphQL, payload, strategyName })
      }
      return { user: null }
    }

    const secretKey = new TextEncoder().encode(payload.secret)
    const { payload: decodedPayload } = await jwtVerify<JWTToken>(token, secretKey)
    const collection = payload.collections[decodedPayload.collection]

    const user = (await payload.findByID({
      id: decodedPayload.id,
      collection: decodedPayload.collection,
      depth: isGraphQL ? 0 : collection.config.auth.depth,
    })) as AuthStrategyResult['user']

    if (user && (!collection.config.auth.verify || user._verified)) {
      user.collection = collection.config.slug
      user._strategy = strategyName
      return {
        user,
      }
    } else {
      if (headers.get('DisableAutologin') !== 'true') {
        return await autoLogin({ isGraphQL, payload, strategyName })
      }
      return { user: null }
    }
  } catch (ignore) {
    if (headers.get('DisableAutologin') !== 'true') {
      return await autoLogin({ isGraphQL, payload, strategyName })
    }
    return { user: null }
  }
}
</file>

<file path="packages/payload/src/auth/cookies.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from './../collections/config/types.js'

type CookieOptions = {
  domain?: string
  expires?: Date
  httpOnly?: boolean
  maxAge?: number
  name: string
  path?: string
  returnCookieAsObject: boolean
  sameSite?: 'Lax' | 'None' | 'Strict'
  secure?: boolean
  value?: string
}

type CookieObject = {
  domain?: string
  expires?: string
  httpOnly?: boolean
  maxAge?: number
  name: string
  path?: string
  sameSite?: 'Lax' | 'None' | 'Strict'
  secure?: boolean
  value: string | undefined
}

export const generateCookie = <ReturnCookieAsObject = boolean>(
  args: CookieOptions,
): ReturnCookieAsObject extends true ? CookieObject : string => {
  const {
    name,
    domain,
    expires,
    httpOnly,
    maxAge,
    path,
    returnCookieAsObject,
    sameSite,
    secure: secureArg,
    value,
  } = args

  let cookieString = `${name}=${value || ''}`
  const cookieObject: CookieObject = {
    name,
    value,
  }

  const secure = secureArg || sameSite === 'None'

  if (expires) {
    if (returnCookieAsObject) {
      cookieObject.expires = expires.toUTCString()
    } else {
      cookieString += `; Expires=${expires.toUTCString()}`
    }
  }

  if (maxAge) {
    if (returnCookieAsObject) {
      cookieObject.maxAge = maxAge
    } else {
      cookieString += `; Max-Age=${maxAge.toString()}`
    }
  }

  if (domain) {
    if (returnCookieAsObject) {
      cookieObject.domain = domain
    } else {
      cookieString += `; Domain=${domain}`
    }
  }

  if (path) {
    if (returnCookieAsObject) {
      cookieObject.path = path
    } else {
      cookieString += `; Path=${path}`
    }
  }

  if (secure) {
    if (returnCookieAsObject) {
      cookieObject.secure = secure
    } else {
      cookieString += `; Secure=${secure}`
    }
  }

  if (httpOnly) {
    if (returnCookieAsObject) {
      cookieObject.httpOnly = httpOnly
    } else {
      cookieString += `; HttpOnly=${httpOnly}`
    }
  }

  if (sameSite) {
    if (returnCookieAsObject) {
      cookieObject.sameSite = sameSite
    } else {
      cookieString += `; SameSite=${sameSite}`
    }
  }

  return (returnCookieAsObject ? cookieObject : cookieString) as ReturnCookieAsObject extends true
    ? CookieObject
    : string
}
type GetCookieExpirationArgs = {
  /*
    The number of seconds until the cookie expires
    @default 7200 seconds (2 hours)
  */
  seconds: number
}
export const getCookieExpiration = ({ seconds = 7200 }: GetCookieExpirationArgs) => {
  const currentTime = new Date()
  currentTime.setSeconds(currentTime.getSeconds() + seconds)
  return currentTime
}

type GeneratePayloadCookieArgs = {
  /* The auth collection config */
  collectionAuthConfig: SanitizedCollectionConfig['auth']
  /* Prefix to scope the cookie */
  cookiePrefix: string
  /* The returnAs value */
  returnCookieAsObject?: boolean
  /* The token to be stored in the cookie */
  token: string
}
export const generatePayloadCookie = <T extends GeneratePayloadCookieArgs>({
  collectionAuthConfig,
  cookiePrefix,
  returnCookieAsObject = false,
  token,
}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {
  const sameSite =
    typeof collectionAuthConfig.cookies.sameSite === 'string'
      ? collectionAuthConfig.cookies.sameSite
      : collectionAuthConfig.cookies.sameSite
        ? 'Strict'
        : undefined

  return generateCookie<T['returnCookieAsObject']>({
    name: `${cookiePrefix}-token`,
    domain: collectionAuthConfig.cookies.domain ?? undefined,
    expires: getCookieExpiration({ seconds: collectionAuthConfig.tokenExpiration }),
    httpOnly: true,
    path: '/',
    returnCookieAsObject,
    sameSite,
    secure: collectionAuthConfig.cookies.secure,
    value: token,
  })
}

export const generateExpiredPayloadCookie = <T extends Omit<GeneratePayloadCookieArgs, 'token'>>({
  collectionAuthConfig,
  cookiePrefix,
  returnCookieAsObject = false,
}: T): T['returnCookieAsObject'] extends true ? CookieObject : string => {
  const sameSite =
    typeof collectionAuthConfig.cookies.sameSite === 'string'
      ? collectionAuthConfig.cookies.sameSite
      : collectionAuthConfig.cookies.sameSite
        ? 'Strict'
        : undefined

  const expires = new Date(Date.now() - 1000)

  return generateCookie<T['returnCookieAsObject']>({
    name: `${cookiePrefix}-token`,
    domain: collectionAuthConfig.cookies.domain ?? undefined,
    expires,
    httpOnly: true,
    path: '/',
    returnCookieAsObject,
    sameSite,
    secure: collectionAuthConfig.cookies.secure,
  })
}

export const parseCookies = (headers: Request['headers']): Map<string, string> => {
  const cookieMap = new Map<string, string>()
  const cookie = headers.get('Cookie')

  if (cookie) {
    cookie.split(';').forEach((cookie) => {
      const parts = cookie.split('=')
      const key = parts.shift()?.trim()
      const encodedValue = parts.join('=')

      try {
        const decodedValue = decodeURI(encodedValue)
        cookieMap.set(key, decodedValue)
      } catch (ignore) {
        return null
      }
    })
  }

  return cookieMap
}
</file>

<file path="packages/payload/src/auth/crypto.ts">
// @ts-strict-ignore
import crypto from 'crypto'

const algorithm = 'aes-256-ctr'

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv(algorithm, this.secret, iv)

  const encrypted = Buffer.concat([cipher.update(text), cipher.final()])

  const ivString = iv.toString('hex')
  const encryptedString = encrypted.toString('hex')

  return `${ivString}${encryptedString}`
}

export function decrypt(hash: string): string {
  const iv = hash.slice(0, 32)
  const content = hash.slice(32)

  const decipher = crypto.createDecipheriv(algorithm, this.secret, Buffer.from(iv, 'hex'))

  const decrypted = Buffer.concat([decipher.update(Buffer.from(content, 'hex')), decipher.final()])

  return decrypted.toString()
}
</file>

<file path="packages/payload/src/auth/defaultAccess.ts">
import type { PayloadRequest } from '../types/index.js'

export default ({ req: { user } }: { req: PayloadRequest }): boolean => Boolean(user)
</file>

<file path="packages/payload/src/auth/defaultUser.ts">
import type { CollectionConfig } from '../collections/config/types.js'

export const defaultUserCollection: CollectionConfig = {
  slug: 'users',
  admin: {
    useAsTitle: 'email',
  },
  auth: {
    tokenExpiration: 7200,
  },
  fields: [],
  labels: {
    plural: ({ t }) => t('general:users'),
    singular: ({ t }) => t('general:user'),
  },
}
</file>

<file path="packages/payload/src/auth/ensureUsernameOrEmail.ts">
import type { RequiredDataFromCollectionSlug } from '../collections/config/types.js'
import type { AuthCollection, CollectionSlug, PayloadRequest } from '../index.js'

import { ValidationError } from '../errors/index.js'

type ValidateUsernameOrEmailArgs<TSlug extends CollectionSlug> = {
  authOptions: AuthCollection['config']['auth']
  collectionSlug: string
  data: RequiredDataFromCollectionSlug<TSlug>
  req: PayloadRequest
} & (
  | {
      operation: 'create'
      originalDoc?: never
    }
  | {
      operation: 'update'
      originalDoc: RequiredDataFromCollectionSlug<TSlug>
    }
)
export const ensureUsernameOrEmail = <TSlug extends CollectionSlug>({
  authOptions: { disableLocalStrategy, loginWithUsername },
  collectionSlug,
  data,
  operation,
  originalDoc,
  req,
}: ValidateUsernameOrEmailArgs<TSlug>) => {
  // neither username or email are required
  // and neither are provided
  // so we need to manually validate
  if (
    !disableLocalStrategy &&
    loginWithUsername &&
    !loginWithUsername.requireEmail &&
    !loginWithUsername.requireUsername
  ) {
    let missingFields = false
    if (operation === 'create' && !data.email && !data.username) {
      missingFields = true
    } else if (operation === 'update') {
      // prevent clearing both email and username
      if ('email' in data && !data.email && 'username' in data && !data.username) {
        missingFields = true
      }
      // prevent clearing email if no username
      if ('email' in data && !data.email && !originalDoc.username && !data?.username) {
        missingFields = true
      }
      // prevent clearing username if no email
      if ('username' in data && !data.username && !originalDoc.email && !data?.email) {
        missingFields = true
      }
    }

    if (missingFields) {
      throw new ValidationError(
        {
          collection: collectionSlug,
          errors: [
            {
              message: 'Username or email is required',
              path: 'username',
            },
            {
              message: 'Username or email is required',
              path: 'email',
            },
          ],
        },
        req.t,
      )
    }
  }

  return
}
</file>

<file path="packages/payload/src/auth/executeAccess.ts">
import type { Access, AccessResult } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { Forbidden } from '../errors/index.js'

type OperationArgs = {
  data?: any
  disableErrors?: boolean
  id?: number | string
  isReadingStaticFile?: boolean
  req: PayloadRequest
}
const executeAccess = async (
  { id, data, disableErrors, isReadingStaticFile = false, req }: OperationArgs,
  access: Access,
): Promise<AccessResult> => {
  if (access) {
    const result = await access({
      id,
      data,
      isReadingStaticFile,
      req,
    })

    if (!result) {
      if (!disableErrors) {
        throw new Forbidden(req.t)
      }
    }

    return result
  }

  if (req.user) {
    return true
  }

  if (!disableErrors) {
    throw new Forbidden(req.t)
  }
  return false
}

export default executeAccess
</file>

<file path="packages/payload/src/auth/executeAuthStrategies.ts">
import type { AuthStrategyFunctionArgs, AuthStrategyResult } from './index.js'

import { logError } from '../utilities/logError.js'
import { mergeHeaders } from '../utilities/mergeHeaders.js'
export const executeAuthStrategies = async (
  args: AuthStrategyFunctionArgs,
): Promise<AuthStrategyResult> => {
  let result: AuthStrategyResult = { user: null }

  if (!args.payload.authStrategies?.length) {
    return result
  }

  for (const strategy of args.payload.authStrategies) {
    // add the configured AuthStrategy `name` to the strategy function args
    args.strategyName = strategy.name

    try {
      const authResult = await strategy.authenticate(args)
      if (authResult.responseHeaders) {
        authResult.responseHeaders = mergeHeaders(
          result.responseHeaders || new Headers(),
          authResult.responseHeaders || new Headers(),
        )
      }
      result = authResult
    } catch (err) {
      logError({ err, payload: args.payload })
    }

    if (result.user) {
      return result
    }
  }
  return result
}
</file>

<file path="packages/payload/src/auth/extractAccessFromPermission.ts">
import type { AccessResult } from '../config/types.js'
import type { Permission } from './index.js'

export const extractAccessFromPermission = (hasPermission: boolean | Permission): AccessResult => {
  if (typeof hasPermission === 'boolean') {
    return hasPermission
  }

  const { permission, where } = hasPermission
  if (!permission) {
    return false
  }
  if (where && typeof where === 'object') {
    return where
  }
  return true
}
</file>

<file path="packages/payload/src/auth/extractJWT.ts">
import type { BasePayload } from '../index.js'
import type { AuthStrategyFunctionArgs } from './index.js'

import { parseCookies } from '../utilities/parseCookies.js'

type ExtractionMethod = (args: { headers: Headers; payload: BasePayload }) => null | string

const extractionMethods: Record<string, ExtractionMethod> = {
  Bearer: ({ headers }) => {
    const jwtFromHeader = headers.get('Authorization')

    // allow RFC6750 OAuth 2.0 compliant Bearer tokens
    // in addition to the payload default JWT format
    if (jwtFromHeader?.startsWith('Bearer ')) {
      return jwtFromHeader.replace('Bearer ', '')
    }

    return null
  },
  cookie: ({ headers, payload }) => {
    const origin = headers.get('Origin')
    const cookies = parseCookies(headers)
    const tokenCookieName = `${payload.config.cookiePrefix}-token`
    const cookieToken = cookies.get(tokenCookieName)

    if (!cookieToken) {
      return null
    }

    if (!origin || payload.config.csrf.length === 0 || payload.config.csrf.indexOf(origin) > -1) {
      return cookieToken
    }

    return null
  },
  JWT: ({ headers }) => {
    const jwtFromHeader = headers.get('Authorization')

    if (jwtFromHeader?.startsWith('JWT ')) {
      return jwtFromHeader.replace('JWT ', '')
    }

    return null
  },
}

export const extractJWT = (args: Omit<AuthStrategyFunctionArgs, 'strategyName'>): null | string => {
  const { headers, payload } = args

  const extractionOrder = payload.config.auth.jwtOrder

  for (const extractionStrategy of extractionOrder) {
    const result = extractionMethods[extractionStrategy]({ headers, payload })

    if (result) {
      return result
    }
  }

  return null
}
</file>

<file path="packages/payload/src/auth/getAccessResults.ts">
// @ts-strict-ignore
import type { AllOperations, PayloadRequest } from '../types/index.js'
import type { Permissions, SanitizedPermissions } from './types.js'

import { getEntityPolicies } from '../utilities/getEntityPolicies.js'
import { sanitizePermissions } from '../utilities/sanitizePermissions.js'

type GetAccessResultsArgs = {
  req: PayloadRequest
}
export async function getAccessResults({
  req,
}: GetAccessResultsArgs): Promise<SanitizedPermissions> {
  const results = {
    collections: {},
    globals: {},
  } as Permissions
  const { payload, user } = req

  const isLoggedIn = !!user
  const userCollectionConfig =
    user && user.collection ? payload?.collections?.[user.collection]?.config : null

  if (userCollectionConfig && payload.config.admin.user === user?.collection) {
    results.canAccessAdmin = userCollectionConfig.access.admin
      ? await userCollectionConfig.access.admin({ req })
      : isLoggedIn
  } else {
    results.canAccessAdmin = false
  }
  const blockPolicies = {}

  await Promise.all(
    payload.config.collections.map(async (collection) => {
      const collectionOperations: AllOperations[] = ['create', 'read', 'update', 'delete']

      if (
        collection.auth &&
        typeof collection.auth.maxLoginAttempts !== 'undefined' &&
        collection.auth.maxLoginAttempts !== 0
      ) {
        collectionOperations.push('unlock')
      }

      if (collection.versions) {
        collectionOperations.push('readVersions')
      }

      const collectionPolicy = await getEntityPolicies({
        type: 'collection',
        blockPolicies,
        entity: collection,
        operations: collectionOperations,
        req,
      })
      results.collections[collection.slug] = collectionPolicy
    }),
  )

  await Promise.all(
    payload.config.globals.map(async (global) => {
      const globalOperations: AllOperations[] = ['read', 'update']

      if (global.versions) {
        globalOperations.push('readVersions')
      }

      const globalPolicy = await getEntityPolicies({
        type: 'global',
        blockPolicies,
        entity: global,
        operations: globalOperations,
        req,
      })
      results.globals[global.slug] = globalPolicy
    }),
  )

  return sanitizePermissions(results)
}
</file>

<file path="packages/payload/src/auth/getAuthFields.ts">
import type { Field, TextField } from '../fields/config/types.js'
import type { IncomingAuthType } from './types.js'

import { accountLockFields } from './baseFields/accountLock.js'
import { apiKeyFields } from './baseFields/apiKey.js'
import { baseAuthFields } from './baseFields/auth.js'
import { emailFieldConfig } from './baseFields/email.js'
import { usernameFieldConfig } from './baseFields/username.js'
import { verificationFields } from './baseFields/verification.js'

export const getBaseAuthFields = (authConfig: IncomingAuthType): Field[] => {
  const authFields: Field[] = []

  if (authConfig.useAPIKey) {
    authFields.push(...apiKeyFields)
  }

  if (
    !authConfig.disableLocalStrategy ||
    (typeof authConfig.disableLocalStrategy === 'object' &&
      authConfig.disableLocalStrategy.enableFields)
  ) {
    const emailField = { ...emailFieldConfig }
    let usernameField: TextField | undefined

    if (authConfig.loginWithUsername) {
      usernameField = { ...usernameFieldConfig }
      if (typeof authConfig.loginWithUsername === 'object') {
        if (authConfig.loginWithUsername.requireEmail === false) {
          emailField.required = false
        }
        if (authConfig.loginWithUsername.requireUsername === false) {
          usernameField.required = false
        }
        if (authConfig.loginWithUsername.allowEmailLogin === false) {
          emailField.unique = false
        }
      }
    }

    authFields.push(emailField)
    if (usernameField) {
      authFields.push(usernameField)
    }

    authFields.push(...baseAuthFields)

    if (authConfig.verify) {
      authFields.push(...verificationFields)
    }

    if (authConfig?.maxLoginAttempts && authConfig.maxLoginAttempts > 0) {
      authFields.push(...accountLockFields)
    }
  }

  return authFields
}
</file>

<file path="packages/payload/src/auth/getFieldsToSign.ts">
// @ts-strict-ignore
import type { CollectionConfig } from '../collections/config/types.js'
import type { Field, TabAsField } from '../fields/config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { fieldAffectsData, tabHasName } from '../fields/config/types.js'

type TraverseFieldsArgs = {
  data: Record<string, unknown>
  fields: (Field | TabAsField)[]
  result: Record<string, unknown>
}
const traverseFields = ({
  data,
  // parent,
  fields,
  result,
}: TraverseFieldsArgs) => {
  fields.forEach((field) => {
    switch (field.type) {
      case 'collapsible':
      case 'row': {
        traverseFields({
          data,
          fields: field.fields,
          result,
        })
        break
      }
      case 'group': {
        let targetResult
        if (typeof field.saveToJWT === 'string') {
          targetResult = field.saveToJWT
          result[field.saveToJWT] = data[field.name]
        } else if (field.saveToJWT) {
          targetResult = field.name
          result[field.name] = data[field.name]
        }
        const groupData: Record<string, unknown> = data[field.name] as Record<string, unknown>
        const groupResult = (targetResult ? result[targetResult] : result) as Record<
          string,
          unknown
        >
        traverseFields({
          data: groupData,
          fields: field.fields,
          result: groupResult,
        })
        break
      }
      case 'tab': {
        if (tabHasName(field)) {
          let targetResult
          if (typeof field.saveToJWT === 'string') {
            targetResult = field.saveToJWT
            result[field.saveToJWT] = data[field.name]
          } else if (field.saveToJWT) {
            targetResult = field.name
            result[field.name] = data[field.name]
          }
          const tabData: Record<string, unknown> = data[field.name] as Record<string, unknown>
          const tabResult = (targetResult ? result[targetResult] : result) as Record<
            string,
            unknown
          >
          traverseFields({
            data: tabData,
            fields: field.fields,
            result: tabResult,
          })
        } else {
          traverseFields({
            data,
            fields: field.fields,
            result,
          })
        }
        break
      }
      case 'tabs': {
        traverseFields({
          data,
          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
          result,
        })
        break
      }
      default:
        if (fieldAffectsData(field)) {
          if (field.saveToJWT) {
            if (typeof field.saveToJWT === 'string') {
              result[field.saveToJWT] = data[field.name]
              delete result[field.name]
            } else {
              result[field.name] = data[field.name] as Record<string, unknown>
            }
          } else if (field.saveToJWT === false) {
            delete result[field.name]
          }
        }
    }
  })
  return result
}
export const getFieldsToSign = (args: {
  collectionConfig: CollectionConfig
  email: string
  user: PayloadRequest['user']
}): Record<string, unknown> => {
  const { collectionConfig, email, user } = args

  const result: Record<string, unknown> = {
    id: user?.id,
    collection: collectionConfig.slug,
    email,
  }

  traverseFields({
    data: user,
    fields: collectionConfig.fields,
    result,
  })

  return result
}
</file>

<file path="packages/payload/src/auth/getLoginOptions.ts">
// @ts-strict-ignore
import type { Auth } from './types.js'

export const getLoginOptions = (
  loginWithUsername: Auth['loginWithUsername'],
): {
  canLoginWithEmail: boolean
  canLoginWithUsername: boolean
} => {
  return {
    canLoginWithEmail: !loginWithUsername || loginWithUsername.allowEmailLogin,
    canLoginWithUsername: Boolean(loginWithUsername),
  }
}
</file>

<file path="packages/payload/src/auth/index.ts">
export * from './cookies.js'

export { extractJWT } from './extractJWT.js'
export * from './types.js'
</file>

<file path="packages/payload/src/auth/isLocked.ts">
const isLocked = (date: number): boolean => {
  if (!date) {
    return false
  }
  return date > Date.now()
}
export default isLocked
</file>

<file path="packages/payload/src/auth/jwt.ts">
import { SignJWT } from 'jose'

export const jwtSign = async ({
  fieldsToSign,
  secret,
  tokenExpiration,
}: {
  fieldsToSign: Record<string, unknown>
  secret: string
  tokenExpiration: number
}) => {
  const secretKey = new TextEncoder().encode(secret)
  const issuedAt = Math.floor(Date.now() / 1000)
  const exp = issuedAt + tokenExpiration
  const token = await new SignJWT(fieldsToSign)
    .setProtectedHeader({ alg: 'HS256', typ: 'JWT' })
    .setIssuedAt(issuedAt)
    .setExpirationTime(exp)
    .sign(secretKey)
  return { exp, token }
}
</file>

<file path="packages/payload/src/auth/sendVerificationEmail.ts">
// @ts-strict-ignore
import { URL } from 'url'

import type { Collection } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { InitializedEmailAdapter } from '../email/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { User, VerifyConfig } from './types.js'

type Args = {
  collection: Collection
  config: SanitizedConfig
  disableEmail: boolean
  email: InitializedEmailAdapter
  req: PayloadRequest
  token: string
  user: User
}

export async function sendVerificationEmail(args: Args): Promise<void> {
  // Verify token from e-mail
  const {
    collection: { config: collectionConfig },
    config,
    disableEmail,
    email,
    req,
    token,
    user,
  } = args

  if (!disableEmail) {
    const protocol = new URL(req.url).protocol // includes the final :
    const serverURL =
      config.serverURL !== null && config.serverURL !== ''
        ? config.serverURL
        : `${protocol}//${req.headers.get('host')}`

    const verificationURL = `${serverURL}${config.routes.admin}/${collectionConfig.slug}/verify/${token}`

    let html = `${req.t('authentication:newAccountCreated', {
      serverURL: config.serverURL,
      verificationURL,
    })}`

    const verify = collectionConfig.auth.verify as VerifyConfig

    // Allow config to override email content
    if (typeof verify.generateEmailHTML === 'function') {
      html = await verify.generateEmailHTML({
        req,
        token,
        user,
      })
    }

    let subject = req.t('authentication:verifyYourEmail')

    // Allow config to override email subject
    if (typeof verify.generateEmailSubject === 'function') {
      subject = await verify.generateEmailSubject({
        req,
        token,
        user,
      })
    }

    await email.sendEmail({
      from: `"${email.defaultFromName}" <${email.defaultFromAddress}>`,
      html,
      subject,
      to: user.email,
    })
  }
}
</file>

<file path="packages/payload/src/auth/types.ts">
import type { DeepRequired } from 'ts-essentials'

import type { CollectionSlug, GlobalSlug, Payload } from '../index.js'
import type { PayloadRequest, Where } from '../types/index.js'

/**
 * A permission object that can be used to determine if a user has access to a specific operation.
 */
export type Permission = {
  permission: boolean
  where?: Where
}

export type FieldsPermissions = {
  [fieldName: string]: FieldPermissions
}

export type BlockPermissions = {
  create: Permission
  fields: FieldsPermissions
  read: Permission
  update: Permission
}

export type SanitizedBlockPermissions =
  | {
      fields: SanitizedFieldsPermissions
    }
  | true

export type BlocksPermissions = {
  [blockSlug: string]: BlockPermissions
}

export type SanitizedBlocksPermissions =
  | {
      [blockSlug: string]: SanitizedBlockPermissions
    }
  | true

export type FieldPermissions = {
  blocks?: BlocksPermissions
  create: Permission
  fields?: FieldsPermissions
  read: Permission
  update: Permission
}

export type SanitizedFieldPermissions =
  | {
      blocks?: SanitizedBlocksPermissions
      create: true
      fields?: SanitizedFieldsPermissions
      read: true
      update: true
    }
  | true

export type SanitizedFieldsPermissions =
  | {
      [fieldName: string]: SanitizedFieldPermissions
    }
  | true

export type CollectionPermission = {
  create: Permission
  delete: Permission
  fields: FieldsPermissions
  read: Permission
  readVersions?: Permission
  update: Permission
}

export type SanitizedCollectionPermission = {
  create?: true
  delete?: true
  fields: SanitizedFieldsPermissions
  read?: true
  readVersions?: true
  update?: true
}

export type GlobalPermission = {
  fields: FieldsPermissions
  read: Permission
  readVersions?: Permission
  update: Permission
}

export type SanitizedGlobalPermission = {
  fields: SanitizedFieldsPermissions
  read?: true
  readVersions?: true
  update?: true
}

export type DocumentPermissions = CollectionPermission | GlobalPermission

export type SanitizedDocumentPermissions = SanitizedCollectionPermission | SanitizedGlobalPermission

export type Permissions = {
  canAccessAdmin: boolean
  collections?: Record<CollectionSlug, CollectionPermission>
  globals?: Record<GlobalSlug, GlobalPermission>
}

export type SanitizedPermissions = {
  canAccessAdmin?: boolean
  collections?: {
    [collectionSlug: string]: SanitizedCollectionPermission
  }
  globals?: {
    [globalSlug: string]: SanitizedGlobalPermission
  }
}

type BaseUser = {
  collection: string
  email?: string
  id: number | string
  username?: string
}

export type User = {
  [key: string]: any
} & BaseUser

/**
 * `collection` is not available one the client. It's only available on the server (req.user)
 * On the client, you can access the collection via config.admin.user. Config can be accessed using the useConfig() hook
 */
export type ClientUser = {
  [key: string]: any
} & BaseUser

type GenerateVerifyEmailHTML<TUser = any> = (args: {
  req: PayloadRequest
  token: string
  user: TUser
}) => Promise<string> | string

type GenerateVerifyEmailSubject<TUser = any> = (args: {
  req: PayloadRequest
  token: string
  user: TUser
}) => Promise<string> | string

type GenerateForgotPasswordEmailHTML<TUser = any> = (args?: {
  req?: PayloadRequest
  token?: string
  user?: TUser
}) => Promise<string> | string

type GenerateForgotPasswordEmailSubject<TUser = any> = (args?: {
  req?: PayloadRequest
  token?: string
  user?: TUser
}) => Promise<string> | string

export type AuthStrategyFunctionArgs = {
  headers: Request['headers']
  isGraphQL?: boolean
  payload: Payload
  /**
   * The AuthStrategy name property from the payload config.
   */
  strategyName?: string
}

export type AuthStrategyResult = {
  responseHeaders?: Headers
  user:
    | ({
        _strategy?: string
        collection?: string
      } & User)
    | null
}

export type AuthStrategyFunction = (
  args: AuthStrategyFunctionArgs,
) => AuthStrategyResult | Promise<AuthStrategyResult>
export type AuthStrategy = {
  authenticate: AuthStrategyFunction
  name: string
}

export type LoginWithUsernameOptions =
  | {
      allowEmailLogin?: false
      requireEmail?: boolean
      // If `allowEmailLogin` is false, `requireUsername` must be true (default: true)
      requireUsername?: true
    }
  | {
      allowEmailLogin?: true
      requireEmail?: boolean
      requireUsername?: boolean
    }

export interface IncomingAuthType {
  /**
   * Set cookie options, including secure, sameSite, and domain. For advanced users.
   */
  cookies?: {
    domain?: string
    sameSite?: 'Lax' | 'None' | 'Strict' | boolean
    secure?: boolean
  }
  /**
   * How many levels deep a user document should be populated when creating the JWT and binding the user to the req. Defaults to 0 and should only be modified if absolutely necessary, as this will affect performance.
   * @default 0
   */
  depth?: number
  /**
   * Advanced - disable Payload's built-in local auth strategy. Only use this property if you have replaced Payload's auth mechanisms with your own.
   */
  disableLocalStrategy?:
    | {
        /**
         * Include auth fields on the collection even though the local strategy is disabled.
         * Useful when you do not want the database or types to vary depending on the auth configuration.
         */
        enableFields?: true
        optionalPassword?: true
      }
    | true
  /**
   * Customize the way that the forgotPassword operation functions.
   * @link https://payloadcms.com/docs/authentication/email#forgot-password
   */
  forgotPassword?: {
    /**
     * The number of milliseconds that the forgot password token should be valid for.
     * @default 3600000 // 1 hour
     */
    expiration?: number
    generateEmailHTML?: GenerateForgotPasswordEmailHTML
    generateEmailSubject?: GenerateForgotPasswordEmailSubject
  }
  /**
   * Set the time (in milliseconds) that a user should be locked out if they fail authentication more times than maxLoginAttempts allows for.
   */
  lockTime?: number
  /**
   * Ability to allow users to login with username/password.
   *
   * @link https://payloadcms.com/docs/authentication/overview#login-with-username
   */
  loginWithUsername?: boolean | LoginWithUsernameOptions
  /**
   * Only allow a user to attempt logging in X amount of times. Automatically locks out a user from authenticating if this limit is passed. Set to 0 to disable.
   */
  maxLoginAttempts?: number
  /***
   * Set to true if you want to remove the token from the returned authentication API responses such as login or refresh.
   */
  removeTokenFromResponses?: true
  /**
   * Advanced - an array of custom authentification strategies to extend this collection's authentication with.
   * @link https://payloadcms.com/docs/authentication/custom-strategies
   */
  strategies?: AuthStrategy[]
  /**
   * Controls how many seconds the token will be valid for. Default is 2 hours.
   * @default 7200
   * @link https://payloadcms.com/docs/authentication/overview#config-options
   */
  tokenExpiration?: number
  /**
   * Payload Authentication provides for API keys to be set on each user within an Authentication-enabled Collection.
   * @default false
   * @link https://payloadcms.com/docs/authentication/api-keys
   */
  useAPIKey?: boolean
  /**
   * Set to true or pass an object with verification options to require users to verify by email before they are allowed to log into your app.
   * @link https://payloadcms.com/docs/authentication/email#email-verification
   */
  verify?:
    | {
        generateEmailHTML?: GenerateVerifyEmailHTML
        generateEmailSubject?: GenerateVerifyEmailSubject
      }
    | boolean
}

export type VerifyConfig = {
  generateEmailHTML?: GenerateVerifyEmailHTML
  generateEmailSubject?: GenerateVerifyEmailSubject
}

export interface Auth
  extends Omit<DeepRequired<IncomingAuthType>, 'forgotPassword' | 'loginWithUsername' | 'verify'> {
  forgotPassword?: {
    expiration?: number
    generateEmailHTML?: GenerateForgotPasswordEmailHTML
    generateEmailSubject?: GenerateForgotPasswordEmailSubject
  }
  loginWithUsername: false | LoginWithUsernameOptions
  verify?: boolean | VerifyConfig
}

export function hasWhereAccessResult(result: boolean | Where): result is Where {
  return result && typeof result === 'object'
}
</file>

<file path="packages/payload/src/bin/generateImportMap/utilities/addPayloadComponentToImportMap.ts">
import crypto from 'crypto'
import path from 'path'

import type { PayloadComponent } from '../../../config/types.js'
import type { Imports, InternalImportMap } from '../index.js'

import { parsePayloadComponent } from './parsePayloadComponent.js'

/**
 * Normalizes the component path based on the import map's base directory path.
 */
function getAdjustedComponentPath(importMapToBaseDirPath: string, componentPath: string): string {
  // Normalize input paths to use forward slashes
  const normalizedBasePath = importMapToBaseDirPath.replace(/\\/g, '/')
  const normalizedComponentPath = componentPath.replace(/\\/g, '/')

  // Base path starts with './' - preserve the './' prefix
  // => import map is in a subdirectory of the base directory, or in the same directory as the base directory
  if (normalizedBasePath.startsWith('./')) {
    // Remove './' from component path if it exists
    const cleanComponentPath = normalizedComponentPath.startsWith('./')
      ? normalizedComponentPath.substring(2)
      : normalizedComponentPath

    // Join the paths to preserve the './' prefix
    return `${normalizedBasePath}${cleanComponentPath}`
  }

  return path.posix.join(normalizedBasePath, normalizedComponentPath)
}

/**
 * Adds a payload component to the import map.
 */
export function addPayloadComponentToImportMap({
  importMap,
  importMapToBaseDirPath,
  imports,
  payloadComponent,
}: {
  importMap: InternalImportMap
  importMapToBaseDirPath: string
  imports: Imports
  payloadComponent: PayloadComponent
}): {
  path: string
  specifier: string
} | null {
  if (!payloadComponent) {
    return null
  }
  const { exportName, path: componentPath } = parsePayloadComponent(payloadComponent)

  if (importMap[componentPath + '#' + exportName]) {
    return null
  }

  const importIdentifier =
    exportName + '_' + crypto.createHash('md5').update(componentPath).digest('hex')

  importMap[componentPath + '#' + exportName] = importIdentifier

  const isRelativePath = componentPath.startsWith('.') || componentPath.startsWith('/')

  if (isRelativePath) {
    const adjustedComponentPath = getAdjustedComponentPath(importMapToBaseDirPath, componentPath)

    imports[importIdentifier] = {
      path: adjustedComponentPath,
      specifier: exportName,
    }
    return {
      path: adjustedComponentPath,
      specifier: exportName,
    }
  } else {
    // Tsconfig alias or package import, e.g. '@convexcms/ui' or '@/components/MyComponent'
    imports[importIdentifier] = {
      path: componentPath,
      specifier: exportName,
    }
    return {
      path: componentPath,
      specifier: exportName,
    }
  }
}
</file>

<file path="packages/payload/src/bin/generateImportMap/utilities/getFromImportMap.ts">
import type { PayloadComponent } from '../../../config/types.js'
import type { ImportMap } from '../index.js'

import { parsePayloadComponent } from './parsePayloadComponent.js'

export const getFromImportMap = <TOutput>(args: {
  importMap: ImportMap
  PayloadComponent: PayloadComponent
  schemaPath?: string
  silent?: boolean
}): TOutput => {
  const { importMap, PayloadComponent, schemaPath, silent } = args

  const { exportName, path } = parsePayloadComponent(PayloadComponent)

  const key = path + '#' + exportName

  const importMapEntry = importMap[key]

  if (!importMapEntry && !silent) {
    // eslint-disable-next-line no-console
    console.error(
      `getFromImportMap: PayloadComponent not found in importMap`,
      {
        key,
        PayloadComponent,
        schemaPath,
      },
      'You may need to run the `payload generate:importmap` command to generate the importMap ahead of runtime.',
    )
  }

  return importMapEntry
}
</file>

<file path="packages/payload/src/bin/generateImportMap/utilities/getImportMapToBaseDirPath.ts">
import path from 'path'

/**
 * Returns the path that navigates from the import map file to the base directory.
 * This can then be prepended to relative paths in the import map to get the full, absolute path.
 */
export function getImportMapToBaseDirPath({
  baseDir,
  importMapPath,
}: {
  /**
   * Absolute path to the base directory
   */
  baseDir: string
  /**
   * Absolute path to the import map file
   */
  importMapPath: string
}): string {
  const importMapDir = path.dirname(importMapPath)

  // 1. Direct relative path from `importMapDir` -> `baseDir`
  let relativePath = path.relative(importMapDir, baseDir).replace(/\\/g, '/')

  // 2. If they're the same directory, path.relative will be "", so use "./"
  if (!relativePath) {
    relativePath = './'
  } // Add ./ prefix for subdirectories of the current directory
  else if (!relativePath.startsWith('.') && !relativePath.startsWith('/')) {
    relativePath = `./${relativePath}`
  }

  // 3. For consistency ensure a trailing slash
  if (!relativePath.endsWith('/')) {
    relativePath += '/'
  }

  return relativePath
}
</file>

<file path="packages/payload/src/bin/generateImportMap/utilities/parsePayloadComponent.ts">
// @ts-strict-ignore
import type { PayloadComponent } from '../../../config/types.js'

export function parsePayloadComponent(PayloadComponent: PayloadComponent): {
  exportName: string
  path: string
} {
  if (!PayloadComponent) {
    return null
  }

  const pathAndMaybeExport =
    typeof PayloadComponent === 'string' ? PayloadComponent : PayloadComponent.path

  let path = ''
  let exportName = 'default'

  if (pathAndMaybeExport?.includes('#')) {
    ;[path, exportName] = pathAndMaybeExport.split('#')
  } else {
    path = pathAndMaybeExport
  }

  if (typeof PayloadComponent === 'object' && PayloadComponent.exportName) {
    exportName = PayloadComponent.exportName
  }

  return { exportName, path }
}
</file>

<file path="packages/payload/src/bin/generateImportMap/utilities/resolveImportMapFilePath.ts">
import fs from 'fs'
import path from 'path'

/**
 * Returns the path to the import map file. If the import map file is not found, it throws an error.
 */
export function resolveImportMapFilePath({
  adminRoute = '/admin',
  importMapFile,
  rootDir,
}: {
  adminRoute?: string
  importMapFile?: string
  rootDir: string
}) {
  let importMapFilePath: string | undefined = undefined

  if (importMapFile?.length) {
    if (!fs.existsSync(importMapFile)) {
      throw new Error(`Could not find the import map file at ${importMapFile}`)
    }
    importMapFilePath = importMapFile
  } else {
    const appLocation = path.resolve(rootDir, `app/(payload)${adminRoute}/`)
    const srcAppLocation = path.resolve(rootDir, `src/app/(payload)${adminRoute}/`)

    if (fs.existsSync(appLocation)) {
      importMapFilePath = path.resolve(appLocation, 'importMap.js')
    } else if (fs.existsSync(srcAppLocation)) {
      importMapFilePath = path.resolve(srcAppLocation, 'importMap.js')
    } else {
      throw new Error(
        `Could not find Payload import map folder. Looked in ${appLocation} and ${srcAppLocation}`,
      )
    }
  }
  return importMapFilePath
}
</file>

<file path="packages/payload/src/bin/generateImportMap/generateImportMap.spec.ts">
import type { PayloadComponent } from '../../index.js'
import { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'
import { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'

describe('addPayloadComponentToImportMap', () => {
  let importMap: Record<string, string>
  let imports: Record<
    string,
    {
      path: string
      specifier: string
    }
  >

  beforeEach(() => {
    importMap = {}
    imports = {}
    jest.restoreAllMocks()
  })

  function componentPathTest({
    baseDir,
    importMapFilePath,
    payloadComponent,
    expectedPath,
    expectedSpecifier,
    expectedImportMapToBaseDirPath,
  }: {
    baseDir: string
    importMapFilePath: string
    payloadComponent: PayloadComponent
    expectedPath: string
    expectedImportMapToBaseDirPath: string
    expectedSpecifier: string
  }) {
    const importMapToBaseDirPath = getImportMapToBaseDirPath({
      baseDir,
      importMapPath: importMapFilePath,
    })

    expect(importMapToBaseDirPath).toBe(expectedImportMapToBaseDirPath)

    const { path, specifier } =
      addPayloadComponentToImportMap({
        importMapToBaseDirPath,
        importMap,
        imports,
        payloadComponent,
      }) ?? {}

    expect(path).toBe(expectedPath)
    expect(specifier).toBe(expectedSpecifier)
  }

  it('relative path with import map partially in base dir', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map partially in base dir 2', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/prod/app/(payload)/importMap.js',
      payloadComponent: {
        path: './MyComponent.js#MyExport',
      },
      expectedImportMapToBaseDirPath: '../../../myTest/',
      expectedPath: '../../../myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map partially in base dir 3', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/prod/app/(payload)/importMap.js',
      payloadComponent: {
        path: '../otherTest/MyComponent.js',
        exportName: 'MyExport',
      },
      expectedImportMapToBaseDirPath: '../../../myTest/',
      expectedPath: '../../../otherTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map within base dir', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/myTest/prod/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../../',
      expectedPath: '../../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir 2', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '../myOtherTest/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myOtherTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir, baseDir ending with slash', () => {
    componentPathTest({
      baseDir: '/test/myTest/',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir, component starting with slash', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('aliased path', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '@components/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '@components/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })
  it('aliased path in PayloadComponent object', () => {
    componentPathTest({
      baseDir: '/test/',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: {
        path: '@components/MyComponent.js',
      },
      expectedImportMapToBaseDirPath: '../../test/',
      expectedPath: '@components/MyComponent.js',
      expectedSpecifier: 'default',
    })
  })

  it('relative path import starting with slash, going up', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/app/importMap.js',
      payloadComponent: '/../MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../',
      expectedPath: '../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path import starting with dot-slash, going up', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/app/importMap.js',
      payloadComponent: './../MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../',
      expectedPath: '../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('importMap and baseDir in same directory', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: './',
      expectedPath: './MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('baseDir within importMap dir', () => {
    componentPathTest({
      baseDir: '/test/myTest/components',
      importMapFilePath: '/test/myTest/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: './components/',
      expectedPath: './components/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })
})
</file>

<file path="packages/payload/src/bin/generateImportMap/index.ts">
/* eslint-disable no-console */
import fs from 'fs/promises'
import process from 'node:process'

import type { PayloadComponent, SanitizedConfig } from '../../config/types.js'

import { iterateConfig } from './iterateConfig.js'
import { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'
import { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'
import { resolveImportMapFilePath } from './utilities/resolveImportMapFilePath.js'

type ImportIdentifier = string
type ImportSpecifier = string
type ImportPath = string
type UserImportPath = string

/**
 * Import Map before being written to the file. Only contains all paths
 */
export type InternalImportMap = {
  [path: UserImportPath]: ImportIdentifier
}

/**
 * Imports of the import map.
 */
export type Imports = {
  [identifier: ImportIdentifier]: {
    path: ImportPath
    specifier: ImportSpecifier
  }
}

/**
 * Import Map after being imported from the actual import map. Contains all the actual imported components
 */
export type ImportMap = {
  [path: UserImportPath]: any
}

export type AddToImportMap = (payloadComponent: PayloadComponent | PayloadComponent[]) => void

export async function generateImportMap(
  config: SanitizedConfig,
  options?: { force?: boolean; log: boolean },
): Promise<void> {
  const shouldLog = options?.log ?? true

  if (shouldLog) {
    console.log('Generating import map')
  }

  const importMap: InternalImportMap = {}
  const imports: Imports = {}

  // Determine the root directory of the project - usually the directory where the src or app folder is located
  const rootDir = process.env.ROOT_DIR ?? process.cwd()

  const baseDir = config.admin.importMap.baseDir ?? process.cwd()

  const importMapFilePath = resolveImportMapFilePath({
    adminRoute: config.routes.admin,
    importMapFile: config?.admin?.importMap?.importMapFile,
    rootDir,
  })

  const importMapToBaseDirPath = getImportMapToBaseDirPath({
    baseDir,
    importMapPath: importMapFilePath,
  })

  const addToImportMap: AddToImportMap = (payloadComponent) => {
    if (!payloadComponent) {
      return
    }

    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {
      console.error(payloadComponent)
      throw new Error('addToImportMap > Payload component must be an object or a string')
    }

    if (Array.isArray(payloadComponent)) {
      for (const component of payloadComponent) {
        addPayloadComponentToImportMap({
          importMap,
          importMapToBaseDirPath,
          imports,
          payloadComponent: component,
        })
      }
    } else {
      addPayloadComponentToImportMap({
        importMap,
        importMapToBaseDirPath,
        imports,
        payloadComponent,
      })
    }
  }

  iterateConfig({
    addToImportMap,
    baseDir: config.admin.importMap.baseDir,
    config,
    importMap,
    imports,
  })

  await writeImportMap({
    componentMap: importMap,
    force: options?.force,
    importMap: imports,
    importMapFilePath,
    log: shouldLog,
  })
}

export async function writeImportMap({
  componentMap,
  force,
  importMap,
  importMapFilePath,
  log,
}: {
  componentMap: InternalImportMap
  force?: boolean
  importMap: Imports
  importMapFilePath: string
  log?: boolean
}) {
  const imports: string[] = []
  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {
    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)
  }

  const mapKeys: string[] = []
  for (const [userPath, identifier] of Object.entries(componentMap)) {
    mapKeys.push(`  "${userPath}": ${identifier}`)
  }

  const importMapOutputFile = `${imports.join('\n')}

export const importMap = {
${mapKeys.join(',\n')}
}
`

  if (!force) {
    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.
    const currentImportMap = await fs.readFile(importMapFilePath, 'utf-8')

    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {
      if (log) {
        console.log('No new imports found, skipping writing import map')
      }
      return
    }
  }

  if (log) {
    console.log('Writing import map to', importMapFilePath)
  }

  await fs.writeFile(importMapFilePath, importMapOutputFile)
}
</file>

<file path="packages/payload/src/bin/generateImportMap/iterateCollections.ts">
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { SanitizedConfig } from '../../config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { genImportMapIterateFields } from './iterateFields.js'

export function iterateCollections({
  addToImportMap,
  baseDir,
  collections,
  config,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  collections: SanitizedCollectionConfig[]
  config: SanitizedConfig
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const collection of collections) {
    genImportMapIterateFields({
      addToImportMap,
      baseDir,
      config,
      fields: collection.fields,
      importMap,
      imports,
    })

    addToImportMap(collection.admin?.components?.afterList)
    addToImportMap(collection.admin?.components?.listMenuItems)
    addToImportMap(collection.admin?.components?.afterListTable)
    addToImportMap(collection.admin?.components?.beforeList)
    addToImportMap(collection.admin?.components?.beforeListTable)
    addToImportMap(collection.admin?.components?.Description)

    addToImportMap(collection.admin?.components?.edit?.PreviewButton)
    addToImportMap(collection.admin?.components?.edit?.PublishButton)
    addToImportMap(collection.admin?.components?.edit?.SaveButton)
    addToImportMap(collection.admin?.components?.edit?.SaveDraftButton)
    addToImportMap(collection.admin?.components?.edit?.Upload)

    if (collection.admin?.components?.views?.edit) {
      for (const editViewConfig of Object.values(collection.admin?.components?.views?.edit)) {
        if ('Component' in editViewConfig) {
          addToImportMap(editViewConfig?.Component)
        }

        if ('actions' in editViewConfig) {
          addToImportMap(editViewConfig?.actions)
        }

        if ('tab' in editViewConfig) {
          addToImportMap(editViewConfig?.tab?.Component)
          addToImportMap(editViewConfig?.tab?.Pill)
        }
      }
    }

    addToImportMap(collection.admin?.components?.views?.list?.Component)
    addToImportMap(collection.admin?.components?.views?.list?.actions)
  }
}
</file>

<file path="packages/payload/src/bin/generateImportMap/iterateConfig.ts">
// @ts-strict-ignore

import type { AdminViewConfig } from '../../admin/views/index.js'
import type { SanitizedConfig } from '../../config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { iterateCollections } from './iterateCollections.js'
import { genImportMapIterateFields } from './iterateFields.js'
import { iterateGlobals } from './iterateGlobals.js'

export function iterateConfig({
  addToImportMap,
  baseDir,
  config,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  importMap: InternalImportMap
  imports: Imports
}) {
  iterateCollections({
    addToImportMap,
    baseDir,
    collections: config.collections,
    config,
    importMap,
    imports,
  })

  iterateGlobals({
    addToImportMap,
    baseDir,
    config,
    globals: config.globals,
    importMap,
    imports,
  })

  if (config?.blocks) {
    const blocks = Object.values(config.blocks)
    if (blocks?.length) {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: blocks,
        importMap,
        imports,
      })
    }
  }

  if (typeof config.admin?.avatar === 'object') {
    addToImportMap(config.admin?.avatar?.Component)
  }

  addToImportMap(config.admin?.components?.Nav)
  addToImportMap(config.admin?.components?.header)
  addToImportMap(config.admin?.components?.logout?.Button)
  addToImportMap(config.admin?.components?.graphics?.Icon)
  addToImportMap(config.admin?.components?.graphics?.Logo)

  addToImportMap(config.admin?.components?.actions)
  addToImportMap(config.admin?.components?.afterDashboard)
  addToImportMap(config.admin?.components?.afterLogin)
  addToImportMap(config.admin?.components?.afterNavLinks)
  addToImportMap(config.admin?.components?.beforeDashboard)
  addToImportMap(config.admin?.components?.beforeLogin)
  addToImportMap(config.admin?.components?.beforeNavLinks)

  addToImportMap(config.admin?.components?.providers)

  if (config.admin?.components?.views) {
    if (Object.keys(config.admin?.components?.views)?.length) {
      for (const key in config.admin?.components?.views) {
        const adminViewConfig = config.admin?.components?.views[key]
        addToImportMap(adminViewConfig?.Component)
      }
    }
  }

  if (config?.admin?.importMap?.generators?.length) {
    for (const generator of config.admin.importMap.generators) {
      generator({
        addToImportMap,
        baseDir,
        config,
        importMap,
        imports,
      })
    }
  }

  if (config?.admin?.dependencies) {
    for (const dependency of Object.values(config.admin.dependencies)) {
      addToImportMap(dependency.path)
    }
  }

  /*
  if (
    config?.editor &&
    typeof config.editor === 'object' &&
    config.editor.generateImportMap &&
    typeof config.editor.generateImportMap === 'function'
  ) {
    config.editor.generateImportMap({
      addToImportMap,
      baseDir,
      componentMap,
      config,
      importMap,
    })
  }*/ // No need to do that here since in the sanitized editor config, this root editor is already added to the field editor - and we already process that in iterateFields
}
</file>

<file path="packages/payload/src/bin/generateImportMap/iterateFields.ts">
// @ts-strict-ignore
/* eslint-disable @typescript-eslint/no-unused-expressions */
import type { PayloadComponent, SanitizedConfig } from '../../config/types.js'
import type { Block, Field, Tab } from '../../fields/config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

function hasKey<T, K extends string>(
  obj: null | T | undefined,
  key: K,
): obj is { [P in K]: PayloadComponent | PayloadComponent[] } & T {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, key)
}

const defaultUIFieldComponentKeys: Array<'Cell' | 'Description' | 'Field' | 'Filter'> = [
  'Cell',
  'Description',
  'Field',
  'Filter',
]
export function genImportMapIterateFields({
  addToImportMap,
  baseDir,
  config,
  fields,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  fields: Block[] | Field[] | Tab[]
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const field of fields) {
    if ('fields' in field) {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.fields,
        importMap,
        imports,
      })
    } else if (field.type === 'blocks') {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.blocks.filter((block) => typeof block !== 'string'),
        importMap,
        imports,
      })
    } else if (field.type === 'tabs') {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.tabs,
        importMap,
        imports,
      })
    } else if (field.type === 'richText') {
      if (
        field?.editor &&
        typeof field.editor === 'object' &&
        field.editor.generateImportMap &&
        typeof field.editor.generateImportMap === 'function'
      ) {
        field.editor.generateImportMap({
          addToImportMap,
          baseDir,
          config,
          importMap,
          imports,
        })
      }
    } else if (field.type === 'ui') {
      if (field?.admin?.components) {
        // Render any extra, untyped components
        for (const key in field.admin.components) {
          if (key in defaultUIFieldComponentKeys) {
            continue
          }
          addToImportMap(field.admin.components[key])
        }
      }
    }

    hasKey(field?.admin, 'jsx') && addToImportMap(field.admin.jsx) // For Blocks

    hasKey(field?.admin?.components, 'Label') && addToImportMap(field.admin.components.Label)

    hasKey(field?.admin?.components, 'Block') && addToImportMap(field.admin.components.Block)

    hasKey(field?.admin?.components, 'Cell') && addToImportMap(field?.admin?.components?.Cell)

    hasKey(field?.admin?.components, 'Description') &&
      addToImportMap(field?.admin?.components?.Description)

    hasKey(field?.admin?.components, 'Field') && addToImportMap(field?.admin?.components?.Field)
    hasKey(field?.admin?.components, 'Filter') && addToImportMap(field?.admin?.components?.Filter)

    hasKey(field?.admin?.components, 'Error') && addToImportMap(field?.admin?.components?.Error)

    hasKey(field?.admin?.components, 'afterInput') &&
      addToImportMap(field?.admin?.components?.afterInput)

    hasKey(field?.admin?.components, 'beforeInput') &&
      addToImportMap(field?.admin?.components?.beforeInput)

    hasKey(field?.admin?.components, 'RowLabel') &&
      addToImportMap(field?.admin?.components?.RowLabel)

    hasKey(field?.admin?.components, 'Diff') && addToImportMap(field?.admin?.components?.Diff)
  }
}
</file>

<file path="packages/payload/src/bin/generateImportMap/iterateGlobals.ts">
import type { SanitizedConfig } from '../../config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { genImportMapIterateFields } from './iterateFields.js'

export function iterateGlobals({
  addToImportMap,
  baseDir,
  config,
  globals,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  globals: SanitizedGlobalConfig[]
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const global of globals) {
    genImportMapIterateFields({
      addToImportMap,
      baseDir,
      config,
      fields: global.fields,
      importMap,
      imports,
    })

    addToImportMap(global.admin?.components?.elements?.Description)
    addToImportMap(global.admin?.components?.elements?.PreviewButton)
    addToImportMap(global.admin?.components?.elements?.PublishButton)
    addToImportMap(global.admin?.components?.elements?.SaveButton)
    addToImportMap(global.admin?.components?.elements?.SaveDraftButton)

    if (global.admin?.components?.views?.edit) {
      for (const editViewConfig of Object.values(global.admin?.components?.views?.edit)) {
        if ('Component' in editViewConfig) {
          addToImportMap(editViewConfig?.Component)
        }

        if ('actions' in editViewConfig) {
          addToImportMap(editViewConfig?.actions)
        }

        if ('tab' in editViewConfig) {
          addToImportMap(editViewConfig?.tab?.Component)
          addToImportMap(editViewConfig?.tab?.Pill)
        }
      }
    }
  }
}
</file>

<file path="packages/payload/src/bin/generateTypes.ts">
import type { AcceptedLanguages } from '@convexcms/translations'

import { initI18n } from '@convexcms/translations'
import fs from 'fs/promises'
import { compile } from 'json-schema-to-typescript'

import type { SanitizedConfig } from '../config/types.js'

import { addSelectGenericsToGeneratedTypes } from '../utilities/addSelectGenericsToGeneretedTypes.js'
import { configToJSONSchema } from '../utilities/configToJSONSchema.js'
import { getLogger } from '../utilities/logger.js'

export async function generateTypes(
  config: SanitizedConfig,
  options?: { log: boolean },
): Promise<void> {
  const logger = getLogger('payload', 'sync')
  const outputFile = process.env.PAYLOAD_TS_OUTPUT_PATH || config.typescript.outputFile

  const shouldLog = options?.log ?? true

  if (shouldLog) {
    logger.info('Compiling TS types for Collections and Globals...')
  }

  const languages = Object.keys(config.i18n.supportedLanguages) as AcceptedLanguages[]

  const language = languages.includes('en') ? 'en' : config.i18n.fallbackLanguage

  const i18n = await initI18n({ config: config.i18n, context: 'api', language })

  const jsonSchema = configToJSONSchema(config, config.db.defaultIDType, i18n)

  const declare = `declare module 'payload' {\n  export interface GeneratedTypes extends Config {}\n}`
  const declareWithTSIgnoreError = `declare module 'payload' {\n  // @ts-ignore \n  export interface GeneratedTypes extends Config {}\n}`

  let compiled = await compile(jsonSchema, 'Config', {
    bannerComment:
      '/* tslint:disable */\n/* eslint-disable */\n/**\n* This file was automatically generated by Payload.\n* DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n* and re-run `payload generate:types` to regenerate this file.\n*/',
    style: {
      singleQuote: true,
    },
    // Generates code for $defs that aren't referenced by the schema. Reason:
    // If a field defines an interfaceName, it should be included in the generated types
    // even if it's not used by another type. Reason: the user might want to use it in their own code.
    unreachableDefinitions: true,
  })

  compiled = addSelectGenericsToGeneratedTypes({ compiledGeneratedTypes: compiled })

  if (config.typescript.declare !== false) {
    if (config.typescript.declare?.ignoreTSError) {
      compiled += `\n\n${declareWithTSIgnoreError}`
    } else {
      compiled += `\n\n${declare}`
    }
  }

  // Diff the compiled types against the existing types file
  try {
    const existingTypes = await fs.readFile(outputFile, 'utf-8')

    if (compiled === existingTypes) {
      return
    }
  } catch (_) {
    // swallow err
  }

  await fs.writeFile(outputFile, compiled)
  if (shouldLog) {
    logger.info(`Types written to ${outputFile}`)
  }
}
</file>

<file path="packages/payload/src/bin/index.ts">
// @ts-strict-ignore
/* eslint-disable no-console */
import { Cron } from 'croner'
import minimist from 'minimist'
import { pathToFileURL } from 'node:url'
import path from 'path'

import type { BinScript } from '../config/types.js'

import { findConfig } from '../config/find.js'
import payload, { getPayload } from '../index.js'
import { generateImportMap } from './generateImportMap/index.js'
import { generateTypes } from './generateTypes.js'
import { info } from './info.js'
import { loadEnv } from './loadEnv.js'
import { migrate, availableCommands as migrateCommands } from './migrate.js'

// Note: this does not account for any user bin scripts
const availableScripts = [
  'generate:db-schema',
  'generate:importmap',
  'generate:types',
  'info',
  'jobs:run',
  'run',
  ...migrateCommands,
] as const

export const bin = async () => {
  loadEnv()

  const args = minimist(process.argv.slice(2))
  const script = (typeof args._[0] === 'string' ? args._[0] : '').toLowerCase()

  if (script === 'info') {
    await info()
    return
  }

  if (script === 'run') {
    const scriptPath = args._[1]
    if (!scriptPath) {
      console.error('Please provide a script path to run.')
      process.exit(1)
    }

    const absoluteScriptPath = path.resolve(process.cwd(), scriptPath)

    // Modify process.argv to remove 'run' and the script path
    const originalArgv = process.argv
    process.argv = [process.argv[0], process.argv[1], ...args._.slice(2)]

    try {
      await import(pathToFileURL(absoluteScriptPath).toString())
    } catch (error) {
      console.error(`Error running script: ${absoluteScriptPath}`)
      console.error(error)
      process.exit(1)
    } finally {
      // Restore original process.argv
      process.argv = originalArgv
    }
    return
  }

  const configPath = findConfig()
  const configPromise = await import(pathToFileURL(configPath).toString())
  let config = await configPromise
  if (config.default) {
    config = await config.default
  }

  const userBinScript = Array.isArray(config.bin)
    ? config.bin.find(({ key }) => key === script)
    : false

  if (userBinScript) {
    try {
      const module = await import(pathToFileURL(userBinScript.scriptPath).toString())

      if (!module.script || typeof module.script !== 'function') {
        console.error(
          `Could not find "script" function export for script ${userBinScript.key} in ${userBinScript.scriptPath}`,
        )
      } else {
        await module.script(config).catch((err: unknown) => {
          console.log(`Script ${userBinScript.key} failed, details:`)
          console.error(err)
        })
      }
    } catch (err) {
      console.log(`Could not find associated bin script for the ${userBinScript.key} command`)
      console.error(err)
    }

    return
  }

  if (script.startsWith('migrate')) {
    return migrate({ config, parsedArgs: args }).then(() => process.exit(0))
  }

  if (script === 'generate:types') {
    return generateTypes(config)
  }

  if (script === 'generate:importmap') {
    return generateImportMap(config)
  }

  if (script === 'jobs:run') {
    const payload = await getPayload({ config })
    const limit = args.limit ? parseInt(args.limit, 10) : undefined
    const queue = args.queue ? args.queue : undefined

    if (args.cron) {
      new Cron(args.cron, async () => {
        await payload.jobs.run({
          limit,
          queue,
        })
      })

      process.stdin.resume() // Keep the process alive

      return
    } else {
      await payload.jobs.run({
        limit,
        queue,
      })

      await payload.db.destroy() // close database connections after running jobs so process can exit cleanly

      return
    }
  }

  if (script === 'generate:db-schema') {
    // Barebones instance to access database adapter, without connecting to the DB
    await payload.init({
      config,
      disableDBConnect: true,
      disableOnInit: true,
    })

    if (typeof payload.db.generateSchema !== 'function') {
      payload.logger.error({
        msg: `${payload.db.packageName} does not support database schema generation`,
      })

      process.exit(1)
    }

    await payload.db.generateSchema({
      log: args.log === 'false' ? false : true,
      prettify: args.prettify === 'false' ? false : true,
    })

    process.exit(0)
  }

  console.error(script ? `Unknown command: "${script}"` : 'Please provide a command to run')
  console.log(`\nAvailable commands:\n${availableScripts.map((c) => `  - ${c}`).join('\n')}`)

  process.exit(1)
}
</file>

<file path="packages/payload/src/bin/info.ts">
import { execFileSync } from 'child_process'
import os from 'os'

import { getDependencies } from '../index.js'
import { PAYLOAD_PACKAGE_LIST } from '../versions/payloadPackageList.js'

export const info = async () => {
  const deps = await getDependencies(process.cwd(), [
    ...PAYLOAD_PACKAGE_LIST,
    'next',
    'react',
    'react-dom',
  ])

  const formattedDeps = Array.from(deps.resolved.entries()).map(([name, { version }]) => ({
    name,
    version,
  }))

  console.log(generateOutput(formattedDeps))
}

function generateOutput(packages: Array<{ name: string; version: string }>) {
  const cpuCores = os.cpus().length

  const primaryDeps = packages.filter(({ name }) => name === 'payload' || name === 'next')
  const otherDeps = packages
    .filter(({ name }) => name !== 'payload' && name !== 'next')
    .sort((a, b) => a.name.localeCompare(b.name))

  const formattedDeps = [...primaryDeps, ...otherDeps]
    .map(({ name, version }) => `  ${name}: ${version}`)
    .join('\n')

  return `
Binaries:
  Node: ${process.versions.node}
  npm: ${getBinaryVersion('npm')}
  Yarn: ${getBinaryVersion('yarn')}
  pnpm: ${getBinaryVersion('pnpm')}
Relevant Packages:
${formattedDeps}
Operating System:
  Platform: ${os.platform()}
  Arch: ${os.arch()}
  Version: ${os.version()}
  Available memory (MB): ${Math.ceil(os.totalmem() / 1024 / 1024)}
  Available CPU cores: ${cpuCores > 0 ? cpuCores : 'N/A'}
`
}

function getBinaryVersion(binaryName: string) {
  try {
    return execFileSync(binaryName, ['--version']).toString().trim()
  } catch {
    return 'N/A'
  }
}

// Direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  void info()
}
</file>

<file path="packages/payload/src/bin/loadEnv.ts">
// @ts-strict-ignore
import nextEnvImport from '@next/env'

import { findUpSync } from '../utilities/findUp.js'
const { loadEnvConfig } = nextEnvImport

/**
 * Try to find user's env files and load it. Uses the same algorithm next.js uses to parse env files, meaning this also supports .env.local, .env.development, .env.production, etc.
 */
export function loadEnv(path?: string) {
  if (path?.length) {
    loadEnvConfig(path, true)
    return
  }

  const { loadedEnvFiles } = loadEnvConfig(process.cwd(), true) // assuming this won't run in production

  if (!loadedEnvFiles?.length) {
    // use findUp to find the env file. So, run loadEnvConfig for every directory upwards
    findUpSync({
      condition: (dir) => {
        const { loadedEnvFiles } = loadEnvConfig(dir, true)
        if (loadedEnvFiles?.length) {
          return true
        }
      },
      dir: process.cwd(),
    })
  }
}
</file>

<file path="packages/payload/src/bin/migrate.ts">
// @ts-strict-ignore
import type { ParsedArgs } from 'minimist'

import type { SanitizedConfig } from '../config/types.js'

import payload from '../index.js'
import { prettySyncLoggerDestination } from '../utilities/logger.js'

/**
 * The default logger's options did not allow for forcing sync logging
 * Using these options, to force both pretty print and sync logging
 */
const prettySyncLogger = {
  loggerDestination: prettySyncLoggerDestination,
  loggerOptions: {},
}

export const availableCommands = [
  'migrate',
  'migrate:create',
  'migrate:down',
  'migrate:refresh',
  'migrate:reset',
  'migrate:status',
  'migrate:fresh',
]

const availableCommandsMsg = `Available commands: ${availableCommands.join(', ')}`

type Args = {
  config: SanitizedConfig
  parsedArgs: ParsedArgs
}

export const migrate = async ({ config, parsedArgs }: Args): Promise<void> => {
  const { _: args, file, forceAcceptWarning: forceAcceptFromProps, help } = parsedArgs

  const formattedArgs = Object.keys(parsedArgs)
    .map((key) => {
      const formattedKey = key.replace(/^[-_]+/, '')
      if (!formattedKey) {
        return null
      }

      return formattedKey
        .split('-')
        .map((word, index) =>
          index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1),
        )
        .join('')
    })
    .filter(Boolean)

  const forceAcceptWarning = forceAcceptFromProps || formattedArgs.includes('forceAcceptWarning')
  const skipEmpty = formattedArgs.includes('skipEmpty')

  if (help) {
    // eslint-disable-next-line no-console
    console.log(`\n\n${availableCommandsMsg}\n`) // Avoid having to init payload to get the logger
    process.exit(0)
  }

  process.env.PAYLOAD_MIGRATING = 'true'

  // Barebones instance to access database adapter
  await payload.init({
    config,
    disableOnInit: true,
    ...prettySyncLogger,
  })

  const adapter = payload.db

  if (!adapter) {
    throw new Error('No database adapter found')
  }

  if (!args.length) {
    payload.logger.error({
      msg: `No migration command provided. ${availableCommandsMsg}`,
    })
    process.exit(1)
  }

  switch (args[0]) {
    case 'migrate':
      await adapter.migrate()
      break
    case 'migrate:create':
      try {
        await adapter.createMigration({
          file,
          forceAcceptWarning,
          migrationName: args[1],
          payload,
          skipEmpty,
        })
      } catch (err) {
        throw new Error(`Error creating migration: ${err.message}`)
      }
      break
    case 'migrate:down':
      await adapter.migrateDown()
      break
    case 'migrate:fresh':
      await adapter.migrateFresh({ forceAcceptWarning })
      break
    case 'migrate:refresh':
      await adapter.migrateRefresh()
      break
    case 'migrate:reset':
      await adapter.migrateReset()
      break
    case 'migrate:status':
      await adapter.migrateStatus()
      break

    default:
      payload.logger.error({
        msg: `Unknown migration command: ${args[0]}. ${availableCommandsMsg}`,
      })
      process.exit(1)
  }

  payload.logger.info('Done.')
}
</file>

<file path="packages/payload/src/collections/config/build.ts">
import type { CollectionConfig } from './types.js'

const buildCollection = (collection: CollectionConfig): CollectionConfig => collection

export default buildCollection
</file>

<file path="packages/payload/src/collections/config/client.ts">
// @ts-strict-ignore
import type { I18nClient } from '@convexcms/translations'

import type { StaticDescription } from '../../admin/types.js'
import type { ImportMap } from '../../bin/generateImportMap/index.js'
import type {
  LivePreviewConfig,
  ServerOnlyLivePreviewProperties,
  StaticLabel,
} from '../../config/types.js'
import type { ClientField } from '../../fields/config/client.js'
import type { Payload } from '../../types/index.js'
import type { SanitizedUploadConfig } from '../../uploads/types.js'
import type { SanitizedCollectionConfig } from './types.js'

import { createClientFields } from '../../fields/config/client.js'

export type ServerOnlyCollectionProperties = keyof Pick<
  SanitizedCollectionConfig,
  | 'access'
  | 'custom'
  | 'endpoints'
  | 'flattenedFields'
  | 'hooks'
  | 'indexes'
  | 'joins'
  | 'polymorphicJoins'
  | 'sanitizedIndexes'
>

export type ServerOnlyCollectionAdminProperties = keyof Pick<
  SanitizedCollectionConfig['admin'],
  'baseListFilter' | 'components' | 'hidden'
>

export type ServerOnlyUploadProperties = keyof Pick<
  SanitizedCollectionConfig['upload'],
  | 'adminThumbnail'
  | 'externalFileHeaderFilter'
  | 'handlers'
  | 'modifyResponseHeaders'
  | 'withMetadata'
>

export type ClientCollectionConfig = {
  admin: {
    description?: StaticDescription
    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>
    preview?: boolean
  } & Omit<
    SanitizedCollectionConfig['admin'],
    | 'components'
    | 'description'
    | 'joins'
    | 'livePreview'
    | 'preview'
    | ServerOnlyCollectionAdminProperties
  >
  auth?: { verify?: true } & Omit<
    SanitizedCollectionConfig['auth'],
    'forgotPassword' | 'strategies' | 'verify'
  >
  fields: ClientField[]
  labels: {
    plural: StaticLabel
    singular: StaticLabel
  }
} & Omit<
  SanitizedCollectionConfig,
  'admin' | 'auth' | 'fields' | 'labels' | ServerOnlyCollectionProperties
>

const serverOnlyCollectionProperties: Partial<ServerOnlyCollectionProperties>[] = [
  'hooks',
  'access',
  'endpoints',
  'custom',
  'joins',
  'polymorphicJoins',
  'flattenedFields',
  'indexes',
  'sanitizedIndexes',
  // `upload`
  // `admin`
  // are all handled separately
]

const serverOnlyUploadProperties: Partial<ServerOnlyUploadProperties>[] = [
  'adminThumbnail',
  'externalFileHeaderFilter',
  'handlers',
  'modifyResponseHeaders',
  'withMetadata',
]

const serverOnlyCollectionAdminProperties: Partial<ServerOnlyCollectionAdminProperties>[] = [
  'hidden',
  'baseListFilter',
  'components',
  // 'preview' is handled separately
  // `livePreview` is handled separately
]

export const createClientCollectionConfig = ({
  collection,
  defaultIDType,
  i18n,
  importMap,
}: {
  collection: SanitizedCollectionConfig
  defaultIDType: Payload['config']['db']['defaultIDType']
  i18n: I18nClient
  importMap: ImportMap
}): ClientCollectionConfig => {
  const clientCollection = {} as Partial<ClientCollectionConfig>

  for (const key in collection) {
    if (serverOnlyCollectionProperties.includes(key as any)) {
      continue
    }
    switch (key) {
      case 'admin':
        if (!collection.admin) {
          break
        }
        clientCollection.admin = {} as ClientCollectionConfig['admin']
        for (const adminKey in collection.admin) {
          if (serverOnlyCollectionAdminProperties.includes(adminKey as any)) {
            continue
          }

          switch (adminKey) {
            case 'description':
              if (
                typeof collection.admin.description === 'string' ||
                typeof collection.admin.description === 'object'
              ) {
                if (collection.admin.description) {
                  clientCollection.admin.description = collection.admin.description
                }
              } else if (typeof collection.admin.description === 'function') {
                const description = collection.admin.description({ t: i18n.t })
                if (description) {
                  clientCollection.admin.description = description
                }
              }
              break
            case 'livePreview':
              clientCollection.admin.livePreview =
                {} as ClientCollectionConfig['admin']['livePreview']
              if (collection.admin.livePreview.breakpoints) {
                clientCollection.admin.livePreview.breakpoints =
                  collection.admin.livePreview.breakpoints
              }
              break
            case 'preview':
              if (collection.admin.preview) {
                clientCollection.admin.preview = true
              }
              break
            default:
              clientCollection.admin[adminKey] = collection.admin[adminKey]
          }
        }
        break
      case 'auth':
        if (!collection.auth) {
          break
        }
        clientCollection.auth = {} as { verify?: true } & SanitizedCollectionConfig['auth']
        if (collection.auth.cookies) {
          clientCollection.auth.cookies = collection.auth.cookies
        }
        if (collection.auth.depth !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.depth = collection.auth.depth
        }
        if (collection.auth.disableLocalStrategy) {
          clientCollection.auth.disableLocalStrategy = collection.auth.disableLocalStrategy
        }
        if (collection.auth.lockTime !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.lockTime = collection.auth.lockTime
        }
        if (collection.auth.loginWithUsername) {
          clientCollection.auth.loginWithUsername = collection.auth.loginWithUsername
        }
        if (collection.auth.maxLoginAttempts !== undefined) {
          // Check for undefined as it can be a number (0)
          clientCollection.auth.maxLoginAttempts = collection.auth.maxLoginAttempts
        }
        if (collection.auth.removeTokenFromResponses) {
          clientCollection.auth.removeTokenFromResponses = collection.auth.removeTokenFromResponses
        }

        if (collection.auth.useAPIKey) {
          clientCollection.auth.useAPIKey = collection.auth.useAPIKey
        }
        if (collection.auth.tokenExpiration) {
          clientCollection.auth.tokenExpiration = collection.auth.tokenExpiration
        }
        if (collection.auth.verify) {
          clientCollection.auth.verify = true
        }
        break
      case 'fields':
        clientCollection.fields = createClientFields({
          defaultIDType,
          fields: collection.fields,
          i18n,
          importMap,
        })
        break
      case 'labels':
        clientCollection.labels = {
          plural:
            typeof collection.labels.plural === 'function'
              ? collection.labels.plural({ i18n, t: i18n.t })
              : collection.labels.plural,
          singular:
            typeof collection.labels.singular === 'function'
              ? collection.labels.singular({ i18n, t: i18n.t })
              : collection.labels.singular,
        }
        break
      case 'upload':
        if (!collection.upload) {
          break
        }
        clientCollection.upload = {} as SanitizedUploadConfig
        for (const uploadKey in collection.upload) {
          if (serverOnlyUploadProperties.includes(uploadKey as any)) {
            continue
          }
          if (uploadKey === 'imageSizes') {
            clientCollection.upload.imageSizes = collection.upload.imageSizes.map((size) => {
              const sanitizedSize = { ...size }
              if ('generateImageName' in sanitizedSize) {
                delete sanitizedSize.generateImageName
              }
              return sanitizedSize
            })
          } else {
            clientCollection.upload[uploadKey] = collection.upload[uploadKey]
          }
        }
        break

      default:
        clientCollection[key] = collection[key]
    }
  }

  return clientCollection as ClientCollectionConfig
}

export const createClientCollectionConfigs = ({
  collections,
  defaultIDType,
  i18n,
  importMap,
}: {
  collections: SanitizedCollectionConfig[]
  defaultIDType: Payload['config']['db']['defaultIDType']
  i18n: I18nClient
  importMap: ImportMap
}): ClientCollectionConfig[] => {
  const clientCollections = new Array(collections.length)

  for (let i = 0; i < collections.length; i++) {
    const collection = collections[i]

    clientCollections[i] = createClientCollectionConfig({
      collection,
      defaultIDType,
      i18n,
      importMap,
    })
  }

  return clientCollections
}
</file>

<file path="packages/payload/src/collections/config/defaults.ts">
import type { IncomingAuthType, LoginWithUsernameOptions } from '../../auth/types.js'
import type { CollectionConfig } from './types.js'

import defaultAccess from '../../auth/defaultAccess.js'

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const defaults: Partial<CollectionConfig> = {
  access: {
    create: defaultAccess,
    delete: defaultAccess,
    read: defaultAccess,
    unlock: defaultAccess,
    update: defaultAccess,
  },
  admin: {
    components: {},
    custom: {},
    enableRichTextLink: true,
    enableRichTextRelationship: true,
    pagination: {
      defaultLimit: 10,
      limits: [5, 10, 25, 50, 100],
    },
    useAsTitle: 'id',
  },
  auth: false,
  custom: {},
  endpoints: [],
  fields: [],
  hooks: {
    afterChange: [],
    afterDelete: [],
    afterForgotPassword: [],
    afterLogin: [],
    afterLogout: [],
    afterMe: [],
    afterOperation: [],
    afterRead: [],
    afterRefresh: [],
    beforeChange: [],
    beforeDelete: [],
    beforeLogin: [],
    beforeOperation: [],
    beforeRead: [],
    beforeValidate: [],
    me: [],
    refresh: [],
  },
  indexes: [],
  timestamps: true,
  upload: false,
  versions: false,
}

export const addDefaultsToCollectionConfig = (collection: CollectionConfig): CollectionConfig => {
  collection.access = {
    create: defaultAccess,
    delete: defaultAccess,
    read: defaultAccess,
    unlock: defaultAccess,
    update: defaultAccess,
    ...(collection.access || {}),
  }

  collection.admin = {
    components: {},
    custom: {},
    enableRichTextLink: true,
    enableRichTextRelationship: true,
    useAsTitle: 'id',
    ...(collection.admin || {}),
    pagination: {
      defaultLimit: 10,
      limits: [5, 10, 25, 50, 100],
      ...(collection.admin?.pagination || {}),
    },
  }

  collection.auth = collection.auth ?? false
  collection.custom = collection.custom ?? {}
  collection.endpoints = collection.endpoints ?? []
  collection.fields = collection.fields ?? []

  collection.hooks = {
    afterChange: [],
    afterDelete: [],
    afterForgotPassword: [],
    afterLogin: [],
    afterLogout: [],
    afterMe: [],
    afterOperation: [],
    afterRead: [],
    afterRefresh: [],
    beforeChange: [],
    beforeDelete: [],
    beforeLogin: [],
    beforeOperation: [],
    beforeRead: [],
    beforeValidate: [],
    me: [],
    refresh: [],
    ...(collection.hooks || {}),
  }

  collection.timestamps = collection.timestamps ?? true
  collection.upload = collection.upload ?? false
  collection.versions = collection.versions ?? false

  collection.indexes = collection.indexes ?? []

  return collection
}

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const authDefaults: IncomingAuthType = {
  cookies: {
    sameSite: 'Lax',
    secure: false,
  },
  forgotPassword: {},
  lockTime: 600000, // 10 minutes
  loginWithUsername: false,
  maxLoginAttempts: 5,
  tokenExpiration: 7200,
  verify: false,
}

export const addDefaultsToAuthConfig = (auth: IncomingAuthType): IncomingAuthType => {
  auth.cookies = {
    sameSite: 'Lax',
    secure: false,
    ...(auth.cookies || {}),
  }

  auth.forgotPassword = auth.forgotPassword ?? {}
  auth.lockTime = auth.lockTime ?? 600000 // 10 minutes
  auth.loginWithUsername = auth.loginWithUsername ?? false
  auth.maxLoginAttempts = auth.maxLoginAttempts ?? 5
  auth.tokenExpiration = auth.tokenExpiration ?? 7200
  auth.verify = auth.verify ?? false
  auth.strategies = auth.strategies ?? []

  if (!auth.disableLocalStrategy && auth.verify === true) {
    auth.verify = {}
  }

  return auth
}

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const loginWithUsernameDefaults: LoginWithUsernameOptions = {
  allowEmailLogin: false,
  requireEmail: false,
  requireUsername: true,
}

export const addDefaultsToLoginWithUsernameConfig = (
  loginWithUsername: LoginWithUsernameOptions,
): LoginWithUsernameOptions =>
  ({
    allowEmailLogin: false,
    requireEmail: false,
    requireUsername: true,
    ...(loginWithUsername || {}),
  }) as LoginWithUsernameOptions
</file>

<file path="packages/payload/src/collections/config/reservedFieldNames.spec.ts">
import type { Config } from '../../config/types.js'
import type { CollectionConfig, Field } from '../../index.js'

import { ReservedFieldName } from '../../errors/index.js'
import { sanitizeCollection } from './sanitize.js'

describe('reservedFieldNames - collections -', () => {
  const config = {
    collections: [],
    globals: [],
  } as Partial<Config>

  describe('uploads -', () => {
    const collectionWithUploads: CollectionConfig = {
      slug: 'collection-with-uploads',
      fields: [],
      upload: true,
    }

    it('should throw on file', async () => {
      const fields: Field[] = [
        {
          name: 'file',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithUploads,
                fields,
              },
            ],
          },
          {
            ...collectionWithUploads,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should not throw on a custom field', async () => {
      const fields: Field[] = [
        {
          name: 'customField',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithUploads,
                fields,
              },
            ],
          },
          {
            ...collectionWithUploads,
            fields,
          },
        )
      }).not.toThrow()
    })
  })

  describe('auth -', () => {
    const collectionWithAuth: CollectionConfig = {
      slug: 'collection-with-auth',
      auth: {
        loginWithUsername: true,
        useAPIKey: true,
        verify: true,
      },
      fields: [],
    }

    it('should throw on hash', async () => {
      const fields: Field[] = [
        {
          name: 'hash',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should throw on salt', async () => {
      const fields: Field[] = [
        {
          name: 'salt',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).rejects.toThrow(ReservedFieldName)
    })

    it('should not throw on a custom field', async () => {
      const fields: Field[] = [
        {
          name: 'customField',
          type: 'text',
          label: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [
              {
                ...collectionWithAuth,
                fields,
              },
            ],
          },
          {
            ...collectionWithAuth,
            fields,
          },
        )
      }).not.toThrow()
    })
  })
})
</file>

<file path="packages/payload/src/collections/config/reservedFieldNames.ts">
// @ts-strict-ignore
import type { Field } from '../../fields/config/types.js'
import type { CollectionConfig } from '../../index.js'

import { ReservedFieldName } from '../../errors/ReservedFieldName.js'
import { fieldAffectsData } from '../../fields/config/types.js'

// Note for future reference: We've slimmed down the reserved field names but left them in here for reference in case it's needed in the future.

/**
 * Reserved field names for collections with auth config enabled
 */
const reservedBaseAuthFieldNames = [
  /* 'email',
  'resetPasswordToken',
  'resetPasswordExpiration', */
  'salt',
  'hash',
]
/**
 * Reserved field names for auth collections with verify: true
 */
const reservedVerifyFieldNames = [
  /* '_verified', '_verificationToken' */
]
/**
 * Reserved field names for auth collections with useApiKey: true
 */
const reservedAPIKeyFieldNames = [
  /* 'enableAPIKey', 'apiKeyIndex', 'apiKey' */
]

/**
 * Reserved field names for collections with upload config enabled
 */
const reservedBaseUploadFieldNames = [
  'file',
  /* 'mimeType',
  'thumbnailURL',
  'width',
  'height',
  'filesize',
  'filename',
  'url',
  'focalX',
  'focalY',
  'sizes', */
]

/**
 * Reserved field names for collections with versions enabled
 */
const reservedVersionsFieldNames = [
  /* '__v', '_status' */
]

/**
 * Sanitize fields for collections with auth config enabled.
 *
 * Should run on top level fields only.
 */
export const sanitizeAuthFields = (fields: Field[], config: CollectionConfig) => {
  for (let i = 0; i < fields.length; i++) {
    const field = fields[i]

    if (fieldAffectsData(field) && field.name) {
      if (config.auth && typeof config.auth === 'object' && !config.auth.disableLocalStrategy) {
        const auth = config.auth

        if (reservedBaseAuthFieldNames.includes(field.name)) {
          throw new ReservedFieldName(field, field.name)
        }

        if (auth.verify) {
          if (reservedAPIKeyFieldNames.includes(field.name)) {
            throw new ReservedFieldName(field, field.name)
          }
        }

        /* if (auth.maxLoginAttempts) {
          if (field.name === 'loginAttempts' || field.name === 'lockUntil') {
            throw new ReservedFieldName(field, field.name)
          }
        } */

        /* if (auth.loginWithUsername) {
          if (field.name === 'username') {
            throw new ReservedFieldName(field, field.name)
          }
        } */

        if (auth.verify) {
          if (reservedVerifyFieldNames.includes(field.name)) {
            throw new ReservedFieldName(field, field.name)
          }
        }
      }
    }

    // Handle tabs without a name
    if (field.type === 'tabs') {
      for (let j = 0; j < field.tabs.length; j++) {
        const tab = field.tabs[j]

        if (!('name' in tab)) {
          sanitizeAuthFields(tab.fields, config)
        }
      }
    }

    // Handle presentational fields like rows and collapsibles
    if (!fieldAffectsData(field) && 'fields' in field && field.fields) {
      sanitizeAuthFields(field.fields, config)
    }
  }
}

/**
 * Sanitize fields for collections with upload config enabled.
 *
 * Should run on top level fields only.
 */
export const sanitizeUploadFields = (fields: Field[], config: CollectionConfig) => {
  if (config.upload && typeof config.upload === 'object') {
    for (let i = 0; i < fields.length; i++) {
      const field = fields[i]

      if (fieldAffectsData(field) && field.name) {
        if (reservedBaseUploadFieldNames.includes(field.name)) {
          throw new ReservedFieldName(field, field.name)
        }
      }

      // Handle tabs without a name
      if (field.type === 'tabs') {
        for (let j = 0; j < field.tabs.length; j++) {
          const tab = field.tabs[j]

          if (!('name' in tab)) {
            sanitizeUploadFields(tab.fields, config)
          }
        }
      }

      // Handle presentational fields like rows and collapsibles
      if (!fieldAffectsData(field) && 'fields' in field && field.fields) {
        sanitizeUploadFields(field.fields, config)
      }
    }
  }
}
</file>

<file path="packages/payload/src/collections/config/sanitize.ts">
// @ts-strict-ignore

import type { Config, SanitizedConfig } from '../../config/types.js'
import type {
  CollectionConfig,
  SanitizedCollectionConfig,
  SanitizedJoin,
  SanitizedJoins,
} from './types.js'

import { authCollectionEndpoints } from '../../auth/endpoints/index.js'
import { getBaseAuthFields } from '../../auth/getAuthFields.js'
import { TimestampsRequired } from '../../errors/TimestampsRequired.js'
import { sanitizeFields } from '../../fields/config/sanitize.js'
import { fieldAffectsData } from '../../fields/config/types.js'
import mergeBaseFields from '../../fields/mergeBaseFields.js'
import { uploadCollectionEndpoints } from '../../uploads/endpoints/index.js'
import { getBaseUploadFields } from '../../uploads/getBaseFields.js'
import { flattenAllFields } from '../../utilities/flattenAllFields.js'
import { formatLabels } from '../../utilities/formatLabels.js'
import baseVersionFields from '../../versions/baseFields.js'
import { versionDefaults } from '../../versions/defaults.js'
import { defaultCollectionEndpoints } from '../endpoints/index.js'
import {
  addDefaultsToAuthConfig,
  addDefaultsToCollectionConfig,
  addDefaultsToLoginWithUsernameConfig,
} from './defaults.js'
import { sanitizeAuthFields, sanitizeUploadFields } from './reservedFieldNames.js'
import { sanitizeCompoundIndexes } from './sanitizeCompoundIndexes.js'
import { validateUseAsTitle } from './useAsTitle.js'

export const sanitizeCollection = async (
  config: Config,
  collection: CollectionConfig,
  /**
   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises
   * so that you can sanitize them together, after the config has been sanitized.
   */
  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,
  _validRelationships?: string[],
): Promise<SanitizedCollectionConfig> => {
  if (collection._sanitized) {
    return collection as SanitizedCollectionConfig
  }
  collection._sanitized = true
  // /////////////////////////////////
  // Make copy of collection config
  // /////////////////////////////////

  const sanitized: CollectionConfig = addDefaultsToCollectionConfig(collection)

  // /////////////////////////////////
  // Sanitize fields
  // /////////////////////////////////

  const validRelationships = _validRelationships ?? config.collections.map((c) => c.slug) ?? []

  const joins: SanitizedJoins = {}
  const polymorphicJoins: SanitizedJoin[] = []
  sanitized.fields = await sanitizeFields({
    collectionConfig: sanitized,
    config,
    fields: sanitized.fields,
    joinPath: '',
    joins,
    parentIsLocalized: false,
    polymorphicJoins,
    richTextSanitizationPromises,
    validRelationships,
  })

  if (sanitized.endpoints !== false) {
    if (!sanitized.endpoints) {
      sanitized.endpoints = []
    }

    if (sanitized.auth) {
      for (const endpoint of authCollectionEndpoints) {
        sanitized.endpoints.push(endpoint)
      }
    }

    if (sanitized.upload) {
      for (const endpoint of uploadCollectionEndpoints) {
        sanitized.endpoints.push(endpoint)
      }
    }

    for (const endpoint of defaultCollectionEndpoints) {
      sanitized.endpoints.push(endpoint)
    }
  }

  if (sanitized.timestamps !== false) {
    // add default timestamps fields only as needed
    let hasUpdatedAt: boolean | null = null
    let hasCreatedAt: boolean | null = null
    sanitized.fields.some((field) => {
      if (fieldAffectsData(field)) {
        if (field.name === 'updatedAt') {
          hasUpdatedAt = true
        }
        if (field.name === 'createdAt') {
          hasCreatedAt = true
        }
      }
      return hasCreatedAt && hasUpdatedAt
    })
    if (!hasUpdatedAt) {
      sanitized.fields.push({
        name: 'updatedAt',
        type: 'date',
        admin: {
          disableBulkEdit: true,
          hidden: true,
        },
        index: true,
        label: ({ t }) => t('general:updatedAt'),
      })
    }
    if (!hasCreatedAt) {
      sanitized.fields.push({
        name: 'createdAt',
        admin: {
          disableBulkEdit: true,
          hidden: true,
        },
        // The default sort for list view is createdAt. Thus, enabling indexing by default, is a major performance improvement, especially for large or a large amount of collections.
        type: 'date',
        index: true,
        label: ({ t }) => t('general:createdAt'),
      })
    }
  }

  sanitized.labels = sanitized.labels || formatLabels(sanitized.slug)

  if (sanitized.versions) {
    if (sanitized.versions === true) {
      sanitized.versions = { drafts: false, maxPerDoc: 100 }
    }

    if (sanitized.timestamps === false) {
      throw new TimestampsRequired(collection)
    }

    sanitized.versions.maxPerDoc =
      typeof sanitized.versions.maxPerDoc === 'number' ? sanitized.versions.maxPerDoc : 100

    if (sanitized.versions.drafts) {
      if (sanitized.versions.drafts === true) {
        sanitized.versions.drafts = {
          autosave: false,
          validate: false,
        }
      }

      if (sanitized.versions.drafts.autosave === true) {
        sanitized.versions.drafts.autosave = {
          interval: versionDefaults.autosaveInterval,
        }
      }

      if (sanitized.versions.drafts.validate === undefined) {
        sanitized.versions.drafts.validate = false
      }

      sanitized.fields = mergeBaseFields(sanitized.fields, baseVersionFields)
    }
  }

  if (sanitized.upload) {
    if (sanitized.upload === true) {
      sanitized.upload = {}
    }

    // sanitize fields for reserved names
    sanitizeUploadFields(sanitized.fields, sanitized)

    sanitized.upload.cacheTags = sanitized.upload?.cacheTags ?? true
    sanitized.upload.bulkUpload = sanitized.upload?.bulkUpload ?? true
    sanitized.upload.staticDir = sanitized.upload.staticDir || sanitized.slug
    sanitized.admin.useAsTitle =
      sanitized.admin?.useAsTitle && sanitized.admin.useAsTitle !== 'id'
        ? sanitized.admin.useAsTitle
        : 'filename'

    const uploadFields = getBaseUploadFields({
      collection: sanitized,
      config,
    })

    sanitized.fields = mergeBaseFields(sanitized.fields, uploadFields)
  }

  if (sanitized.auth) {
    // sanitize fields for reserved names
    sanitizeAuthFields(sanitized.fields, sanitized)

    sanitized.auth = addDefaultsToAuthConfig(
      typeof sanitized.auth === 'boolean' ? {} : sanitized.auth,
    )

    // disable duplicate for auth enabled collections by default
    sanitized.disableDuplicate = sanitized.disableDuplicate ?? true

    if (sanitized.auth.loginWithUsername) {
      if (sanitized.auth.loginWithUsername === true) {
        sanitized.auth.loginWithUsername = addDefaultsToLoginWithUsernameConfig({})
      } else {
        const loginWithUsernameWithDefaults = addDefaultsToLoginWithUsernameConfig(
          sanitized.auth.loginWithUsername,
        )

        // if allowEmailLogin is false, requireUsername must be true
        if (loginWithUsernameWithDefaults.allowEmailLogin === false) {
          loginWithUsernameWithDefaults.requireUsername = true
        }
        sanitized.auth.loginWithUsername = loginWithUsernameWithDefaults
      }
    } else {
      sanitized.auth.loginWithUsername = false
    }

    if (!collection?.admin?.useAsTitle) {
      sanitized.admin.useAsTitle = sanitized.auth.loginWithUsername ? 'username' : 'email'
    }

    sanitized.fields = mergeBaseFields(sanitized.fields, getBaseAuthFields(sanitized.auth))
  }

  if (collection?.admin?.pagination?.limits?.length) {
    sanitized.admin.pagination.limits = collection.admin.pagination.limits
  }

  validateUseAsTitle(sanitized)

  const sanitizedConfig = sanitized as SanitizedCollectionConfig

  sanitizedConfig.joins = joins
  sanitizedConfig.polymorphicJoins = polymorphicJoins

  sanitizedConfig.flattenedFields = flattenAllFields({ fields: sanitizedConfig.fields })

  sanitizedConfig.sanitizedIndexes = sanitizeCompoundIndexes({
    fields: sanitizedConfig.flattenedFields,
    indexes: sanitizedConfig.indexes,
  })

  return sanitizedConfig
}
</file>

<file path="packages/payload/src/collections/config/sanitizeCompoundIndexes.ts">
import type { FlattenedField } from '../../fields/config/types.js'
import type { CompoundIndex, SanitizedCompoundIndex } from './types.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { getFieldByPath } from '../../utilities/getFieldByPath.js'

export const sanitizeCompoundIndexes = ({
  fields,
  indexes,
}: {
  fields: FlattenedField[]
  indexes: CompoundIndex[]
}): SanitizedCompoundIndex[] => {
  const sanitizedCompoundIndexes: SanitizedCompoundIndex[] = []

  for (const index of indexes) {
    const sanitized: SanitizedCompoundIndex = { fields: [], unique: index.unique ?? false }
    for (const path of index.fields) {
      const result = getFieldByPath({ fields, path })

      if (!result) {
        throw new InvalidConfiguration(`Field ${path} was not found`)
      }

      const { field, localizedPath, pathHasLocalized } = result

      if (['array', 'blocks', 'group', 'tab'].includes(field.type)) {
        throw new InvalidConfiguration(
          `Compound index on ${field.type} cannot be set. Path: ${localizedPath}`,
        )
      }

      sanitized.fields.push({ field, localizedPath, path, pathHasLocalized })
    }

    sanitizedCompoundIndexes.push(sanitized)
  }

  return sanitizedCompoundIndexes
}
</file>

<file path="packages/payload/src/collections/config/types.ts">
import type { GraphQLInputObjectType, GraphQLNonNull, GraphQLObjectType } from 'graphql'
import type { DeepRequired, IsAny, MarkOptional } from 'ts-essentials'

import type { CustomUpload } from '../../admin/types.js'
import type { Arguments as MeArguments } from '../../auth/operations/me.js'
import type {
  Arguments as RefreshArguments,
  Result as RefreshResult,
} from '../../auth/operations/refresh.js'
import type { Auth, ClientUser, IncomingAuthType } from '../../auth/types.js'
import type {
  Access,
  AfterErrorHookArgs,
  AfterErrorResult,
  CustomComponent,
  EditConfig,
  Endpoint,
  EntityDescription,
  EntityDescriptionComponent,
  GeneratePreviewURL,
  LabelFunction,
  LivePreviewConfig,
  MetaConfig,
  PayloadComponent,
  StaticLabel,
} from '../../config/types.js'
import type { DBIdentifierName } from '../../database/types.js'
import type {
  Field,
  FlattenedField,
  JoinField,
  RelationshipField,
  UploadField,
} from '../../fields/config/types.js'
import type {
  CollectionSlug,
  JsonObject,
  RequestContext,
  TypedAuthOperations,
  TypedCollection,
  TypedCollectionSelect,
  TypedLocale,
} from '../../index.js'
import type {
  PayloadRequest,
  SelectIncludeType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../types/index.js'
import type { SanitizedUploadConfig, UploadConfig } from '../../uploads/types.js'
import type {
  IncomingCollectionVersions,
  SanitizedCollectionVersions,
} from '../../versions/types.js'
import type { AfterOperationArg, AfterOperationMap } from '../operations/utils.js'

export type DataFromCollectionSlug<TSlug extends CollectionSlug> = TypedCollection[TSlug]

export type SelectFromCollectionSlug<TSlug extends CollectionSlug> = TypedCollectionSelect[TSlug]

export type AuthOperationsFromCollectionSlug<TSlug extends CollectionSlug> =
  TypedAuthOperations[TSlug]

export type RequiredDataFromCollection<TData extends JsonObject> = MarkOptional<
  TData,
  'createdAt' | 'id' | 'sizes' | 'updatedAt'
>

export type RequiredDataFromCollectionSlug<TSlug extends CollectionSlug> =
  RequiredDataFromCollection<DataFromCollectionSlug<TSlug>>

export type HookOperationType =
  | 'autosave'
  | 'count'
  | 'countVersions'
  | 'create'
  | 'delete'
  | 'forgotPassword'
  | 'login'
  | 'read'
  | 'refresh'
  | 'update'

type CreateOrUpdateOperation = Extract<HookOperationType, 'create' | 'update'>

export type BeforeOperationHook = (args: {
  args?: any
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  /**
   * Hook operation being performed
   */
  operation: HookOperationType
  req: PayloadRequest
}) => any

export type BeforeValidateHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  data?: Partial<T>
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  /**
   * Original document before change
   *
   * `undefined` on 'create' operation
   */
  originalDoc?: T
  req: PayloadRequest
}) => any

export type BeforeChangeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  data: Partial<T>
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  /**
   * Original document before change
   *
   * `undefined` on 'create' operation
   */
  originalDoc?: T
  req: PayloadRequest
}) => any

export type AfterChangeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  /**
   * Hook operation being performed
   */
  operation: CreateOrUpdateOperation
  previousDoc: T
  req: PayloadRequest
}) => any

export type BeforeReadHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  query: { [key: string]: any }
  req: PayloadRequest
}) => any

export type AfterReadHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  findMany?: boolean
  query?: { [key: string]: any }
  req: PayloadRequest
}) => any

export type BeforeDeleteHook = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  id: number | string
  req: PayloadRequest
}) => any

export type AfterDeleteHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  doc: T
  id: number | string
  req: PayloadRequest
}) => any

export type AfterOperationHook<TOperationGeneric extends CollectionSlug = string> = (
  arg: AfterOperationArg<TOperationGeneric>,
) =>
  | Awaited<
      ReturnType<AfterOperationMap<TOperationGeneric>[keyof AfterOperationMap<TOperationGeneric>]>
    >
  | Promise<
      Awaited<
        ReturnType<AfterOperationMap<TOperationGeneric>[keyof AfterOperationMap<TOperationGeneric>]>
      >
    >

export type BeforeLoginHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  user: T
}) => any

export type AfterLoginHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  token: string
  user: T
}) => any

export type AfterLogoutHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
}) => any

export type AfterMeHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  req: PayloadRequest
  response: unknown
}) => any

export type RefreshHook<T extends TypeWithID = any> = (args: {
  args: RefreshArguments
  user: T
}) => Promise<RefreshResult | void> | (RefreshResult | void)

export type MeHook<T extends TypeWithID = any> = (args: {
  args: MeArguments
  user: T
}) => ({ exp: number; user: T } | void) | Promise<{ exp: number; user: T } | void>

export type AfterRefreshHook<T extends TypeWithID = any> = (args: {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
  exp: number
  req: PayloadRequest
  token: string
}) => any

export type AfterErrorHook = (
  args: { collection: SanitizedCollectionConfig } & AfterErrorHookArgs,
) => AfterErrorResult | Promise<AfterErrorResult>

export type AfterForgotPasswordHook = (args: {
  args?: any
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  context: RequestContext
}) => any

export type BaseListFilter = (args: {
  limit: number
  locale?: TypedLocale
  page: number
  req: PayloadRequest
  sort: string
}) => null | Promise<null | Where> | Where

export type CollectionAdminOptions = {
  baseListFilter?: BaseListFilter
  /**
   * Custom admin components
   */
  components?: {
    afterList?: CustomComponent[]
    afterListTable?: CustomComponent[]
    beforeList?: CustomComponent[]
    beforeListTable?: CustomComponent[]
    Description?: EntityDescriptionComponent
    /**
     * Components within the edit view
     */
    edit?: {
      /**
       * Replaces the "Preview" button
       */
      PreviewButton?: CustomComponent
      /**
       * Replaces the "Publish" button
       * + drafts must be enabled
       */
      PublishButton?: CustomComponent
      /**
       * Replaces the "Save" button
       * + drafts must be disabled
       */
      SaveButton?: CustomComponent
      /**
       * Replaces the "Save Draft" button
       * + drafts must be enabled
       * + autosave must be disabled
       */
      SaveDraftButton?: CustomComponent
      /**
       * Replaces the "Upload" section
       * + upload must be enabled
       */
      Upload?: CustomUpload
    }
    listMenuItems?: CustomComponent[]
    views?: {
      /**
       * Set to a React component to replace the entire Edit View, including all nested routes.
       * Set to an object to replace or modify individual nested routes, or to add new ones.
       */
      edit?: EditConfig
      list?: {
        actions?: CustomComponent[]
        Component?: PayloadComponent
      }
    }
  }
  /** Extension point to add your custom data. Available in server and client. */
  custom?: Record<string, any>
  /**
   * Default columns to show in list view
   */
  defaultColumns?: string[]
  /**
   * Custom description for collection. This will also be used as JSDoc for the generated types
   */
  description?: EntityDescription
  /**
   * Disable the Copy To Locale button in the edit document view
   * @default false
   */
  disableCopyToLocale?: boolean
  enableRichTextLink?: boolean
  enableRichTextRelationship?: boolean
  /**
   * Specify a navigational group for collections in the admin sidebar.
   * - Provide a string to place the entity in a custom group.
   * - Provide a record to define localized group names.
   * - Set to `false` to exclude the entity from the sidebar / dashboard without disabling its routes.
   */
  group?: false | Record<string, string> | string
  /**
   * Exclude the collection from the admin nav and routes
   */
  hidden?: ((args: { user: ClientUser }) => boolean) | boolean
  /**
   * Hide the API URL within the Edit view
   */
  hideAPIURL?: boolean
  /**
   * Additional fields to be searched via the full text search
   */
  listSearchableFields?: string[]
  /**
   * Live preview options
   */
  livePreview?: LivePreviewConfig
  meta?: MetaConfig
  pagination?: {
    defaultLimit?: number
    limits?: number[]
  }
  /**
   * Function to generate custom preview URL
   */
  preview?: GeneratePreviewURL
  /**
   * Field to use as title in Edit View and first column in List view
   */
  useAsTitle?: string
}

/** Manage all aspects of a data collection */
export type CollectionConfig<TSlug extends CollectionSlug = any> = {
  /**
   * Do not set this property manually. This is set to true during sanitization, to avoid
   * sanitizing the same collection multiple times.
   */
  _sanitized?: boolean
  /**
   * Access control
   */
  access?: {
    admin?: ({ req }: { req: PayloadRequest }) => boolean | Promise<boolean>
    create?: Access
    delete?: Access
    read?: Access
    readVersions?: Access
    unlock?: Access
    update?: Access
  }
  /**
   * Collection admin options
   */
  admin?: CollectionAdminOptions
  /**
   * Collection login options
   *
   * Use `true` to enable with default options
   */
  auth?: boolean | IncomingAuthType
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  /**
   * Used to override the default naming of the database table or collection with your using a function or string
   * @WARNING: If you change this property with existing data, you will need to handle the renaming of the table in your database or by using migrations
   */
  dbName?: DBIdentifierName
  defaultPopulate?: IsAny<SelectFromCollectionSlug<TSlug>> extends true
    ? SelectType
    : SelectFromCollectionSlug<TSlug>
  /**
   * Default field to sort by in collection list view
   */
  defaultSort?: Sort
  /**
   * When true, do not show the "Duplicate" button while editing documents within this collection and prevent `duplicate` from all APIs
   */
  disableDuplicate?: boolean
  /**
   * Opt-in to enable query presets for this collection.
   * @see https://payloadcms.com/docs/query-presets/overview
   */
  enableQueryPresets?: boolean
  /**
   * Custom rest api endpoints, set false to disable all rest endpoints for this collection.
   */
  endpoints?: false | Omit<Endpoint, 'root'>[]
  fields: Field[]
  /**
   * Specify which fields should be selected always, regardless of the `select` query which can be useful that the field exists for access control / hooks
   */
  forceSelect?: IsAny<SelectFromCollectionSlug<TSlug>> extends true
    ? SelectIncludeType
    : SelectFromCollectionSlug<TSlug>
  /**
   * GraphQL configuration
   */
  graphQL?:
    | {
        disableMutations?: true
        disableQueries?: true
        pluralName?: string
        singularName?: string
      }
    | false
  /**
   * Hooks to modify Payload functionality
   */
  hooks?: {
    afterChange?: AfterChangeHook[]
    afterDelete?: AfterDeleteHook[]
    afterError?: AfterErrorHook[]
    afterForgotPassword?: AfterForgotPasswordHook[]
    afterLogin?: AfterLoginHook[]
    afterLogout?: AfterLogoutHook[]
    afterMe?: AfterMeHook[]
    afterOperation?: AfterOperationHook<TSlug>[]
    afterRead?: AfterReadHook[]
    afterRefresh?: AfterRefreshHook[]
    beforeChange?: BeforeChangeHook[]
    beforeDelete?: BeforeDeleteHook[]
    beforeLogin?: BeforeLoginHook[]
    beforeOperation?: BeforeOperationHook[]
    beforeRead?: BeforeReadHook[]
    beforeValidate?: BeforeValidateHook[]
    /**
    /**
     * Use the `me` hook to control the `me` operation.
     * Here, you can optionally instruct the me operation to return early,
     * and skip its default logic.
     */
    me?: MeHook[]
    /**
     * Use the `refresh` hook to control the refresh operation.
     * Here, you can optionally instruct the refresh operation to return early,
     * and skip its default logic.
     */
    refresh?: RefreshHook[]
  }
  /**
   * Define compound indexes for this collection.
   * This can be used to either speed up querying/sorting by 2 or more fields at the same time or
   * to ensure uniqueness between several fields.
   * Specify field paths
   * @example
   * [{ unique: true, fields: ['title', 'group.name'] }]
   * @default []
   */
  indexes?: CompoundIndex[]
  /**
   * Label configuration
   */
  labels?: {
    plural?: LabelFunction | StaticLabel
    singular?: LabelFunction | StaticLabel
  }
  /**
   * Enables / Disables the ability to lock documents while editing
   * @default true
   */
  lockDocuments?:
    | {
        duration: number
      }
    | false
  /**
   * If true, enables custom ordering for the collection, and documents in the listView can be reordered via drag and drop.
   * New documents are inserted at the end of the list according to this parameter.
   *
   * Under the hood, a field with {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing|fractional indexing} is used to optimize inserts and reorderings.
   *
   * @default false
   *
   * @experimental There may be frequent breaking changes to this API
   */
  orderable?: boolean
  slug: string
  /**
   * Add `createdAt` and `updatedAt` fields
   *
   * @default true
   */
  timestamps?: boolean
  /**
   * Options used in typescript generation
   */
  typescript?: {
    /**
     * Typescript generation name given to the interface type
     */
    interface?: string
  }
  /**
   * Customize the handling of incoming file uploads
   *
   * @default false // disable uploads
   */
  upload?: boolean | UploadConfig
  /**
   * Enable versioning. Set it to true to enable default versions settings,
   * or customize versions options by setting the property equal to an object
   * containing the version options.
   *
   * @default false // disable versioning
   */
  versions?: boolean | IncomingCollectionVersions
}

export type SanitizedJoin = {
  /**
   * The field configuration defining the join
   */
  field: JoinField
  getForeignPath?(args: { locale?: TypedLocale }): string
  /**
   * The path of the join field in dot notation
   */
  joinPath: string
  /**
   * `parentIsLocalized` is true if any parent field of the
   * field configuration defining the join is localized
   */
  parentIsLocalized: boolean
  targetField: RelationshipField | UploadField
}

export type SanitizedJoins = {
  [collectionSlug: string]: SanitizedJoin[]
}

/**
 * @todo remove the `DeepRequired` in v4.
 * We don't actually guarantee that all properties are set when sanitizing configs.
 */
export interface SanitizedCollectionConfig
  extends Omit<
    DeepRequired<CollectionConfig>,
    'auth' | 'endpoints' | 'fields' | 'slug' | 'upload' | 'versions'
  > {
  auth: Auth
  endpoints: Endpoint[] | false
  fields: Field[]
  /**
   * Fields in the database schema structure
   * Rows / collapsible / tabs w/o name `fields` merged to top, UIs are excluded
   */
  flattenedFields: FlattenedField[]
  /**
   * Object of collections to join 'Join Fields object keyed by collection
   */
  joins: SanitizedJoins

  /**
   * List of all polymorphic join fields
   */
  polymorphicJoins: SanitizedJoin[]

  sanitizedIndexes: SanitizedCompoundIndex[]

  slug: CollectionSlug
  upload: SanitizedUploadConfig
  versions: SanitizedCollectionVersions
}

export type Collection = {
  config: SanitizedCollectionConfig
  customIDType?: 'number' | 'text'
  graphQL?: {
    countType: GraphQLObjectType
    JWT: GraphQLObjectType
    mutationInputType: GraphQLNonNull<any>
    paginatedType: GraphQLObjectType
    type: GraphQLObjectType
    updateMutationInputType: GraphQLNonNull<any>
    versionType: GraphQLObjectType
    whereInputType: GraphQLInputObjectType
  }
}

export type BulkOperationResult<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  docs: TransformCollectionWithSelect<TSlug, TSelect>[]
  errors: {
    id: DataFromCollectionSlug<TSlug>['id']
    message: string
  }[]
}

export type AuthCollection = {
  config: SanitizedCollectionConfig
}

export type TypeWithID = {
  docId?: any
  id: number | string
}

export type TypeWithTimestamps = {
  [key: string]: unknown
  createdAt: string
  id: number | string
  updatedAt: string
}

export type CompoundIndex = {
  fields: string[]
  unique?: boolean
}

export type SanitizedCompoundIndex = {
  fields: {
    field: FlattenedField
    localizedPath: string
    path: string
    pathHasLocalized: boolean
  }[]
  unique: boolean
}
</file>

<file path="packages/payload/src/collections/config/useAsTitle.spec.ts">
import type { Config } from '../../config/types.js'
import type { CollectionConfig } from '../../index.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { sanitizeCollection } from './sanitize.js'

describe('sanitize - collections -', () => {
  const config = {
    collections: [],
    globals: [],
  } as Partial<Config>

  describe('validate useAsTitle -', () => {
    const defaultCollection: CollectionConfig = {
      slug: 'collection-with-defaults',
      fields: [
        {
          name: 'title',
          type: 'text',
        },
      ],
    }

    it('should throw on invalid field', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'invalidField',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })

    it('should not throw on valid field', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on valid field inside tabs', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
        fields: [
          {
            type: 'tabs',
            tabs: [
              {
                label: 'General',
                fields: [
                  {
                    name: 'title',
                    type: 'text',
                  },
                ],
              },
            ],
          },
        ],
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on valid field inside collapsibles', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'title',
        },
        fields: [
          {
            type: 'collapsible',
            label: 'Collapsible',
            fields: [
              {
                name: 'title',
                type: 'text',
              },
            ],
          },
        ],
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should throw on nested useAsTitle', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'content.title',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })

    it('should not throw on default field: id', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'id',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })

    it('should not throw on default field: email if auth is enabled', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        auth: true,
        admin: {
          useAsTitle: 'email',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).not.toThrow()
    })
    it('should throw on default field: email if auth is not enabled', async () => {
      const collectionConfig: CollectionConfig = {
        ...defaultCollection,
        admin: {
          useAsTitle: 'email',
        },
      }
      await expect(async () => {
        await sanitizeCollection(
          // @ts-expect-error
          {
            ...config,
            collections: [collectionConfig],
          },
          collectionConfig,
        )
      }).rejects.toThrow(InvalidConfiguration)
    })
  })
})
</file>

<file path="packages/payload/src/collections/config/useAsTitle.ts">
import type { CollectionConfig } from '../../index.js'

import { InvalidConfiguration } from '../../errors/InvalidConfiguration.js'
import { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'
import flattenFields from '../../utilities/flattenTopLevelFields.js'

/**
 * Validate useAsTitle for collections.
 */
export const validateUseAsTitle = (config: CollectionConfig) => {
  if (config.admin?.useAsTitle?.includes('.')) {
    throw new InvalidConfiguration(
      `"useAsTitle" cannot be a nested field. Please specify a top-level field in the collection "${config.slug}"`,
    )
  }

  if (config?.admin && config.admin?.useAsTitle && config.admin.useAsTitle !== 'id') {
    const fields = flattenFields(config.fields)
    const useAsTitleField = fields.find((field) => {
      if (fieldAffectsData(field) && config.admin) {
        return field.name === config.admin.useAsTitle
      }
      return false
    })

    // If auth is enabled then we don't need to
    if (config.auth) {
      if (config.admin.useAsTitle !== 'email') {
        if (!useAsTitleField) {
          throw new InvalidConfiguration(
            `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" does not exist in the collection "${config.slug}"`,
          )
        }
      }
    } else {
      if (useAsTitleField && fieldIsVirtual(useAsTitleField)) {
        throw new InvalidConfiguration(
          `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" in the collection "${config.slug}" is virtual. A virtual field cannot be used as the title.`,
        )
      }
      if (!useAsTitleField) {
        throw new InvalidConfiguration(
          `The field "${config.admin.useAsTitle}" specified in "admin.useAsTitle" does not exist in the collection "${config.slug}"`,
        )
      }
    }
  }
}
</file>

<file path="packages/payload/src/collections/endpoints/count.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { countOperation } from '../operations/count.js'

export const countHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { where } = req.query as {
    where?: Where
  }

  const result = await countOperation({
    collection,
    req,
    where,
  })

  return Response.json(result, {
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/create.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { createOperation } from '../operations/create.js'

export const createHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { searchParams } = req
  const autosave = searchParams.get('autosave') === 'true'
  const draft = searchParams.get('draft') === 'true'
  const depth = searchParams.get('depth')

  const doc = await createOperation({
    autosave,
    collection,
    data: req.data,
    depth: isNumber(depth) ? depth : undefined,
    draft,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(
    {
      doc,
      message: req.t('general:successfullyCreated', {
        label: getTranslation(collection.config.labels.singular, req.i18n),
      }),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.CREATED,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/delete.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { deleteOperation } from '../operations/delete.js'

export const deleteHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, overrideLock, populate, select, where } = req.query as {
    depth?: string
    overrideLock?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    where?: Where
  }

  const result = await deleteOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    where,
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (result.errors.length === 0) {
    const message = req.t('general:deletedCountSuccessfully', {
      count: result.docs.length,
      label: getTranslation(
        collection.config.labels[result.docs.length === 1 ? 'singular' : 'plural'],
        req.i18n,
      ),
    })

    return Response.json(
      {
        ...result,
        message,
      },
      {
        headers,
        status: httpStatus.OK,
      },
    )
  }

  const total = result.docs.length + result.errors.length

  const message = req.t('error:unableToDeleteCount', {
    count: result.errors.length,
    label: getTranslation(collection.config.labels[total === 1 ? 'singular' : 'plural'], req.i18n),
    total,
  })

  return Response.json(
    {
      ...result,
      message,
    },
    {
      headers,
      status: httpStatus.BAD_REQUEST,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/deleteByID.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { deleteByIDOperation } from '../operations/deleteByID.js'

export const deleteByIDHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const overrideLock = searchParams.get('overrideLock')

  const doc = await deleteByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? depth : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (!doc) {
    return Response.json(
      {
        message: req.t('general:notFound'),
      },
      {
        headers,
        status: httpStatus.NOT_FOUND,
      },
    )
  }

  return Response.json(
    {
      doc,
      message: req.t('general:deletedSuccessfully'),
    },
    {
      headers,
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/docAccess.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { docAccessOperation } from '../operations/docAccess.js'

export const docAccessHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req, { optionalID: true })
  const result = await docAccessOperation({
    id,
    collection,
    req,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/duplicate.ts">
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { duplicateOperation } from '../operations/duplicate.js'

export const duplicateHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  // draft defaults to true, unless explicitly set requested as false to prevent the newly duplicated document from being published
  const draft = searchParams.get('draft') !== 'false'

  const doc = await duplicateOperation({
    id,
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  const message = req.t('general:successfullyDuplicated', {
    label: getTranslation(collection.config.labels.singular, req.i18n),
  })

  return Response.json(
    {
      doc,
      message,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/find.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { JoinQuery, Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizeJoinParams } from '../../utilities/sanitizeJoinParams.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findOperation } from '../operations/find.js'

export const findHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, draft, joins, limit, page, pagination, populate, select, sort, where } =
    req.query as {
      depth?: string
      draft?: string
      joins?: JoinQuery
      limit?: string
      page?: string
      pagination?: string
      populate?: Record<string, unknown>
      select?: Record<string, unknown>
      sort?: string
      where?: Where
    }

  const result = await findOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true',
    joins: sanitizeJoinParams(joins),
    limit: isNumber(limit) ? Number(limit) : undefined,
    page: isNumber(page) ? Number(page) : undefined,
    pagination: pagination === 'false' ? false : undefined,
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/findByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { JoinQuery } from '../../types/index.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizeJoinParams } from '../../utilities/sanitizeJoinParams.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findByIDOperation } from '../operations/findByID.js'

export const findByIDHandler: PayloadHandler = async (req) => {
  const { searchParams } = req
  const { id, collection } = getRequestCollectionWithID(req)
  const depth = searchParams.get('depth')

  const result = await findByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    joins: sanitizeJoinParams(req.query.joins as JoinQuery),
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/findVersionByID.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionByIDOperation } from '../operations/findVersionByID.js'

export const findVersionByIDHandler: PayloadHandler = async (req) => {
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const { id, collection } = getRequestCollectionWithID(req)

  const result = await findVersionByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/findVersions.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionsOperation } from '../operations/findVersions.js'

export const findVersionsHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, limit, page, pagination, populate, select, sort, where } = req.query as {
    depth?: string
    limit?: string
    page?: string
    pagination?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    sort?: string
    where?: Where
  }

  const result = await findVersionsOperation({
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    limit: isNumber(limit) ? Number(limit) : undefined,
    page: isNumber(page) ? Number(page) : undefined,
    pagination: pagination === 'false' ? false : undefined,
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/index.ts">
import type { Endpoint } from '../../config/types.js'

import { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'
import { countHandler } from './count.js'
import { createHandler } from './create.js'
import { deleteHandler } from './delete.js'
import { deleteByIDHandler } from './deleteByID.js'
import { docAccessHandler } from './docAccess.js'
import { duplicateHandler } from './duplicate.js'
import { findHandler } from './find.js'
import { findByIDHandler } from './findByID.js'
import { findVersionByIDHandler } from './findVersionByID.js'
import { findVersionsHandler } from './findVersions.js'
import { previewHandler } from './preview.js'
import { restoreVersionHandler } from './restoreVersion.js'
import { updateHandler } from './update.js'
import { updateByIDHandler } from './updateByID.js'

export const defaultCollectionEndpoints: Endpoint[] = [
  ...wrapInternalEndpoints([
    {
      handler: countHandler,
      method: 'get',
      path: '/count',
    },
    {
      handler: createHandler,
      method: 'post',
      path: '/',
    },
    {
      handler: deleteHandler,
      method: 'delete',
      path: '/',
    },
    {
      handler: deleteByIDHandler,
      method: 'delete',
      path: '/:id',
    },
    {
      handler: docAccessHandler,
      method: 'post',
      path: '/access/:id?',
    },
    {
      handler: findVersionsHandler,
      method: 'get',
      path: '/versions',
    },
    {
      handler: duplicateHandler,
      method: 'post',
      path: '/:id/duplicate',
    },
    {
      handler: findHandler,
      method: 'get',
      path: '/',
    },
    {
      handler: findByIDHandler,
      method: 'get',
      path: '/:id',
    },
    {
      handler: findVersionByIDHandler,
      method: 'get',
      path: '/versions/:id',
    },
    {
      handler: previewHandler,
      method: 'get',
      path: '/:id/preview',
    },
    {
      handler: restoreVersionHandler,
      method: 'post',
      path: '/versions/:id',
    },
    {
      handler: updateHandler,
      method: 'patch',
      path: '/',
    },
    {
      handler: updateByIDHandler,
      method: 'patch',
      path: '/:id',
    },
  ]),
]
</file>

<file path="packages/payload/src/collections/endpoints/preview.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { extractJWT } from '../../auth/extractJWT.js'
import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { findByIDOperation } from '../operations/findByID.js'

export const previewHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const doc = await findByIDOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    req,
  })

  let previewURL: string

  const generatePreviewURL =
    req.payload?.collections?.[collection.config.slug]?.config?.admin?.preview

  const token = extractJWT(req)

  if (typeof generatePreviewURL === 'function') {
    previewURL = await generatePreviewURL(doc, {
      locale: req.locale,
      req,
      token,
    })
  }

  return Response.json(previewURL, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/collections/endpoints/restoreVersion.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { restoreVersionOperation } from '../operations/restoreVersion.js'

export const restoreVersionHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const draft = searchParams.get('draft')

  const result = await restoreVersionOperation({
    id,
    collection,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true' ? true : undefined,
    populate: sanitizePopulateParam(req.query.populate),
    req,
  })

  return Response.json(
    {
      ...result,
      message: req.t('version:restoredSuccessfully'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/update.ts">
// @ts-strict-ignore
import { getTranslation } from '@convexcms/translations'
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { updateOperation } from '../operations/update.js'

export const updateHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)
  const { depth, draft, limit, overrideLock, populate, select, sort, where } = req.query as {
    depth?: string
    draft?: string
    limit?: string
    overrideLock?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    sort?: string
    where?: Where
  }

  const result = await updateOperation({
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true',
    limit: isNumber(limit) ? Number(limit) : undefined,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  if (result.errors.length === 0) {
    const message = req.t('general:updatedCountSuccessfully', {
      count: result.docs.length,
      label: getTranslation(
        collection.config.labels[result.docs.length === 1 ? 'singular' : 'plural'],
        req.i18n,
      ),
    })

    return Response.json(
      {
        ...result,
        message,
      },
      {
        headers,
        status: httpStatus.OK,
      },
    )
  }

  const total = result.docs.length + result.errors.length
  const message = req.t('error:unableToUpdateCount', {
    count: result.errors.length,
    label: getTranslation(collection.config.labels[total === 1 ? 'singular' : 'plural'], req.i18n),
    total,
  })

  return Response.json(
    {
      ...result,
      message,
    },
    {
      headers,
      status: httpStatus.BAD_REQUEST,
    },
  )
}
</file>

<file path="packages/payload/src/collections/endpoints/updateByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { updateByIDOperation } from '../operations/updateByID.js'

export const updateByIDHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const autosave = searchParams.get('autosave') === 'true'
  const draft = searchParams.get('draft') === 'true'
  const overrideLock = searchParams.get('overrideLock')
  const publishSpecificLocale = req.query.publishSpecificLocale as string | undefined

  const doc = await updateByIDOperation({
    id,
    autosave,
    collection,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft,
    overrideLock: Boolean(overrideLock === 'true'),
    populate: sanitizePopulateParam(req.query.populate),
    publishSpecificLocale,
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  let message = req.t('general:updatedSuccessfully')

  if (draft) {
    message = req.t('version:draftSavedSuccessfully')
  }
  if (autosave) {
    message = req.t('version:autosavedSuccessfully')
  }

  return Response.json(
    {
      doc,
      message,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/collections/operations/local/count.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, Where } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { countOperation } from '../count.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   *  Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

// eslint-disable-next-line no-restricted-exports
export default async function countLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<{ totalDocs: number }> {
  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Count Operation.`,
    )
  }

  return countOperation<TSlug>({
    collection,
    disableErrors,
    overrideAccess,
    req: await createLocalReq(options, payload),
    where,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/countVersions.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, Where } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { countVersionsOperation } from '../countVersions.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

// eslint-disable-next-line no-restricted-exports
export default async function countVersionsLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<{ totalDocs: number }> {
  const { collection: collectionSlug, disableErrors, overrideAccess = true, where } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Count Versions Operation.`,
    )
  }

  return countVersionsOperation<TSlug>({
    collection,
    disableErrors,
    overrideAccess,
    req: await createLocalReq(options, payload),
    where,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/create.ts">
// @ts-strict-ignore
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type { File } from '../../../uploads/types.js'
import type {
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import {
  type CollectionSlug,
  deepCopyObjectSimple,
  type Payload,
  type RequestContext,
  type TypedLocale,
} from '../../../index.js'
import { getFileByPath } from '../../../uploads/getFileByPath.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { createOperation } from '../create.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The data for the document to create.
   */
  data: RequiredDataFromCollectionSlug<TSlug>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * If creating verification-enabled auth doc,
   * you can disable the email that is auto-sent
   */
  disableVerificationEmail?: boolean
  /**
   * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * If you want to create a document that is a duplicate of another document
   */
  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * A `File` object when creating a collection with `upload: true`.
   */
  file?: File
  /**
   * A file path when creating a collection with `upload: true`.
   */
  filePath?: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * If you are uploading a file and would like to replace
   * the existing file instead of generating a new filename,
   * you can set the following property to `true`
   */
  overwriteExistingFiles?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

// eslint-disable-next-line no-restricted-exports
export default async function createLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    disableVerificationEmail,
    draft,
    duplicateFromID,
    file,
    filePath,
    overrideAccess = true,
    overwriteExistingFiles = false,
    populate,
    select,
    showHiddenFields,
  } = options
  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Create Operation.`,
    )
  }

  const req = await createLocalReq(options, payload)
  req.file = file ?? (await getFileByPath(filePath))

  return createOperation<TSlug, TSelect>({
    collection,
    data: deepCopyObjectSimple(data), // Ensure mutation of data in create operation hooks doesn't affect the original data
    depth,
    disableTransaction,
    disableVerificationEmail,
    draft,
    duplicateFromID,
    overrideAccess,
    overwriteExistingFiles,
    populate,
    req,
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/delete.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { BulkOperationResult, SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { deleteOperation } from '../delete.js'
import { deleteByIDOperation } from '../deleteByID.js'

export type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).
   * @default true
   */
  overrideLock?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export type ByIDOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to delete.
   */
  id: number | string
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: never
} & BaseOptions<TSlug, TSelect>

export type ManyOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to delete.
   */
  id?: never
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where: Where
} & BaseOptions<TSlug, TSelect>

export type Options<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>

async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ByIDOptions<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ManyOptions<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>
async function deleteLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    disableTransaction,
    overrideAccess = true,
    overrideLock,
    populate,
    select,
    showHiddenFields,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Delete Operation.`,
    )
  }

  const args = {
    id,
    collection,
    depth,
    disableTransaction,
    overrideAccess,
    overrideLock,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    where,
  }

  if (options.id) {
    return deleteByIDOperation<TSlug, TSelect>(args)
  }
  return deleteOperation<TSlug, TSelect>(args)
}

export default deleteLocal
</file>

<file path="packages/payload/src/collections/operations/local/duplicate.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug, TypedLocale } from '../../..//index.js'
import type { Payload, RequestContext } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type {
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { duplicateOperation } from '../duplicate.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * Override the data for the document to duplicate.
   */
  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Create a **draft** document. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the document to duplicate from.
   */
  id: number | string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export async function duplicate<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    draft,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options
  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Duplicate Operation.`,
    )
  }

  if (collection.config.disableDuplicate === true) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} cannot be duplicated.`,
      400,
    )
  }

  const req = await createLocalReq(options, payload)

  return duplicateOperation<TSlug, TSelect>({
    id,
    collection,
    data,
    depth,
    disableTransaction,
    draft,
    overrideAccess,
    populate,
    req,
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/find.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../../database/types.js'
import type {
  CollectionSlug,
  JoinQuery,
  Payload,
  RequestContext,
  TypedLocale,
} from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findOperation } from '../find.js'

export type Options<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The current population depth, used internally for relationships population.
   * @internal
   */
  currentDepth?: number
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   * Whether the documents should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Include info about the lock status to the result into all documents with fields: `_isLocked` and `_userEditing`
   */
  includeLockStatus?: boolean
  /**
   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).
   * Pass `false` to disable all join fields from the result.
   */
  joins?: JoinQuery<TSlug>
  /**
   * The maximum related documents to be returned.
   * Defaults unless `defaultLimit` is specified for the collection config
   * @default 10
   */
  limit?: number
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Get a specific page number
   * @default 1
   */
  page?: number
  /**
   * Set to `false` to return all documents and avoid querying for document counts which introduces some overhead.
   * You can also combine that property with a specified `limit` to limit documents but avoid the count query.
   */
  pagination?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

export async function findLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> {
  const {
    collection: collectionSlug,
    currentDepth,
    depth,
    disableErrors,
    draft = false,
    includeLockStatus,
    joins,
    limit,
    overrideAccess = true,
    page,
    pagination = true,
    populate,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find Operation.`,
    )
  }

  return findOperation<TSlug, TSelect>({
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    limit,
    overrideAccess,
    page,
    pagination,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    sort,
    where,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/findByID.ts">
// @ts-strict-ignore
/* eslint-disable no-restricted-exports */
import type {
  CollectionSlug,
  JoinQuery,
  Payload,
  RequestContext,
  SelectType,
  TypedLocale,
} from '../../../index.js'
import type {
  ApplyDisableErrors,
  Document,
  PayloadRequest,
  PopulateType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type { SelectFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findByIDOperation } from '../findByID.js'

export type Options<
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectType,
> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The current population depth, used internally for relationships population.
   * @internal
   */
  currentDepth?: number
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   * `null` will be returned instead, if the document on this ID was not found.
   */
  disableErrors?: TDisableErrors
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the document to find.
   */
  id: number | string
  /**
   * Include info about the lock status to the result with fields: `_isLocked` and `_userEditing`
   */
  includeLockStatus?: boolean
  /**
   * The [Join Field Query](https://payloadcms.com/docs/fields/join#query-options).
   * Pass `false` to disable all join fields from the result.
   */
  joins?: JoinQuery<TSlug>
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function findByIDLocal<
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TDisableErrors, TSelect>,
): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> {
  const {
    id,
    collection: collectionSlug,
    currentDepth,
    depth,
    disableErrors = false,
    draft = false,
    includeLockStatus,
    joins,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find By ID Operation.`,
    )
  }

  return findByIDOperation<TSlug, TDisableErrors, TSelect>({
    id,
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/findVersionByID.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionByIDOperation } from '../findVersionByID.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   * `null` will be returned instead, if the document on this ID was not found.
   */
  disableErrors?: boolean
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to find.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function findVersionByIDLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    disableErrors = false,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Find Version By ID Operation.`,
    )
  }

  return findVersionByIDOperation({
    id,
    collection,
    depth,
    disableErrors,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/findVersions.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../../database/types.js'
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  Where,
} from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionsOperation } from '../findVersions.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Whether the documents should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The maximum related documents to be returned.
   * Defaults unless `defaultLimit` is specified for the collection config
   * @default 10
   */
  limit?: number
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Get a specific page number
   * @default 1
   */
  page?: number
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-version.createdAt' // Sort DESC by createdAt
   * @example ['version.group', '-version.createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

export default async function findVersionsLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> {
  const {
    collection: collectionSlug,
    depth,
    limit,
    overrideAccess = true,
    page,
    populate,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Find Versions Operation.`,
    )
  }

  return findVersionsOperation({
    collection,
    depth,
    limit,
    overrideAccess,
    page,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    sort,
    where,
  })
}
</file>

<file path="packages/payload/src/collections/operations/local/index.ts">
/* eslint-disable no-restricted-exports */
import * as auth from '../../../auth/operations/local/index.js'
import count from './count.js'
import countVersions from './countVersions.js'
import create from './create.js'
import deleteLocal from './delete.js'
import { duplicate } from './duplicate.js'
import { findLocal } from './find.js'
import findByID from './findByID.js'
import findVersionByID from './findVersionByID.js'
import findVersions from './findVersions.js'
import restoreVersion from './restoreVersion.js'
import update from './update.js'

export default {
  auth,
  count,
  countVersions,
  create,
  deleteLocal,
  duplicate,
  find: findLocal,
  findByID,
  findVersionByID,
  findVersions,
  restoreVersion,
  update,
}
</file>

<file path="packages/payload/src/collections/operations/local/restoreVersion.ts">
// @ts-strict-ignore
import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'
import type { DataFromCollectionSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { restoreVersionOperation } from '../restoreVersion.js'

export type Options<TSlug extends CollectionSlug> = {
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to restore.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function restoreVersionLocal<TSlug extends CollectionSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<DataFromCollectionSlug<TSlug>> {
  const {
    id,
    collection: collectionSlug,
    depth,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(
        collectionSlug,
      )} can't be found. Restore Version Operation.`,
    )
  }

  const args = {
    id,
    collection,
    depth,
    overrideAccess,
    payload,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  }

  return restoreVersionOperation(args)
}
</file>

<file path="packages/payload/src/collections/operations/local/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../../types/index.js'
import type { File } from '../../../uploads/types.js'
import type {
  BulkOperationResult,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { getFileByPath } from '../../../uploads/getFileByPath.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { updateOperation } from '../update.js'
import { updateByIDOperation } from '../updateByID.js'

export type BaseOptions<TSlug extends CollectionSlug, TSelect extends SelectType> = {
  /**
   * Whether the current update should be marked as from autosave.
   * `versions.drafts.autosave` should be specified.
   */
  autosave?: boolean
  /**
   * the Collection slug to operate against.
   */
  collection: TSlug
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The document / documents data to update.
   */
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, a [database transactions](https://payloadcms.com/docs/database/transactions) will not be initialized.
   * @default false
   */
  disableTransaction?: boolean
  /**
   * Update documents to a draft.
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * A `File` object when updating a collection with `upload: true`.
   */
  file?: File
  /**
   * A file path when creating a collection with `upload: true`.
   */
  filePath?: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * By default, document locks are ignored (`true`). Set to `false` to enforce locks and prevent operations when a document is locked by another user. [More details](https://payloadcms.com/docs/admin/locked-documents).
   * @default true
   */
  overrideLock?: boolean
  /**
   * If you are uploading a file and would like to replace
   * the existing file instead of generating a new filename,
   * you can set the following property to `true`
   */
  overwriteExistingFiles?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * Publish the document / documents with a specific locale.
   */
  publishSpecificLocale?: string
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export type ByIDOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to update.
   */
  id: number | string
  /**
   * Limit documents to update
   */
  limit?: never
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: never
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: never
} & BaseOptions<TSlug, TSelect>

export type ManyOptions<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = {
  /**
   * The ID of the document to update.
   */
  id?: never
  /**
   * Limit documents to update
   */
  limit?: number
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where: Where
} & BaseOptions<TSlug, TSelect>

export type Options<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
> = ByIDOptions<TSlug, TSelect> | ManyOptions<TSlug, TSelect>

async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ByIDOptions<TSlug, TSelect>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: ManyOptions<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>>
async function updateLocal<
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
  const {
    id,
    autosave,
    collection: collectionSlug,
    data,
    depth,
    disableTransaction,
    draft,
    file,
    filePath,
    limit,
    overrideAccess = true,
    overrideLock,
    overwriteExistingFiles = false,
    populate,
    publishSpecificLocale,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const collection = payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(
      `The collection with slug ${String(collectionSlug)} can't be found. Update Operation.`,
    )
  }

  const req = await createLocalReq(options, payload)
  req.file = file ?? (await getFileByPath(filePath))

  const args = {
    id,
    autosave,
    collection,
    data,
    depth,
    disableTransaction,
    draft,
    limit,
    overrideAccess,
    overrideLock,
    overwriteExistingFiles,
    payload,
    populate,
    publishSpecificLocale,
    req,
    select,
    showHiddenFields,
    sort,
    where,
  }

  if (options.id) {
    return updateByIDOperation<TSlug, TSelect>(args)
  }
  return updateOperation<TSlug, TSelect>(args)
}

export default updateLocal
</file>

<file path="packages/payload/src/collections/operations/utilities/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { Args } from '../../../fields/hooks/beforeChange/index.js'
import type {
  Payload,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../../types/index.js'
import type {
  DataFromCollectionSlug,
  SanitizedCollectionConfig,
  SelectFromCollectionSlug,
} from '../../config/types.js'

import { ensureUsernameOrEmail } from '../../../auth/ensureUsernameOrEmail.js'
import { generatePasswordSaltHash } from '../../../auth/strategies/local/generatePasswordSaltHash.js'
import { combineQueries } from '../../../database/combineQueries.js'
import { afterChange } from '../../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../../fields/hooks/afterRead/index.js'
import { beforeChange } from '../../../fields/hooks/beforeChange/index.js'
import { beforeValidate } from '../../../fields/hooks/beforeValidate/index.js'
import {
  type AccessResult,
  type CollectionSlug,
  deepCopyObjectSimple,
  type FileToSave,
  type SanitizedConfig,
} from '../../../index.js'
import { deleteAssociatedFiles } from '../../../uploads/deleteAssociatedFiles.js'
import { uploadFiles } from '../../../uploads/uploadFiles.js'
import { checkDocumentLockStatus } from '../../../utilities/checkDocumentLockStatus.js'
import { getLatestCollectionVersion } from '../../../versions/getLatestCollectionVersion.js'
import { saveVersion } from '../../../versions/saveVersion.js'

export type SharedUpdateDocumentArgs<TSlug extends CollectionSlug> = {
  accessResults: AccessResult
  autosave: boolean
  collectionConfig: SanitizedCollectionConfig
  config: SanitizedConfig
  data: DeepPartial<DataFromCollectionSlug<TSlug>>
  depth: number
  docWithLocales: any
  draftArg: boolean
  fallbackLocale: string
  filesToUpload: FileToSave[]
  id: number | string
  locale: string
  overrideAccess: boolean
  overrideLock: boolean
  payload: Payload
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select: SelectType
  showHiddenFields: boolean
}

/**
 * This function is used to update a document in the DB and return the result.
 *
 * It runs the following hooks in order:
 * - beforeValidate - Fields
 * - beforeValidate - Collection
 * - beforeChange - Collection
 * - beforeChange - Fields
 * - afterRead - Fields
 * - afterRead - Collection
 * - afterChange - Fields
 * - afterChange - Collection
 */
export const updateDocument = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,
>({
  id,
  accessResults,
  autosave,
  collectionConfig,
  config,
  data,
  depth,
  docWithLocales,
  draftArg,
  fallbackLocale,
  filesToUpload,
  locale,
  overrideAccess,
  overrideLock,
  payload,
  populate,
  publishSpecificLocale,
  req,
  select,
  showHiddenFields,
}: SharedUpdateDocumentArgs<TSlug>): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  const password = data?.password
  const shouldSaveDraft =
    Boolean(draftArg && collectionConfig.versions.drafts) && data._status !== 'published'
  const shouldSavePassword = Boolean(
    password &&
      collectionConfig.auth &&
      (!collectionConfig.auth.disableLocalStrategy ||
        (typeof collectionConfig.auth.disableLocalStrategy === 'object' &&
          collectionConfig.auth.disableLocalStrategy.enableFields)) &&
      !shouldSaveDraft,
  )

  // /////////////////////////////////////
  // Handle potentially locked documents
  // /////////////////////////////////////

  await checkDocumentLockStatus({
    id,
    collectionSlug: collectionConfig.slug,
    lockErrorMessage: `Document with ID ${id} is currently locked by another user and cannot be updated.`,
    overrideLock,
    req,
  })

  const originalDoc = await afterRead({
    collection: collectionConfig,
    context: req.context,
    depth: 0,
    doc: deepCopyObjectSimple(docWithLocales),
    draft: draftArg,
    fallbackLocale: id ? null : fallbackLocale,
    global: null,
    locale,
    overrideAccess: true,
    req,
    showHiddenFields: true,
  })

  if (collectionConfig.auth) {
    ensureUsernameOrEmail<TSlug>({
      authOptions: collectionConfig.auth,
      collectionSlug: collectionConfig.slug,
      data,
      operation: 'update',
      originalDoc,
      req,
    })
  }

  // /////////////////////////////////////
  // Delete any associated files
  // /////////////////////////////////////

  await deleteAssociatedFiles({
    collectionConfig,
    config,
    doc: docWithLocales,
    files: filesToUpload,
    overrideDelete: false,
    req,
  })

  // /////////////////////////////////////
  // beforeValidate - Fields
  // /////////////////////////////////////

  data = await beforeValidate<DeepPartial<DataFromCollectionSlug<TSlug>>>({
    id,
    collection: collectionConfig,
    context: req.context,
    data,
    doc: originalDoc,
    global: null,
    operation: 'update',
    overrideAccess,
    req,
  })

  // /////////////////////////////////////
  // beforeValidate - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.beforeValidate?.length) {
    for (const hook of collectionConfig.hooks.beforeValidate) {
      data =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          data,
          operation: 'update',
          originalDoc,
          req,
        })) || data
    }
  }

  // /////////////////////////////////////
  // Write files to local storage
  // /////////////////////////////////////

  if (!collectionConfig.upload.disableLocalStorage) {
    await uploadFiles(payload, filesToUpload, req)
  }

  // /////////////////////////////////////
  // beforeChange - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.beforeChange?.length) {
    for (const hook of collectionConfig.hooks.beforeChange) {
      data =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          data,
          operation: 'update',
          originalDoc,
          req,
        })) || data
    }
  }

  // /////////////////////////////////////
  // beforeChange - Fields
  // /////////////////////////////////////

  let publishedDocWithLocales = docWithLocales
  let versionSnapshotResult

  const beforeChangeArgs: Args<DataFromCollectionSlug<TSlug>> = {
    id,
    collection: collectionConfig,
    context: req.context,
    data: { ...data, id },
    doc: originalDoc,
    docWithLocales: undefined,
    global: null,
    operation: 'update',
    req,
    skipValidation:
      shouldSaveDraft &&
      collectionConfig.versions.drafts &&
      !collectionConfig.versions.drafts.validate,
  }

  if (publishSpecificLocale) {
    versionSnapshotResult = await beforeChange({
      ...beforeChangeArgs,
      docWithLocales,
    })

    const lastPublished = await getLatestCollectionVersion({
      id,
      config: collectionConfig,
      payload,
      published: true,
      query: {
        collection: collectionConfig.slug,
        locale,
        req,
        where: combineQueries({ id: { equals: id } }, accessResults),
      },
      req,
    })

    publishedDocWithLocales = lastPublished ? lastPublished : {}
  }

  let result = await beforeChange({
    ...beforeChangeArgs,
    docWithLocales: publishedDocWithLocales,
  })

  // /////////////////////////////////////
  // Handle potential password update
  // /////////////////////////////////////

  const dataToUpdate: Record<string, unknown> = { ...result }

  if (shouldSavePassword && typeof password === 'string') {
    const { hash, salt } = await generatePasswordSaltHash({
      collection: collectionConfig,
      password,
      req,
    })
    dataToUpdate.salt = salt
    dataToUpdate.hash = hash
    delete dataToUpdate.password
    delete data.password
  }

  // /////////////////////////////////////
  // Update
  // /////////////////////////////////////

  if (!shouldSaveDraft) {
    result = await req.payload.db.updateOne({
      id,
      collection: collectionConfig.slug,
      data: dataToUpdate,
      locale,
      req,
      select,
    })
  }

  // /////////////////////////////////////
  // Create version
  // /////////////////////////////////////

  if (collectionConfig.versions) {
    result = await saveVersion({
      id,
      autosave,
      collection: collectionConfig,
      docWithLocales: result,
      draft: shouldSaveDraft,
      payload,
      publishSpecificLocale,
      req,
      select,
      snapshot: versionSnapshotResult,
    })
  }

  // /////////////////////////////////////
  // afterRead - Fields
  // /////////////////////////////////////

  result = await afterRead({
    collection: collectionConfig,
    context: req.context,
    depth,
    doc: result,
    draft: draftArg,
    fallbackLocale,
    global: null,
    locale,
    overrideAccess,
    populate,
    req,
    select,
    showHiddenFields,
  })

  // /////////////////////////////////////
  // afterRead - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.afterRead?.length) {
    for (const hook of collectionConfig.hooks.afterRead) {
      result =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          doc: result,
          req,
        })) || result
    }
  }

  // /////////////////////////////////////
  // afterChange - Fields
  // /////////////////////////////////////

  result = await afterChange({
    collection: collectionConfig,
    context: req.context,
    data,
    doc: result,
    global: null,
    operation: 'update',
    previousDoc: originalDoc,
    req,
  })

  // /////////////////////////////////////
  // afterChange - Collection
  // /////////////////////////////////////

  if (collectionConfig.hooks?.afterChange?.length) {
    for (const hook of collectionConfig.hooks.afterChange) {
      result =
        (await hook({
          collection: collectionConfig,
          context: req.context,
          doc: result,
          operation: 'update',
          previousDoc: originalDoc,
          req,
        })) || result
    }
  }

  return result as TransformCollectionWithSelect<TSlug, TSelect>
}
</file>

<file path="packages/payload/src/collections/operations/count.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, Where } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  disableErrors?: boolean
  overrideAccess?: boolean
  req?: PayloadRequest
  where?: Where
}

export const countOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments,
): Promise<{ totalDocs: number }> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'count',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      disableErrors,
      overrideAccess,
      req: { payload },
      req,
      where,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          totalDocs: 0,
        }
      }
    }

    let result: { totalDocs: number }

    const fullWhere = combineQueries(where, accessResult)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    result = await payload.db.count({
      collection: collectionConfig.slug,
      req,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'count',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/countVersions.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, Where } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { buildVersionCollectionFields, type CollectionSlug } from '../../index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  disableErrors?: boolean
  overrideAccess?: boolean
  req?: PayloadRequest
  where?: Where
}

export const countVersionsOperation = async <TSlug extends CollectionSlug>(
  incomingArgs: Arguments,
): Promise<{ totalDocs: number }> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'countVersions',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      disableErrors,
      overrideAccess,
      req: { payload },
      req,
      where,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess(
        { disableErrors, req },
        collectionConfig.access.readVersions,
      )

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          totalDocs: 0,
        }
      }
    }

    let result: { totalDocs: number }

    const fullWhere = combineQueries(where, accessResult)

    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    result = await payload.db.countVersions({
      collection: collectionConfig.slug,
      req,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'countVersions',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/create.ts">
// @ts-strict-ignore
import crypto from 'crypto'

import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  AfterChangeHook,
  BeforeOperationHook,
  BeforeValidateHook,
  Collection,
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import { ensureUsernameOrEmail } from '../../auth/ensureUsernameOrEmail.js'
import executeAccess from '../../auth/executeAccess.js'
import { sendVerificationEmail } from '../../auth/sendVerificationEmail.js'
import { registerLocalStrategy } from '../../auth/strategies/local/register.js'
import { getDuplicateDocumentData } from '../../duplicateDocument/index.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { beforeChange } from '../../fields/hooks/beforeChange/index.js'
import { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'
import { type CollectionSlug, type JsonObject } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { uploadFiles } from '../../uploads/uploadFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { saveVersion } from '../../versions/saveVersion.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  autosave?: boolean
  collection: Collection
  data: RequiredDataFromCollectionSlug<TSlug>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  duplicateFromID?: DataFromCollectionSlug<TSlug>['id']
  overrideAccess?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const createOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    ensureUsernameOrEmail<TSlug>({
      authOptions: args.collection.config.auth,
      collectionSlug: args.collection.config.slug,
      data: args.data,
      operation: 'create',
      req: args.req,
    })

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'create',
            req: args.req,
          })) || args
      }
    }

    const {
      autosave = false,
      collection: { config: collectionConfig },
      collection,
      depth,
      disableVerificationEmail,
      draft = false,
      duplicateFromID,
      overrideAccess,
      overwriteExistingFiles = false,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload,
        payload: { config },
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    let { data } = args

    const shouldSaveDraft = Boolean(draft && collectionConfig.versions.drafts)

    let duplicatedFromDocWithLocales: JsonObject = {}
    let duplicatedFromDoc: JsonObject = {}

    if (duplicateFromID) {
      const duplicateResult = await getDuplicateDocumentData({
        id: duplicateFromID,
        collectionConfig,
        draftArg: shouldSaveDraft,
        overrideAccess,
        req,
        shouldSaveDraft,
      })

      duplicatedFromDoc = duplicateResult.duplicatedFromDoc
      duplicatedFromDocWithLocales = duplicateResult.duplicatedFromDocWithLocales
    }

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    if (!overrideAccess) {
      await executeAccess({ data, req }, collectionConfig.access.create)
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data: newFileData, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data,
      isDuplicating: Boolean(duplicateFromID),
      operation: 'create',
      originalDoc: duplicatedFromDoc,
      overwriteExistingFiles,
      req,
      throwOnMissingFile:
        !shouldSaveDraft && collection.config.upload.filesRequiredOnCreate !== false,
    })

    data = newFileData

    // /////////////////////////////////////
    // beforeValidate - Fields
    // /////////////////////////////////////

    data = await beforeValidate({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: duplicatedFromDoc,
      global: null,
      operation: 'create',
      overrideAccess,
      req,
    })

    // /////////////////////////////////////
    // beforeValidate - Collections
    // /////////////////////////////////////

    if (collectionConfig.hooks.beforeValidate?.length) {
      for (const hook of collectionConfig.hooks.beforeValidate) {
        data =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            data,
            operation: 'create',
            originalDoc: duplicatedFromDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeChange?.length) {
      for (const hook of collectionConfig.hooks.beforeChange) {
        data =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            data,
            operation: 'create',
            originalDoc: duplicatedFromDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Fields
    // /////////////////////////////////////

    const resultWithLocales = await beforeChange<JsonObject>({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: duplicatedFromDoc,
      docWithLocales: duplicatedFromDocWithLocales,
      global: null,
      operation: 'create',
      req,
      skipValidation:
        shouldSaveDraft &&
        collectionConfig.versions.drafts &&
        !collectionConfig.versions.drafts.validate,
    })

    // /////////////////////////////////////
    // Write files to local storage
    // /////////////////////////////////////

    if (!collectionConfig.upload.disableLocalStorage) {
      await uploadFiles(payload, filesToUpload, req)
    }

    // /////////////////////////////////////
    // Create
    // /////////////////////////////////////

    let doc

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    if (collectionConfig.auth && !collectionConfig.auth.disableLocalStrategy) {
      if (collectionConfig.auth.verify) {
        resultWithLocales._verified = Boolean(resultWithLocales._verified) || false
        resultWithLocales._verificationToken = crypto.randomBytes(20).toString('hex')
      }

      doc = await registerLocalStrategy({
        collection: collectionConfig,
        doc: resultWithLocales,
        password: data.password as string,
        payload: req.payload,
        req,
        select,
      })
    } else {
      doc = await payload.db.create({
        collection: collectionConfig.slug,
        data: resultWithLocales,
        req,
        select,
      })
    }

    const verificationToken = doc._verificationToken
    let result: Document = sanitizeInternalFields(doc)

    // /////////////////////////////////////
    // Create version
    // /////////////////////////////////////

    if (collectionConfig.versions) {
      await saveVersion({
        id: result.id,
        autosave,
        collection: collectionConfig,
        docWithLocales: result,
        payload,
        req,
      })
    }

    // /////////////////////////////////////
    // Send verification email if applicable
    // /////////////////////////////////////

    if (collectionConfig.auth && collectionConfig.auth.verify && result.email) {
      await sendVerificationEmail({
        collection: { config: collectionConfig },
        config: payload.config,
        disableEmail: disableVerificationEmail,
        email: payload.email,
        req,
        token: verificationToken,
        user: result,
      })
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: collectionConfig,
      context: req.context,
      data,
      doc: result,
      global: null,
      operation: 'create',
      previousDoc: {},
      req,
    })

    // /////////////////////////////////////
    // afterChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterChange?.length) {
      for (const hook of collectionConfig.hooks.afterChange) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            operation: 'create',
            previousDoc: {},
            req: args.req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation<TSlug>({
      args,
      collection: collectionConfig,
      operation: 'create',
      result,
    })

    await unlinkTempFiles({ collectionConfig, config, req })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/delete.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { AccessResult } from '../../config/types.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest, PopulateType, SelectType, Where } from '../../types/index.js'
import type {
  BeforeOperationHook,
  BulkOperationResult,
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { APIError } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'
import { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'
import { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'
import { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  depth?: number
  disableTransaction?: boolean
  overrideAccess?: boolean
  overrideLock?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  where: Where
}

export const deleteOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<BulkOperationResult<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'delete',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      depth,
      overrideAccess,
      overrideLock,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
      where,
    } = args

    if (!where) {
      throw new APIError("Missing 'where' query of documents to delete.", httpStatus.BAD_REQUEST)
    }

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ req }, collectionConfig.access.delete)
    }

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    const fullWhere = combineQueries(where, accessResult)

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Retrieve documents
    // /////////////////////////////////////

    const { docs } = await payload.db.find<DataFromCollectionSlug<TSlug>>({
      collection: collectionConfig.slug,
      locale,
      req,
      select,
      where: fullWhere,
    })

    const errors = []

    const promises = docs.map(async (doc) => {
      let result

      const { id } = doc

      try {
        // /////////////////////////////////////
        // Handle potentially locked documents
        // /////////////////////////////////////

        await checkDocumentLockStatus({
          id,
          collectionSlug: collectionConfig.slug,
          lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,
          overrideLock,
          req,
        })

        // /////////////////////////////////////
        // beforeDelete - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.beforeDelete?.length) {
          for (const hook of collectionConfig.hooks.beforeDelete) {
            await hook({
              id,
              collection: collectionConfig,
              context: req.context,
              req,
            })
          }
        }

        await deleteAssociatedFiles({
          collectionConfig,
          config,
          doc,
          overrideDelete: true,
          req,
        })

        // /////////////////////////////////////
        // Delete versions
        // /////////////////////////////////////

        if (collectionConfig.versions) {
          await deleteCollectionVersions({
            id,
            slug: collectionConfig.slug,
            payload,
            req,
          })
        }

        // /////////////////////////////////////
        // Delete scheduled posts
        // /////////////////////////////////////
        if (collectionConfig.versions?.drafts && collectionConfig.versions.drafts.schedulePublish) {
          await deleteScheduledPublishJobs({
            id,
            slug: collectionConfig.slug,
            payload,
            req,
          })
        }

        // /////////////////////////////////////
        // Delete document
        // /////////////////////////////////////

        await payload.db.deleteOne({
          collection: collectionConfig.slug,
          req,
          returning: false,
          where: {
            id: {
              equals: id,
            },
          },
        })

        // /////////////////////////////////////
        // afterRead - Fields
        // /////////////////////////////////////

        result = await afterRead({
          collection: collectionConfig,
          context: req.context,
          depth,
          doc: result || doc,
          draft: undefined,
          fallbackLocale,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select,
          showHiddenFields,
        })

        // /////////////////////////////////////
        // afterRead - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.afterRead?.length) {
          for (const hook of collectionConfig.hooks.afterRead) {
            result =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: result || doc,
                req,
              })) || result
          }
        }

        // /////////////////////////////////////
        // afterDelete - Collection
        // /////////////////////////////////////

        if (collectionConfig.hooks?.afterDelete?.length) {
          for (const hook of collectionConfig.hooks.afterDelete) {
            result =
              (await hook({
                id,
                collection: collectionConfig,
                context: req.context,
                doc: result,
                req,
              })) || result
          }
        }

        // /////////////////////////////////////
        // 8. Return results
        // /////////////////////////////////////

        return result
      } catch (error) {
        errors.push({
          id: doc.id,
          message: error.message,
        })
      }
      return null
    })

    const awaitedDocs = await Promise.all(promises)

    // /////////////////////////////////////
    // Delete Preferences
    // /////////////////////////////////////

    await deleteUserPreferences({
      collectionConfig,
      ids: docs.map(({ id }) => id),
      payload,
      req,
    })

    let result = {
      docs: awaitedDocs.filter(Boolean),
      errors,
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'delete',
      result,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/deleteByID.ts">
// @ts-strict-ignore
import type { CollectionSlug } from '../../index.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type { BeforeOperationHook, Collection, DataFromCollectionSlug } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { Forbidden, NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { deleteUserPreferences } from '../../preferences/deleteUserPreferences.js'
import { deleteAssociatedFiles } from '../../uploads/deleteAssociatedFiles.js'
import { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { deleteCollectionVersions } from '../../versions/deleteCollectionVersions.js'
import { deleteScheduledPublishJobs } from '../../versions/deleteScheduledPublishJobs.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  depth?: number
  disableTransaction?: boolean
  id: number | string
  overrideAccess?: boolean
  overrideLock?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const deleteByIDOperation = async <TSlug extends CollectionSlug, TSelect extends SelectType>(
  incomingArgs: Arguments,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'delete',
            req: args.req,
          })) || args
      }
    }

    const {
      id,
      collection: { config: collectionConfig },
      depth,
      overrideAccess,
      overrideLock,
      populate,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, req }, collectionConfig.access.delete)
      : true
    const hasWhereAccess = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // beforeDelete - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeDelete?.length) {
      for (const hook of collectionConfig.hooks.beforeDelete) {
        await hook({
          id,
          collection: collectionConfig,
          context: req.context,
          req,
        })
      }
    }

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const docToDelete = await req.payload.db.findOne({
      collection: collectionConfig.slug,
      locale: req.locale,
      req,
      where: combineQueries({ id: { equals: id } }, accessResults),
    })

    if (!docToDelete && !hasWhereAccess) {
      throw new NotFound(req.t)
    }
    if (!docToDelete && hasWhereAccess) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // Handle potentially locked documents
    // /////////////////////////////////////

    await checkDocumentLockStatus({
      id,
      collectionSlug: collectionConfig.slug,
      lockErrorMessage: `Document with ID ${id} is currently locked and cannot be deleted.`,
      overrideLock,
      req,
    })

    await deleteAssociatedFiles({
      collectionConfig,
      config,
      doc: docToDelete,
      overrideDelete: true,
      req,
    })

    // /////////////////////////////////////
    // Delete versions
    // /////////////////////////////////////

    if (collectionConfig.versions) {
      await deleteCollectionVersions({
        id,
        slug: collectionConfig.slug,
        payload,
        req,
      })
    }

    // /////////////////////////////////////
    // Delete scheduled posts
    // /////////////////////////////////////
    if (collectionConfig.versions?.drafts && collectionConfig.versions.drafts.schedulePublish) {
      await deleteScheduledPublishJobs({
        id,
        slug: collectionConfig.slug,
        payload,
        req,
      })
    }

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Delete document
    // /////////////////////////////////////

    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.deleteOne({
      collection: collectionConfig.slug,
      req,
      select,
      where: { id: { equals: id } },
    })

    // /////////////////////////////////////
    // Delete Preferences
    // /////////////////////////////////////

    await deleteUserPreferences({
      collectionConfig,
      ids: [id],
      payload,
      req,
    })

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterDelete - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterDelete?.length) {
      for (const hook of collectionConfig.hooks.afterDelete) {
        result =
          (await hook({
            id,
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'deleteByID',
      result,
    })

    // /////////////////////////////////////
    // 8. Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result as TransformCollectionWithSelect<TSlug, TSelect>
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/docAccess.ts">
// @ts-strict-ignore
import type { SanitizedCollectionPermission } from '../../auth/index.js'
import type { AllOperations, PayloadRequest } from '../../types/index.js'
import type { Collection } from '../config/types.js'

import { getEntityPolicies } from '../../utilities/getEntityPolicies.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizePermissions } from '../../utilities/sanitizePermissions.js'

const allOperations: AllOperations[] = ['create', 'read', 'update', 'delete']

type Arguments = {
  collection: Collection
  id: number | string
  req: PayloadRequest
}

export async function docAccessOperation(args: Arguments): Promise<SanitizedCollectionPermission> {
  const {
    id,
    collection: { config },
    req,
  } = args

  const collectionOperations = [...allOperations]

  if (
    config.auth &&
    typeof config.auth.maxLoginAttempts !== 'undefined' &&
    config.auth.maxLoginAttempts !== 0
  ) {
    collectionOperations.push('unlock')
  }

  if (config.versions) {
    collectionOperations.push('readVersions')
  }

  try {
    const result = await getEntityPolicies({
      id,
      type: 'collection',
      blockPolicies: {},
      entity: config,
      operations: collectionOperations,
      req,
    })

    const sanitizedPermissions = sanitizePermissions({
      collections: {
        [config.slug]: result,
      },
    })

    return sanitizedPermissions?.collections?.[config.slug]
  } catch (e: unknown) {
    await killTransaction(req)
    throw e
  }
}
</file>

<file path="packages/payload/src/collections/operations/duplicate.ts">
import type { DeepPartial } from 'ts-essentials'

import type { CollectionSlug } from '../../index.js'
import type { TransformCollectionWithSelect } from '../../types/index.js'
import type { RequiredDataFromCollectionSlug, SelectFromCollectionSlug } from '../config/types.js'

import { type Arguments as CreateArguments, createOperation } from './create.js'

export type Arguments<TSlug extends CollectionSlug> = {
  data?: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  id: number | string
} & Omit<CreateArguments<TSlug>, 'data' | 'duplicateFromID'>

export const duplicateOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  const { id, ...args } = incomingArgs
  return createOperation({
    ...args,
    data: incomingArgs?.data || {},
    duplicateFromID: id,
  })
}
</file>

<file path="packages/payload/src/collections/operations/find.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PaginatedDocs } from '../../database/types.js'
import type { CollectionSlug, JoinQuery } from '../../index.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  TransformCollectionWithSelect,
  Where,
} from '../../types/index.js'
import type {
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'
import { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  includeLockStatus?: boolean
  joins?: JoinQuery
  limit?: number
  overrideAccess?: boolean
  page?: number
  pagination?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  sort?: Sort
  where?: Where
}

const lockDurationDefault = 300 // Default 5 minutes in seconds

export const findOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'read',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      collection,
      currentDepth,
      depth,
      disableErrors,
      draft: draftsEnabled,
      includeLockStatus,
      joins,
      limit,
      overrideAccess,
      page,
      pagination = true,
      populate,
      req: { fallbackLocale, locale, payload },
      req,
      select: incomingSelect,
      showHiddenFields,
      sort,
      where,
    } = args

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ disableErrors, req }, collectionConfig.access.read)

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          docs: [],
          hasNextPage: false,
          hasPrevPage: false,
          limit,
          nextPage: null,
          page: 1,
          pagingCounter: 1,
          prevPage: null,
          totalDocs: 0,
          totalPages: 1,
        }
      }
    }

    // /////////////////////////////////////
    // Find
    // /////////////////////////////////////

    const usePagination = pagination && limit !== 0
    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)
    const sanitizedPage = page || 1

    let result: PaginatedDocs<DataFromCollectionSlug<TSlug>>

    let fullWhere = combineQueries(where, accessResult)

    const sanitizedJoins = await sanitizeJoinQuery({
      collectionConfig,
      joins,
      overrideAccess,
      req,
    })

    if (collectionConfig.versions?.drafts && draftsEnabled) {
      fullWhere = appendVersionToQueryKey(fullWhere)

      await validateQueryPaths({
        collectionConfig: collection.config,
        overrideAccess,
        req,
        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),
        where: appendVersionToQueryKey(where),
      })

      result = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
        limit: sanitizedLimit,
        locale,
        page: sanitizedPage,
        pagination: usePagination,
        req,
        select: getQueryDraftsSelect({ select }),
        sort: getQueryDraftsSort({ collectionConfig, sort }),
        where: fullWhere,
      })
    } else {
      await validateQueryPaths({
        collectionConfig,
        overrideAccess,
        req,
        where,
      })

      result = await payload.db.find<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        draftsEnabled,
        joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
        limit: sanitizedLimit,
        locale,
        page: sanitizedPage,
        pagination,
        req,
        select,
        sort,
        where: fullWhere,
      })
    }

    if (includeLockStatus) {
      try {
        const lockDocumentsProp = collectionConfig?.lockDocuments

        const lockDuration =
          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault
        const lockDurationInMilliseconds = lockDuration * 1000

        const now = new Date().getTime()

        const lockedDocuments = await payload.find({
          collection: lockedDocumentsCollectionSlug,
          depth: 1,
          limit: sanitizedLimit,
          overrideAccess: false,
          pagination: false,
          req,
          where: {
            and: [
              {
                'document.relationTo': {
                  equals: collectionConfig.slug,
                },
              },
              {
                'document.value': {
                  in: result.docs.map((doc) => doc.id),
                },
              },
              // Query where the lock is newer than the current time minus lock time
              {
                updatedAt: {
                  greater_than: new Date(now - lockDurationInMilliseconds),
                },
              },
            ],
          },
        })

        const lockedDocs = Array.isArray(lockedDocuments?.docs) ? lockedDocuments.docs : []

        // Filter out stale locks
        const validLockedDocs = lockedDocs.filter((lock) => {
          const lastEditedAt = new Date(lock?.updatedAt).getTime()
          return lastEditedAt + lockDurationInMilliseconds > now
        })

        for (const doc of result.docs) {
          const lockedDoc = validLockedDocs.find((lock) => lock?.document?.value === doc.id)
          doc._isLocked = !!lockedDoc
          doc._userEditing = lockedDoc ? lockedDoc?.user?.value : null
        }
      } catch (_err) {
        for (const doc of result.docs) {
          doc._isLocked = false
          doc._userEditing = null
        }
      }
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig?.hooks?.beforeRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          let docRef = doc

          for (const hook of collectionConfig.hooks.beforeRead) {
            docRef =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef,
                query: fullWhere,
                req,
              })) || docRef
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.docs = await Promise.all(
      result.docs.map(async (doc) =>
        afterRead<DataFromCollectionSlug<TSlug>>({
          collection: collectionConfig,
          context: req.context,
          currentDepth,
          depth,
          doc,
          draft: draftsEnabled,
          fallbackLocale,
          findMany: true,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select,
          showHiddenFields,
        }),
      ),
    )

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig?.hooks?.afterRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          let docRef = doc

          for (const hook of collectionConfig.hooks.afterRead) {
            docRef =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef,
                findMany: true,
                query: fullWhere,
                req,
              })) || doc
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'find',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result as PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/findByID.ts">
// @ts-strict-ignore
import type { FindOneArgs } from '../../database/types.js'
import type { CollectionSlug, JoinQuery } from '../../index.js'
import type {
  ApplyDisableErrors,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { sanitizeJoinQuery } from '../../database/sanitizeJoinQuery.js'
import { NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { validateQueryPaths } from '../../index.js'
import { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import replaceWithDraftIfAvailable from '../../versions/drafts/replaceWithDraftIfAvailable.js'
import { buildAfterOperation } from './utils.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  id: number | string
  includeLockStatus?: boolean
  joins?: JoinQuery
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const findByIDOperation = async <
  TSlug extends CollectionSlug,
  TDisableErrors extends boolean,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments,
): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {
  let args = incomingArgs

  try {
    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'read',
            req: args.req,
          })) || args
      }
    }

    const {
      id,
      collection: { config: collectionConfig },
      currentDepth,
      depth,
      disableErrors,
      draft: draftEnabled = false,
      includeLockStatus,
      joins,
      overrideAccess = false,
      populate,
      req: { fallbackLocale, locale, t },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResult = !overrideAccess
      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.read)
      : true

    // If errors are disabled, and access returns false, return null
    if (accessResult === false) {
      return null
    }

    const where = { id: { equals: id } }

    const fullWhere = combineQueries(where, accessResult)

    const sanitizedJoins = await sanitizeJoinQuery({
      collectionConfig,
      joins,
      overrideAccess,
      req,
    })

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      draftsEnabled: draftEnabled,
      joins: req.payloadAPI === 'GraphQL' ? false : sanitizedJoins,
      locale,
      req: {
        transactionID: req.transactionID,
      } as PayloadRequest,
      select,
      where: fullWhere,
    }

    // execute only if there's a custom ID and potentially overwriten access on id
    if (req.payload.collections[collectionConfig.slug].customIDType) {
      await validateQueryPaths({
        collectionConfig,
        overrideAccess,
        req,
        where,
      })
    }
    // /////////////////////////////////////
    // Find by ID
    // /////////////////////////////////////

    if (!findOneArgs.where.and[0].id) {
      throw new NotFound(t)
    }

    let result: DataFromCollectionSlug<TSlug> = await req.payload.db.findOne(findOneArgs)

    if (!result) {
      if (!disableErrors) {
        throw new NotFound(req.t)
      }

      return null
    }

    // /////////////////////////////////////
    // Include Lock Status if required
    // /////////////////////////////////////

    if (includeLockStatus && id) {
      let lockStatus = null

      try {
        const lockDocumentsProp = collectionConfig?.lockDocuments

        const lockDurationDefault = 300 // Default 5 minutes in seconds
        const lockDuration =
          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault
        const lockDurationInMilliseconds = lockDuration * 1000

        const lockedDocument = await req.payload.find({
          collection: lockedDocumentsCollectionSlug,
          depth: 1,
          limit: 1,
          overrideAccess: false,
          pagination: false,
          req,
          where: {
            and: [
              {
                'document.relationTo': {
                  equals: collectionConfig.slug,
                },
              },
              {
                'document.value': {
                  equals: id,
                },
              },
              // Query where the lock is newer than the current time minus lock time
              {
                updatedAt: {
                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),
                },
              },
            ],
          },
        })

        if (lockedDocument && lockedDocument.docs.length > 0) {
          lockStatus = lockedDocument.docs[0]
        }
      } catch {
        // swallow error
      }

      result._isLocked = !!lockStatus
      result._userEditing = lockStatus?.user?.value ?? null
    }

    // /////////////////////////////////////
    // Replace document with draft if available
    // /////////////////////////////////////

    if (collectionConfig.versions?.drafts && draftEnabled) {
      result = await replaceWithDraftIfAvailable({
        accessResult,
        doc: result,
        entity: collectionConfig,
        entityType: 'collection',
        overrideAccess,
        req,
        select,
      })
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeRead?.length) {
      for (const hook of collectionConfig.hooks.beforeRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            query: findOneArgs.where,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      currentDepth,
      depth,
      doc: result,
      draft: draftEnabled,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            query: findOneArgs.where,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'findByID',
      result,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result as ApplyDisableErrors<
      TransformCollectionWithSelect<TSlug, TSelect>,
      TDisableErrors
    >
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/findVersionByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { Collection, TypeWithID } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const findVersionByIDOperation = async <TData extends TypeWithID = any>(
  args: Arguments,
): Promise<TypeWithVersion<TData>> => {
  const {
    id,
    collection: { config: collectionConfig },
    currentDepth,
    depth,
    disableErrors,
    overrideAccess,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
  } = args

  if (!id) {
    throw new APIError('Missing ID of version.', httpStatus.BAD_REQUEST)
  }

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, disableErrors, req }, collectionConfig.access.readVersions)
      : true

    // If errors are disabled, and access returns false, return null
    if (accessResults === false) {
      return null
    }

    const hasWhereAccess = typeof accessResults === 'object'

    const fullWhere = combineQueries({ id: { equals: id } }, accessResults)

    // /////////////////////////////////////
    // Find by ID
    // /////////////////////////////////////

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),
      select: incomingSelect,
    })

    const versionsQuery = await payload.db.findVersions<TData>({
      collection: collectionConfig.slug,
      limit: 1,
      locale,
      pagination: false,
      req,
      select,
      where: fullWhere,
    })

    const result = versionsQuery.docs[0]

    if (!result) {
      if (!disableErrors) {
        if (!hasWhereAccess) {
          throw new NotFound(req.t)
        }
        if (hasWhereAccess) {
          throw new Forbidden(req.t)
        }
      }

      return null
    }

    if (!result.version) {
      // Fallback if not selected
      ;(result as any).version = {}
    }

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.beforeRead?.length) {
      for (const hook of collectionConfig.hooks.beforeRead) {
        result.version =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result.version,
            query: fullWhere,
            req,
          })) || result.version
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.version = await afterRead({
      collection: collectionConfig,
      context: req.context,
      currentDepth,
      depth,
      doc: result.version,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select: typeof select?.version === 'object' ? select.version : undefined,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result.version =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result.version,
            query: fullWhere,
            req,
          })) || result.version
      }
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/findVersions.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { Collection } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  collection: Collection
  depth?: number
  limit?: number
  overrideAccess?: boolean
  page?: number
  pagination?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  sort?: Sort
  where?: Where
}

export const findVersionsOperation = async <TData extends TypeWithVersion<TData>>(
  args: Arguments,
): Promise<PaginatedDocs<TData>> => {
  const {
    collection: { config: collectionConfig },
    depth,
    limit,
    overrideAccess,
    page,
    pagination = true,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
    sort,
    where,
  } = args

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResults

    if (!overrideAccess) {
      accessResults = await executeAccess({ req }, collectionConfig.access.readVersions)
    }

    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    const fullWhere = combineQueries(where, accessResults)

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Find
    // /////////////////////////////////////

    const paginatedDocs = await payload.db.findVersions<TData>({
      collection: collectionConfig.slug,
      limit: limit ?? 10,
      locale,
      page: page || 1,
      pagination,
      req,
      select,
      sort,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////
    const result: PaginatedDocs<TData> = paginatedDocs as unknown as PaginatedDocs<TData>
    result.docs = (await Promise.all(
      paginatedDocs.docs.map(async (doc) => {
        const docRef = doc
        // Fallback if not selected
        if (!docRef.version) {
          ;(docRef as any).version = {}
        }

        if (collectionConfig.hooks?.beforeRead?.length) {
          for (const hook of collectionConfig.hooks.beforeRead) {
            docRef.version =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: docRef.version,
                query: fullWhere,
                req,
              })) || docRef.version
          }
        }

        return docRef
      }),
    )) as TData[]
    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.docs = await Promise.all(
      result.docs.map(async (data) => {
        data.version = await afterRead({
          collection: collectionConfig,
          context: req.context,
          depth,
          doc: data.version,
          draft: undefined,
          fallbackLocale,
          findMany: true,
          global: null,
          locale,
          overrideAccess,
          populate,
          req,
          select: typeof select?.version === 'object' ? select.version : undefined,
          showHiddenFields,
        })
        return data
      }),
    )

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks.afterRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          const docRef = doc

          for (const hook of collectionConfig.hooks.afterRead) {
            docRef.version =
              (await hook({
                collection: collectionConfig,
                context: req.context,
                doc: doc.version,
                findMany: true,
                query: fullWhere,
                req,
              })) || doc.version
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////
    result.docs = result.docs.map((doc) => sanitizeInternalFields<TData>(doc))

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/restoreVersion.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { FindOneArgs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'
import type { Collection, TypeWithID } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'

export type Arguments = {
  collection: Collection
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  draft?: boolean
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const restoreVersionOperation = async <TData extends TypeWithID = any>(
  args: Arguments,
): Promise<TData> => {
  const {
    id,
    collection: { config: collectionConfig },
    depth,
    draft,
    overrideAccess = false,
    populate,
    req,
    req: { fallbackLocale, locale, payload },
    select: incomingSelect,
    showHiddenFields,
  } = args

  try {
    if (!id) {
      throw new APIError('Missing ID of version to restore.', httpStatus.BAD_REQUEST)
    }

    // /////////////////////////////////////
    // Retrieve original raw version
    // /////////////////////////////////////

    const { docs: versionDocs } = await req.payload.db.findVersions({
      collection: collectionConfig.slug,
      limit: 1,
      locale,
      pagination: false,
      req,
      where: { id: { equals: id } },
    })

    const [rawVersion] = versionDocs

    if (!rawVersion) {
      throw new NotFound(req.t)
    }

    const parentDocID = rawVersion.parent

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id: parentDocID, req }, collectionConfig.access.update)
      : true
    const hasWherePolicy = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      locale,
      req,
      where: combineQueries({ id: { equals: parentDocID } }, accessResults),
    }

    const doc = await req.payload.db.findOne(findOneArgs)

    if (!doc && !hasWherePolicy) {
      throw new NotFound(req.t)
    }
    if (!doc && hasWherePolicy) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // fetch previousDoc
    // /////////////////////////////////////

    const prevDocWithLocales = await getLatestCollectionVersion({
      id: parentDocID,
      config: collectionConfig,
      payload,
      query: findOneArgs,
      req,
    })

    // /////////////////////////////////////
    // Update
    // /////////////////////////////////////

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    let result = await req.payload.db.updateOne({
      id: parentDocID,
      collection: collectionConfig.slug,
      data: rawVersion.version,
      req,
      select,
    })

    // /////////////////////////////////////
    // Save `previousDoc` as a version after restoring
    // /////////////////////////////////////

    const prevVersion = { ...prevDocWithLocales }

    delete prevVersion.id

    await payload.db.createVersion({
      autosave: false,
      collectionSlug: collectionConfig.slug,
      createdAt: prevVersion.createdAt,
      parent: parentDocID,
      req,
      updatedAt: new Date().toISOString(),
      versionData: draft ? { ...rawVersion.version, _status: 'draft' } : rawVersion.version,
    })

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: collectionConfig,
      context: req.context,
      depth,
      doc: result,
      draft: undefined,
      fallbackLocale,
      global: null,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterRead?.length) {
      for (const hook of collectionConfig.hooks.afterRead) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: collectionConfig,
      context: req.context,
      data: result,
      doc: result,
      global: null,
      operation: 'update',
      previousDoc: prevDocWithLocales,
      req,
    })

    // /////////////////////////////////////
    // afterChange - Collection
    // /////////////////////////////////////

    if (collectionConfig.hooks?.afterChange?.length) {
      for (const hook of collectionConfig.hooks.afterChange) {
        result =
          (await hook({
            collection: collectionConfig,
            context: req.context,
            doc: result,
            operation: 'update',
            previousDoc: prevDocWithLocales,
            req,
          })) || result
      }
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import { status as httpStatus } from 'http-status'

import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'
import type {
  BulkOperationResult,
  Collection,
  DataFromCollectionSlug,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { APIError } from '../../errors/index.js'
import { type CollectionSlug, deepCopyObjectSimple } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'
import { appendVersionToQueryKey } from '../../versions/drafts/appendVersionToQueryKey.js'
import { getQueryDraftsSort } from '../../versions/drafts/getQueryDraftsSort.js'
import { updateDocument } from './utilities/update.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  collection: Collection
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  limit?: number
  overrideAccess?: boolean
  overrideLock?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-createdAt' // Sort DESC by createdAt
   * @example ['group', '-createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  where: Where
}

export const updateOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug>,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<BulkOperationResult<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'update',
            req: args.req,
          })) || args
      }
    }

    const {
      collection: { config: collectionConfig },
      collection,
      depth,
      draft: draftArg = false,
      limit = 0,
      overrideAccess,
      overrideLock,
      overwriteExistingFiles = false,
      populate,
      publishSpecificLocale,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
      sort,
      where,
    } = args

    if (!where) {
      throw new APIError("Missing 'where' query of documents to update.", httpStatus.BAD_REQUEST)
    }

    const { data: bulkUpdateData } = args
    const shouldSaveDraft = Boolean(draftArg && collectionConfig.versions.drafts)

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult
    if (!overrideAccess) {
      accessResult = await executeAccess({ req }, collectionConfig.access.update)
    }

    await validateQueryPaths({
      collectionConfig,
      overrideAccess,
      req,
      where,
    })

    // /////////////////////////////////////
    // Retrieve documents
    // /////////////////////////////////////

    const fullWhere = combineQueries(where, accessResult)

    let docs

    if (collectionConfig.versions?.drafts && shouldSaveDraft) {
      const versionsWhere = appendVersionToQueryKey(fullWhere)

      await validateQueryPaths({
        collectionConfig: collection.config,
        overrideAccess,
        req,
        versionFields: buildVersionCollectionFields(payload.config, collection.config, true),
        where: appendVersionToQueryKey(where),
      })

      const query = await payload.db.queryDrafts<DataFromCollectionSlug<TSlug>>({
        collection: collectionConfig.slug,
        limit,
        locale,
        pagination: false,
        req,
        sort: getQueryDraftsSort({ collectionConfig, sort }),
        where: versionsWhere,
      })

      docs = query.docs
    } else {
      const query = await payload.db.find({
        collection: collectionConfig.slug,
        limit,
        locale,
        pagination: false,
        req,
        sort,
        where: fullWhere,
      })

      docs = query.docs
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data: bulkUpdateData,
      operation: 'update',
      overwriteExistingFiles,
      req,
      throwOnMissingFile: false,
    })

    const errors = []

    const promises = docs.map(async (docWithLocales) => {
      const { id } = docWithLocales

      try {
        const select = sanitizeSelect({
          forceSelect: collectionConfig.forceSelect,
          select: incomingSelect,
        })

        // ///////////////////////////////////////////////
        // Update document, runs all document level hooks
        // ///////////////////////////////////////////////
        const updatedDoc = await updateDocument({
          id,
          accessResults: accessResult,
          autosave: false,
          collectionConfig,
          config,
          data: deepCopyObjectSimple(data),
          depth,
          docWithLocales,
          draftArg,
          fallbackLocale,
          filesToUpload,
          locale,
          overrideAccess,
          overrideLock,
          payload,
          populate,
          publishSpecificLocale,
          req,
          select,
          showHiddenFields,
        })

        return updatedDoc
      } catch (error) {
        errors.push({
          id,
          message: error.message,
        })
      }
      return null
    })

    await unlinkTempFiles({
      collectionConfig,
      config,
      req,
    })

    const awaitedDocs = await Promise.all(promises)

    let result = {
      docs: awaitedDocs.filter(Boolean),
      errors,
    }

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'update',
      result,
    })

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/updateByID.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import { status as httpStatus } from 'http-status'

import type { FindOneArgs } from '../../database/types.js'
import type {
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformCollectionWithSelect,
} from '../../types/index.js'
import type {
  Collection,
  RequiredDataFromCollectionSlug,
  SelectFromCollectionSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { hasWhereAccessResult } from '../../auth/types.js'
import { combineQueries } from '../../database/combineQueries.js'
import { APIError, Forbidden, NotFound } from '../../errors/index.js'
import { type CollectionSlug, deepCopyObjectSimple } from '../../index.js'
import { generateFileData } from '../../uploads/generateFileData.js'
import { unlinkTempFiles } from '../../uploads/unlinkTempFiles.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getLatestCollectionVersion } from '../../versions/getLatestCollectionVersion.js'
import { updateDocument } from './utilities/update.js'
import { buildAfterOperation } from './utils.js'

export type Arguments<TSlug extends CollectionSlug> = {
  autosave?: boolean
  collection: Collection
  data: DeepPartial<RequiredDataFromCollectionSlug<TSlug>>
  depth?: number
  disableTransaction?: boolean
  disableVerificationEmail?: boolean
  draft?: boolean
  id: number | string
  overrideAccess?: boolean
  overrideLock?: boolean
  overwriteExistingFiles?: boolean
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const updateByIDOperation = async <
  TSlug extends CollectionSlug,
  TSelect extends SelectFromCollectionSlug<TSlug> = SelectType,
>(
  incomingArgs: Arguments<TSlug>,
): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
  let args = incomingArgs

  try {
    const shouldCommit = !args.disableTransaction && (await initTransaction(args.req))

    // /////////////////////////////////////
    // beforeOperation - Collection
    // /////////////////////////////////////

    if (args.collection.config.hooks?.beforeOperation?.length) {
      for (const hook of args.collection.config.hooks.beforeOperation) {
        args =
          (await hook({
            args,
            collection: args.collection.config,
            context: args.req.context,
            operation: 'update',
            req: args.req,
          })) || args
      }
    }

    if (args.publishSpecificLocale) {
      args.req.locale = args.publishSpecificLocale
    }

    const {
      id,
      autosave = false,
      collection: { config: collectionConfig },
      collection,
      depth,
      draft: draftArg = false,
      overrideAccess,
      overrideLock,
      overwriteExistingFiles = false,
      populate,
      publishSpecificLocale,
      req: {
        fallbackLocale,
        locale,
        payload: { config },
        payload,
      },
      req,
      select: incomingSelect,
      showHiddenFields,
    } = args

    if (!id) {
      throw new APIError('Missing ID of document to update.', httpStatus.BAD_REQUEST)
    }

    const { data } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, data, req }, collectionConfig.access.update)
      : true
    const hasWherePolicy = hasWhereAccessResult(accessResults)

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const findOneArgs: FindOneArgs = {
      collection: collectionConfig.slug,
      locale,
      req,
      where: combineQueries({ id: { equals: id } }, accessResults),
    }

    const docWithLocales = await getLatestCollectionVersion({
      id,
      config: collectionConfig,
      payload,
      query: findOneArgs,
      req,
    })

    if (!docWithLocales && !hasWherePolicy) {
      throw new NotFound(req.t)
    }
    if (!docWithLocales && hasWherePolicy) {
      throw new Forbidden(req.t)
    }

    // /////////////////////////////////////
    // Generate data for all files and sizes
    // /////////////////////////////////////

    const { data: newFileData, files: filesToUpload } = await generateFileData({
      collection,
      config,
      data,
      operation: 'update',
      overwriteExistingFiles,
      req,
      throwOnMissingFile: false,
    })

    const select = sanitizeSelect({
      forceSelect: collectionConfig.forceSelect,
      select: incomingSelect,
    })

    // ///////////////////////////////////////////////
    // Update document, runs all document level hooks
    // ///////////////////////////////////////////////

    let result = await updateDocument<TSlug, TSelect>({
      id,
      accessResults,
      autosave,
      collectionConfig,
      config,
      data: deepCopyObjectSimple(newFileData),
      depth,
      docWithLocales,
      draftArg,
      fallbackLocale,
      filesToUpload,
      locale,
      overrideAccess,
      overrideLock,
      payload,
      populate,
      publishSpecificLocale,
      req,
      select,
      showHiddenFields,
    })

    await unlinkTempFiles({
      collectionConfig,
      config,
      req,
    })

    // /////////////////////////////////////
    // afterOperation - Collection
    // /////////////////////////////////////

    result = (await buildAfterOperation({
      args,
      collection: collectionConfig,
      operation: 'updateByID',
      result,
    })) as TransformCollectionWithSelect<TSlug, TSelect>

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/collections/operations/utils.ts">
import type { forgotPasswordOperation } from '../../auth/operations/forgotPassword.js'
import type { loginOperation } from '../../auth/operations/login.js'
import type { refreshOperation } from '../../auth/operations/refresh.js'
import type { CollectionSlug } from '../../index.js'
import type { PayloadRequest } from '../../types/index.js'
import type {
  AfterOperationHook,
  SanitizedCollectionConfig,
  SelectFromCollectionSlug,
} from '../config/types.js'
import type { countOperation } from './count.js'
import type { countVersionsOperation } from './countVersions.js'
import type { createOperation } from './create.js'
import type { deleteOperation } from './delete.js'
import type { deleteByIDOperation } from './deleteByID.js'
import type { findOperation } from './find.js'
import type { findByIDOperation } from './findByID.js'
import type { updateOperation } from './update.js'
import type { updateByIDOperation } from './updateByID.js'

export type AfterOperationMap<TOperationGeneric extends CollectionSlug> = {
  count: typeof countOperation<TOperationGeneric>
  countVersions: typeof countVersionsOperation<TOperationGeneric>
  create: typeof createOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  delete: typeof deleteOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  deleteByID: typeof deleteByIDOperation<
    TOperationGeneric,
    SelectFromCollectionSlug<TOperationGeneric>
  >
  find: typeof findOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  findByID: typeof findByIDOperation<
    TOperationGeneric,
    boolean,
    SelectFromCollectionSlug<TOperationGeneric>
  >
  forgotPassword: typeof forgotPasswordOperation
  login: typeof loginOperation<TOperationGeneric>
  refresh: typeof refreshOperation
  update: typeof updateOperation<TOperationGeneric, SelectFromCollectionSlug<TOperationGeneric>>
  updateByID: typeof updateByIDOperation<
    TOperationGeneric,
    SelectFromCollectionSlug<TOperationGeneric>
  >
}

export type AfterOperationArg<TOperationGeneric extends CollectionSlug> = {
  /** The collection which this hook is being run on */
  collection: SanitizedCollectionConfig
  req: PayloadRequest
} & (
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['count']>[0]
      operation: 'count'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['count']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['countVersions']>[0]
      operation: 'countVersions'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['countVersions']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['create']>[0]
      operation: 'create'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['create']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['delete']>[0]
      operation: 'delete'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['delete']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['deleteByID']>[0]
      operation: 'deleteByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['deleteByID']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['find']>[0]
      operation: 'find'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['find']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['findByID']>[0]
      operation: 'findByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['findByID']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['forgotPassword']>[0]
      operation: 'forgotPassword'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['forgotPassword']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['login']>[0]
      operation: 'login'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['login']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['refresh']>[0]
      operation: 'refresh'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['refresh']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['update']>[0]
      operation: 'update'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['update']>>
    }
  | {
      args: Parameters<AfterOperationMap<TOperationGeneric>['updateByID']>[0]
      operation: 'updateByID'
      result: Awaited<ReturnType<AfterOperationMap<TOperationGeneric>['updateByID']>>
    }
)

type OperationResult<
  TOperationGeneric extends CollectionSlug,
  O extends keyof AfterOperationMap<TOperationGeneric>,
> = Awaited<ReturnType<AfterOperationMap<TOperationGeneric>[O]>>

export const buildAfterOperation = async <
  TOperationGeneric extends CollectionSlug,
  O extends keyof AfterOperationMap<TOperationGeneric> = keyof AfterOperationMap<TOperationGeneric>,
>(
  operationArgs: { operation: O } & Omit<AfterOperationArg<TOperationGeneric>, 'req'>,
): Promise<any | OperationResult<TOperationGeneric, O>> => {
  const { args, collection, operation, result } = operationArgs

  let newResult = result as OperationResult<TOperationGeneric, O>

  if (args.collection.config.hooks?.afterOperation?.length) {
    for (const hook of args.collection.config.hooks.afterOperation) {
      const hookResult = await hook({
        args,
        collection,
        operation,
        req: args.req,
        result: newResult,
      } as AfterOperationArg<TOperationGeneric>)

      if (hookResult !== undefined) {
        newResult = hookResult as OperationResult<TOperationGeneric, O>
      }
    }
  }

  return newResult
}
</file>

<file path="packages/payload/src/collections/dataloader.ts">
// @ts-strict-ignore
import type { BatchLoadFn } from 'dataloader'

import DataLoader from 'dataloader'

import type { FindArgs } from '../database/types.js'
import type { PayloadRequest, PopulateType, SelectType } from '../types/index.js'
import type { TypeWithID } from './config/types.js'
import type { Options } from './operations/local/find.js'

import { isValidID } from '../utilities/isValidID.js'

// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.

// We keep a list of all documents requested to be populated for any given request
// and then batch together documents within the same collection,
// making only 1 find per each collection, rather than `findByID` per each requested doc.

// This dramatically improves performance for REST and Local API `depth` populations,
// and also ensures complex GraphQL queries perform lightning-fast.

const batchAndLoadDocs =
  (req: PayloadRequest): BatchLoadFn<string, TypeWithID> =>
  async (keys: string[]): Promise<TypeWithID[]> => {
    const { payload } = req

    // Create docs array of same length as keys, using null as value
    // We will replace nulls with injected docs as they are retrieved
    const docs: (null | TypeWithID)[] = keys.map(() => null)

    /**
    * Batch IDs by their `find` args
    * so we can make one find query per combination of collection, depth, locale, and fallbackLocale.
    *
    * Resulting shape will be as follows:
      {
        // key is stringified set of find args
        '[null,"pages",2,0,"es","en",false,false]': [
          // value is array of IDs to find with these args
          'q34tl23462346234524',
          '435523540194324280',
          '2346245j35l3j5234532li',
        ],
        // etc
      };
    *
    **/

    const batchByFindArgs = {}

    for (const key of keys) {
      const [
        transactionID,
        collection,
        id,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ] = JSON.parse(key)

      const batchKeyArray = [
        transactionID,
        collection,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ]

      const batchKey = JSON.stringify(batchKeyArray)

      const idType = payload.collections?.[collection].customIDType || payload.db.defaultIDType
      const sanitizedID = idType === 'number' ? parseFloat(id) : id

      if (isValidID(sanitizedID, idType)) {
        batchByFindArgs[batchKey] = [...(batchByFindArgs[batchKey] || []), sanitizedID]
      }
    }

    // Run find requests one after another, so as to not hang transactions

    for (const [batchKey, ids] of Object.entries(batchByFindArgs)) {
      const [
        transactionID,
        collection,
        depth,
        currentDepth,
        locale,
        fallbackLocale,
        overrideAccess,
        showHiddenFields,
        draft,
        select,
        populate,
      ] = JSON.parse(batchKey)

      req.transactionID = transactionID

      const result = await payload.find({
        collection,
        currentDepth,
        depth,
        disableErrors: true,
        draft,
        fallbackLocale,
        locale,
        overrideAccess: Boolean(overrideAccess),
        pagination: false,
        populate,
        req,
        select,
        showHiddenFields: Boolean(showHiddenFields),
        where: {
          id: {
            in: ids,
          },
        },
      })

      // For each returned doc, find index in original keys
      // Inject doc within docs array if index exists
      for (const doc of result.docs) {
        const docKey = createDataloaderCacheKey({
          collectionSlug: collection,
          currentDepth,
          depth,
          docID: doc.id,
          draft,
          fallbackLocale,
          locale,
          overrideAccess,
          populate,
          select,
          showHiddenFields,
          transactionID: req.transactionID,
        })
        const docsIndex = keys.findIndex((key) => key === docKey)

        if (docsIndex > -1) {
          docs[docsIndex] = doc
        }
      }
    }

    // Return docs array,
    // which has now been injected with all fetched docs
    // and should match the length of the incoming keys arg
    return docs
  }

export const getDataLoader = (req: PayloadRequest) => {
  const findQueries = new Map()
  const dataLoader = new DataLoader(batchAndLoadDocs(req)) as PayloadRequest['payloadDataLoader']

  dataLoader.find = (args: FindArgs) => {
    const key = createFindDataloaderCacheKey(args)
    const cached = findQueries.get(key)
    if (cached) {
      return cached
    }
    const request = req.payload.find(args)
    findQueries.set(key, request)
    return request
  }

  return dataLoader
}

const createFindDataloaderCacheKey = ({
  collection,
  currentDepth,
  depth,
  disableErrors,
  draft,
  includeLockStatus,
  joins,
  limit,
  overrideAccess,
  page,
  pagination,
  populate,
  req,
  select,
  showHiddenFields,
  sort,
  where,
}: Options<string, SelectType>): string =>
  JSON.stringify([
    collection,
    currentDepth,
    depth,
    disableErrors,
    draft,
    includeLockStatus,
    joins,
    limit,
    overrideAccess,
    page,
    pagination,
    populate,
    req?.locale,
    req?.fallbackLocale,
    req?.user?.id,
    req?.transactionID,
    select,
    showHiddenFields,
    sort,
    where,
  ])

type CreateCacheKeyArgs = {
  collectionSlug: string
  currentDepth: number
  depth: number
  docID: number | string
  draft: boolean
  fallbackLocale: string
  locale: string
  overrideAccess: boolean
  populate?: PopulateType
  select?: SelectType
  showHiddenFields: boolean
  transactionID: number | Promise<number | string> | string
}
export const createDataloaderCacheKey = ({
  collectionSlug,
  currentDepth,
  depth,
  docID,
  draft,
  fallbackLocale,
  locale,
  overrideAccess,
  populate,
  select,
  showHiddenFields,
  transactionID,
}: CreateCacheKeyArgs): string =>
  JSON.stringify([
    transactionID,
    collectionSlug,
    docID,
    depth,
    currentDepth,
    locale,
    fallbackLocale,
    overrideAccess,
    showHiddenFields,
    draft,
    select,
    populate,
  ])
</file>

<file path="packages/payload/src/config/orderable/fractional-indexing.js">
// @ts-check

/**
 * THIS FILE IS COPIED FROM:
 * https://github.com/rocicorp/fractional-indexing/blob/main/src/index.js
 *
 * I AM NOT INSTALLING THAT LIBRARY BECAUSE JEST COMPLAINS ABOUT THE ESM MODULE AND THE TESTS FAIL.
 * DO NOT MODIFY IT
 */

// License: CC0 (no rights reserved).

// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing

export const BASE_62_DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

// `a` may be empty string, `b` is null or non-empty string.
// `a < b` lexicographically if `b` is non-null.
// no trailing zeros allowed.
// digits is a string such as '0123456789' for base 10.  Digits must be in
// ascending character code order!
/**
 * @param {string} a
 * @param {string | null | undefined} b
 * @param {string} digits
 * @returns {string}
 */
function midpoint(a, b, digits) {
  const zero = digits[0]
  if (b != null && a >= b) {
    throw new Error(a + ' >= ' + b)
  }
  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {
    throw new Error('trailing zero')
  }
  if (b) {
    // remove longest common prefix.  pad `a` with 0s as we
    // go.  note that we don't need to pad `b`, because it can't
    // end before `a` while traversing the common prefix.
    let n = 0
    while ((a[n] || zero) === b[n]) {
      n++
    }
    if (n > 0) {
      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits)
    }
  }
  // first digits (or lack of digit) are different
  const digitA = a ? digits.indexOf(a[0]) : 0
  const digitB = b != null ? digits.indexOf(b[0]) : digits.length
  if (digitB - digitA > 1) {
    const midDigit = Math.round(0.5 * (digitA + digitB))
    return digits[midDigit]
  } else {
    // first digits are consecutive
    if (b && b.length > 1) {
      return b.slice(0, 1)
    } else {
      // `b` is null or has length 1 (a single digit).
      // the first digit of `a` is the previous digit to `b`,
      // or 9 if `b` is null.
      // given, for example, midpoint('49', '5'), return
      // '4' + midpoint('9', null), which will become
      // '4' + '9' + midpoint('', null), which is '495'
      return digits[digitA] + midpoint(a.slice(1), null, digits)
    }
  }
}

/**
 * @param {string} int
 * @return {void}
 */

function validateInteger(int) {
  if (int.length !== getIntegerLength(int[0])) {
    throw new Error('invalid integer part of order key: ' + int)
  }
}

/**
 * @param {string} head
 * @return {number}
 */

function getIntegerLength(head) {
  if (head >= 'a' && head <= 'z') {
    return head.charCodeAt(0) - 'a'.charCodeAt(0) + 2
  } else if (head >= 'A' && head <= 'Z') {
    return 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2
  } else {
    throw new Error('invalid order key head: ' + head)
  }
}

/**
 * @param {string} key
 * @return {string}
 */

function getIntegerPart(key) {
  const integerPartLength = getIntegerLength(key[0])
  if (integerPartLength > key.length) {
    throw new Error('invalid order key: ' + key)
  }
  return key.slice(0, integerPartLength)
}

/**
 * @param {string} key
 * @param {string} digits
 * @return {void}
 */

function validateOrderKey(key, digits) {
  if (key === 'A' + digits[0].repeat(26)) {
    throw new Error('invalid order key: ' + key)
  }
  // getIntegerPart will throw if the first character is bad,
  // or the key is too short.  we'd call it to check these things
  // even if we didn't need the result
  const i = getIntegerPart(key)
  const f = key.slice(i.length)
  if (f.slice(-1) === digits[0]) {
    throw new Error('invalid order key: ' + key)
  }
}

// note that this may return null, as there is a largest integer
/**
 * @param {string} x
 * @param {string} digits
 * @return {string | null}
 */
function incrementInteger(x, digits) {
  validateInteger(x)
  const [head, ...digs] = x.split('')
  let carry = true
  for (let i = digs.length - 1; carry && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) + 1
    if (d === digits.length) {
      digs[i] = digits[0]
    } else {
      digs[i] = digits[d]
      carry = false
    }
  }
  if (carry) {
    if (head === 'Z') {
      return 'a' + digits[0]
    }
    if (head === 'z') {
      return null
    }
    const h = String.fromCharCode(head.charCodeAt(0) + 1)
    if (h > 'a') {
      digs.push(digits[0])
    } else {
      digs.pop()
    }
    return h + digs.join('')
  } else {
    return head + digs.join('')
  }
}

// note that this may return null, as there is a smallest integer
/**
 * @param {string} x
 * @param {string} digits
 * @return {string | null}
 */

function decrementInteger(x, digits) {
  validateInteger(x)
  const [head, ...digs] = x.split('')
  let borrow = true
  for (let i = digs.length - 1; borrow && i >= 0; i--) {
    const d = digits.indexOf(digs[i]) - 1
    if (d === -1) {
      digs[i] = digits.slice(-1)
    } else {
      digs[i] = digits[d]
      borrow = false
    }
  }
  if (borrow) {
    if (head === 'a') {
      return 'Z' + digits.slice(-1)
    }
    if (head === 'A') {
      return null
    }
    const h = String.fromCharCode(head.charCodeAt(0) - 1)
    if (h < 'Z') {
      digs.push(digits.slice(-1))
    } else {
      digs.pop()
    }
    return h + digs.join('')
  } else {
    return head + digs.join('')
  }
}

// `a` is an order key or null (START).
// `b` is an order key or null (END).
// `a < b` lexicographically if both are non-null.
// digits is a string such as '0123456789' for base 10.  Digits must be in
// ascending character code order!
/**
 * @param {string | null | undefined} a
 * @param {string | null | undefined} b
 * @param {string=} digits
 * @return {string}
 */
export function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {
  if (a != null) {
    validateOrderKey(a, digits)
  }
  if (b != null) {
    validateOrderKey(b, digits)
  }
  if (a != null && b != null && a >= b) {
    throw new Error(a + ' >= ' + b)
  }
  if (a == null) {
    if (b == null) {
      return 'a' + digits[0]
    }

    const ib = getIntegerPart(b)
    const fb = b.slice(ib.length)
    if (ib === 'A' + digits[0].repeat(26)) {
      return ib + midpoint('', fb, digits)
    }
    if (ib < b) {
      return ib
    }
    const res = decrementInteger(ib, digits)
    if (res == null) {
      throw new Error('cannot decrement any more')
    }
    return res
  }

  if (b == null) {
    const ia = getIntegerPart(a)
    const fa = a.slice(ia.length)
    const i = incrementInteger(ia, digits)
    return i == null ? ia + midpoint(fa, null, digits) : i
  }

  const ia = getIntegerPart(a)
  const fa = a.slice(ia.length)
  const ib = getIntegerPart(b)
  const fb = b.slice(ib.length)
  if (ia === ib) {
    return ia + midpoint(fa, fb, digits)
  }
  const i = incrementInteger(ia, digits)
  if (i == null) {
    throw new Error('cannot increment any more')
  }
  if (i < b) {
    return i
  }
  return ia + midpoint(fa, null, digits)
}

/**
 * same preconditions as generateKeysBetween.
 * n >= 0.
 * Returns an array of n distinct keys in sorted order.
 * If a and b are both null, returns [a0, a1, ...]
 * If one or the other is null, returns consecutive "integer"
 * keys.  Otherwise, returns relatively short keys between
 * a and b.
 * @param {string | null | undefined} a
 * @param {string | null | undefined} b
 * @param {number} n
 * @param {string} digits
 * @return {string[]}
 */
export function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {
  if (n === 0) {
    return []
  }
  if (n === 1) {
    return [generateKeyBetween(a, b, digits)]
  }
  if (b == null) {
    let c = generateKeyBetween(a, b, digits)
    const result = [c]
    for (let i = 0; i < n - 1; i++) {
      c = generateKeyBetween(c, b, digits)
      result.push(c)
    }
    return result
  }
  if (a == null) {
    let c = generateKeyBetween(a, b, digits)
    const result = [c]
    for (let i = 0; i < n - 1; i++) {
      c = generateKeyBetween(a, c, digits)
      result.push(c)
    }
    result.reverse()
    return result
  }
  const mid = Math.floor(n / 2)
  const c = generateKeyBetween(a, b, digits)
  return [
    ...generateNKeysBetween(a, c, mid, digits),
    c,
    ...generateNKeysBetween(c, b, n - mid - 1, digits),
  ]
}
</file>

<file path="packages/payload/src/config/orderable/index.ts">
import type { BeforeChangeHook, CollectionConfig } from '../../collections/config/types.js'
import type { Field } from '../../fields/config/types.js'
import type { Endpoint, PayloadHandler, SanitizedConfig } from '../types.js'

import executeAccess from '../../auth/executeAccess.js'
import { traverseFields } from '../../utilities/traverseFields.js'
import { generateKeyBetween, generateNKeysBetween } from './fractional-indexing.js'

/**
 * This function creates:
 * - N fields per collection, named `_order` or `_<collection>_<joinField>_order`
 * - 1 hook per collection
 * - 1 endpoint per app
 *
 * Also, if collection.defaultSort or joinField.defaultSort is not set, it will be set to the orderable field.
 */
export const setupOrderable = (config: SanitizedConfig) => {
  const fieldsToAdd = new Map<CollectionConfig, string[]>()

  config.collections.forEach((collection) => {
    if (collection.orderable) {
      const currentFields = fieldsToAdd.get(collection) || []
      fieldsToAdd.set(collection, [...currentFields, '_order'])
      collection.defaultSort = collection.defaultSort ?? '_order'
    }

    traverseFields({
      callback: ({ field, parentRef, ref }) => {
        if (field.type === 'array' || field.type === 'blocks') {
          return false
        }
        if (field.type === 'group' || field.type === 'tab') {
          // @ts-expect-error ref is untyped
          const parentPrefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''
          // @ts-expect-error ref is untyped
          ref.prefix = `${parentPrefix}${field.name}`
        }
        if (field.type === 'join' && field.orderable === true) {
          if (Array.isArray(field.collection)) {
            throw new Error('Orderable joins must target a single collection')
          }
          const relationshipCollection = config.collections.find((c) => c.slug === field.collection)
          if (!relationshipCollection) {
            return false
          }
          field.defaultSort = field.defaultSort ?? `_${field.collection}_${field.name}_order`
          const currentFields = fieldsToAdd.get(relationshipCollection) || []
          // @ts-expect-error ref is untyped
          const prefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''
          fieldsToAdd.set(relationshipCollection, [
            ...currentFields,
            `_${field.collection}_${prefix}${field.name}_order`,
          ])
        }
      },
      fields: collection.fields,
    })
  })

  Array.from(fieldsToAdd.entries()).forEach(([collection, orderableFields]) => {
    addOrderableFieldsAndHook(collection, orderableFields)
  })

  if (fieldsToAdd.size > 0) {
    addOrderableEndpoint(config)
  }
}

export const addOrderableFieldsAndHook = (
  collection: CollectionConfig,
  orderableFieldNames: string[],
) => {
  // 1. Add field
  orderableFieldNames.forEach((orderableFieldName) => {
    const orderField: Field = {
      name: orderableFieldName,
      type: 'text',
      admin: {
        disableBulkEdit: true,
        disabled: true,
        disableListColumn: true,
        disableListFilter: true,
        hidden: true,
        readOnly: true,
      },
      index: true,
      required: true,
      // override the schema to make order fields optional for payload.create()
      typescriptSchema: [
        () => ({
          type: 'string',
          required: false,
        }),
      ],
      unique: true,
    }

    collection.fields.unshift(orderField)
  })

  // 2. Add hook
  if (!collection.hooks) {
    collection.hooks = {}
  }
  if (!collection.hooks.beforeChange) {
    collection.hooks.beforeChange = []
  }

  const orderBeforeChangeHook: BeforeChangeHook = async ({ data, originalDoc, req }) => {
    for (const orderableFieldName of orderableFieldNames) {
      if (!data[orderableFieldName] && !originalDoc?.[orderableFieldName]) {
        const lastDoc = await req.payload.find({
          collection: collection.slug,
          depth: 0,
          limit: 1,
          pagination: false,
          req,
          select: { [orderableFieldName]: true },
          sort: `-${orderableFieldName}`,
          where: {
            [orderableFieldName]: {
              exists: true,
            },
          },
        })

        const lastOrderValue = lastDoc.docs[0]?.[orderableFieldName] || null
        data[orderableFieldName] = generateKeyBetween(lastOrderValue, null)
      }
    }

    return data
  }

  collection.hooks.beforeChange.push(orderBeforeChangeHook)
}

/**
 * The body of the reorder endpoint.
 * @internal
 */
export type OrderableEndpointBody = {
  collectionSlug: string
  docsToMove: string[]
  newKeyWillBe: 'greater' | 'less'
  orderableFieldName: string
  target: {
    id: string
    key: string
  }
}

export const addOrderableEndpoint = (config: SanitizedConfig) => {
  // 3. Add endpoint
  const reorderHandler: PayloadHandler = async (req) => {
    const body = (await req.json?.()) as OrderableEndpointBody

    const { collectionSlug, docsToMove, newKeyWillBe, orderableFieldName, target } = body

    if (!Array.isArray(docsToMove) || docsToMove.length === 0) {
      return new Response(JSON.stringify({ error: 'docsToMove must be a non-empty array' }), {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
      })
    }
    if (
      typeof target !== 'object' ||
      typeof target.id === 'undefined' ||
      typeof target.key !== 'string'
    ) {
      return new Response(JSON.stringify({ error: 'target must be an object with id and key' }), {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
      })
    }
    if (newKeyWillBe !== 'greater' && newKeyWillBe !== 'less') {
      return new Response(JSON.stringify({ error: 'newKeyWillBe must be "greater" or "less"' }), {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
      })
    }
    const collection = config.collections.find((c) => c.slug === collectionSlug)
    if (!collection) {
      return new Response(JSON.stringify({ error: `Collection ${collectionSlug} not found` }), {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
      })
    }
    if (typeof orderableFieldName !== 'string') {
      return new Response(JSON.stringify({ error: 'orderableFieldName must be a string' }), {
        headers: { 'Content-Type': 'application/json' },
        status: 400,
      })
    }

    // Prevent reordering if user doesn't have editing permissions
    if (collection.access?.update) {
      await executeAccess(
        {
          // Currently only one doc can be moved at a time. We should review this if we want to allow
          // multiple docs to be moved at once in the future.
          id: docsToMove[0],
          data: {},
          req,
        },
        collection.access.update,
      )
    }

    const targetId = target.id
    let targetKey = target.key

    // If targetKey = pending, we need to find its current key.
    // This can only happen if the user reorders rows quickly with a slow connection.
    if (targetKey === 'pending') {
      const beforeDoc = await req.payload.findByID({
        id: targetId,
        collection: collection.slug,
        depth: 0,
        select: { [orderableFieldName]: true },
      })
      targetKey = beforeDoc?.[orderableFieldName] || null
    }

    // The reason the endpoint does not receive this docId as an argument is that there
    // are situations where the user may not see or know what the next or previous one is. For
    // example, access control restrictions, if docBefore is the last one on the page, etc.
    const adjacentDoc = await req.payload.find({
      collection: collection.slug,
      depth: 0,
      limit: 1,
      pagination: false,
      select: { [orderableFieldName]: true },
      sort: newKeyWillBe === 'greater' ? orderableFieldName : `-${orderableFieldName}`,
      where: {
        [orderableFieldName]: {
          [newKeyWillBe === 'greater' ? 'greater_than' : 'less_than']: targetKey,
        },
      },
    })
    const adjacentDocKey = adjacentDoc.docs?.[0]?.[orderableFieldName] || null

    // Currently N (= docsToMove.length) is always 1. Maybe in the future we will
    // allow dragging and reordering multiple documents at once via the UI.
    const orderValues =
      newKeyWillBe === 'greater'
        ? generateNKeysBetween(targetKey, adjacentDocKey, docsToMove.length)
        : generateNKeysBetween(adjacentDocKey, targetKey, docsToMove.length)

    // Update each document with its new order value
    for (const [index, id] of docsToMove.entries()) {
      await req.payload.update({
        id,
        collection: collection.slug,
        data: {
          [orderableFieldName]: orderValues[index],
        },
        depth: 0,
        req,
        select: { id: true },
      })
    }

    return new Response(JSON.stringify({ orderValues, success: true }), {
      headers: { 'Content-Type': 'application/json' },
      status: 200,
    })
  }

  const reorderEndpoint: Endpoint = {
    handler: reorderHandler,
    method: 'post',
    path: '/reorder',
  }

  if (!config.endpoints) {
    config.endpoints = []
  }
  config.endpoints.push(reorderEndpoint)
}
</file>

<file path="packages/payload/src/config/build.ts">
import type { Config, SanitizedConfig } from './types.js'

import { sanitizeConfig } from './sanitize.js'

/**
 * @description Builds and validates Payload configuration
 * @param config Payload Config
 * @returns Built and sanitized Payload Config
 */
export async function buildConfig(config: Config): Promise<SanitizedConfig> {
  if (Array.isArray(config.plugins)) {
    let configAfterPlugins = config
    for (const plugin of config.plugins) {
      configAfterPlugins = await plugin(configAfterPlugins)
    }
    return await sanitizeConfig(configAfterPlugins)
  }

  return await sanitizeConfig(config)
}
</file>

<file path="packages/payload/src/config/client.ts">
// @ts-strict-ignore
import type { I18nClient } from '@convexcms/translations'
import type { DeepPartial } from 'ts-essentials'

import type { ImportMap } from '../bin/generateImportMap/index.js'
import type { ClientBlock } from '../fields/config/types.js'
import type { BlockSlug } from '../index.js'
import type {
  LivePreviewConfig,
  SanitizedConfig,
  ServerOnlyLivePreviewProperties,
} from './types.js'

import {
  type ClientCollectionConfig,
  createClientCollectionConfigs,
} from '../collections/config/client.js'
import { createClientBlocks } from '../fields/config/client.js'
import { type ClientGlobalConfig, createClientGlobalConfigs } from '../globals/config/client.js'

export type ServerOnlyRootProperties = keyof Pick<
  SanitizedConfig,
  | 'bin'
  | 'cors'
  | 'csrf'
  | 'custom'
  | 'db'
  | 'editor'
  | 'email'
  | 'endpoints'
  | 'graphQL'
  | 'hooks'
  | 'i18n'
  | 'jobs'
  | 'logger'
  | 'onInit'
  | 'plugins'
  | 'queryPresets'
  | 'secret'
  | 'sharp'
  | 'typescript'
>

export type ServerOnlyRootAdminProperties = keyof Pick<SanitizedConfig['admin'], 'components'>

export type UnsanitizedClientConfig = {
  admin: {
    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>
  } & Omit<SanitizedConfig['admin'], 'components' | 'dependencies' | 'livePreview'>
  blocks: ClientBlock[]
  collections: ClientCollectionConfig[]
  custom?: Record<string, any>
  globals: ClientGlobalConfig[]
} & Omit<SanitizedConfig, 'admin' | 'collections' | 'globals' | 'i18n' | ServerOnlyRootProperties>

export type ClientConfig = {
  admin: {
    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>
  } & Omit<SanitizedConfig['admin'], 'components' | 'dependencies' | 'livePreview'>
  blocks: ClientBlock[]
  blocksMap: Record<BlockSlug, ClientBlock>
  collections: ClientCollectionConfig[]
  custom?: Record<string, any>
  globals: ClientGlobalConfig[]
} & Omit<SanitizedConfig, 'admin' | 'collections' | 'globals' | 'i18n' | ServerOnlyRootProperties>

export const serverOnlyAdminConfigProperties: readonly Partial<ServerOnlyRootAdminProperties>[] = []

export const serverOnlyConfigProperties: readonly Partial<ServerOnlyRootProperties>[] = [
  'endpoints',
  'db',
  'editor',
  'plugins',
  'sharp',
  'onInit',
  'secret',
  'hooks',
  'bin',
  'i18n',
  'typescript',
  'cors',
  'csrf',
  'email',
  'custom',
  'graphQL',
  'jobs',
  'logger',
  'queryPresets',
  // `admin`, `onInit`, `localization`, `collections`, and `globals` are all handled separately
]

export const createClientConfig = ({
  config,
  i18n,
  importMap,
}: {
  config: SanitizedConfig
  i18n: I18nClient
  importMap: ImportMap
}): ClientConfig => {
  const clientConfig = {} as DeepPartial<ClientConfig>

  for (const key in config) {
    if (serverOnlyConfigProperties.includes(key as any)) {
      continue
    }
    switch (key) {
      case 'admin':
        clientConfig.admin = {
          autoLogin: config.admin.autoLogin,
          avatar: config.admin.avatar,
          custom: config.admin.custom,
          dateFormat: config.admin.dateFormat,
          importMap: config.admin.importMap,
          meta: config.admin.meta,
          routes: config.admin.routes,
          theme: config.admin.theme,
          timezones: config.admin.timezones,
          user: config.admin.user,
        }
        if (config.admin.livePreview) {
          clientConfig.admin.livePreview = {}

          if (config.admin.livePreview.breakpoints) {
            clientConfig.admin.livePreview.breakpoints = config.admin.livePreview.breakpoints
          }
        }
        break
      case 'blocks': {
        ;(clientConfig.blocks as ClientBlock[]) = createClientBlocks({
          blocks: config.blocks,
          defaultIDType: config.db.defaultIDType,
          i18n,
          importMap,
        }).filter((block) => typeof block !== 'string') as ClientBlock[]

        break
      }
      case 'collections':
        ;(clientConfig.collections as ClientCollectionConfig[]) = createClientCollectionConfigs({
          collections: config.collections,
          defaultIDType: config.db.defaultIDType,
          i18n,
          importMap,
        })
        break
      case 'globals':
        ;(clientConfig.globals as ClientGlobalConfig[]) = createClientGlobalConfigs({
          defaultIDType: config.db.defaultIDType,
          globals: config.globals,
          i18n,
          importMap,
        })
        break

      case 'localization':
        if (typeof config.localization === 'object' && config.localization) {
          clientConfig.localization = {}
          if (config.localization.defaultLocale) {
            clientConfig.localization.defaultLocale = config.localization.defaultLocale
          }
          if (config.localization.defaultLocalePublishOption) {
            clientConfig.localization.defaultLocalePublishOption =
              config.localization.defaultLocalePublishOption
          }
          if (config.localization.fallback) {
            clientConfig.localization.fallback = config.localization.fallback
          }
          if (config.localization.localeCodes) {
            clientConfig.localization.localeCodes = config.localization.localeCodes
          }
          if (config.localization.locales) {
            clientConfig.localization.locales = []
            for (const locale of config.localization.locales) {
              if (locale) {
                const clientLocale: Partial<(typeof config.localization.locales)[0]> = {}
                if (locale.code) {
                  clientLocale.code = locale.code
                }
                if (locale.fallbackLocale) {
                  clientLocale.fallbackLocale = locale.fallbackLocale
                }
                if (locale.label) {
                  clientLocale.label = locale.label
                }
                if (locale.rtl) {
                  clientLocale.rtl = locale.rtl
                }
                clientConfig.localization.locales.push(clientLocale)
              }
            }
          }
        }
        break
      default:
        clientConfig[key] = config[key]
    }
  }
  return clientConfig as ClientConfig
}
</file>

<file path="packages/payload/src/config/defaults.ts">
import type { JobsConfig } from '../queues/config/types/index.js'
import type { Config } from './types.js'

import defaultAccess from '../auth/defaultAccess.js'

/**
 * @deprecated - remove in 4.0. This is error-prone, as mutating this object will affect any objects that use the defaults as a base.
 */
export const defaults: Omit<Config, 'db' | 'editor' | 'secret'> = {
  admin: {
    avatar: 'gravatar',
    components: {},
    custom: {},
    dateFormat: 'MMMM do yyyy, h:mm a',
    dependencies: {},
    importMap: {
      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,
    },
    meta: {
      defaultOGImageType: 'dynamic',
      robots: 'noindex, nofollow',
      titleSuffix: '- Payload',
    },
    routes: {
      account: '/account',
      createFirstUser: '/create-first-user',
      forgot: '/forgot',
      inactivity: '/logout-inactivity',
      login: '/login',
      logout: '/logout',
      reset: '/reset',
      unauthorized: '/unauthorized',
    },
    theme: 'all',
  },
  auth: {
    jwtOrder: ['JWT', 'Bearer', 'cookie'],
  },
  bin: [],
  collections: [],
  cookiePrefix: 'payload',
  cors: [],
  csrf: [],
  custom: {},
  defaultDepth: 2,
  defaultMaxTextLength: 40000,
  endpoints: [],
  globals: [],
  graphQL: {
    disablePlaygroundInProduction: true,
    maxComplexity: 1000,
    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,
  },
  hooks: {},
  i18n: {},
  jobs: {
    access: {
      run: defaultAccess,
    },
    deleteJobOnComplete: true,
    depth: 0,
  } as JobsConfig,
  localization: false,
  maxDepth: 10,
  routes: {
    admin: '/admin',
    api: '/api',
    graphQL: '/graphql',
    graphQLPlayground: '/graphql-playground',
  },
  serverURL: '',
  telemetry: true,
  typescript: {
    autoGenerate: true,
    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,
  },
  upload: {},
}

export const addDefaultsToConfig = (config: Config): Config => {
  config.admin = {
    avatar: 'gravatar',
    components: {},
    custom: {},
    dateFormat: 'MMMM do yyyy, h:mm a',
    dependencies: {},
    theme: 'all',
    ...(config.admin || {}),
    importMap: {
      baseDir: `${typeof process?.cwd === 'function' ? process.cwd() : ''}`,
      ...(config?.admin?.importMap || {}),
    },
    meta: {
      defaultOGImageType: 'dynamic',
      robots: 'noindex, nofollow',
      titleSuffix: '- Payload',
      ...(config?.admin?.meta || {}),
    },
    routes: {
      account: '/account',
      createFirstUser: '/create-first-user',
      forgot: '/forgot',
      inactivity: '/logout-inactivity',
      login: '/login',
      logout: '/logout',
      reset: '/reset',
      unauthorized: '/unauthorized',
      ...(config?.admin?.routes || {}),
    },
  }

  config.bin = config.bin ?? []
  config.collections = config.collections ?? []
  config.cookiePrefix = config.cookiePrefix ?? 'payload'
  config.cors = config.cors ?? []
  config.csrf = config.csrf ?? []
  config.custom = config.custom ?? {}
  config.defaultDepth = config.defaultDepth ?? 2
  config.defaultMaxTextLength = config.defaultMaxTextLength ?? 40000
  config.endpoints = config.endpoints ?? []
  config.globals = config.globals ?? []
  config.graphQL = {
    disablePlaygroundInProduction: true,
    maxComplexity: 1000,
    schemaOutputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/schema.graphql`,
    ...(config.graphQL || {}),
  }
  config.hooks = config.hooks ?? {}
  config.i18n = config.i18n ?? {}
  config.jobs = {
    deleteJobOnComplete: true,
    depth: 0,
    ...(config.jobs || {}),
    access: {
      run: defaultAccess,
      ...(config.jobs?.access || {}),
    },
  } as JobsConfig
  config.localization = config.localization ?? false
  config.maxDepth = config.maxDepth ?? 10
  config.routes = {
    admin: '/admin',
    api: (process.env.NEXT_BASE_PATH ?? '') + '/api',
    graphQL: '/graphql',
    graphQLPlayground: '/graphql-playground',
    ...(config.routes || {}),
  }
  config.serverURL = config.serverURL ?? ''
  config.telemetry = config.telemetry ?? true
  config.typescript = {
    autoGenerate: true,
    outputFile: `${typeof process?.cwd === 'function' ? process.cwd() : ''}/payload-types.ts`,
    ...(config.typescript || {}),
  }
  config.upload = config.upload ?? {}

  config.auth = {
    jwtOrder: ['JWT', 'Bearer', 'cookie'],
    ...(config.auth || {}),
  }

  return config
}
</file>

<file path="packages/payload/src/config/find.ts">
// @ts-strict-ignore
import { getTsconfig } from 'get-tsconfig'
import path from 'path'

import { findUpSync } from '../utilities/findUp.js'

/**
 * List of all filenames to detect as a Payload configuration file.
 */
export const payloadConfigFileNames = ['payload.config.js', 'payload.config.ts']

/**
 * Returns the source and output paths from the nearest tsconfig.json file.
 * If no tsconfig.json file is found, returns the current working directory.
 * @returns An object containing the source and output paths.
 */
const getTSConfigPaths = (): {
  configPath?: string
  outPath?: string
  rootPath?: string
  srcPath?: string
  tsConfigPath?: string
} => {
  const tsConfigResult = getTsconfig()
  const tsConfig = tsConfigResult.config
  const tsConfigDir = path.dirname(tsConfigResult.path)

  try {
    const rootConfigDir = path.resolve(tsConfigDir, tsConfig.compilerOptions.baseUrl || '')
    const srcPath = tsConfig.compilerOptions?.rootDir || path.resolve(process.cwd(), 'src')
    const outPath = tsConfig.compilerOptions?.outDir || path.resolve(process.cwd(), 'dist')
    let configPath = tsConfig.compilerOptions?.paths?.['@payload-config']?.[0]

    if (configPath) {
      configPath = path.resolve(rootConfigDir, configPath)
    }
    return {
      configPath,
      outPath,
      rootPath: rootConfigDir,
      srcPath,
      tsConfigPath: tsConfigResult.path,
    }
  } catch (error) {
    console.error(`Error parsing tsconfig.json: ${error}`) // Do not throw the error, as we can still continue with the other config path finding methods
    return {
      rootPath: process.cwd(),
    }
  }
}

/**
 * Searches for a Payload configuration file.
 * @returns The absolute path to the Payload configuration file.
 * @throws An error if no configuration file is found.
 */
export const findConfig = (): string => {
  // If the developer has specified a config path,
  // format it if relative and use it directly if absolute
  if (process.env.PAYLOAD_CONFIG_PATH) {
    if (path.isAbsolute(process.env.PAYLOAD_CONFIG_PATH)) {
      return process.env.PAYLOAD_CONFIG_PATH
    }

    return path.resolve(process.cwd(), process.env.PAYLOAD_CONFIG_PATH)
  }

  const { configPath, outPath, rootPath, srcPath } = getTSConfigPaths()

  // if configPath is absolute file, not folder, return it
  if (configPath && (path.extname(configPath) === '.js' || path.extname(configPath) === '.ts')) {
    return configPath
  }

  const searchPaths =
    process.env.NODE_ENV === 'production'
      ? [configPath, outPath, srcPath, rootPath]
      : [configPath, srcPath, rootPath]

  for (const searchPath of searchPaths) {
    if (!searchPath) {
      continue
    }

    const configPath = findUpSync({
      dir: searchPath,
      fileNames: payloadConfigFileNames,
    })

    if (configPath) {
      return configPath
    }
  }

  // If no config file is found in the directories defined by tsconfig.json,
  // try searching in the 'src' and 'dist' directory as a last resort, as they are most commonly used
  if (process.env.NODE_ENV === 'production') {
    const distConfigPath = findUpSync({
      dir: path.resolve(process.cwd(), 'dist'),
      fileNames: ['payload.config.js'],
    })

    if (distConfigPath) {
      return distConfigPath
    }
  } else {
    const srcConfigPath = findUpSync({
      dir: path.resolve(process.cwd(), 'src'),
      fileNames: payloadConfigFileNames,
    })

    if (srcConfigPath) {
      return srcConfigPath
    }
  }

  throw new Error(
    'Error: cannot find Payload config. Please create a configuration file located at the root of your current working directory called "payload.config.js" or "payload.config.ts".',
  )
}
</file>

<file path="packages/payload/src/config/sanitize.ts">
// @ts-strict-ignore
import type { AcceptedLanguages } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { deepMergeSimple } from '@convexcms/translations/utilities'

import type {
  Config,
  LocalizationConfigWithLabels,
  LocalizationConfigWithNoLabels,
  SanitizedConfig,
  Timezone,
} from './types.js'

import { defaultUserCollection } from '../auth/defaultUser.js'
import { authRootEndpoints } from '../auth/endpoints/index.js'
import { sanitizeCollection } from '../collections/config/sanitize.js'
import { migrationsCollection } from '../database/migrations/migrationsCollection.js'
import { DuplicateCollection, InvalidConfiguration } from '../errors/index.js'
import { defaultTimezones } from '../fields/baseFields/timezone/defaultTimezones.js'
import { sanitizeGlobal } from '../globals/config/sanitize.js'
import {
  baseBlockFields,
  type CollectionSlug,
  formatLabels,
  type GlobalSlug,
  sanitizeFields,
} from '../index.js'
import {
  getLockedDocumentsCollection,
  lockedDocumentsCollectionSlug,
} from '../locked-documents/config.js'
import { getPreferencesCollection, preferencesCollectionSlug } from '../preferences/config.js'
import { getQueryPresetsConfig, queryPresetsCollectionSlug } from '../query-presets/config.js'
import { getDefaultJobsCollection, jobsCollectionSlug } from '../queues/config/index.js'
import { flattenBlock } from '../utilities/flattenAllFields.js'
import { getSchedulePublishTask } from '../versions/schedule/job.js'
import { addDefaultsToConfig } from './defaults.js'
import { setupOrderable } from './orderable/index.js'

const sanitizeAdminConfig = (configToSanitize: Config): Partial<SanitizedConfig> => {
  const sanitizedConfig = { ...configToSanitize }

  if (configToSanitize?.compatibility?.allowLocalizedWithinLocalized) {
    process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized = 'true'
  }

  // default logging level will be 'error' if not provided
  sanitizedConfig.loggingLevels = {
    Forbidden: 'info',
    Locked: 'info',
    MissingFile: 'info',
    NotFound: 'info',
    ValidationError: 'info',
    ...(sanitizedConfig.loggingLevels || {}),
  }

  // add default user collection if none provided
  if (!sanitizedConfig?.admin?.user) {
    const firstCollectionWithAuth = sanitizedConfig.collections.find(({ auth }) => Boolean(auth))
    if (firstCollectionWithAuth) {
      sanitizedConfig.admin.user = firstCollectionWithAuth.slug
    } else {
      sanitizedConfig.admin.user = defaultUserCollection.slug
      sanitizedConfig.collections.push(defaultUserCollection)
    }
  }

  const userCollection = sanitizedConfig.collections.find(
    ({ slug }) => slug === sanitizedConfig.admin.user,
  )
  if (!userCollection || !userCollection.auth) {
    throw new InvalidConfiguration(
      `${sanitizedConfig.admin.user} is not a valid admin user collection`,
    )
  }

  if (sanitizedConfig?.admin?.timezones) {
    if (typeof sanitizedConfig?.admin?.timezones?.supportedTimezones === 'function') {
      sanitizedConfig.admin.timezones.supportedTimezones =
        sanitizedConfig.admin.timezones.supportedTimezones({ defaultTimezones })
    }

    if (!sanitizedConfig?.admin?.timezones?.supportedTimezones) {
      sanitizedConfig.admin.timezones.supportedTimezones = defaultTimezones
    }
  } else {
    sanitizedConfig.admin.timezones = {
      supportedTimezones: defaultTimezones,
    }
  }
  // Timezones supported by the Intl API
  const _internalSupportedTimezones = Intl.supportedValuesOf('timeZone')

  // We're casting here because it's already been sanitised above but TS still thinks it could be a function
  ;(sanitizedConfig.admin.timezones.supportedTimezones as Timezone[]).forEach((timezone) => {
    if (!_internalSupportedTimezones.includes(timezone.value)) {
      throw new InvalidConfiguration(
        `Timezone ${timezone.value} is not supported by the current runtime via the Intl API.`,
      )
    }
  })

  return sanitizedConfig as unknown as Partial<SanitizedConfig>
}

export const sanitizeConfig = async (incomingConfig: Config): Promise<SanitizedConfig> => {
  const configWithDefaults = addDefaultsToConfig(incomingConfig)

  const config: Partial<SanitizedConfig> = sanitizeAdminConfig(configWithDefaults)

  // Add orderable fields
  setupOrderable(config as SanitizedConfig)

  if (!config.endpoints) {
    config.endpoints = []
  }

  for (const endpoint of authRootEndpoints) {
    config.endpoints.push(endpoint)
  }

  if (config.localization && config.localization.locales?.length > 0) {
    // clone localization config so to not break everything
    const firstLocale = config.localization.locales[0]
    if (typeof firstLocale === 'string') {
      config.localization.localeCodes = [
        ...(config.localization as unknown as LocalizationConfigWithNoLabels).locales,
      ]

      // is string[], so convert to Locale[]
      config.localization.locales = (
        config.localization as unknown as LocalizationConfigWithNoLabels
      ).locales.map((locale) => ({
        code: locale,
        label: locale,
        rtl: false,
        toString: () => locale,
      }))
    } else {
      // is Locale[], so convert to string[] for localeCodes
      config.localization.localeCodes = config.localization.locales.map((locale) => locale.code)

      config.localization.locales = (
        config.localization as LocalizationConfigWithLabels
      ).locales.map((locale) => ({
        ...locale,
        toString: () => locale.code,
      }))
    }

    // Default fallback to true if not provided
    config.localization.fallback = config.localization?.fallback ?? true
  }

  const i18nConfig: SanitizedConfig['i18n'] = {
    fallbackLanguage: 'en',
    supportedLanguages: {
      en,
    },
    translations: {},
  }

  if (incomingConfig?.i18n) {
    i18nConfig.supportedLanguages =
      incomingConfig.i18n?.supportedLanguages || i18nConfig.supportedLanguages

    const supportedLangKeys = <AcceptedLanguages[]>Object.keys(i18nConfig.supportedLanguages)
    const fallbackLang = incomingConfig.i18n?.fallbackLanguage || i18nConfig.fallbackLanguage

    i18nConfig.fallbackLanguage = supportedLangKeys.includes(fallbackLang)
      ? fallbackLang
      : supportedLangKeys[0]
    i18nConfig.translations =
      (incomingConfig.i18n?.translations as SanitizedConfig['i18n']['translations']) ||
      i18nConfig.translations
  }

  config.i18n = i18nConfig

  const richTextSanitizationPromises: Array<(config: SanitizedConfig) => Promise<void>> = []

  const schedulePublishCollections: CollectionSlug[] = []

  const queryPresetsCollections: CollectionSlug[] = []

  const schedulePublishGlobals: GlobalSlug[] = []

  const collectionSlugs = new Set<CollectionSlug>()

  const validRelationships = [
    ...(config.collections.map((c) => c.slug) ?? []),
    jobsCollectionSlug,
    lockedDocumentsCollectionSlug,
    preferencesCollectionSlug,
  ]

  /**
   * Blocks sanitization needs to happen before collections, as collection/global join field sanitization needs config.blocks
   * to be populated with the sanitized blocks
   */
  config.blocks = []

  if (incomingConfig.blocks?.length) {
    for (const block of incomingConfig.blocks) {
      const sanitizedBlock = block

      if (sanitizedBlock._sanitized === true) {
        continue
      }
      sanitizedBlock._sanitized = true

      sanitizedBlock.fields = sanitizedBlock.fields.concat(baseBlockFields)

      sanitizedBlock.labels = !sanitizedBlock.labels
        ? formatLabels(sanitizedBlock.slug)
        : sanitizedBlock.labels

      sanitizedBlock.fields = await sanitizeFields({
        config: config as unknown as Config,
        existingFieldNames: new Set(),
        fields: sanitizedBlock.fields,
        parentIsLocalized: false,
        richTextSanitizationPromises,
        validRelationships,
      })

      const flattenedSanitizedBlock = flattenBlock({ block })

      config.blocks.push(flattenedSanitizedBlock)
    }
  }

  for (let i = 0; i < config.collections.length; i++) {
    if (collectionSlugs.has(config.collections[i].slug)) {
      throw new DuplicateCollection('slug', config.collections[i].slug)
    }

    collectionSlugs.add(config.collections[i].slug)

    const draftsConfig = config.collections[i]?.versions?.drafts

    if (typeof draftsConfig === 'object' && draftsConfig.schedulePublish) {
      schedulePublishCollections.push(config.collections[i].slug)
    }

    if (config.collections[i].enableQueryPresets) {
      queryPresetsCollections.push(config.collections[i].slug)

      if (!validRelationships.includes(queryPresetsCollectionSlug)) {
        validRelationships.push(queryPresetsCollectionSlug)
      }
    }

    config.collections[i] = await sanitizeCollection(
      config as unknown as Config,
      config.collections[i],
      richTextSanitizationPromises,
      validRelationships,
    )
  }

  if (config.globals.length > 0) {
    for (let i = 0; i < config.globals.length; i++) {
      const draftsConfig = config.globals[i]?.versions?.drafts

      if (typeof draftsConfig === 'object' && draftsConfig.schedulePublish) {
        schedulePublishGlobals.push(config.globals[i].slug)
      }

      config.globals[i] = await sanitizeGlobal(
        config as unknown as Config,
        config.globals[i],
        richTextSanitizationPromises,
        validRelationships,
      )
    }
  }

  if (schedulePublishCollections.length > 0 || schedulePublishGlobals.length > 0) {
    if (!Array.isArray(configWithDefaults.jobs?.tasks)) {
      configWithDefaults.jobs.tasks = []
    }

    configWithDefaults.jobs.tasks.push(
      getSchedulePublishTask({
        adminUserSlug: config.admin.user,
        collections: schedulePublishCollections,
        globals: schedulePublishGlobals,
      }),
    )
  }

  // Need to add default jobs collection before locked documents collections
  if (
    (Array.isArray(configWithDefaults.jobs?.tasks) && configWithDefaults.jobs?.tasks?.length) ||
    (Array.isArray(configWithDefaults.jobs?.workflows) &&
      configWithDefaults.jobs?.workflows?.length)
  ) {
    let defaultJobsCollection = getDefaultJobsCollection(config as unknown as Config)

    if (defaultJobsCollection) {
      if (typeof configWithDefaults.jobs.jobsCollectionOverrides === 'function') {
        defaultJobsCollection = configWithDefaults.jobs.jobsCollectionOverrides({
          defaultJobsCollection,
        })

        const hooks = defaultJobsCollection?.hooks
        // @todo - delete this check in 4.0
        if (hooks && config?.jobs?.runHooks !== true) {
          for (const hook of Object.keys(hooks)) {
            const defaultAmount = hook === 'afterRead' || hook === 'beforeChange' ? 1 : 0
            if (hooks[hook]?.length > defaultAmount) {
              console.warn(
                `The jobsCollectionOverrides function is returning a collection with an additional ${hook} hook defined. These hooks will not run unless the jobs.runHooks option is set to true. Setting this option to true will negatively impact performance.`,
              )
              break
            }
          }
        }
      }
      const sanitizedJobsCollection = await sanitizeCollection(
        config as unknown as Config,
        defaultJobsCollection,
        richTextSanitizationPromises,
        validRelationships,
      )

      configWithDefaults.collections.push(sanitizedJobsCollection)
    }
  }

  configWithDefaults.collections.push(
    await sanitizeCollection(
      config as unknown as Config,
      getLockedDocumentsCollection(config as unknown as Config),
      richTextSanitizationPromises,
      validRelationships,
    ),
  )

  configWithDefaults.collections.push(
    await sanitizeCollection(
      config as unknown as Config,
      getPreferencesCollection(config as unknown as Config),
      richTextSanitizationPromises,
      validRelationships,
    ),
  )

  configWithDefaults.collections.push(
    await sanitizeCollection(
      config as unknown as Config,
      migrationsCollection,
      richTextSanitizationPromises,
      validRelationships,
    ),
  )

  if (queryPresetsCollections.length > 0) {
    configWithDefaults.collections.push(
      await sanitizeCollection(
        config as unknown as Config,
        getQueryPresetsConfig(config as unknown as Config),
        richTextSanitizationPromises,
        validRelationships,
      ),
    )
  }

  if (config.serverURL !== '') {
    config.csrf.push(config.serverURL)
  }

  // Get deduped list of upload adapters
  if (!config.upload) {
    config.upload = { adapters: [] }
  }

  config.upload.adapters = Array.from(
    new Set(config.collections.map((c) => c.upload?.adapter).filter(Boolean)),
  )

  // Pass through the email config as is so adapters don't break
  if (incomingConfig.email) {
    config.email = incomingConfig.email
  }

  /*
    Execute richText sanitization
   */
  if (typeof incomingConfig.editor === 'function') {
    config.editor = await incomingConfig.editor({
      config: config as SanitizedConfig,
      isRoot: true,
      parentIsLocalized: false,
    })
    if (config.editor.i18n && Object.keys(config.editor.i18n).length >= 0) {
      config.i18n.translations = deepMergeSimple(config.i18n.translations, config.editor.i18n)
    }
  }

  const promises: Promise<void>[] = []

  for (const sanitizeFunction of richTextSanitizationPromises) {
    promises.push(sanitizeFunction(config as SanitizedConfig))
  }

  await Promise.all(promises)

  return config as SanitizedConfig
}
</file>

<file path="packages/payload/src/config/types.ts">
// @ts-strict-ignore
import type {
  DefaultTranslationKeys,
  DefaultTranslationsObject,
  I18n,
  I18nClient,
  I18nOptions,
  TFunction,
} from '@convexcms/translations'
import type { BusboyConfig } from 'busboy'
import type GraphQL from 'graphql'
import type { GraphQLFormattedError } from 'graphql'
import type { JSONSchema4 } from 'json-schema'
import type { Metadata } from 'next'
import type { DestinationStream, Level, pino } from 'pino'
import type React from 'react'
import type { default as sharp } from 'sharp'
import type { DeepRequired } from 'ts-essentials'

import type { RichTextAdapterProvider } from '../admin/RichText.js'
import type {
  DocumentSubViewTypes,
  DocumentTabConfig,
  DocumentViewServerProps,
  RichTextAdapter,
} from '../admin/types.js'
import type { AdminViewConfig, ViewTypes, VisibleEntities } from '../admin/views/index.js'
import type { SanitizedPermissions } from '../auth/index.js'
import type {
  AddToImportMap,
  ImportMap,
  Imports,
  InternalImportMap,
} from '../bin/generateImportMap/index.js'
import type {
  Collection,
  CollectionConfig,
  SanitizedCollectionConfig,
} from '../collections/config/types.js'
import type { DatabaseAdapterResult } from '../database/types.js'
import type { EmailAdapter, SendEmailOptions } from '../email/types.js'
import type { ErrorName } from '../errors/types.js'
import type { GlobalConfig, Globals, SanitizedGlobalConfig } from '../globals/config/types.js'
import type {
  Block,
  FlattenedBlock,
  JobsConfig,
  Payload,
  RequestContext,
  TypedUser,
} from '../index.js'
import type { QueryPreset, QueryPresetConstraints } from '../query-presets/types.js'
import type { PayloadRequest, Where } from '../types/index.js'
import type { PayloadLogger } from '../utilities/logger.js'

/**
 * The string path pointing to the React component. If one of the generics is `never`, you effectively mark it as a server-only or client-only component.
 *
 * If it is `false` an empty component will be rendered.
 */
export type PayloadComponent<
  TComponentServerProps extends never | object = Record<string, any>,
  TComponentClientProps extends never | object = Record<string, any>,
> = false | RawPayloadComponent<TComponentServerProps, TComponentClientProps> | string

// We need the actual object as its own type, otherwise the infers for the PayloadClientReactComponent / PayloadServerReactComponent will not work due to the string union.
// We also NEED to actually use those generics for this to work, thus they are part of the props.
export type RawPayloadComponent<
  TComponentServerProps extends never | object = Record<string, any>,
  TComponentClientProps extends never | object = Record<string, any>,
> = {
  clientProps?: object | TComponentClientProps
  exportName?: string
  path: string
  serverProps?: object | TComponentServerProps
}

export type PayloadComponentProps<TPayloadComponent> =
  TPayloadComponent extends RawPayloadComponent<
    infer TComponentServerProps,
    infer TComponentClientProps
  >
    ? TComponentClientProps | TComponentServerProps
    : never

export type PayloadClientComponentProps<TPayloadComponent> =
  TPayloadComponent extends RawPayloadComponent<infer _, infer TComponentClientProps>
    ? TComponentClientProps
    : never

export type PayloadServerComponentProps<TPayloadComponent> =
  TPayloadComponent extends RawPayloadComponent<infer TComponentServerProps, infer _>
    ? TComponentServerProps
    : never

export type PayloadReactComponent<TPayloadComponent> = React.FC<
  PayloadComponentProps<TPayloadComponent>
>

// This also ensures that if never is passed to TComponentClientProps, this entire type will be never.
// => TypeScript will now ensure that users cannot even define the typed Server Components if the PayloadComponent is marked as
// Client-Only (marked as Client-Only = TComponentServerProps is never)
export type PayloadClientReactComponent<TPayloadComponent> =
  TPayloadComponent extends RawPayloadComponent<infer _, infer TComponentClientProps>
    ? TComponentClientProps extends never
      ? never
      : React.FC<TComponentClientProps>
    : never

export type PayloadServerReactComponent<TPayloadComponent> =
  TPayloadComponent extends RawPayloadComponent<infer TComponentServerProps, infer _>
    ? TComponentServerProps extends never
      ? never
      : React.FC<TComponentServerProps>
    : never

export type ResolvedComponent<
  TComponentServerProps extends never | object,
  TComponentClientProps extends never | object,
> = {
  clientProps?: TComponentClientProps
  Component: React.FC<TComponentClientProps | TComponentServerProps>
  serverProps?: TComponentServerProps
}

export type BinScriptConfig = {
  key: string
  scriptPath: string
}

export type BinScript = (config: SanitizedConfig) => Promise<void> | void

type Prettify<T> = {
  [K in keyof T]: T[K]
} & NonNullable<unknown>

export type Plugin = (config: Config) => Config | Promise<Config>

export type LivePreviewConfig = {
  /**
   Device breakpoints to use for the `iframe` of the Live Preview window.
   Options are displayed in the Live Preview toolbar.
   The `responsive` breakpoint is included by default.
   */
  breakpoints?: {
    height: number | string
    label: string
    name: string
    width: number | string
  }[]
  /**
   The URL of the frontend application. This will be rendered within an `iframe` as its `src`.
   Payload will send a `window.postMessage()` to this URL with the document data in real-time.
   The frontend application is responsible for receiving the message and updating the UI accordingly.
   Use the `useLivePreview` hook to get started in React applications.
   */
  url?:
    | ((args: {
        collectionConfig?: SanitizedCollectionConfig
        data: Record<string, any>
        globalConfig?: SanitizedGlobalConfig
        locale: Locale
        /**
         * @deprecated
         * Use `req.payload` instead. This will be removed in the next major version.
         */
        payload: Payload
        req: PayloadRequest
      }) => Promise<string> | string)
    | string
}

export type OGImageConfig = {
  alt?: string
  height?: number | string
  type?: string
  url: string
  width?: number | string
}

/**
 * @todo find a way to remove the deep clone here.
 * It can probably be removed after the `DeepRequired` from `Config` to `SanitizedConfig` is removed.
 * Same with `CollectionConfig` to `SanitizedCollectionConfig`.
 */
type DeepClone<T> = T extends object ? { [K in keyof T]: DeepClone<T[K]> } : T

export type MetaConfig = {
  /**
   * When `static`, a pre-made image will be used for all pages.
   * When `dynamic`, a unique image will be generated for each page based on page content and given overrides.
   * When `off`, no Open Graph images will be generated and the `/api/og` endpoint will be disabled. You can still provide custom images using the `openGraph.images` property.
   * @default 'dynamic'
   */
  defaultOGImageType?: 'dynamic' | 'off' | 'static'
  /**
   * String to append to the auto-generated <title> of admin pages
   * @example `" - Custom CMS"`
   */
  titleSuffix?: string
} & DeepClone<Metadata>

export type ServerOnlyLivePreviewProperties = keyof Pick<LivePreviewConfig, 'url'>

type GeneratePreviewURLOptions = {
  locale: string
  req: PayloadRequest
  token: null | string
}

export type GeneratePreviewURL = (
  doc: Record<string, unknown>,
  options: GeneratePreviewURLOptions,
) => null | Promise<null | string> | string

export type GraphQLInfo = {
  collections: {
    [slug: string]: Collection
  }
  globals: Globals
  Mutation: {
    fields: Record<string, any>
    name: string
  }
  Query: {
    fields: Record<string, any>
    name: string
  }
  types: {
    arrayTypes: Record<string, GraphQL.GraphQLType>
    blockInputTypes: Record<string, GraphQL.GraphQLInputObjectType>
    blockTypes: Record<string, GraphQL.GraphQLObjectType>
    fallbackLocaleInputType?: GraphQL.GraphQLEnumType | GraphQL.GraphQLScalarType
    groupTypes: Record<string, GraphQL.GraphQLObjectType>
    localeInputType?: GraphQL.GraphQLEnumType | GraphQL.GraphQLScalarType
    tabTypes: Record<string, GraphQL.GraphQLObjectType>
  }
}
export type GraphQLExtension = (
  graphQL: typeof GraphQL,
  context: {
    config: SanitizedConfig
  } & GraphQLInfo,
) => Record<string, unknown>

export type InitOptions = {
  /**
   * Sometimes, with the local API, you might need to pass a config file directly, for example, serverless on Vercel
   * The passed config should match the config file, and if it doesn't, there could be mismatches between the admin UI
   * and the backend functionality
   */
  config: Promise<SanitizedConfig> | SanitizedConfig
  /**
   * Disable connect to the database on init
   */
  disableDBConnect?: boolean

  /**
   * Disable running of the `onInit` function
   */
  disableOnInit?: boolean

  importMap?: ImportMap

  /**
   * A function that is called immediately following startup that receives the Payload instance as it's only argument.
   */
  onInit?: (payload: Payload) => Promise<void> | void
}

/**
 * This result is calculated on the server
 * and then sent to the client allowing the dashboard to show accessible data and actions.
 *
 * If the result is `true`, the user has access.
 * If the result is an object, it is interpreted as a MongoDB query.
 *
 * @example `{ createdBy: { equals: id } }`
 *
 * @example `{ tenant: { in: tenantIds } }`
 *
 * @see https://payloadcms.com/docs/access-control/overview
 */
export type AccessResult = boolean | Where

export type AccessArgs<TData = any> = {
  /**
   * The relevant resource that is being accessed.
   *
   * `data` is null when a list is requested
   */
  data?: TData
  /** ID of the resource being accessed */
  id?: number | string
  /** If true, the request is for a static file */
  isReadingStaticFile?: boolean
  /** The original request that requires an access check */
  req: PayloadRequest
}

/**
 * Access function runs on the server
 * and is sent to the client allowing the dashboard to show accessible data and actions.
 *
 * @see https://payloadcms.com/docs/access-control/overview
 */
export type Access<TData = any> = (args: AccessArgs<TData>) => AccessResult | Promise<AccessResult>

/** Web Request/Response model, but the req has more payload specific properties added to it. */
export type PayloadHandler = (req: PayloadRequest) => Promise<Response> | Response

/**
 * Docs: https://payloadcms.com/docs/rest-api/overview#custom-endpoints
 */
export type Endpoint = {
  /** Extension point to add your custom data. */
  custom?: Record<string, any>

  /**
   * Middleware that will be called when the path/method matches
   *
   * Compatible with Web Request/Response Model
   */
  handler: PayloadHandler
  /** HTTP method (or "all") */
  method: 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put'
  /**
   * Pattern that should match the path of the incoming request
   *
   * Compatible with the Express router
   */
  path: string
  /**
   * Please add "root" routes under the /api folder in the Payload Project.
   * https://nextjs.org/docs/app/api-reference/file-conventions/route
   *
   * @deprecated in 3.0
   */
  root?: never
}

export type EditViewComponent = PayloadComponent<DocumentViewServerProps>

export type EditViewConfig = {
  meta?: MetaConfig
} & (
  | {
      actions?: CustomComponent[]
    }
  | {
      Component: EditViewComponent
      path?: string
    }
  | {
      path?: string
      /**
       * Add a new Edit View to the admin panel
       * i.e. you can render a custom view that has no tab, if desired
       * Or override a specific properties of an existing one
       * i.e. you can customize the `Default` view tab label, if desired
       */
      tab?: DocumentTabConfig
    }
)

export type Params = { [key: string]: string | string[] | undefined }

export type ServerProps = {
  readonly documentSubViewType?: DocumentSubViewTypes
  readonly i18n: I18nClient
  readonly locale?: Locale
  readonly params?: Params
  readonly payload: Payload
  readonly permissions?: SanitizedPermissions
  readonly searchParams?: Params
  readonly user?: TypedUser
  readonly viewType?: ViewTypes
  readonly visibleEntities?: VisibleEntities
}

export const serverProps: (keyof ServerProps)[] = [
  'payload',
  'i18n',
  'locale',
  'params',
  'permissions',
  'searchParams',
  'permissions',
]

export type Timezone = {
  label: string
  value: string
}

type SupportedTimezonesFn = (args: { defaultTimezones: Timezone[] }) => Timezone[]

type TimezonesConfig = {
  /**
   * The default timezone to use for the admin panel.
   */
  defaultTimezone?: string
  /**
   * Provide your own list of supported timezones for the admin panel
   *
   * Values should be IANA timezone names, eg. `America/New_York`
   *
   * We use `@date-fns/tz` to handle timezones
   */
  supportedTimezones?: SupportedTimezonesFn | Timezone[]
}

type SanitizedTimezoneConfig = {
  supportedTimezones: Timezone[]
} & Omit<TimezonesConfig, 'supportedTimezones'>

export type CustomComponent<TAdditionalProps extends object = Record<string, any>> =
  PayloadComponent<ServerProps & TAdditionalProps, TAdditionalProps>

export type Locale = {
  /**
   * value of supported locale
   * @example "en"
   */
  code: string
  /**
   * Code of another locale to use when reading documents with fallback, if not specified defaultLocale is used
   */
  fallbackLocale?: string
  /**
   * label of supported locale
   * @example "English"
   */
  label: Record<string, string> | string
  /**
   * if true, defaults textAligmnent on text fields to RTL
   */
  rtl?: boolean
}

export type BaseLocalizationConfig = {
  /**
   * Locale for users that have not expressed their preference for a specific locale
   * @example `"en"`
   */
  defaultLocale: string
  /**
   * Change the locale used by the default Publish button.
   * If set to `all`, all locales will be published.
   * If set to `active`, only the locale currently being edited will be published.
   * The non-default option will be available via the secondary button.
   * @default 'all'
   */
  defaultLocalePublishOption?: 'active' | 'all'
  /** Set to `true` to let missing values in localised fields fall back to the values in `defaultLocale`
   *
   * If false, then no requests will fallback unless a fallbackLocale is specified in the request.
   * @default true
   */
  fallback?: boolean
  /**
   * Define a function to filter the locales made available in Payload admin UI
   * based on user.
   */
  filterAvailableLocales?: (args: {
    locales: Locale[]
    req: PayloadRequest
  }) => Locale[] | Promise<Locale[]>
}

export type LocalizationConfigWithNoLabels = Prettify<
  {
    /**
     * List of supported locales
     * @example `["en", "es", "fr", "nl", "de", "jp"]`
     */
    locales: string[]
  } & BaseLocalizationConfig
>

export type LocalizationConfigWithLabels = Prettify<
  {
    /**
     * List of supported locales with labels
     * @example {
     *  label: 'English',
     *  value: 'en',
     *  rtl: false
     * }
     */
    locales: Locale[]
  } & BaseLocalizationConfig
>

export type SanitizedLocalizationConfig = Prettify<
  {
    /**
     * List of supported locales
     * @example `["en", "es", "fr", "nl", "de", "jp"]`
     */
    localeCodes: string[]
  } & LocalizationConfigWithLabels
>

/**
 * @see https://payloadcms.com/docs/configuration/localization#localization
 */
export type LocalizationConfig = Prettify<
  LocalizationConfigWithLabels | LocalizationConfigWithNoLabels
>

export type LabelFunction<TTranslationKeys = DefaultTranslationKeys> = (args: {
  i18n: I18nClient
  t: TFunction<TTranslationKeys>
}) => string

export type StaticLabel = Record<string, string> | string

export type SharpDependency = (
  input?:
    | ArrayBuffer
    | Buffer
    | Float32Array
    | Float64Array
    | Int8Array
    | Int16Array
    | Int32Array
    | string
    | Uint8Array
    | Uint8ClampedArray
    | Uint16Array
    | Uint32Array,
  options?: sharp.SharpOptions,
) => sharp.Sharp

export type CORSConfig = {
  headers?: string[]
  origins: '*' | string[]
}

export type AdminFunction = {
  args?: object
  path: string
  type: 'function'
}

export type AdminComponent = {
  clientProps?: object
  path: string
  serverProps?: object
  type: 'component'
}

export interface AdminDependencies {
  [key: string]: AdminComponent | AdminFunction
}

export type FetchAPIFileUploadOptions = {
  /**
   * Returns a HTTP 413 when the file is bigger than the size limit if `true`.
   * Otherwise, it will add a `truncated = true` to the resulting file structure.
   * @default false
   */
  abortOnLimit?: boolean | undefined
  /**
   * Automatically creates the directory path specified in `.mv(filePathName)`
   * @default false
   */
  createParentPath?: boolean | undefined
  /**
   * Turn on/off upload process logging. Can be useful for troubleshooting.
   * @default false
   */
  debug?: boolean | undefined
  /**
   * User defined limit handler which will be invoked if the file is bigger than configured limits.
   * @default false
   */
  limitHandler?: ((args: { request: Request; size: number }) => void) | boolean | undefined
  /**
   * By default, `req.body` and `req.files` are flattened like this:
   * `{'name': 'John', 'hobbies[0]': 'Cinema', 'hobbies[1]': 'Bike'}
   *
   * When this option is enabled they are parsed in order to be nested like this:
   * `{'name': 'John', 'hobbies': ['Cinema', 'Bike']}`
   * @default false
   */
  parseNested?: boolean | undefined
  /**
   * Preserves filename extension when using `safeFileNames` option.
   * If set to `true`, will default to an extension length of `3`.
   * If set to `number`, this will be the max allowable extension length.
   * If an extension is smaller than the extension length, it remains untouched. If the extension is longer,
   * it is shifted.
   * @default false
   *
   * @example
   * // true
   * app.use(fileUpload({ safeFileNames: true, preserveExtension: true }));
   * // myFileName.ext --> myFileName.ext
   *
   * @example
   * // max extension length 2, extension shifted
   * app.use(fileUpload({ safeFileNames: true, preserveExtension: 2 }));
   * // myFileName.ext --> myFileNamee.xt
   */
  preserveExtension?: boolean | number | undefined
  /**
   * Response which will be send to client if file size limit exceeded when `abortOnLimit` set to `true`.
   * @default 'File size limit has been reached'
   */
  responseOnLimit?: string | undefined
  /**
   * Strips characters from the upload's filename.
   * You can use custom regex to determine what to strip.
   * If set to `true`, non-alphanumeric characters _except_ dashes and underscores will be stripped.
   * This option is off by default.
   * @default false
   *
   * @example
   * // strip slashes from file names
   * app.use(fileUpload({ safeFileNames: /\\/g }))
   *
   * @example
   * app.use(fileUpload({ safeFileNames: true }))
   */
  safeFileNames?: boolean | RegExp | undefined
  /**
   * Path to store temporary files.
   * Used along with the `useTempFiles` option. By default this module uses `'tmp'` folder
   * in the current working directory.
   * You can use trailing slash, but it is not necessary.
   * @default './tmp'
   */
  tempFileDir?: string | undefined
  /**
   * This defines how long to wait for data before aborting. Set to `0` if you want to turn off timeout checks.
   * @default 60_000
   */
  uploadTimeout?: number | undefined
  /**
   * Applies uri decoding to file names if set `true`.
   * @default false
   */
  uriDecodeFileNames?: boolean | undefined
  /**
   * By default this module uploads files into RAM.
   * Setting this option to `true` turns on using temporary files instead of utilising RAM.
   * This avoids memory overflow issues when uploading large files or in case of uploading
   * lots of files at same time.
   * @default false
   */
  useTempFiles?: boolean | undefined
} & Partial<BusboyConfig>

export type ErrorResult = { data?: any; errors: unknown[]; stack?: string }

export type AfterErrorResult = {
  graphqlResult?: GraphQLFormattedError
  response?: Partial<ErrorResult> & Record<string, unknown>
  status?: number
} | void

export type AfterErrorHookArgs = {
  /** The Collection that the hook is operating on. This will be undefined if the hook is executed from a non-collection endpoint or GraphQL. */
  collection?: SanitizedCollectionConfig
  /** 	Custom context passed between hooks */
  context: RequestContext
  /** The error that occurred. */
  error: Error
  /** The GraphQL result object, available if the hook is executed within a GraphQL context. */
  graphqlResult?: GraphQLFormattedError
  /** The Request object containing the currently authenticated user. */
  req: PayloadRequest
  /** The formatted error result object, available if the hook is executed from a REST context. */
  result?: ErrorResult
}

export type AfterErrorHook = (
  args: AfterErrorHookArgs,
) => AfterErrorResult | Promise<AfterErrorResult>

/**
 * This is the central configuration
 *
 * @see https://payloadcms.com/docs/configuration/overview
 */
export type Config = {
  /** Configure admin dashboard */
  admin?: {
    /** Automatically log in as a user */
    autoLogin?:
      | {
          /**
           * The email address of the user to login as
           */
          email?: string
          /** The password of the user to login as. This is only needed if `prefillOnly` is set to true */
          password?: string
          /**
           * If set to true, the login credentials will be prefilled but the user will still need to click the login button.
           *
           * @default false
           */
          prefillOnly?: boolean
          /** The username of the user to login as */
          username?: string
        }
      | false

    /** Set account profile picture. Options: gravatar, default or a custom React component. */
    avatar?:
      | 'default'
      | 'gravatar'
      | {
          Component: PayloadComponent
        }
    /**
     * Add extra and/or replace built-in components with custom components
     *
     * @see https://payloadcms.com/docs/admin/custom-components/overview
     */
    components?: {
      /**
       * Add custom components to the top right of the Admin Panel
       */
      actions?: CustomComponent[]
      /**
       * Add custom components after the collection overview
       */
      afterDashboard?: CustomComponent[]
      /**
       * Add custom components after the email/password field
       */
      afterLogin?: CustomComponent[]
      /**
       * Add custom components after the navigation links
       */
      afterNavLinks?: CustomComponent[]
      /**
       * Add custom components before the collection overview
       */
      beforeDashboard?: CustomComponent[]
      /**
       * Add custom components before the email/password field
       */
      beforeLogin?: CustomComponent[]
      /**
       * Add custom components before the navigation links
       */
      beforeNavLinks?: CustomComponent[]
      /** Replace graphical components */
      graphics?: {
        /** Replace the icon in the navigation */
        Icon?: CustomComponent
        /** Replace the logo on the login page */
        Logo?: CustomComponent
      }
      /**
       * Add custom header to top of page globally
       */
      header?: CustomComponent[]
      /** Replace logout related components */
      logout?: {
        /** Replace the logout button  */
        Button?: CustomComponent
      }
      /**
       * Replace the navigation with a custom component
       */
      Nav?: CustomComponent
      /**
       * Wrap the admin dashboard in custom context providers
       */
      providers?: PayloadComponent<{ children?: React.ReactNode }, { children?: React.ReactNode }>[]
      /**
       * Replace or modify top-level admin routes, or add new ones:
       * + `Account` - `/admin/account`
       * + `Dashboard` - `/admin`
       * + `:path` - `/admin/:path`
       */
      views?: {
        /** Add custom admin views */
        [key: string]: AdminViewConfig
        /** Replace the account screen */
        account?: AdminViewConfig
        /** Replace the admin homepage */
        dashboard?: AdminViewConfig
      }
    }
    /** Extension point to add your custom data. Available in server and client. */
    custom?: Record<string, any>
    /** Global date format that will be used for all dates in the Admin panel. Any valid date-fns format pattern can be used. */
    dateFormat?: string
    /**
     * Each entry in this map generates an entry in the importMap.
     */
    dependencies?: AdminDependencies
    /**
     * @deprecated
     * This option is deprecated and will be removed in v4.
     * To disable the admin panel itself, delete your `/app/(payload)/admin` directory.
     * To disable all REST API and GraphQL endpoints, delete your `/app/(payload)/api` directory.
     * Note: If you've modified the default paths via `admin.routes`, delete those directories instead.
     */
    disable?: boolean
    importMap?: {
      /**
       * Automatically generate component map during development
       * @default true
       */
      autoGenerate?: boolean
      /**
       * The base directory for component paths starting with /.
       * @default process.cwd()
       **/
      baseDir?: string
      /**
       * You can use generators to add custom components to the component import map.
       * This allows you to import custom components in the admin panel.
       */
      generators?: Array<
        (props: {
          addToImportMap: AddToImportMap
          baseDir: string
          config: SanitizedConfig
          importMap: InternalImportMap
          imports: Imports
        }) => void
      >
      /**
       * If Payload cannot find the import map file location automatically,
       * you can manually provide it here.
       */
      importMapFile?: string
    }
    livePreview?: {
      collections?: string[]
      globals?: string[]
    } & LivePreviewConfig
    /** Base meta data to use for the Admin Panel. Included properties are titleSuffix, ogImage, and favicon. */
    meta?: MetaConfig
    routes?: {
      /** The route for the account page.
       *
       * @default '/account'
       */
      account?: `/${string}`
      /** The route for the create first user page.
       *
       * @default '/create-first-user'
       */
      createFirstUser?: `/${string}`
      /** The route for the forgot password page.
       *
       * @default '/forgot'
       */
      forgot?: `/${string}`
      /** The route the user will be redirected to after being inactive for too long.
       *
       * @default '/logout-inactivity'
       */
      inactivity?: `/${string}`
      /** The route for the login page.
       *
       * @default '/login'
       */
      login?: `/${string}`
      /** The route for the logout page.
       *
       * @default '/logout'
       */
      logout?: `/${string}`
      /** The route for the reset password page.
       *
       * @default '/reset'
       */
      reset?: `/${string}`
      /** The route for the unauthorized page.
       *
       * @default '/unauthorized'
       */
      unauthorized?: `/${string}`
    }
    /**
     * Suppresses React hydration mismatch warnings during the hydration of the root <html> tag.
     * Useful in scenarios where the server-rendered HTML might intentionally differ from the client-rendered DOM.
     * @default false
     */
    suppressHydrationWarning?: boolean
    /**
     * Restrict the Admin Panel theme to use only one of your choice
     *
     * @default 'all' // The theme can be configured by users
     */
    theme?: 'all' | 'dark' | 'light'
    /**
     * Configure timezone related settings for the admin panel.
     */
    timezones?: TimezonesConfig
    /** The slug of a Collection that you want to be used to log in to the Admin dashboard. */
    user?: string
  }
  /**
   * Configure authentication-related Payload-wide settings.
   */
  auth?: {
    /**
     * Define which JWT identification methods you'd like to support for Payload's local auth strategy, as well as the order that they're retrieved in.
     * Defaults to ['JWT', 'Bearer', 'cookie]
     */
    jwtOrder: ('Bearer' | 'cookie' | 'JWT')[]
  }
  /** Custom Payload bin scripts can be injected via the config. */
  bin?: BinScriptConfig[]
  blocks?: Block[]
  /**
   * Manage the datamodel of your application
   *
   * @see https://payloadcms.com/docs/configuration/collections#collection-configs
   */
  collections?: CollectionConfig[]
  /**
   * Compatibility flags for prior Payload versions
   */
  compatibility?: {
    /**
     * By default, Payload will remove the `localized: true` property
     * from fields if a parent field is localized. Set this property
     * to `true` only if you have an existing Payload database from pre-3.0
     * that you would like to maintain without migrating. This is only
     * relevant for MongoDB databases.
     *
     * @todo Remove in v4
     */
    allowLocalizedWithinLocalized: true
  }
  /**
   * Prefix a string to all cookies that Payload sets.
   *
   * @default '@convexcms/core'
   */
  cookiePrefix?: string
  /** Either a whitelist array of URLS to allow CORS requests from, or a wildcard string ('*') to accept incoming requests from any domain. */
  cors?: '*' | CORSConfig | string[]
  /** A whitelist array of URLs to allow Payload cookies to be accepted from as a form of CSRF protection. */
  csrf?: string[]

  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>

  /** Pass in a database adapter for use on this project. */
  db: DatabaseAdapterResult
  /** Enable to expose more detailed error information. */
  debug?: boolean
  /**
   * If a user does not specify `depth` while requesting a resource, this depth will be used.
   *
   * @see https://payloadcms.com/docs/getting-started/concepts#depth
   *
   * @default 2
   */
  defaultDepth?: number
  /**
   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.
   *
   * @default 40000
   */
  defaultMaxTextLength?: number
  /** Default richtext editor to use for richText fields */
  editor?: RichTextAdapterProvider<any, any, any>
  /**
   * Email Adapter
   *
   * @see https://payloadcms.com/docs/email/overview
   */
  email?: EmailAdapter | Promise<EmailAdapter>
  /** Custom REST endpoints */
  endpoints?: Endpoint[]
  /**
   * @see https://payloadcms.com/docs/configuration/globals#global-configs
   */
  globals?: GlobalConfig[]
  /**
   * Manage the GraphQL API
   *
   * You can add your own GraphQL queries and mutations to Payload, making use of all the types that Payload has defined for you.
   *
   * @see https://payloadcms.com/docs/graphql/overview
   */
  graphQL?: {
    disable?: boolean
    disablePlaygroundInProduction?: boolean
    maxComplexity?: number
    /**
     * Function that returns an object containing keys to custom GraphQL mutations
     *
     * @see https://payloadcms.com/docs/graphql/extending
     */
    mutations?: GraphQLExtension
    /**
     * Function that returns an object containing keys to custom GraphQL queries
     *
     * @see https://payloadcms.com/docs/graphql/extending
     */
    queries?: GraphQLExtension
    /**
     * Filepath to write the generated schema to
     */
    schemaOutputFile?: string
    /**
     * Function that returns an array of validation rules to apply to the GraphQL schema
     *
     * @see https://payloadcms.com/docs/graphql/overview#custom-validation-rules
     */
    validationRules?: (args: GraphQL.ExecutionArgs) => GraphQL.ValidationRule[]
  }
  /**
   * Tap into Payload-wide hooks.
   *
   * @see https://payloadcms.com/docs/hooks/overview
   */
  hooks?: {
    afterError?: AfterErrorHook[]
  }
  /** i18n config settings */
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  i18n?: I18nOptions<{} | DefaultTranslationsObject> // loosen the type here to allow for custom translations
  /** Automatically index all sortable top-level fields in the database to improve sort performance and add database compatibility for Azure Cosmos and similar. */
  indexSortableFields?: boolean
  /**
   * @experimental There may be frequent breaking changes to this API
   */
  jobs?: JobsConfig
  /**
   * Translate your content to different languages/locales.
   *
   * @default false // disable localization
   */
  localization?: false | LocalizationConfig
  /**
   * Logger options, logger options with a destination stream, or an instantiated logger instance.
   *
   * See Pino Docs for options: https://getpino.io/#/docs/api?id=options
   *
   * ```ts
   * // Logger options only
   * logger: {
   *   level: 'info',
   * }
   *
   * // Logger options with destination stream
   * logger: {
   *  options: {
   *   level: 'info',
   *  },
   *  destination: process.stdout
   * },
   *
   * // Logger instance
   * logger: pino({ name: 'my-logger' })
   *
   * ```
   */
  logger?: 'sync' | { destination?: DestinationStream; options: pino.LoggerOptions } | PayloadLogger

  /**
   * Override the log level of errors for Payload's error handler or disable logging with `false`.
   * Levels can be any of the following: 'trace', 'debug', 'info', 'warn', 'error', 'fatal' or false.
   *
   * Default levels:
   * {
  `*   APIError: 'error',
  `*   AuthenticationError: 'error',
  `*   ErrorDeletingFile: 'error',
  `*   FileRetrievalError: 'error',
  `*   FileUploadError: 'error',
  `*   Forbidden: 'info',
  `*   Locked: 'info',
  `*   LockedAuth: 'error',
  `*   MissingFile: 'info',
  `*   NotFound: 'info',
  `*   QueryError: 'error',
  `*   ValidationError: 'info',
   * }
   */
  loggingLevels?: Partial<Record<ErrorName, false | Level>>

  /**
   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.
   *
   * @see https://payloadcms.com/docs/getting-started/concepts#depth
   *
   * @default 10
   */
  maxDepth?: number

  /** A function that is called immediately following startup that receives the Payload instance as its only argument. */
  onInit?: (payload: Payload) => Promise<void> | void
  /**
   * An array of Payload plugins.
   *
   * @see https://payloadcms.com/docs/plugins/overview
   */
  plugins?: Plugin[]
  /**
   * Allow you to save and share filters, columns, and sort orders for your collections.
   * @see https://payloadcms.com/docs/query-presets/overview
   */
  queryPresets?: {
    access: {
      create?: Access<QueryPreset>
      delete?: Access<QueryPreset>
      read?: Access<QueryPreset>
      update?: Access<QueryPreset>
    }
    constraints: {
      create?: QueryPresetConstraints
      delete?: QueryPresetConstraints
      read?: QueryPresetConstraints
      update?: QueryPresetConstraints
    }
    labels?: CollectionConfig['labels']
  }
  /** Control the routing structure that Payload binds itself to. */
  routes?: {
    /** The route for the admin panel.
     * @example "/my-admin"
     * @default "/admin"
     */
    admin?: string
    /** @default "/api"  */
    api?: string
    /** @default "/graphql"  */
    graphQL?: string
    /** @default "/graphql-playground" */
    graphQLPlayground?: string
  }
  /** Secure string that Payload will use for any encryption workflows */
  secret: string
  /**
   * Define the absolute URL of your app including the protocol, for example `https://example.org`.
   * No paths allowed, only protocol, domain and (optionally) port.
   *
   * @see https://payloadcms.com/docs/configuration/overview#options
   */
  serverURL?: string
  /**
   * Pass in a local copy of Sharp if you'd like to use it.
   *
   */
  sharp?: SharpDependency
  /** Send anonymous telemetry data about general usage. */
  telemetry?: boolean
  /** Control how typescript interfaces are generated from your collections. */
  typescript?: {
    /**
     * Automatically generate types during development
     * @default true
     */
    autoGenerate?: boolean

    /** Disable declare block in generated types file */
    declare?:
      | {
          /**
           * @internal internal use only to allow for multiple declarations within a monorepo and suppress the "Duplicate identifier GeneratedTypes" error
           *
           * Adds a @ts-ignore flag above the GeneratedTypes interface declaration
           *
           * @default false
           */
          ignoreTSError?: boolean
        }
      | false

    /** Filename to write the generated types to */
    outputFile?: string

    /**
     * Allows you to modify the base JSON schema that is generated during generate:types. This JSON schema will be used
     * to generate the TypeScript interfaces.
     */
    schema?: Array<
      (args: {
        collectionIDFieldTypes: {
          [key: string]: 'number' | 'string'
        }
        config: SanitizedConfig
        i18n: I18n
        jsonSchema: JSONSchema4
      }) => JSONSchema4
    >
  }
  /**
   * Customize the handling of incoming file uploads for collections that have uploads enabled.
   */
  upload?: FetchAPIFileUploadOptions
}

/**
 * @todo remove the `DeepRequired` in v4.
 * We don't actually guarantee that all properties are set when sanitizing configs.
 */
export type SanitizedConfig = {
  admin: {
    timezones: SanitizedTimezoneConfig
  } & DeepRequired<Config['admin']>
  blocks?: FlattenedBlock[]
  collections: SanitizedCollectionConfig[]
  /** Default richtext editor to use for richText fields */
  editor?: RichTextAdapter<any, any, any>
  endpoints: Endpoint[]
  globals: SanitizedGlobalConfig[]
  i18n: Required<I18nOptions>
  jobs: JobsConfig // Redefine here, as the DeepRequired<Config> can break its type
  localization: false | SanitizedLocalizationConfig
  paths: {
    config: string
    configDir: string
    rawConfig: string
  }
  upload: {
    /**
     * Deduped list of adapters used in the project
     */
    adapters: string[]
  } & FetchAPIFileUploadOptions
} & Omit<
  // TODO: DeepRequired breaks certain, advanced TypeScript types / certain type information is lost. We should remove it when possible.
  // E.g. in packages/ui/src/graphics/Account/index.tsx in getComponent, if avatar.Component is casted to what it's supposed to be,
  // the result type is different
  DeepRequired<Config>,
  | 'admin'
  | 'blocks'
  | 'collections'
  | 'editor'
  | 'endpoint'
  | 'globals'
  | 'i18n'
  | 'localization'
  | 'upload'
>

export type EditConfig = EditConfigWithoutRoot | EditConfigWithRoot

export type EditConfigWithRoot = {
  api?: never
  default?: never
  livePreview?: never
  /**
   * Replace or modify _all_ nested document views and routes, including the document header, controls, and tabs. This cannot be used in conjunction with other nested views.
   * + `root` - `/admin/collections/:collection/:id/**\/*`
   */
  root: Partial<EditViewConfig>
  version?: never
  versions?: never
}

export type EditConfigWithoutRoot = {
  [key: string]: EditViewConfig
  /**
   * Replace or modify individual nested routes, or add new ones:
   * + `default` - `/admin/collections/:collection/:id`
   * + `api` - `/admin/collections/:collection/:id/api`
   * + `livePreview` - `/admin/collections/:collection/:id/preview`
   * + `references` - `/admin/collections/:collection/:id/references`
   * + `relationships` - `/admin/collections/:collection/:id/relationships`
   * + `versions` - `/admin/collections/:collection/:id/versions`
   * + `version` - `/admin/collections/:collection/:id/versions/:version`
   * + `customView` - `/admin/collections/:collection/:id/:path`
   *
   * To override the entire Edit View including all nested views, use the `root` key.
   */
  api?: Partial<EditViewConfig>
  default?: Partial<EditViewConfig>
  livePreview?: Partial<EditViewConfig>
  root?: never
  version?: Partial<EditViewConfig>
  versions?: Partial<EditViewConfig>
}

export type EntityDescriptionComponent = CustomComponent

export type EntityDescriptionFunction = ({ t }: { t: TFunction }) => string

export type EntityDescription = EntityDescriptionFunction | Record<string, string> | string

export type { EmailAdapter, SendEmailOptions }
</file>

<file path="packages/payload/src/database/migrations/createMigration.ts">
// @ts-strict-ignore
import fs from 'fs'

import type { CreateMigration } from '../types.js'

import { writeMigrationIndex } from '../../index.js'
import { migrationTemplate } from './migrationTemplate.js'

export const createMigration: CreateMigration = function createMigration({
  migrationName,
  payload,
}) {
  const dir = payload.db.migrationDir
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir)
  }

  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')
  const formattedDate = yyymmdd.replace(/\D/g, '')
  const formattedTime = hhmmss.split('.')[0].replace(/\D/g, '')

  const timestamp = `${formattedDate}_${formattedTime}`

  const formattedName = migrationName.replace(/\W/g, '_')
  const fileName = `${timestamp}_${formattedName}.ts`
  const filePath = `${dir}/${fileName}`
  fs.writeFileSync(filePath, migrationTemplate)

  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })

  payload.logger.info({ msg: `Migration created at ${filePath}` })
}
</file>

<file path="packages/payload/src/database/migrations/getMigrations.ts">
import type { Payload } from '../../index.js'
import type { MigrationData } from '../types.js'

/**
 * Gets all existing migrations from the database, excluding the dev migration
 */
export async function getMigrations({
  payload,
}: {
  payload: Payload
}): Promise<{ existingMigrations: MigrationData[]; latestBatch: number }> {
  const migrationQuery = await payload.find({
    collection: 'payload-migrations',
    limit: 0,
    sort: ['-batch', '-name'],
    where: {
      batch: {
        not_equals: -1,
      },
    },
  })

  const existingMigrations = migrationQuery.docs as unknown as MigrationData[]

  // Get the highest batch number from existing migrations
  const latestBatch = Number(existingMigrations?.[0]?.batch) || 0

  return {
    existingMigrations,
    latestBatch,
  }
}
</file>

<file path="packages/payload/src/database/migrations/getPredefinedMigration.ts">
import fs from 'fs'
import path from 'path'
import { pathToFileURL } from 'url'

import type { Payload } from '../../index.js'
import type { MigrationTemplateArgs } from '../types.js'

/**
 * Get predefined migration 'up', 'down' and 'imports'
 */
export const getPredefinedMigration = async ({
  dirname,
  file,
  migrationName: migrationNameArg,
  payload,
}: {
  dirname: string
  file?: string
  migrationName?: string
  payload: Payload
}): Promise<MigrationTemplateArgs> => {
  // Check for predefined migration.
  // Either passed in via --file or prefixed with '@payloadcms/db-mongodb/' for example
  const importPath = file ?? migrationNameArg

  if (importPath?.startsWith('@payloadcms/db-')) {
    // removes the package name from the migrationName.
    const migrationName = importPath.split('/').slice(2).join('/')
    let cleanPath = path.join(dirname, `./predefinedMigrations/${migrationName}`)
    if (fs.existsSync(`${cleanPath}.mjs`)) {
      cleanPath = `${cleanPath}.mjs`
    } else if (fs.existsSync(`${cleanPath}.js`)) {
      cleanPath = `${cleanPath}.js`
    } else {
      payload.logger.error({
        msg: `Canned migration ${migrationName} not found.`,
      })
      process.exit(1)
    }
    cleanPath = cleanPath.replaceAll('\\', '/')
    const moduleURL = pathToFileURL(cleanPath)
    try {
      const { downSQL, imports, upSQL } = await eval(`import('${moduleURL.href}')`)
      return {
        downSQL,
        imports,
        upSQL,
      }
    } catch (err) {
      payload.logger.error({
        err,
        msg: `Error loading predefined migration ${migrationName}`,
      })
      process.exit(1)
    }
  } else if (importPath) {
    try {
      const { downSQL, imports, upSQL } = await eval(`import('${importPath}')`)
      return {
        downSQL,
        imports,
        upSQL,
      }
    } catch (_err) {
      if (importPath?.includes('/')) {
        // We can assume that the intent was to import a file, thus we throw an error.
        throw new Error(`Error importing migration file from ${importPath}`)
      }
      // Silently fail. If the migration cannot be imported, it will be created as a blank migration and the import path will be used as the migration name.
      return {}
    }
  }
  return {}
}
</file>

<file path="packages/payload/src/database/migrations/migrate.ts">
// @ts-strict-ignore
import type { BaseDatabaseAdapter } from '../types.js'

import { commitTransaction } from '../../utilities/commitTransaction.js'
import { createLocalReq } from '../../utilities/createLocalReq.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getMigrations } from './getMigrations.js'
import { readMigrationFiles } from './readMigrationFiles.js'

export const migrate: BaseDatabaseAdapter['migrate'] = async function migrate(
  this: BaseDatabaseAdapter,
  args,
): Promise<void> {
  const { payload } = this
  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))
  const { existingMigrations, latestBatch } = await getMigrations({ payload })

  const newBatch = latestBatch + 1

  // Execute 'up' function for each migration sequentially
  for (const migration of migrationFiles) {
    const existingMigration = existingMigrations.find(
      (existing) => existing.name === migration.name,
    )

    // Run migration if not found in database
    if (existingMigration) {
      continue
    }

    const start = Date.now()
    const req = await createLocalReq({}, payload)

    payload.logger.info({ msg: `Migrating: ${migration.name}` })

    try {
      await initTransaction(req)
      const session = payload.db.sessions?.[await req.transactionID]
      await migration.up({ payload, req, session })
      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })
      await payload.create({
        collection: 'payload-migrations',
        data: {
          name: migration.name,
          batch: newBatch,
        },
        req,
      })
      await commitTransaction(req)
    } catch (err: unknown) {
      await killTransaction(req)
      payload.logger.error({ err, msg: `Error running migration ${migration.name}` })
      throw err
    }
  }
}
</file>

<file path="packages/payload/src/database/migrations/migrateDown.ts">
// @ts-strict-ignore
import type { BaseDatabaseAdapter } from '../types.js'

import { commitTransaction } from '../../utilities/commitTransaction.js'
import { createLocalReq } from '../../utilities/createLocalReq.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getMigrations } from './getMigrations.js'
import { readMigrationFiles } from './readMigrationFiles.js'

export async function migrateDown(this: BaseDatabaseAdapter): Promise<void> {
  const { payload } = this
  const migrationFiles = await readMigrationFiles({ payload })

  const { existingMigrations, latestBatch } = await getMigrations({
    payload,
  })

  if (!existingMigrations?.length) {
    payload.logger.info({ msg: 'No migrations to rollback.' })
    return
  }

  payload.logger.info({
    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,
  })

  const latestBatchMigrations = existingMigrations.filter(({ batch }) => batch === latestBatch)

  for (const migration of latestBatchMigrations) {
    const migrationFile = migrationFiles.find((m) => m.name === migration.name)
    if (!migrationFile) {
      throw new Error(`Migration ${migration.name} not found locally.`)
    }

    const start = Date.now()
    const req = await createLocalReq({}, payload)

    try {
      payload.logger.info({ msg: `Migrating down: ${migrationFile.name}` })
      await initTransaction(req)
      const session = payload.db.sessions?.[await req.transactionID]
      await migrationFile.down({ payload, req, session })
      payload.logger.info({
        msg: `Migrated down:  ${migrationFile.name} (${Date.now() - start}ms)`,
      })
      // Waiting for implementation here
      await payload.delete({
        id: migration.id,
        collection: 'payload-migrations',
        req,
      })

      await commitTransaction(req)
    } catch (err: unknown) {
      await killTransaction(req)
      payload.logger.error({
        err,
        msg: `Error running migration ${migrationFile.name}`,
      })
      process.exit(1)
    }
  }
}
</file>

<file path="packages/payload/src/database/migrations/migrateRefresh.ts">
// @ts-strict-ignore
import type { BaseDatabaseAdapter } from '../types.js'

import { commitTransaction } from '../../utilities/commitTransaction.js'
import { createLocalReq } from '../../utilities/createLocalReq.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getMigrations } from './getMigrations.js'
import { readMigrationFiles } from './readMigrationFiles.js'

/**
 * Run all migration down functions before running up
 */
export async function migrateRefresh(this: BaseDatabaseAdapter) {
  const { payload } = this
  const migrationFiles = await readMigrationFiles({ payload })

  const { existingMigrations } = await getMigrations({
    payload,
  })

  const req = await createLocalReq({}, payload)

  if (existingMigrations?.length) {
    payload.logger.info({
      msg: `Rolling back all ${existingMigrations.length} migration(s).`,
    })
    // Reverse order of migrations to rollback
    existingMigrations.reverse()

    for (const migration of existingMigrations) {
      try {
        const migrationFile = migrationFiles.find((m) => m.name === migration.name)
        if (!migrationFile) {
          throw new Error(`Migration ${migration.name} not found locally.`)
        }

        payload.logger.info({ msg: `Migrating down: ${migration.name}` })
        const start = Date.now()
        await initTransaction(req)
        const session = payload.db.sessions?.[await req.transactionID]
        await migrationFile.down({ payload, req, session })
        payload.logger.info({
          msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,
        })
        await payload.delete({
          collection: 'payload-migrations',
          req,
          where: {
            name: {
              equals: migration.name,
            },
          },
        })
      } catch (err: unknown) {
        await killTransaction(req)
        let msg = `Error running migration ${migration.name}. Rolling back.`
        if (err instanceof Error) {
          msg += ` ${err.message}`
        }
        payload.logger.error({
          err,
          msg,
        })
        process.exit(1)
      }
    }
  } else {
    payload.logger.info({ msg: 'No migrations to rollback.' })
  }

  // Run all migrate up
  for (const migration of migrationFiles) {
    payload.logger.info({ msg: `Migrating: ${migration.name}` })
    try {
      const start = Date.now()
      await initTransaction(req)
      await migration.up({ payload, req })
      await payload.create({
        collection: 'payload-migrations',
        data: {
          name: migration.name,
          executed: true,
        },
        req,
      })
      await commitTransaction(req)

      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })
    } catch (err: unknown) {
      await killTransaction(req)
      let msg = `Error running migration ${migration.name}. Rolling back.`
      if (err instanceof Error) {
        msg += ` ${err.message}`
      }
      payload.logger.error({
        err,
        msg,
      })
      process.exit(1)
    }
  }
}
</file>

<file path="packages/payload/src/database/migrations/migrateReset.ts">
// @ts-strict-ignore
import type { BaseDatabaseAdapter } from '../types.js'

import { commitTransaction } from '../../utilities/commitTransaction.js'
import { createLocalReq } from '../../utilities/createLocalReq.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { getMigrations } from './getMigrations.js'
import { readMigrationFiles } from './readMigrationFiles.js'

export async function migrateReset(this: BaseDatabaseAdapter): Promise<void> {
  const { payload } = this
  const migrationFiles = await readMigrationFiles({ payload })

  const { existingMigrations } = await getMigrations({ payload })

  if (!existingMigrations?.length) {
    payload.logger.info({ msg: 'No migrations to reset.' })
    return
  }

  const req = await createLocalReq({}, payload)

  // Rollback all migrations in order
  for (const migration of migrationFiles) {
    // Create or update migration in database
    const existingMigration = existingMigrations.find(
      (existing) => existing.name === migration.name,
    )
    if (existingMigration) {
      payload.logger.info({ msg: `Migrating down: ${migration.name}` })
      try {
        const start = Date.now()
        await initTransaction(req)
        const session = payload.db.sessions?.[await req.transactionID]
        await migration.down({ payload, req, session })
        await payload.delete({
          collection: 'payload-migrations',
          req,
          where: {
            id: {
              equals: existingMigration.id,
            },
          },
        })
        await commitTransaction(req)
        payload.logger.info({ msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)` })
      } catch (err: unknown) {
        await killTransaction(req)
        payload.logger.error({ err, msg: `Error running migration ${migration.name}` })
        throw err
      }
    }
  }

  // Delete dev migration
  try {
    await payload.delete({
      collection: 'payload-migrations',
      where: {
        batch: {
          equals: -1,
        },
      },
    })
  } catch (err: unknown) {
    payload.logger.error({ err, msg: 'Error deleting dev migration' })
  }
}
</file>

<file path="packages/payload/src/database/migrations/migrateStatus.ts">
import { Table } from 'console-table-printer'

import type { BaseDatabaseAdapter } from '../types.js'

import { getMigrations } from './getMigrations.js'
import { readMigrationFiles } from './readMigrationFiles.js'

export async function migrateStatus(this: BaseDatabaseAdapter): Promise<void> {
  const { payload } = this
  const migrationFiles = await readMigrationFiles({ payload })

  payload.logger.debug({
    msg: `Found ${migrationFiles.length} migration files.`,
  })

  const { existingMigrations } = await getMigrations({ payload })

  if (!migrationFiles.length) {
    payload.logger.info({ msg: 'No migrations found.' })
    return
  }

  // Compare migration files to existing migrations
  const statuses = migrationFiles.map((migration) => {
    const existingMigration = existingMigrations.find((m) => m.name === migration.name)
    return {
      Name: migration.name,

      Batch: existingMigration?.batch,
      Ran: existingMigration ? 'Yes' : 'No',
    }
  })

  const p = new Table()

  statuses.forEach((s) => {
    p.addRow(s, {
      color: s.Ran === 'Yes' ? 'green' : 'red',
    })
  })
  p.printTable()
}
</file>

<file path="packages/payload/src/database/migrations/migrationsCollection.ts">
import type { CollectionConfig } from '../../collections/config/types.js'

export const migrationsCollection: CollectionConfig = {
  slug: 'payload-migrations',
  admin: {
    hidden: true,
  },
  endpoints: false,
  fields: [
    {
      name: 'name',
      type: 'text',
    },
    {
      name: 'batch',
      type: 'number',
      // NOTE: This value is -1 if it is a "dev push"
    },
  ],
  graphQL: false,
  lockDocuments: false,
}
</file>

<file path="packages/payload/src/database/migrations/migrationTemplate.ts">
export const migrationTemplate = `
import {
  MigrateUpArgs,
  MigrateDownArgs,
} from "@payloadcms/db-mongodb";

export async function up({ payload, req }: MigrateUpArgs): Promise<void> {
  // Migration code
};

export async function down({ payload, req }: MigrateDownArgs): Promise<void> {
  // Migration code
};
`
</file>

<file path="packages/payload/src/database/migrations/readMigrationFiles.ts">
// @ts-strict-ignore
import fs from 'fs'
import { pathToFileURL } from 'node:url'
import path from 'path'

import type { Payload } from '../../index.js'
import type { Migration } from '../types.js'

/**
 * Read the migration files from disk
 */
export const readMigrationFiles = async ({
  payload,
}: {
  payload: Payload
}): Promise<Migration[]> => {
  if (!fs.existsSync(payload.db.migrationDir)) {
    payload.logger.error({
      msg: `No migration directory found at ${payload.db.migrationDir}`,
    })
    return []
  }

  payload.logger.info({
    msg: `Reading migration files from ${payload.db.migrationDir}`,
  })

  const files = fs
    .readdirSync(payload.db.migrationDir)
    .sort()
    .filter((f) => {
      return (f.endsWith('.ts') || f.endsWith('.js')) && f !== 'index.js' && f !== 'index.ts'
    })
    .map((file) => {
      return path.resolve(payload.db.migrationDir, file)
    })

  return Promise.all(
    files.map(async (filePath) => {
      // eval used to circumvent errors bundling
      let migration =
        typeof require === 'function'
          ? await eval(`require('${filePath.replaceAll('\\', '/')}')`)
          : await eval(`import('${pathToFileURL(filePath).href}')`)
      if ('default' in migration) {
        migration = migration.default
      }

      const result: Migration = {
        name: path.basename(filePath).split('.')?.[0],
        down: migration.down,
        up: migration.up,
      }

      return result
    }),
  )
}
</file>

<file path="packages/payload/src/database/migrations/writeMigrationIndex.ts">
import fs from 'fs'
import { getTsconfig } from 'get-tsconfig'
import path from 'path'

// Function to get all migration files (TS or JS) excluding 'index'
const getMigrationFiles = (dir: string) => {
  return fs
    .readdirSync(dir)
    .filter(
      (file) =>
        (file.endsWith('.ts') || file.endsWith('.js')) &&
        file !== 'index.ts' &&
        file !== 'index.js',
    )
    .sort()
}

// Function to generate the index.ts content
const generateIndexContent = (files: string[]) => {
  const tsconfig = getTsconfig()
  const importExt = tsconfig?.config?.compilerOptions?.moduleResolution === 'NodeNext' ? '.js' : ''

  let imports = ''
  let exportsArray = 'export const migrations = [\n'

  files.forEach((file, index) => {
    const fileNameWithoutExt = file.replace(/\.[^/.]+$/, '')
    imports += `import * as migration_${fileNameWithoutExt} from './${fileNameWithoutExt}${importExt}';\n`
    exportsArray += `  {
    up: migration_${fileNameWithoutExt}.up,
    down: migration_${fileNameWithoutExt}.down,
    name: '${fileNameWithoutExt}'${index !== files.length - 1 ? ',' : ''}\n  },\n`
  })

  exportsArray += '];\n'
  return imports + '\n' + exportsArray
}

// Main function to create the index.ts file
export const writeMigrationIndex = (args: { migrationsDir: string }) => {
  const migrationFiles = getMigrationFiles(args.migrationsDir)
  const indexContent = generateIndexContent(migrationFiles)

  fs.writeFileSync(path.join(args.migrationsDir, 'index.ts'), indexContent)
}
</file>

<file path="packages/payload/src/database/queryValidation/types.ts">
import type { CollectionPermission, GlobalPermission } from '../../auth/index.js'
import type { FlattenedField } from '../../fields/config/types.js'

export type EntityPolicies = {
  collections?: {
    [collectionSlug: string]: CollectionPermission
  }
  globals?: {
    [globalSlug: string]: GlobalPermission
  }
}

export type PathToQuery = {
  collectionSlug?: string
  complete: boolean
  field: FlattenedField
  fields?: FlattenedField[]
  globalSlug?: string
  invalid?: boolean
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized: boolean
  path: string
}
</file>

<file path="packages/payload/src/database/queryValidation/validateQueryPaths.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { FlattenedField } from '../../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'
import type { EntityPolicies } from './types.js'

import { QueryError } from '../../errors/QueryError.js'
import { validOperatorSet } from '../../types/constants.js'
import { validateSearchParam } from './validateSearchParams.js'

type Args = {
  errors?: { path: string }[]
  overrideAccess: boolean
  policies?: EntityPolicies
  polymorphicJoin?: boolean
  req: PayloadRequest
  versionFields?: FlattenedField[]
  where: Where
} & (
  | {
      collectionConfig: SanitizedCollectionConfig
      globalConfig?: never | undefined
    }
  | {
      collectionConfig?: never | undefined
      globalConfig: SanitizedGlobalConfig
    }
)

const flattenWhere = (query: Where): WhereField[] => {
  const flattenedConstraints: WhereField[] = []

  for (const [key, val] of Object.entries(query)) {
    if ((key === 'and' || key === 'or') && Array.isArray(val)) {
      for (const subVal of val) {
        flattenedConstraints.push(...flattenWhere(subVal))
      }
    } else {
      flattenedConstraints.push({ [key]: val })
    }
  }

  return flattenedConstraints
}

export async function validateQueryPaths({
  collectionConfig,
  errors = [],
  globalConfig,
  overrideAccess,
  policies = {
    collections: {},
    globals: {},
  },
  polymorphicJoin,
  req,
  versionFields,
  where,
}: Args): Promise<void> {
  const fields = versionFields || (globalConfig || collectionConfig).flattenedFields

  if (typeof where === 'object') {
    const whereFields = flattenWhere(where)
    // We need to determine if the whereKey is an AND, OR, or a schema path
    const promises = []
    for (const constraint of whereFields) {
      for (const path in constraint) {
        for (const operator in constraint[path]) {
          const val = constraint[path][operator]
          if (validOperatorSet.has(operator as Operator)) {
            promises.push(
              validateSearchParam({
                collectionConfig,
                errors,
                fields,
                globalConfig,
                operator,
                overrideAccess,
                path,
                policies,
                polymorphicJoin,
                req,
                val,
                versionFields,
              }),
            )
          }
        }
      }
    }

    await Promise.all(promises)
    if (errors.length > 0) {
      throw new QueryError(errors)
    }
  }
}
</file>

<file path="packages/payload/src/database/queryValidation/validateSearchParams.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { FlattenedField } from '../../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { PayloadRequest } from '../../types/index.js'
import type { EntityPolicies, PathToQuery } from './types.js'

import { fieldAffectsData, fieldIsVirtual } from '../../fields/config/types.js'
import { getEntityPolicies } from '../../utilities/getEntityPolicies.js'
import isolateObjectProperty from '../../utilities/isolateObjectProperty.js'
import { getLocalizedPaths } from '../getLocalizedPaths.js'
import { validateQueryPaths } from './validateQueryPaths.js'

type Args = {
  collectionConfig?: SanitizedCollectionConfig
  errors: { path: string }[]
  fields: FlattenedField[]
  globalConfig?: SanitizedGlobalConfig
  operator: string
  overrideAccess: boolean
  parentIsLocalized?: boolean
  path: string
  policies: EntityPolicies
  polymorphicJoin?: boolean
  req: PayloadRequest
  val: unknown
  versionFields?: FlattenedField[]
}

/**
 * Validate the Payload key / value / operator
 */
export async function validateSearchParam({
  collectionConfig,
  errors,
  fields,
  globalConfig,
  operator,
  overrideAccess,
  parentIsLocalized,
  path: incomingPath,
  policies,
  polymorphicJoin,
  req,
  val,
  versionFields,
}: Args): Promise<void> {
  // Replace GraphQL nested field double underscore formatting
  let sanitizedPath
  if (incomingPath === '_id') {
    sanitizedPath = 'id'
  } else {
    sanitizedPath = incomingPath.replace(/__/g, '.')
  }
  let paths: PathToQuery[] = []
  const { slug } = collectionConfig || globalConfig

  const blockPolicies = {}

  if (globalConfig && !policies.globals[slug]) {
    policies.globals[slug] = await getEntityPolicies({
      type: 'global',
      blockPolicies,
      entity: globalConfig,
      operations: ['read'],
      req,
    })
  }

  if (sanitizedPath !== 'id') {
    paths = getLocalizedPaths({
      collectionSlug: collectionConfig?.slug,
      fields,
      globalSlug: globalConfig?.slug,
      incomingPath: sanitizedPath,
      locale: req.locale,
      overrideAccess,
      parentIsLocalized,
      payload: req.payload,
    })
  }
  const promises = []

  // Sanitize relation.otherRelation.id to relation.otherRelation
  if (paths.at(-1)?.path === 'id') {
    const previousField = paths.at(-2)?.field
    if (
      previousField &&
      (previousField.type === 'relationship' || previousField.type === 'upload') &&
      typeof previousField.relationTo === 'string'
    ) {
      paths.pop()
    }
  }

  promises.push(
    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {
      if (invalid) {
        errors.push({ path })
        return
      }

      if (fieldIsVirtual(field)) {
        errors.push({ path })
      }

      if (polymorphicJoin && path === 'relationTo') {
        return
      }

      if (!overrideAccess && fieldAffectsData(field)) {
        if (collectionSlug) {
          if (!policies.collections[collectionSlug]) {
            policies.collections[collectionSlug] = await getEntityPolicies({
              type: 'collection',
              blockPolicies,
              entity: req.payload.collections[collectionSlug].config,
              operations: ['read'],
              req: isolateObjectProperty(req, 'transactionID'),
            })
          }

          if (
            ['hash', 'salt'].includes(incomingPath) &&
            collectionConfig.auth &&
            !collectionConfig.auth?.disableLocalStrategy
          ) {
            errors.push({ path: incomingPath })
          }
        }
        let fieldPath = path
        // remove locale from end of path
        if (path.endsWith(`.${req.locale}`)) {
          fieldPath = path.slice(0, -(req.locale.length + 1))
        }
        // remove ".value" from ends of polymorphic relationship paths
        if (
          (field.type === 'relationship' || field.type === 'upload') &&
          Array.isArray(field.relationTo)
        ) {
          fieldPath = fieldPath.replace('.value', '')
        }

        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'
        const entitySlug = collectionSlug || globalConfig.slug
        const segments = fieldPath.split('.')

        let fieldAccess

        if (versionFields) {
          fieldAccess = policies[entityType][entitySlug]

          if (segments[0] === 'parent' || segments[0] === 'version') {
            segments.shift()
          }
        } else {
          fieldAccess = policies[entityType][entitySlug].fields
        }

        segments.forEach((segment) => {
          if (fieldAccess[segment]) {
            if ('fields' in fieldAccess[segment]) {
              fieldAccess = fieldAccess[segment].fields
            } else if (
              'blocks' in fieldAccess[segment] ||
              'blockReferences' in fieldAccess[segment]
            ) {
              fieldAccess = fieldAccess[segment]
            } else {
              fieldAccess = fieldAccess[segment]
            }
          }
        })

        if (!fieldAccess?.read?.permission) {
          errors.push({ path: fieldPath })
        }
      }

      if (i > 1) {
        // Remove top collection and reverse array
        // to work backwards from top
        const pathsToQuery = paths.slice(1).reverse()

        pathsToQuery.forEach(
          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {
            // On the "deepest" collection,
            // validate query of the relationship
            if (pathToQueryIndex === 0) {
              promises.push(
                validateQueryPaths({
                  collectionConfig: req.payload.collections[pathCollectionSlug].config,
                  errors,
                  globalConfig: undefined,
                  overrideAccess,
                  policies,
                  req,
                  where: {
                    [subPath]: {
                      [operator]: val,
                    },
                  },
                }),
              )
            }
          },
        )
      }
    }),
  )
  await Promise.all(promises)
}
</file>

<file path="packages/payload/src/database/combineQueries.ts">
import type { Where } from '../types/index.js'

import { hasWhereAccessResult } from '../auth/index.js'

/**
 * Combines two queries into a single query, using an AND operator
 */
export const combineQueries = (where: Where, access: boolean | Where): Where => {
  if (!where && !access) {
    return {}
  }

  const and: Where[] = where ? [where] : []

  if (hasWhereAccessResult(access)) {
    and.push(access)
  }

  return {
    and,
  }
}
</file>

<file path="packages/payload/src/database/createDatabaseAdapter.ts">
// @ts-strict-ignore
import type { MarkOptional } from 'ts-essentials'

import type {
  BaseDatabaseAdapter,
  BeginTransaction,
  CommitTransaction,
  RollbackTransaction,
} from './types.js'

import { defaultUpdateJobs } from './defaultUpdateJobs.js'
import { createMigration } from './migrations/createMigration.js'
import { migrate } from './migrations/migrate.js'
import { migrateDown } from './migrations/migrateDown.js'
import { migrateRefresh } from './migrations/migrateRefresh.js'
import { migrateReset } from './migrations/migrateReset.js'
import { migrateStatus } from './migrations/migrateStatus.js'

const beginTransaction: BeginTransaction = () => Promise.resolve(null)
const rollbackTransaction: RollbackTransaction = () => Promise.resolve(null)
const commitTransaction: CommitTransaction = () => Promise.resolve(null)

export function createDatabaseAdapter<T extends BaseDatabaseAdapter>(
  args: MarkOptional<
    T,
    | 'allowIDOnCreate'
    | 'createMigration'
    | 'migrate'
    | 'migrateDown'
    | 'migrateFresh'
    | 'migrateRefresh'
    | 'migrateReset'
    | 'migrateStatus'
    | 'migrationDir'
    | 'updateJobs'
  >,
): T {
  return {
    // Default 'null' transaction functions
    beginTransaction,
    commitTransaction,
    createMigration,
    migrate,
    migrateDown,
    migrateFresh: () => Promise.resolve(null),
    migrateRefresh,
    migrateReset,
    migrateStatus,
    rollbackTransaction,
    updateJobs: defaultUpdateJobs,

    ...args,
    // Ensure migrationDir is set
    migrationDir: args.migrationDir || 'migrations',
  } as T
}
</file>

<file path="packages/payload/src/database/defaultBeginTransaction.ts">
import type { BeginTransaction } from './types.js'

/**
 * Default implementation of `beginTransaction` that returns a resolved promise of null
 */
export function defaultBeginTransaction(): BeginTransaction {
  const promiseSingleton: Promise<null> = Promise.resolve(null)
  return () => promiseSingleton
}
</file>

<file path="packages/payload/src/database/defaultUpdateJobs.ts">
import type { BaseJob, DatabaseAdapter } from '../index.js'
import type { UpdateJobs } from './types.js'

import { jobsCollectionSlug } from '../queues/config/index.js'

export const defaultUpdateJobs: UpdateJobs = async function updateMany(
  this: DatabaseAdapter,
  { id, data, limit, req, returning, where },
) {
  const updatedJobs: BaseJob[] | null = []

  const jobsToUpdate: BaseJob[] = (
    id
      ? [
          await this.findOne({
            collection: jobsCollectionSlug,
            req,
            where: { id: { equals: id } },
          }),
        ]
      : (
          await this.find({
            collection: jobsCollectionSlug,
            limit,
            pagination: false,
            req,
            where,
          })
        ).docs
  ).filter(Boolean) as BaseJob[]

  if (!jobsToUpdate) {
    return null
  }

  for (const job of jobsToUpdate) {
    const updateData = {
      ...job,
      ...data,
    }
    const updatedJob = await this.updateOne({
      id: job.id,
      collection: jobsCollectionSlug,
      data: updateData,
      req,
      returning,
    })
    updatedJobs.push(updatedJob)
  }

  return updatedJobs
}
</file>

<file path="packages/payload/src/database/flattenWhereToOperators.ts">
import type { Where, WhereField } from '../types/index.js'

/**
 * Take a where query and flatten it to all top-level operators
 */
export function flattenWhereToOperators(query: Where): WhereField[] {
  const result: WhereField[] = []

  for (const [key, value] of Object.entries(query)) {
    if ((key === 'and' || key === 'or') && Array.isArray(value)) {
      for (const subQuery of value) {
        const flattenedSub = flattenWhereToOperators(subQuery)
        result.push(...flattenedSub)
      }
    } else {
      result.push(value as WhereField)
    }
  }

  return result
}
</file>

<file path="packages/payload/src/database/getLocalizedPaths.ts">
import type { PathToQuery } from './queryValidation/types.js'

import { APIError, type Payload, type SanitizedCollectionConfig } from '../index.js'

// @ts-strict-ignore
import {
  type Field,
  fieldShouldBeLocalized,
  type FlattenedBlock,
  type FlattenedField,
} from '../fields/config/types.js'

export function getLocalizedPaths({
  collectionSlug,
  fields,
  globalSlug,
  incomingPath,
  locale,
  overrideAccess = false,
  parentIsLocalized,
  payload,
}: {
  collectionSlug?: string
  fields: FlattenedField[]
  globalSlug?: string
  incomingPath: string
  locale?: string
  overrideAccess?: boolean
  /**
   * @todo make required in v4.0. Usually, you'd wanna pass this through
   */
  parentIsLocalized?: boolean
  payload: Payload
}): PathToQuery[] {
  const pathSegments = incomingPath.split('.')
  const localizationConfig = payload.config.localization

  let paths: PathToQuery[] = [
    {
      collectionSlug,
      complete: false,
      field: undefined,
      fields,
      globalSlug,
      invalid: false,
      parentIsLocalized,
      path: '',
    },
  ]

  for (let i = 0; i < pathSegments.length; i += 1) {
    const segment = pathSegments[i]

    const lastIncompletePath = paths.find(({ complete }) => !complete)

    if (lastIncompletePath) {
      const { path } = lastIncompletePath
      let currentPath = path ? `${path}.${segment}` : segment

      let fieldsToSearch: FlattenedField[]
      let _parentIsLocalized = parentIsLocalized

      let matchedField: FlattenedField

      if (lastIncompletePath?.field?.type === 'blocks') {
        if (segment === 'blockType') {
          matchedField = {
            name: 'blockType',
            type: 'text',
          }
        } else {
          for (const _block of lastIncompletePath.field.blockReferences ??
            lastIncompletePath.field.blocks) {
            let block: FlattenedBlock
            if (typeof _block === 'string') {
              block = payload?.blocks[_block]
            } else {
              block = _block
            }

            matchedField = block.flattenedFields.find((field) => field.name === segment)
            if (matchedField) {
              break
            }
          }
        }
      } else {
        if (lastIncompletePath?.field && 'flattenedFields' in lastIncompletePath.field) {
          fieldsToSearch = lastIncompletePath.field.flattenedFields
        } else {
          fieldsToSearch = lastIncompletePath.fields
        }
        _parentIsLocalized = parentIsLocalized || lastIncompletePath.field?.localized

        matchedField = fieldsToSearch.find((field) => field.name === segment)
      }

      lastIncompletePath.field = matchedField

      if (currentPath === 'globalType' && globalSlug) {
        lastIncompletePath.path = currentPath
        lastIncompletePath.complete = true
        lastIncompletePath.field = {
          name: 'globalType',
          type: 'text',
        }

        return paths
      }

      if (currentPath === 'relationTo') {
        lastIncompletePath.path = currentPath
        lastIncompletePath.complete = true
        lastIncompletePath.field = {
          name: 'relationTo',
          type: 'select',
          options: Object.keys(payload.collections),
        }

        return paths
      }

      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {
        lastIncompletePath.path = currentPath
        const idField: Field = {
          name: 'id',
          type: payload.db.defaultIDType as 'text',
        }
        lastIncompletePath.field = idField
        lastIncompletePath.complete = true
        return paths
      }

      if (matchedField) {
        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {
          lastIncompletePath.invalid = true
        }

        const nextSegment = pathSegments[i + 1]
        const nextSegmentIsLocale =
          localizationConfig && localizationConfig.localeCodes.includes(nextSegment)

        if (nextSegmentIsLocale) {
          // Skip the next iteration, because it's a locale
          i += 1
          currentPath = `${currentPath}.${nextSegment}`
        } else if (
          localizationConfig &&
          fieldShouldBeLocalized({ field: matchedField, parentIsLocalized: _parentIsLocalized })
        ) {
          currentPath = `${currentPath}.${locale}`
        }

        switch (matchedField.type) {
          case 'join':
          case 'relationship':
          case 'upload': {
            // If this is a polymorphic relation,
            // We only support querying directly (no nested querying)
            if (matchedField.type !== 'join' && typeof matchedField.relationTo !== 'string') {
              const lastSegmentIsValid =
                ['relationTo', 'value'].includes(pathSegments[pathSegments.length - 1]) ||
                pathSegments.length === 1 ||
                (pathSegments.length === 2 && pathSegments[0] === 'version')

              lastIncompletePath.path = pathSegments.join('.')

              if (lastSegmentIsValid) {
                lastIncompletePath.complete = true
              } else {
                lastIncompletePath.invalid = true
                return paths
              }
            } else {
              lastIncompletePath.complete = true
              lastIncompletePath.path = currentPath

              const nestedPathToQuery = pathSegments
                .slice(nextSegmentIsLocale ? i + 2 : i + 1)
                .join('.')

              if (nestedPathToQuery) {
                let relatedCollection: SanitizedCollectionConfig
                if (matchedField.type === 'join') {
                  if (Array.isArray(matchedField.collection)) {
                    throw new APIError('Not supported')
                  }

                  relatedCollection = payload.collections[matchedField.collection].config
                } else {
                  relatedCollection = payload.collections[matchedField.relationTo as string].config
                }

                const remainingPaths = getLocalizedPaths({
                  collectionSlug: relatedCollection.slug,
                  fields: relatedCollection.flattenedFields,
                  globalSlug,
                  incomingPath: nestedPathToQuery,
                  locale,
                  parentIsLocalized: false,
                  payload,
                })

                paths = [...paths, ...remainingPaths]
              }

              return paths
            }

            break
          }
          case 'json':
          case 'richText': {
            const upcomingSegments = pathSegments.slice(i + 1).join('.')
            lastIncompletePath.complete = true
            lastIncompletePath.path = upcomingSegments
              ? `${currentPath}.${upcomingSegments}`
              : currentPath
            return paths
          }

          default: {
            if (i + 1 === pathSegments.length) {
              lastIncompletePath.complete = true
            }
            lastIncompletePath.path = currentPath
          }
        }
      } else {
        lastIncompletePath.invalid = true
        lastIncompletePath.path = currentPath
        return paths
      }
    }
  }

  return paths
}
</file>

<file path="packages/payload/src/database/sanitizeJoinQuery.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig, SanitizedJoin } from '../collections/config/types.js'
import type { FlattenedField } from '../fields/config/types.js'
import type { JoinQuery, PayloadRequest } from '../types/index.js'

import executeAccess from '../auth/executeAccess.js'
import { QueryError } from '../errors/QueryError.js'
import { combineQueries } from './combineQueries.js'
import { validateQueryPaths } from './queryValidation/validateQueryPaths.js'

type Args = {
  collectionConfig: SanitizedCollectionConfig
  joins?: JoinQuery
  overrideAccess: boolean
  req: PayloadRequest
}

const sanitizeJoinFieldQuery = async ({
  collectionSlug,
  errors,
  join,
  joinsQuery,
  overrideAccess,
  promises,
  req,
}: {
  collectionSlug: string
  errors: { path: string }[]
  join: SanitizedJoin
  joinsQuery: JoinQuery
  overrideAccess: boolean
  promises: Promise<void>[]
  req: PayloadRequest
}) => {
  const { joinPath } = join

  if (joinsQuery[joinPath] === false) {
    return
  }

  const joinCollectionConfig = req.payload.collections[collectionSlug].config

  const accessResult = !overrideAccess
    ? await executeAccess({ disableErrors: true, req }, joinCollectionConfig.access.read)
    : true

  if (accessResult === false) {
    joinsQuery[joinPath] = false
    return
  }

  if (!joinsQuery[joinPath]) {
    joinsQuery[joinPath] = {}
  }

  const joinQuery = joinsQuery[joinPath]

  if (!joinQuery.where) {
    joinQuery.where = {}
  }

  if (join.field.where) {
    joinQuery.where = combineQueries(joinQuery.where, join.field.where)
  }

  promises.push(
    validateQueryPaths({
      collectionConfig: joinCollectionConfig,
      errors,
      overrideAccess,
      polymorphicJoin: Array.isArray(join.field.collection),
      req,
      // incoming where input, but we shouldn't validate generated from the access control.
      where: joinQuery.where,
    }),
  )

  if (typeof accessResult === 'object') {
    joinQuery.where = combineQueries(joinQuery.where, accessResult)
  }
}

/**
 * * Validates `where` for each join
 * * Combines the access result for joined collection
 * * Combines the default join's `where`
 */
export const sanitizeJoinQuery = async ({
  collectionConfig,
  joins: joinsQuery,
  overrideAccess,
  req,
}: Args) => {
  if (joinsQuery === false) {
    return false
  }

  if (!joinsQuery) {
    joinsQuery = {}
  }

  const errors: { path: string }[] = []
  const promises: Promise<void>[] = []

  for (const collectionSlug in collectionConfig.joins) {
    for (const join of collectionConfig.joins[collectionSlug]) {
      await sanitizeJoinFieldQuery({
        collectionSlug,
        errors,
        join,
        joinsQuery,
        overrideAccess,
        promises,
        req,
      })
    }
  }

  for (const join of collectionConfig.polymorphicJoins) {
    for (const collectionSlug of join.field.collection) {
      await sanitizeJoinFieldQuery({
        collectionSlug,
        errors,
        join,
        joinsQuery,
        overrideAccess,
        promises,
        req,
      })
    }
  }

  await Promise.all(promises)

  if (errors.length > 0) {
    throw new QueryError(errors)
  }

  return joinsQuery
}
</file>

<file path="packages/payload/src/database/types.ts">
import type { TypeWithID } from '../collections/config/types.js'
import type { BaseJob, CollectionSlug, GlobalSlug } from '../index.js'
import type {
  Document,
  JoinQuery,
  Payload,
  PayloadRequest,
  SelectType,
  Sort,
  Where,
} from '../types/index.js'
import type { TypeWithVersion } from '../versions/types.js'

export type { TypeWithVersion }

export interface BaseDatabaseAdapter {
  allowIDOnCreate?: boolean
  /**
   * Start a transaction, requiring commitTransaction() to be called for any changes to be made.
   * @returns an identifier for the transaction or null if one cannot be established
   */
  beginTransaction: BeginTransaction

  /**
   * Persist the changes made since the start of the transaction.
   */
  commitTransaction: CommitTransaction

  /**
   * Open the connection to the database
   */
  connect?: Connect
  count: Count
  countGlobalVersions: CountGlobalVersions

  countVersions: CountVersions

  create: Create

  createGlobal: CreateGlobal
  createGlobalVersion: CreateGlobalVersion

  /**
   * Output a migration file
   */
  createMigration: CreateMigration

  createVersion: CreateVersion

  /**
   * Specify if the ID is a text or number field by default within this database adapter.
   */
  defaultIDType: 'number' | 'text'

  deleteMany: DeleteMany

  deleteOne: DeleteOne
  deleteVersions: DeleteVersions

  /**
   * Terminate the connection with the database
   */
  destroy?: Destroy

  find: Find

  findGlobal: FindGlobal

  findGlobalVersions: FindGlobalVersions

  findOne: FindOne

  findVersions: FindVersions

  generateSchema?: GenerateSchema

  /**
   * Perform startup tasks required to interact with the database such as building Schema and models
   */
  init?: Init

  /**
   * Run any migration up functions that have not yet been performed and update the status
   */
  migrate: (args?: { migrations?: Migration[] }) => Promise<void>

  /**
   * Run any migration down functions that have been performed
   */
  migrateDown: () => Promise<void>
  /**
   * Drop the current database and run all migrate up functions
   */
  migrateFresh: (args: { forceAcceptWarning?: boolean }) => Promise<void>

  /**
   * Run all migration down functions before running up
   */
  migrateRefresh: () => Promise<void>
  /**
   * Run all migrate down functions
   */
  migrateReset: () => Promise<void>
  /**
   * Read the current state of migrations and output the result to show which have been run
   */
  migrateStatus: () => Promise<void>
  /**
   * Path to read and write migration files from
   */
  migrationDir: string

  /**
   * The name of the database adapter
   */
  name: string

  /**
   * Full package name of the database adapter
   *
   * @example @payloadcms/db-postgres
   */
  packageName: string
  /**
   * reference to the instance of payload
   */
  payload: Payload
  queryDrafts: QueryDrafts

  /**
   * Abort any changes since the start of the transaction.
   */
  rollbackTransaction: RollbackTransaction

  /**
   * A key-value store of all sessions open (used for transactions)
   */
  sessions?: {
    [id: string]: {
      db: unknown
      reject: () => Promise<void>
      resolve: () => Promise<void>
    }
  }

  updateGlobal: UpdateGlobal

  updateGlobalVersion: UpdateGlobalVersion

  updateJobs: UpdateJobs

  updateMany: UpdateMany

  updateOne: UpdateOne

  updateVersion: UpdateVersion
  upsert: Upsert
}

export type Init = () => Promise<void> | void

type ConnectArgs = {
  hotReload: boolean
}

export type Connect = (args?: ConnectArgs) => Promise<void>

export type Destroy = () => Promise<void>

export type CreateMigration = (args: {
  file?: string
  forceAcceptWarning?: boolean
  migrationName?: string
  payload: Payload
  /**
   * Skips the prompt asking to create empty migrations
   */
  skipEmpty?: boolean
}) => Promise<void> | void

export type Transaction = (
  callback: () => Promise<void>,
  options?: Record<string, unknown>,
) => Promise<void>

export type BeginTransaction = (
  options?: Record<string, unknown>,
) => Promise<null | number | string>

export type RollbackTransaction = (id: number | Promise<number | string> | string) => Promise<void>

export type CommitTransaction = (id: number | Promise<number | string> | string) => Promise<void>

export type QueryDraftsArgs = {
  collection: CollectionSlug
  joins?: JoinQuery
  limit?: number
  locale?: string
  page?: number
  pagination?: boolean
  req?: Partial<PayloadRequest>
  select?: SelectType
  sort?: Sort
  where?: Where
}

export type QueryDrafts = <T = TypeWithID>(args: QueryDraftsArgs) => Promise<PaginatedDocs<T>>

export type FindOneArgs = {
  collection: CollectionSlug
  draftsEnabled?: boolean
  joins?: JoinQuery
  locale?: string
  req?: Partial<PayloadRequest>
  select?: SelectType
  where?: Where
}

export type FindOne = <T extends TypeWithID>(args: FindOneArgs) => Promise<null | T>

export type FindArgs = {
  collection: CollectionSlug
  draftsEnabled?: boolean
  joins?: JoinQuery
  /** Setting limit to 1 is equal to the previous Model.findOne(). Setting limit to 0 disables the limit */
  limit?: number
  locale?: string
  page?: number
  pagination?: boolean
  projection?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  select?: SelectType
  skip?: number
  sort?: Sort
  versions?: boolean
  where?: Where
}

export type Find = <T = TypeWithID>(args: FindArgs) => Promise<PaginatedDocs<T>>

export type CountArgs = {
  collection: CollectionSlug
  locale?: string
  req?: Partial<PayloadRequest>
  where?: Where
}

export type Count = (args: CountArgs) => Promise<{ totalDocs: number }>

export type CountVersions = (args: CountArgs) => Promise<{ totalDocs: number }>

export type CountGlobalVersionArgs = {
  global: string
  locale?: string
  req?: Partial<PayloadRequest>
  where?: Where
}

export type CountGlobalVersions = (args: CountGlobalVersionArgs) => Promise<{ totalDocs: number }>

type BaseVersionArgs = {
  limit?: number
  locale?: string
  page?: number
  pagination?: boolean
  req?: Partial<PayloadRequest>
  select?: SelectType
  skip?: number
  sort?: Sort
  versions?: boolean
  where?: Where
}

export type FindVersionsArgs = {
  collection: CollectionSlug
} & BaseVersionArgs

export type FindVersions = <T = TypeWithID>(
  args: FindVersionsArgs,
) => Promise<PaginatedDocs<TypeWithVersion<T>>>

export type FindGlobalVersionsArgs = {
  global: GlobalSlug
} & BaseVersionArgs

export type FindGlobalArgs = {
  locale?: string
  req?: Partial<PayloadRequest>
  select?: SelectType
  slug: string
  where?: Where
}

export type UpdateGlobalVersionArgs<T = TypeWithID> = {
  global: GlobalSlug
  locale?: string
  /**
   * Additional database adapter specific options to pass to the query
   */
  options?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  versionData: T
} & (
  | {
      id: number | string
      where?: never
    }
  | {
      id?: never
      where: Where
    }
)

/**
 * @todo type as Promise<TypeWithVersion<T> | null> in 4.0
 */
export type UpdateGlobalVersion = <T extends TypeWithID = TypeWithID>(
  args: UpdateGlobalVersionArgs<T>,
) => Promise<TypeWithVersion<T>>

export type FindGlobal = <T extends Record<string, unknown> = any>(
  args: FindGlobalArgs,
) => Promise<T>

export type CreateGlobalArgs<T extends Record<string, unknown> = any> = {
  data: T
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  slug: string
}
export type CreateGlobal = <T extends Record<string, unknown> = any>(
  args: CreateGlobalArgs<T>,
) => Promise<T>

export type UpdateGlobalArgs<T extends Record<string, unknown> = any> = {
  data: T
  /**
   * Additional database adapter specific options to pass to the query
   */
  options?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  slug: string
}
/**
 * @todo type as Promise<T | null> in 4.0
 */
export type UpdateGlobal = <T extends Record<string, unknown> = any>(
  args: UpdateGlobalArgs<T>,
) => Promise<T>
// export type UpdateOne = (args: UpdateOneArgs) => Promise<Document>

export type FindGlobalVersions = <T = TypeWithID>(
  args: FindGlobalVersionsArgs,
) => Promise<PaginatedDocs<TypeWithVersion<T>>>

export type DeleteVersionsArgs = {
  collection: CollectionSlug
  locale?: string
  req?: Partial<PayloadRequest>
  sort?: {
    [key: string]: string
  }
  where: Where
}

export type CreateVersionArgs<T = TypeWithID> = {
  autosave: boolean
  collectionSlug: CollectionSlug
  createdAt: string
  /** ID of the parent document for which the version should be created for */
  parent: number | string
  publishedLocale?: string
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  snapshot?: true
  updatedAt: string
  versionData: T
}

export type CreateVersion = <T extends TypeWithID = TypeWithID>(
  args: CreateVersionArgs<T>,
) => Promise<TypeWithVersion<T>>

export type CreateGlobalVersionArgs<T = TypeWithID> = {
  autosave: boolean
  createdAt: string
  globalSlug: GlobalSlug
  /** ID of the parent document for which the version should be created for */
  parent: number | string
  publishedLocale?: string
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  snapshot?: true
  updatedAt: string
  versionData: T
}

export type CreateGlobalVersion = <T extends TypeWithID = TypeWithID>(
  args: CreateGlobalVersionArgs<T>,
) => Promise<TypeWithVersion<T>>

export type DeleteVersions = (args: DeleteVersionsArgs) => Promise<void>

export type UpdateVersionArgs<T = TypeWithID> = {
  collection: CollectionSlug
  locale?: string
  /**
   * Additional database adapter specific options to pass to the query
   */
  options?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  versionData: T
} & (
  | {
      id: number | string
      where?: never
    }
  | {
      id?: never
      where: Where
    }
)

/**
 * @todo type as Promise<TypeWithVersion<T> | null> in 4.0
 */
export type UpdateVersion = <T extends TypeWithID = TypeWithID>(
  args: UpdateVersionArgs<T>,
) => Promise<TypeWithVersion<T>>

export type CreateArgs = {
  collection: CollectionSlug
  data: Record<string, unknown>
  draft?: boolean
  locale?: string
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
}

export type Create = (args: CreateArgs) => Promise<Document>

export type UpdateOneArgs = {
  collection: CollectionSlug
  data: Record<string, unknown>
  draft?: boolean
  joins?: JoinQuery
  locale?: string
  /**
   * Additional database adapter specific options to pass to the query
   */
  options?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
} & (
  | {
      id: number | string
      where?: never
    }
  | {
      id?: never
      where: Where
    }
)

/**
 * @todo type as Promise<Document | null> in 4.0
 */
export type UpdateOne = (args: UpdateOneArgs) => Promise<Document>

export type UpdateManyArgs = {
  collection: CollectionSlug
  data: Record<string, unknown>
  draft?: boolean
  joins?: JoinQuery
  limit?: number
  locale?: string
  /**
   * Additional database adapter specific options to pass to the query
   */
  options?: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  sort?: Sort
  where: Where
}

export type UpdateMany = (args: UpdateManyArgs) => Promise<Document[] | null>

export type UpdateJobsArgs = {
  data: Record<string, unknown>
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
} & (
  | {
      id: number | string
      limit?: never
      sort?: never
      where?: never
    }
  | {
      id?: never
      limit?: number
      sort?: Sort
      where: Where
    }
)

export type UpdateJobs = (args: UpdateJobsArgs) => Promise<BaseJob[] | null>

export type UpsertArgs = {
  collection: CollectionSlug
  data: Record<string, unknown>
  joins?: JoinQuery
  locale?: string
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  where: Where
}

export type Upsert = (args: UpsertArgs) => Promise<Document>

export type DeleteOneArgs = {
  collection: CollectionSlug
  joins?: JoinQuery
  req?: Partial<PayloadRequest>
  /**
   * If true, returns the updated documents
   *
   * @default true
   */
  returning?: boolean
  select?: SelectType
  where: Where
}

/**
 * @todo type as Promise<Document | null> in 4.0
 */
export type DeleteOne = (args: DeleteOneArgs) => Promise<Document>

export type DeleteManyArgs = {
  collection: CollectionSlug
  joins?: JoinQuery
  req?: Partial<PayloadRequest>
  where: Where
}

export type DeleteMany = (args: DeleteManyArgs) => Promise<void>

export type Migration = {
  down: (args: unknown) => Promise<void>
  up: (args: unknown) => Promise<void>
} & MigrationData

export type MigrationData = {
  batch?: number
  id?: string
  name: string
}

export type PaginatedDocs<T = any> = {
  docs: T[]
  hasNextPage: boolean
  hasPrevPage: boolean
  limit: number
  nextPage?: null | number | undefined
  page?: number
  pagingCounter: number
  prevPage?: null | number | undefined
  totalDocs: number
  totalPages: number
}

export type DatabaseAdapterResult<T = BaseDatabaseAdapter> = {
  allowIDOnCreate?: boolean
  defaultIDType: 'number' | 'text'
  init: (args: { payload: Payload }) => T
  /**
   * The name of the database adapter. For example, "postgres" or "mongoose".
   *
   * @todo make required in 4.0
   */
  name?: string
}

export type DBIdentifierName =
  | ((Args: {
      /** The name of the parent table when using relational DBs */
      tableName?: string
    }) => string)
  | string

export type MigrationTemplateArgs = {
  downSQL?: string
  imports?: string
  packageName?: string
  upSQL?: string
}

export type GenerateSchemaArgs = {
  log?: boolean
  outputFile?: string
  prettify?: boolean
}

export type GenerateSchema = (args?: GenerateSchemaArgs) => Promise<void>
</file>

<file path="packages/payload/src/duplicateDocument/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { FindOneArgs } from '../database/types.js'
import type { JsonObject, PayloadRequest } from '../types/index.js'

import executeAccess from '../auth/executeAccess.js'
import { hasWhereAccessResult } from '../auth/types.js'
import { combineQueries } from '../database/combineQueries.js'
import { Forbidden } from '../errors/Forbidden.js'
import { NotFound } from '../errors/NotFound.js'
import { afterRead } from '../fields/hooks/afterRead/index.js'
import { beforeDuplicate } from '../fields/hooks/beforeDuplicate/index.js'
import { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'
import { getLatestCollectionVersion } from '../versions/getLatestCollectionVersion.js'

type GetDuplicateDocumentArgs = {
  collectionConfig: SanitizedCollectionConfig
  draftArg?: boolean
  id: number | string
  overrideAccess?: boolean
  req: PayloadRequest
  shouldSaveDraft?: boolean
}
export const getDuplicateDocumentData = async ({
  id,
  collectionConfig,
  draftArg,
  overrideAccess,
  req,
  shouldSaveDraft,
}: GetDuplicateDocumentArgs): Promise<{
  duplicatedFromDoc: JsonObject
  duplicatedFromDocWithLocales: JsonObject
}> => {
  const { payload } = req
  // /////////////////////////////////////
  // Read Access
  // /////////////////////////////////////

  const accessResults = !overrideAccess
    ? await executeAccess({ id, req }, collectionConfig.access.read)
    : true
  const hasWherePolicy = hasWhereAccessResult(accessResults)

  // /////////////////////////////////////
  // Retrieve document
  // /////////////////////////////////////
  const findOneArgs: FindOneArgs = {
    collection: collectionConfig.slug,
    locale: req.locale,
    req,
    where: combineQueries({ id: { equals: id } }, accessResults),
  }

  let duplicatedFromDocWithLocales = await getLatestCollectionVersion({
    id,
    config: collectionConfig,
    payload,
    query: findOneArgs,
    req,
  })

  if (!duplicatedFromDocWithLocales && !hasWherePolicy) {
    throw new NotFound(req.t)
  }
  if (!duplicatedFromDocWithLocales && hasWherePolicy) {
    throw new Forbidden(req.t)
  }

  // remove the createdAt timestamp and rely on the db to set it
  if ('createdAt' in duplicatedFromDocWithLocales) {
    delete duplicatedFromDocWithLocales.createdAt
  }
  // remove the id and rely on the db to set it
  if ('id' in duplicatedFromDocWithLocales) {
    delete duplicatedFromDocWithLocales.id
  }

  duplicatedFromDocWithLocales = await beforeDuplicate({
    id,
    collection: collectionConfig,
    context: req.context,
    doc: duplicatedFromDocWithLocales,
    overrideAccess,
    req,
  })

  // for version enabled collections, override the current status with draft, unless draft is explicitly set to false
  if (shouldSaveDraft) {
    duplicatedFromDocWithLocales._status = 'draft'
  }

  const duplicatedFromDoc = await afterRead({
    collection: collectionConfig,
    context: req.context,
    depth: 0,
    doc: deepCopyObjectSimple(duplicatedFromDocWithLocales),
    draft: draftArg,
    fallbackLocale: null,
    global: null,
    locale: req.locale,
    overrideAccess: true,
    req,
    showHiddenFields: true,
  })

  return { duplicatedFromDoc, duplicatedFromDocWithLocales }
}
</file>

<file path="packages/payload/src/email/consoleEmailAdapter.ts">
import type { EmailAdapter } from './types.js'

import { emailDefaults } from './defaults.js'
import { getStringifiedToAddress } from './getStringifiedToAddress.js'

export const consoleEmailAdapter: EmailAdapter<void> = ({ payload }) => ({
  name: 'console',
  defaultFromAddress: emailDefaults.defaultFromAddress,
  defaultFromName: emailDefaults.defaultFromName,
  sendEmail: async (message) => {
    const stringifiedTo = getStringifiedToAddress(message)
    const res = `Email attempted without being configured. To: '${stringifiedTo}', Subject: '${message.subject}'`
    payload.logger.info({ msg: res })
    return Promise.resolve()
  },
})
</file>

<file path="packages/payload/src/email/defaults.ts">
import type { InitializedEmailAdapter } from './types.js'

export const emailDefaults: Pick<
  InitializedEmailAdapter,
  'defaultFromAddress' | 'defaultFromName'
> = {
  defaultFromAddress: 'info@payloadcms.com',
  defaultFromName: 'Payload',
}
</file>

<file path="packages/payload/src/email/getStringifiedToAddress.ts">
// @ts-strict-ignore
import type { SendEmailOptions } from './types.js'

export const getStringifiedToAddress = (message: SendEmailOptions): string | undefined => {
  let stringifiedTo: string | undefined

  if (typeof message.to === 'string') {
    stringifiedTo = message.to
  } else if (Array.isArray(message.to)) {
    stringifiedTo = message.to
      .map((to) => {
        if (typeof to === 'string') {
          return to
        } else if (to.address) {
          return to.address
        }
        return ''
      })
      .join(', ')
  } else if (message.to.address) {
    stringifiedTo = message.to.address
  }
  return stringifiedTo
}
</file>

<file path="packages/payload/src/email/sendEmail.ts">
import type { Payload } from '../types/index.js'
import type { SendEmailOptions } from './types.js'

import { getStringifiedToAddress } from './getStringifiedToAddress.js'

export async function sendEmail(this: Payload, message: SendEmailOptions): Promise<unknown> {
  let result

  try {
    result = await this.email.sendEmail(message)
  } catch (err: unknown) {
    const stringifiedTo = getStringifiedToAddress(message)

    this.logger.error({
      err,
      msg: `Failed to send mail to ${stringifiedTo}, subject: ${message.subject ?? 'No Subject'}`,
    })
    return err
  }

  return result
}
</file>

<file path="packages/payload/src/email/types.ts">
import type { SendMailOptions as NodemailerSendMailOptions } from 'nodemailer'

import type { Payload } from '../types/index.js'

type Prettify<T> = {
  [K in keyof T]: T[K]
} & NonNullable<unknown>

/**
 * Options for sending an email. Allows access to the PayloadRequest object
 */
export type SendEmailOptions = Prettify<NodemailerSendMailOptions>

/**
 * Email adapter after it has been initialized. This is used internally by Payload.
 */
export type InitializedEmailAdapter<TSendEmailResponse = unknown> = ReturnType<
  EmailAdapter<TSendEmailResponse>
>

/**
 * Email adapter interface. Allows a generic type for the response of the sendEmail method.
 *
 * This is the interface to use if you are creating a new email adapter.
 */

export type EmailAdapter<TSendEmailResponse = unknown> = ({ payload }: { payload: Payload }) => {
  defaultFromAddress: string
  defaultFromName: string
  name: string
  sendEmail: (message: SendEmailOptions) => Promise<TSendEmailResponse>
}
</file>

<file path="packages/payload/src/errors/APIError.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

// This gets dynamically reassigned during compilation
export let APIErrorName = 'APIError'

class ExtendableError<TData extends object = { [key: string]: unknown }> extends Error {
  data: TData

  isOperational: boolean

  isPublic: boolean

  status: number

  constructor(message: string, status: number, data: TData, isPublic: boolean) {
    super(message, {
      // show data in cause
      cause: data,
    })
    APIErrorName = this.constructor.name
    this.name = this.constructor.name
    this.message = message
    this.status = status
    this.data = data
    this.isPublic = isPublic
    this.isOperational = true // This is required since bluebird 4 doesn't append it anymore.
    Error.captureStackTrace(this, this.constructor)
  }
}

/**
 * Class representing an API error.
 * @extends ExtendableError
 */
export class APIError<
  TData extends null | object = { [key: string]: unknown } | null,
> extends ExtendableError<TData> {
  /**
   * Creates an API error.
   * @param {string} message - Error message.
   * @param {number} status - HTTP status code of error.
   * @param {object} data - response data to be returned.
   * @param {boolean} isPublic - Whether the message should be visible to user or not.
   */
  constructor(
    message: string,
    status: number = httpStatus.INTERNAL_SERVER_ERROR,
    data: TData = null,
    isPublic = false,
  ) {
    super(message, status, data, isPublic)
  }
}
</file>

<file path="packages/payload/src/errors/AuthenticationError.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class AuthenticationError extends APIError {
  constructor(t?: TFunction, loginWithUsername?: boolean) {
    super(
      t
        ? `${loginWithUsername ? t('error:usernameOrPasswordIncorrect') : t('error:emailOrPasswordIncorrect')}`
        : en.translations.error.emailOrPasswordIncorrect,
      httpStatus.UNAUTHORIZED,
    )
  }
}
</file>

<file path="packages/payload/src/errors/DuplicateCollection.ts">
import { APIError } from './APIError.js'

export class DuplicateCollection extends APIError {
  constructor(propertyName: string, duplicate: string) {
    super(`Collection ${propertyName} already in use: "${duplicate}"`)
  }
}
</file>

<file path="packages/payload/src/errors/DuplicateFieldName.ts">
import { APIError } from './APIError.js'

export class DuplicateFieldName extends APIError {
  constructor(fieldName: string) {
    super(
      `A field with the name '${fieldName}' was found multiple times on the same level. Field names must be unique.`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/DuplicateGlobal.ts">
import type { GlobalConfig } from '../globals/config/types.js'

import { APIError } from './APIError.js'

export class DuplicateGlobal extends APIError {
  constructor(config: GlobalConfig) {
    super(`Global label "${config.label}" is already in use`)
  }
}
</file>

<file path="packages/payload/src/errors/ErrorDeletingFile.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class ErrorDeletingFile extends APIError {
  constructor(t?: TFunction) {
    super(
      t ? t('error:deletingFile') : en.translations.error.deletingFile,
      httpStatus.INTERNAL_SERVER_ERROR,
    )
  }
}
</file>

<file path="packages/payload/src/errors/FileRetrievalError.ts">
import type { TFunction } from '@convexcms/translations'

import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class FileRetrievalError extends APIError {
  constructor(t?: TFunction, message?: string) {
    let msg = t ? t('error:problemUploadingFile') : 'There was a problem while retrieving the file.'

    if (message) {
      msg += ` ${message}`
    }
    super(msg, httpStatus.INTERNAL_SERVER_ERROR)
  }
}
</file>

<file path="packages/payload/src/errors/FileUploadError.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class FileUploadError extends APIError {
  constructor(t?: TFunction) {
    super(
      t ? t('error:problemUploadingFile') : en.translations.error.problemUploadingFile,
      httpStatus.BAD_REQUEST,
    )
  }
}
</file>

<file path="packages/payload/src/errors/Forbidden.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class Forbidden extends APIError {
  constructor(t?: TFunction) {
    super(
      t ? t('error:notAllowedToPerformAction') : en.translations.error.notAllowedToPerformAction,
      httpStatus.FORBIDDEN,
    )
  }
}
</file>

<file path="packages/payload/src/errors/index.ts">
export { APIError, APIErrorName } from './APIError.js'
export { AuthenticationError } from './AuthenticationError.js'
export { DuplicateCollection } from './DuplicateCollection.js'
export { DuplicateFieldName } from './DuplicateFieldName.js'
export { DuplicateGlobal } from './DuplicateGlobal.js'
export { ErrorDeletingFile } from './ErrorDeletingFile.js'
export { FileRetrievalError } from './FileRetrievalError.js'
export { FileUploadError } from './FileUploadError.js'
export { Forbidden } from './Forbidden.js'
export { InvalidConfiguration } from './InvalidConfiguration.js'
export { InvalidFieldName } from './InvalidFieldName.js'
export { InvalidFieldRelationship } from './InvalidFieldRelationship.js'
export { Locked } from './Locked.js'
export { LockedAuth } from './LockedAuth.js'
export { MissingCollectionLabel } from './MissingCollectionLabel.js'
export { MissingEditorProp } from './MissingEditorProp.js'
export { MissingFieldInputOptions } from './MissingFieldInputOptions.js'
export { MissingFieldType } from './MissingFieldType.js'
export { MissingFile } from './MissingFile.js'
export { NotFound } from './NotFound.js'
export { QueryError } from './QueryError.js'
export { ReservedFieldName } from './ReservedFieldName.js'
export { UnverifiedEmail } from './UnverifiedEmail.js'
export { ValidationError, ValidationErrorName } from './ValidationError.js'
export type { ValidationFieldError } from './ValidationError.js'
</file>

<file path="packages/payload/src/errors/InvalidConfiguration.ts">
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class InvalidConfiguration extends APIError {
  constructor(message: string) {
    super(message, httpStatus.INTERNAL_SERVER_ERROR)
  }
}
</file>

<file path="packages/payload/src/errors/InvalidFieldJoin.ts">
import type { JoinField } from '../fields/config/types.js'

import { APIError } from './APIError.js'

export class InvalidFieldJoin extends APIError {
  constructor(field: JoinField) {
    super(
      `Invalid join field ${field.name}. The config does not have a field '${field.on}' in collection '${field.collection}'.`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/InvalidFieldName.ts">
import type { FieldAffectingData } from '../fields/config/types.js'

import { APIError } from './APIError.js'

export class InvalidFieldName extends APIError {
  constructor(field: FieldAffectingData, fieldName: string) {
    super(
      `Field ${field.label} has invalid name '${fieldName}'. Field names can not include periods (.) and must be alphanumeric.`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/InvalidFieldRelationship.ts">
import type { RelationshipField, UploadField } from '../fields/config/types.js'

import { APIError } from './APIError.js'

export class InvalidFieldRelationship extends APIError {
  constructor(field: RelationshipField | UploadField, relationship: string) {
    super(`Field ${field.label} has invalid relationship '${relationship}'.`)
  }
}
</file>

<file path="packages/payload/src/errors/InvalidSchema.ts">
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class InvalidSchema extends APIError {
  constructor(message: string, results: any) {
    super(message, httpStatus.INTERNAL_SERVER_ERROR, results)
  }
}
</file>

<file path="packages/payload/src/errors/Locked.ts">
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class Locked extends APIError {
  constructor(message: string) {
    super(message, httpStatus.LOCKED)
  }
}
</file>

<file path="packages/payload/src/errors/LockedAuth.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class LockedAuth extends APIError {
  constructor(t?: TFunction) {
    super(t ? t('error:userLocked') : en.translations.error.userLocked, httpStatus.UNAUTHORIZED)
  }
}
</file>

<file path="packages/payload/src/errors/MissingCollectionLabel.ts">
import { APIError } from './APIError.js'

export class MissingCollectionLabel extends APIError {
  constructor() {
    super('payload.config.collection object is missing label')
  }
}
</file>

<file path="packages/payload/src/errors/MissingEditorProp.ts">
import type { Field } from '../fields/config/types.js'

import { fieldAffectsData } from '../fields/config/types.js'
import { APIError } from './APIError.js'

export class MissingEditorProp extends APIError {
  constructor(field: Field) {
    super(
      `RichText field${fieldAffectsData(field) ? ` "${field.name}"` : ''} is missing the editor prop. For sub-richText fields, the editor props is required, as it would otherwise create infinite recursion.`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/MissingFieldInputOptions.ts">
import type { RadioField, SelectField } from '../fields/config/types.js'

import { APIError } from './APIError.js'

export class MissingFieldInputOptions extends APIError {
  constructor(field: RadioField | SelectField) {
    super(`Field ${field.label} is missing options.`)
  }
}
</file>

<file path="packages/payload/src/errors/MissingFieldType.ts">
import type { Field } from '../fields/config/types.js'

import { fieldAffectsData } from '../fields/config/types.js'
import { APIError } from './APIError.js'

export class MissingFieldType extends APIError {
  constructor(field: Field) {
    super(
      `Field${
        fieldAffectsData(field) ? ` "${field.name}"` : ''
      } is either missing a field type or it does not match an available field type`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/MissingFile.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class MissingFile extends APIError {
  constructor(t?: TFunction) {
    super(
      t ? t('error:noFilesUploaded') : en.translations.error.noFilesUploaded,
      httpStatus.BAD_REQUEST,
    )
  }
}
</file>

<file path="packages/payload/src/errors/NotFound.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class NotFound extends APIError {
  constructor(t?: TFunction) {
    super(t ? t('general:notFound') : en.translations.general.notFound, httpStatus.NOT_FOUND)
  }
}
</file>

<file path="packages/payload/src/errors/QueryError.ts">
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class QueryError extends APIError<{ path: string }[]> {
  constructor(results: { path: string }[]) {
    const message = `The following path${results.length === 1 ? '' : 's'} cannot be queried:`

    super(
      `${message} ${results.map((err) => err.path).join(', ')}`,
      httpStatus.BAD_REQUEST,
      results,
    )
  }
}
</file>

<file path="packages/payload/src/errors/ReservedFieldName.ts">
import type { FieldAffectingData } from '../fields/config/types.js'

import { APIError } from './APIError.js'

export class ReservedFieldName extends APIError {
  constructor(field: FieldAffectingData, fieldName: string) {
    super(`Field ${field.label} has reserved name '${fieldName}'.`)
  }
}
</file>

<file path="packages/payload/src/errors/TimestampsRequired.ts">
import type { CollectionConfig } from '../collections/config/types.js'

import { APIError } from './APIError.js'

export class TimestampsRequired extends APIError {
  constructor(collection: CollectionConfig) {
    super(
      `Timestamps are required in the collection ${collection.slug} because you have opted in to Versions.`,
    )
  }
}
</file>

<file path="packages/payload/src/errors/types.ts">
export * from './index.js'

/**
 * Error names that can be thrown by Payload during runtime
 */
export type ErrorName =
  | 'APIError'
  | 'AuthenticationError'
  | 'ErrorDeletingFile'
  | 'FileRetrievalError'
  | 'FileUploadError'
  | 'Forbidden'
  | 'Locked'
  | 'LockedAuth'
  | 'MissingFile'
  | 'NotFound'
  | 'QueryError'
  | 'UnverifiedEmail'
  | 'ValidationError'
</file>

<file path="packages/payload/src/errors/UnauthorizedError.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class UnauthorizedError extends APIError {
  constructor(t?: TFunction) {
    super(t ? t('error:unauthorized') : en.translations.error.unauthorized, httpStatus.UNAUTHORIZED)
  }
}
</file>

<file path="packages/payload/src/errors/UnverifiedEmail.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import { APIError } from './APIError.js'

export class UnverifiedEmail extends APIError {
  constructor({ t }: { t?: TFunction }) {
    super(
      t ? t('error:unverifiedEmail') : en.translations.error.unverifiedEmail,
      httpStatus.FORBIDDEN,
    )
  }
}
</file>

<file path="packages/payload/src/errors/ValidationError.ts">
import type { TFunction } from '@convexcms/translations'

import { en } from '@convexcms/translations/languages/en'
import { status as httpStatus } from 'http-status'

import type { LabelFunction, StaticLabel } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { APIError } from './APIError.js'

// This gets dynamically reassigned during compilation
export let ValidationErrorName = 'ValidationError'

export type ValidationFieldError = {
  label?: LabelFunction | StaticLabel
  // The error message to display for this field
  message: string
  path: string
}

export class ValidationError extends APIError<{
  collection?: string
  errors: ValidationFieldError[]
  global?: string
}> {
  constructor(
    results: {
      collection?: string
      errors: ValidationFieldError[]
      global?: string
      id?: number | string
      /**
       *  req needs to be passed through (if you have one) in order to resolve label functions that may be part of the errors array
       */
      req?: Partial<PayloadRequest>
    },
    t?: TFunction,
  ) {
    const message = t
      ? t('error:followingFieldsInvalid', { count: results.errors.length })
      : results.errors.length === 1
        ? en.translations.error.followingFieldsInvalid_one
        : en.translations.error.followingFieldsInvalid_other

    const req = results.req
    // delete to avoid logging the whole req
    delete results['req']

    super(
      `${message} ${results.errors
        .map((f) => {
          if (f.label) {
            if (typeof f.label === 'function') {
              if (!req || !req.i18n || !req.t) {
                return f.path
              }

              return f.label({ i18n: req.i18n, t: req.t })
            }

            if (typeof f.label === 'object') {
              if (req?.i18n?.language) {
                return f.label[req.i18n.language]
              }

              return f.label[Object.keys(f.label)[0]]
            }

            return f.label
          }

          return f.path
        })
        .join(', ')}`,
      httpStatus.BAD_REQUEST,
      results,
    )

    ValidationErrorName = this.constructor.name
  }
}
</file>

<file path="packages/payload/src/exports/i18n/ar.ts">
export { ar } from '@convexcms/translations/languages/ar'
</file>

<file path="packages/payload/src/exports/i18n/az.ts">
export { az } from '@convexcms/translations/languages/az'
</file>

<file path="packages/payload/src/exports/i18n/bg.ts">
export { bg } from '@convexcms/translations/languages/bg'
</file>

<file path="packages/payload/src/exports/i18n/ca.ts">
export { ca } from '@convexcms/translations/languages/ca'
</file>

<file path="packages/payload/src/exports/i18n/cs.ts">
export { cs } from '@convexcms/translations/languages/cs'
</file>

<file path="packages/payload/src/exports/i18n/da.ts">
export { da } from '@convexcms/translations/languages/da'
</file>

<file path="packages/payload/src/exports/i18n/de.ts">
export { de } from '@convexcms/translations/languages/de'
</file>

<file path="packages/payload/src/exports/i18n/en.ts">
export { en } from '@convexcms/translations/languages/en'
</file>

<file path="packages/payload/src/exports/i18n/es.ts">
export { es } from '@convexcms/translations/languages/es'
</file>

<file path="packages/payload/src/exports/i18n/et.ts">
export { et } from '@convexcms/translations/languages/et'
</file>

<file path="packages/payload/src/exports/i18n/fa.ts">
export { fa } from '@convexcms/translations/languages/fa'
</file>

<file path="packages/payload/src/exports/i18n/fr.ts">
export { fr } from '@convexcms/translations/languages/fr'
</file>

<file path="packages/payload/src/exports/i18n/he.ts">
export { he } from '@convexcms/translations/languages/he'
</file>

<file path="packages/payload/src/exports/i18n/hr.ts">
export { hr } from '@convexcms/translations/languages/hr'
</file>

<file path="packages/payload/src/exports/i18n/hu.ts">
export { hu } from '@convexcms/translations/languages/hu'
</file>

<file path="packages/payload/src/exports/i18n/hy.ts">
export { hy } from '@convexcms/translations/languages/hy'
</file>

<file path="packages/payload/src/exports/i18n/it.ts">
export { it } from '@convexcms/translations/languages/it'
</file>

<file path="packages/payload/src/exports/i18n/ja.ts">
export { ja } from '@convexcms/translations/languages/ja'
</file>

<file path="packages/payload/src/exports/i18n/ko.ts">
export { ko } from '@convexcms/translations/languages/ko'
</file>

<file path="packages/payload/src/exports/i18n/lt.ts">
export { lt } from '@convexcms/translations/languages/lt'
</file>

<file path="packages/payload/src/exports/i18n/my.ts">
export { my } from '@convexcms/translations/languages/my'
</file>

<file path="packages/payload/src/exports/i18n/nb.ts">
export { nb } from '@convexcms/translations/languages/nb'
</file>

<file path="packages/payload/src/exports/i18n/nl.ts">
export { nl } from '@convexcms/translations/languages/nl'
</file>

<file path="packages/payload/src/exports/i18n/pl.ts">
export { pl } from '@convexcms/translations/languages/pl'
</file>

<file path="packages/payload/src/exports/i18n/pt.ts">
export { pt } from '@convexcms/translations/languages/pt'
</file>

<file path="packages/payload/src/exports/i18n/ro.ts">
export { ro } from '@convexcms/translations/languages/ro'
</file>

<file path="packages/payload/src/exports/i18n/rs.ts">
export { rs } from '@convexcms/translations/languages/rs'
</file>

<file path="packages/payload/src/exports/i18n/rsLatin.ts">
export { rsLatin } from '@convexcms/translations/languages/rsLatin'
</file>

<file path="packages/payload/src/exports/i18n/ru.ts">
export { ru } from '@convexcms/translations/languages/ru'
</file>

<file path="packages/payload/src/exports/i18n/sl.ts">
export { sl } from '@convexcms/translations/languages/sl'
</file>

<file path="packages/payload/src/exports/i18n/sv.ts">
export { sv } from '@convexcms/translations/languages/sv'
</file>

<file path="packages/payload/src/exports/i18n/th.ts">
export { th } from '@convexcms/translations/languages/th'
</file>

<file path="packages/payload/src/exports/i18n/tr.ts">
export { tr } from '@convexcms/translations/languages/tr'
</file>

<file path="packages/payload/src/exports/i18n/uk.ts">
export { uk } from '@convexcms/translations/languages/uk'
</file>

<file path="packages/payload/src/exports/i18n/vi.ts">
export { vi } from '@convexcms/translations/languages/vi'
</file>

<file path="packages/payload/src/exports/i18n/zh.ts">
export { zh } from '@convexcms/translations/languages/zh'
</file>

<file path="packages/payload/src/exports/i18n/zhTw.ts">
export { zhTw } from '@convexcms/translations/languages/zhTw'
</file>

<file path="packages/payload/src/exports/node.ts">
/**
 * WARNING: This file contains exports that can only be safely used in Node environments.
 */

export { generateTypes } from '../bin/generateTypes.js'
export { loadEnv } from '../bin/loadEnv.js'
export { findConfig } from '../config/find.js'
</file>

<file path="packages/payload/src/exports/README.md">
Important:

When you export anything with a scss or svg, or any component with a hook, it should be exported from a file within payload/components
</file>

<file path="packages/payload/src/exports/shared.ts">
export {
  generateCookie,
  generateExpiredPayloadCookie,
  generatePayloadCookie,
  getCookieExpiration,
  parseCookies,
} from '../auth/cookies.js'
export { getLoginOptions } from '../auth/getLoginOptions.js'
export { getFromImportMap } from '../bin/generateImportMap/utilities/getFromImportMap.js'
export { parsePayloadComponent } from '../bin/generateImportMap/utilities/parsePayloadComponent.js'
export { defaults as collectionDefaults } from '../collections/config/defaults.js'

export { serverProps } from '../config/types.js'

export { defaultTimezones } from '../fields/baseFields/timezone/defaultTimezones.js'

export {
  fieldAffectsData,
  fieldHasMaxDepth,
  fieldHasSubFields,
  fieldIsArrayType,
  fieldIsBlockType,
  fieldIsGroupType,
  fieldIsHiddenOrDisabled,
  fieldIsID,
  fieldIsLocalized,
  fieldIsPresentationalOnly,
  fieldIsSidebar,
  fieldIsVirtual,
  fieldShouldBeLocalized,
  fieldSupportsMany,
  optionIsObject,
  optionIsValue,
  optionsAreObjects,
  tabHasName,
  valueIsValueWithRelation,
} from '../fields/config/types.js'

export { getFieldPaths } from '../fields/getFieldPaths.js'

export * from '../fields/validations.js'

export { validOperators, validOperatorSet } from '../types/constants.js'

export { formatFilesize } from '../uploads/formatFilesize.js'

export { isImage } from '../uploads/isImage.js'
export {
  deepCopyObject,
  deepCopyObjectComplex,
  deepCopyObjectSimple,
  deepCopyObjectSimpleWithoutReactComponents,
} from '../utilities/deepCopyObject.js'

export {
  deepMerge,
  deepMergeWithCombinedArrays,
  deepMergeWithReactComponents,
  deepMergeWithSourceArrays,
} from '../utilities/deepMerge.js'

export { fieldSchemaToJSON } from '../utilities/fieldSchemaToJSON.js'
export { flattenAllFields } from '../utilities/flattenAllFields.js'

export { default as flattenTopLevelFields } from '../utilities/flattenTopLevelFields.js'
export { formatAdminURL } from '../utilities/formatAdminURL.js'
export { formatLabels, toWords } from '../utilities/formatLabels.js'
export { getDataByPath } from '../utilities/getDataByPath.js'

export { getFieldPermissions } from '../utilities/getFieldPermissions.js'

export { getSelectMode } from '../utilities/getSelectMode.js'

export { getSiblingData } from '../utilities/getSiblingData.js'

export { getUniqueListBy } from '../utilities/getUniqueListBy.js'

export { isNextBuild } from '../utilities/isNextBuild.js'

export { isNumber } from '../utilities/isNumber.js'

export { isPlainObject } from '../utilities/isPlainObject.js'

export {
  isReactClientComponent,
  isReactComponentOrFunction,
  isReactServerComponentOrFunction,
} from '../utilities/isReactComponent.js'

export {
  hoistQueryParamsToAnd,
  mergeListSearchAndWhere,
} from '../utilities/mergeListSearchAndWhere.js'

export { reduceFieldsToValues } from '../utilities/reduceFieldsToValues.js'

export { setsAreEqual } from '../utilities/setsAreEqual.js'

export { default as toKebabCase } from '../utilities/toKebabCase.js'

export {
  transformColumnsToPreferences,
  transformColumnsToSearchParams,
} from '../utilities/transformColumnPreferences.js'

export { transformWhereQuery } from '../utilities/transformWhereQuery.js'

export { unflatten } from '../utilities/unflatten.js'
export { validateMimeType } from '../utilities/validateMimeType.js'
export { validateWhereQuery } from '../utilities/validateWhereQuery.js'
export { wait } from '../utilities/wait.js'
export { default as wordBoundariesRegex } from '../utilities/wordBoundariesRegex.js'
export { versionDefaults } from '../versions/defaults.js'
export { deepMergeSimple } from '@convexcms/translations/utilities'
</file>

<file path="packages/payload/src/fields/baseFields/timezone/baseField.ts">
// @ts-strict-ignore
import type { SelectField } from '../../config/types.js'

export const baseTimezoneField: (args: Partial<SelectField>) => SelectField = ({
  name,
  defaultValue,
  options,
  required,
}) => {
  return {
    name,
    type: 'select',
    admin: {
      hidden: true,
    },
    defaultValue,
    options,
    required,
  }
}
</file>

<file path="packages/payload/src/fields/baseFields/timezone/defaultTimezones.ts">
import type { Timezone } from '../../../config/types.js'

/**
 * List of supported timezones
 *
 * label: UTC offset and location
 * value: IANA timezone name
 *
 * @example
 * { label: '(UTC-12:00) International Date Line West', value: 'Dateline Standard Time' }
 */
export const defaultTimezones: Timezone[] = [
  { label: '(UTC-11:00) Midway Island, Samoa', value: 'Pacific/Midway' },
  { label: '(UTC-11:00) Niue', value: 'Pacific/Niue' },
  { label: '(UTC-10:00) Hawaii', value: 'Pacific/Honolulu' },
  { label: '(UTC-10:00) Cook Islands', value: 'Pacific/Rarotonga' },
  { label: '(UTC-09:00) Alaska', value: 'America/Anchorage' },
  { label: '(UTC-09:00) Gambier Islands', value: 'Pacific/Gambier' },
  { label: '(UTC-08:00) Pacific Time (US & Canada)', value: 'America/Los_Angeles' },
  { label: '(UTC-08:00) Tijuana, Baja California', value: 'America/Tijuana' },
  { label: '(UTC-07:00) Mountain Time (US & Canada)', value: 'America/Denver' },
  { label: '(UTC-07:00) Arizona (No DST)', value: 'America/Phoenix' },
  { label: '(UTC-06:00) Central Time (US & Canada)', value: 'America/Chicago' },
  { label: '(UTC-06:00) Central America', value: 'America/Guatemala' },
  { label: '(UTC-05:00) Eastern Time (US & Canada)', value: 'America/New_York' },
  { label: '(UTC-05:00) Bogota, Lima, Quito', value: 'America/Bogota' },
  { label: '(UTC-04:00) Caracas', value: 'America/Caracas' },
  { label: '(UTC-04:00) Santiago', value: 'America/Santiago' },
  { label: '(UTC-03:00) Buenos Aires', value: 'America/Buenos_Aires' },
  { label: '(UTC-03:00) Brasilia', value: 'America/Sao_Paulo' },
  { label: '(UTC-02:00) South Georgia', value: 'Atlantic/South_Georgia' },
  { label: '(UTC-01:00) Azores', value: 'Atlantic/Azores' },
  { label: '(UTC-01:00) Cape Verde', value: 'Atlantic/Cape_Verde' },
  { label: '(UTC+00:00) London (GMT)', value: 'Europe/London' },
  { label: '(UTC+01:00) Berlin, Paris', value: 'Europe/Berlin' },
  { label: '(UTC+01:00) Lagos', value: 'Africa/Lagos' },
  { label: '(UTC+02:00) Athens, Bucharest', value: 'Europe/Athens' },
  { label: '(UTC+02:00) Cairo', value: 'Africa/Cairo' },
  { label: '(UTC+03:00) Moscow, St. Petersburg', value: 'Europe/Moscow' },
  { label: '(UTC+03:00) Riyadh', value: 'Asia/Riyadh' },
  { label: '(UTC+04:00) Dubai', value: 'Asia/Dubai' },
  { label: '(UTC+04:00) Baku', value: 'Asia/Baku' },
  { label: '(UTC+05:00) Islamabad, Karachi', value: 'Asia/Karachi' },
  { label: '(UTC+05:00) Tashkent', value: 'Asia/Tashkent' },
  { label: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi', value: 'Asia/Calcutta' },
  { label: '(UTC+06:00) Dhaka', value: 'Asia/Dhaka' },
  { label: '(UTC+06:00) Almaty', value: 'Asia/Almaty' },
  { label: '(UTC+07:00) Jakarta', value: 'Asia/Jakarta' },
  { label: '(UTC+07:00) Bangkok', value: 'Asia/Bangkok' },
  { label: '(UTC+08:00) Beijing, Shanghai', value: 'Asia/Shanghai' },
  { label: '(UTC+08:00) Singapore', value: 'Asia/Singapore' },
  { label: '(UTC+09:00) Tokyo, Osaka, Sapporo', value: 'Asia/Tokyo' },
  { label: '(UTC+09:00) Seoul', value: 'Asia/Seoul' },
  { label: '(UTC+10:00) Brisbane', value: 'Australia/Brisbane' },
  { label: '(UTC+10:00) Sydney, Melbourne', value: 'Australia/Sydney' },
  { label: '(UTC+10:00) Guam, Port Moresby', value: 'Pacific/Guam' },
  { label: '(UTC+11:00) New Caledonia', value: 'Pacific/Noumea' },
  { label: '(UTC+12:00) Auckland, Wellington', value: 'Pacific/Auckland' },
  { label: '(UTC+12:00) Fiji', value: 'Pacific/Fiji' },
]
</file>

<file path="packages/payload/src/fields/baseFields/baseBlockFields.ts">
import type { Field } from '../config/types.js'

import { baseIDField } from './baseIDField.js'

export const baseBlockFields: Field[] = [
  baseIDField,
  {
    name: 'blockName',
    type: 'text',
    admin: {
      disabled: true,
    },
    label: 'Block Name',
    required: false,
  },
]
</file>

<file path="packages/payload/src/fields/baseFields/baseIDField.ts">
import ObjectIdImport from 'bson-objectid'

import type { TextField } from '../config/types.js'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

export const baseIDField: TextField = {
  name: 'id',
  type: 'text',
  admin: {
    hidden: true,
  },
  defaultValue: () => new ObjectId().toHexString(),
  hooks: {
    beforeChange: [({ value }) => value || new ObjectId().toHexString()],
    beforeDuplicate: [() => new ObjectId().toHexString()],
  },
  label: 'ID',
}
</file>

<file path="packages/payload/src/fields/config/client.ts">
// @ts-strict-ignore
/* eslint-disable perfectionist/sort-switch-case */
// Keep perfectionist/sort-switch-case disabled - it incorrectly messes up the ordering of the switch cases, causing it to break
import type { I18nClient } from '@convexcms/translations'

import type {
  AdminClient,
  ArrayFieldClient,
  Block,
  BlockJSX,
  BlocksFieldClient,
  ClientBlock,
  ClientField,
  Field,
  FieldBase,
  JoinFieldClient,
  LabelsClient,
  RadioFieldClient,
  RowFieldClient,
  SelectFieldClient,
  TabsFieldClient,
} from '../../fields/config/types.js'
import type { Payload } from '../../types/index.js'

import { getFromImportMap } from '../../bin/generateImportMap/utilities/getFromImportMap.js'
import { MissingEditorProp } from '../../errors/MissingEditorProp.js'
import { fieldAffectsData } from '../../fields/config/types.js'
import { flattenTopLevelFields, type ImportMap } from '../../index.js'

// Should not be used - ClientField should be used instead. This is why we don't export ClientField, we don't want people
// to accidentally use it instead of ClientField and get confused

export { ClientField }

export type ServerOnlyFieldProperties =
  | 'dbName' // can be a function
  | 'editor' // This is a `richText` only property
  | 'enumName' // can be a function
  | 'filterOptions' // This is a `relationship` and `upload` only property
  | 'graphQL'
  | 'label'
  | 'typescriptSchema'
  | 'validate'
  | keyof Pick<FieldBase, 'access' | 'custom' | 'defaultValue' | 'hooks'>

export type ServerOnlyFieldAdminProperties = keyof Pick<
  FieldBase['admin'],
  'components' | 'condition'
>

const serverOnlyFieldProperties: Partial<ServerOnlyFieldProperties>[] = [
  'hooks',
  'access',
  'validate',
  'defaultValue',
  'filterOptions', // This is a `relationship` and `upload` only property
  'editor', // This is a `richText` only property
  'custom',
  'typescriptSchema',
  'dbName', // can be a function
  'enumName', // can be a function
  'graphQL', // client does not need graphQL
  // the following props are handled separately (see below):
  // `label`
  // `fields`
  // `blocks`
  // `tabs`
  // `admin`
]
const serverOnlyFieldAdminProperties: Partial<ServerOnlyFieldAdminProperties>[] = [
  'condition',
  'components',
]
type FieldWithDescription = {
  admin: AdminClient
} & ClientField

export const createClientBlocks = ({
  blocks,
  defaultIDType,
  i18n,
  importMap,
}: {
  blocks: (Block | string)[]
  defaultIDType: Payload['config']['db']['defaultIDType']
  i18n: I18nClient
  importMap: ImportMap
}): (ClientBlock | string)[] | ClientBlock[] => {
  const clientBlocks: (ClientBlock | string)[] = []
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i]

    if (typeof block === 'string') {
      // Do not process blocks that are just strings - they are processed once in the client config
      clientBlocks.push(block)
      continue
    }

    const clientBlock: ClientBlock = {
      slug: block.slug,
      fields: [],
    }
    if (block.imageAltText) {
      clientBlock.imageAltText = block.imageAltText
    }
    if (block.imageURL) {
      clientBlock.imageURL = block.imageURL
    }

    if (block.admin?.custom || block.admin?.group) {
      clientBlock.admin = {}
      if (block.admin.custom) {
        clientBlock.admin.custom = block.admin.custom
      }
      if (block.admin.group) {
        clientBlock.admin.group = block.admin.group
      }
    }

    if (block?.admin?.jsx) {
      const jsxResolved = getFromImportMap<BlockJSX>({
        importMap,
        PayloadComponent: block.admin.jsx,
        schemaPath: '',
      })
      clientBlock.jsx = jsxResolved
    }

    if (block?.admin?.disableBlockName) {
      // Check for existing admin object, this way we don't have to spread it in
      if (clientBlock.admin) {
        clientBlock.admin.disableBlockName = block.admin.disableBlockName
      } else {
        clientBlock.admin = { disableBlockName: block.admin.disableBlockName }
      }
    }

    if (block.labels) {
      clientBlock.labels = {} as unknown as LabelsClient

      if (block.labels.singular) {
        if (typeof block.labels.singular === 'function') {
          clientBlock.labels.singular = block.labels.singular({ i18n, t: i18n.t })
        } else {
          clientBlock.labels.singular = block.labels.singular
        }
        if (typeof block.labels.plural === 'function') {
          clientBlock.labels.plural = block.labels.plural({ i18n, t: i18n.t })
        } else {
          clientBlock.labels.plural = block.labels.plural
        }
      }
    }

    clientBlock.fields = createClientFields({
      defaultIDType,
      fields: block.fields,
      i18n,
      importMap,
    })

    clientBlocks.push(clientBlock)
  }

  return clientBlocks
}

export const createClientField = ({
  defaultIDType,
  field: incomingField,
  i18n,
  importMap,
}: {
  defaultIDType: Payload['config']['db']['defaultIDType']
  field: Field
  i18n: I18nClient
  importMap: ImportMap
}): ClientField => {
  const clientField: ClientField = {} as ClientField

  for (const key in incomingField) {
    if (serverOnlyFieldProperties.includes(key as any)) {
      continue
    }

    switch (key) {
      case 'admin':
        if (!incomingField.admin) {
          break
        }

        clientField.admin = {} as AdminClient

        for (const adminKey in incomingField.admin) {
          if (serverOnlyFieldAdminProperties.includes(adminKey as any)) {
            continue
          }

          switch (adminKey) {
            case 'description':
              if ('description' in incomingField.admin) {
                if (typeof incomingField.admin?.description !== 'function') {
                  ;(clientField as FieldWithDescription).admin.description =
                    incomingField.admin.description
                }
              }

              break

            default:
              clientField.admin[adminKey] = incomingField.admin[adminKey]
          }
        }

        break

      case 'blocks':
      case 'fields':
      case 'tabs':
        // Skip - we handle sub-fields in the switch below
        break

      case 'label':
        //@ts-expect-error - would need to type narrow
        if (typeof incomingField.label === 'function') {
          //@ts-expect-error - would need to type narrow
          clientField.label = incomingField.label({ i18n, t: i18n.t })
        } else {
          //@ts-expect-error - would need to type narrow
          clientField.label = incomingField.label
        }

        break

      default:
        clientField[key] = incomingField[key]
    }
  }

  switch (incomingField.type) {
    case 'array': {
      if (incomingField.labels) {
        const field = clientField as unknown as ArrayFieldClient

        field.labels = {} as unknown as LabelsClient

        if (incomingField.labels.singular) {
          if (typeof incomingField.labels.singular === 'function') {
            field.labels.singular = incomingField.labels.singular({ i18n, t: i18n.t })
          } else {
            field.labels.singular = incomingField.labels.singular
          }
          if (typeof incomingField.labels.plural === 'function') {
            field.labels.plural = incomingField.labels.plural({ i18n, t: i18n.t })
          } else {
            field.labels.plural = incomingField.labels.plural
          }
        }
      }
    }
    // falls through
    case 'collapsible':
    case 'group':
    case 'row': {
      const field = clientField as unknown as RowFieldClient

      if (!field.fields) {
        field.fields = []
      }

      field.fields = createClientFields({
        defaultIDType,
        disableAddingID: incomingField.type !== 'array',
        fields: incomingField.fields,
        i18n,
        importMap,
      })

      break
    }

    case 'blocks': {
      const field = clientField as unknown as BlocksFieldClient

      if (incomingField.labels) {
        field.labels = {} as unknown as LabelsClient

        if (incomingField.labels.singular) {
          if (typeof incomingField.labels.singular === 'function') {
            field.labels.singular = incomingField.labels.singular({ i18n, t: i18n.t })
          } else {
            field.labels.singular = incomingField.labels.singular
          }
          if (typeof incomingField.labels.plural === 'function') {
            field.labels.plural = incomingField.labels.plural({ i18n, t: i18n.t })
          } else {
            field.labels.plural = incomingField.labels.plural
          }
        }
      }

      if (incomingField.blockReferences?.length) {
        field.blockReferences = createClientBlocks({
          blocks: incomingField.blockReferences,
          defaultIDType,
          i18n,
          importMap,
        })
      }

      if (incomingField.blocks?.length) {
        field.blocks = createClientBlocks({
          blocks: incomingField.blocks,
          defaultIDType,
          i18n,
          importMap,
        }) as ClientBlock[]
      }

      break
    }

    case 'join': {
      const field = clientField as JoinFieldClient

      field.targetField = {
        relationTo: field.targetField?.relationTo,
      }

      break
    }

    case 'radio':
    // falls through
    case 'select': {
      const field = clientField as RadioFieldClient | SelectFieldClient

      if (incomingField.options?.length) {
        for (let i = 0; i < incomingField.options.length; i++) {
          const option = incomingField.options[i]

          if (typeof option === 'object' && typeof option.label === 'function') {
            if (!field.options) {
              field.options = []
            }

            field.options[i] = {
              label: option.label({ i18n, t: i18n.t }),
              value: option.value,
            }
          }
        }
      }

      break
    }

    case 'richText': {
      if (!incomingField?.editor) {
        throw new MissingEditorProp(incomingField) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof incomingField?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      break
    }

    case 'tabs': {
      const field = clientField as unknown as TabsFieldClient

      if (incomingField.tabs?.length) {
        field.tabs = []

        for (let i = 0; i < incomingField.tabs.length; i++) {
          const tab = incomingField.tabs[i]
          const clientTab = {} as unknown as TabsFieldClient['tabs'][0]

          for (const key in tab) {
            if (serverOnlyFieldProperties.includes(key as any)) {
              continue
            }

            const tabProp = tab[key]

            if (key === 'fields') {
              clientTab.fields = createClientFields({
                defaultIDType,
                disableAddingID: true,
                fields: tab.fields,
                i18n,
                importMap,
              })
            } else if (
              (key === 'label' || key === 'description') &&
              typeof tabProp === 'function'
            ) {
              clientTab[key] = tabProp({ t: i18n.t })
            } else if (key === 'admin') {
              clientTab.admin = {} as AdminClient

              for (const adminKey in tab.admin) {
                if (serverOnlyFieldAdminProperties.includes(adminKey as any)) {
                  continue
                }

                switch (adminKey) {
                  case 'description':
                    if ('description' in tab.admin) {
                      if (typeof tab.admin?.description === 'function') {
                        clientTab.admin.description = tab.admin.description({ i18n, t: i18n.t })
                      } else {
                        clientTab.admin.description = tab.admin.description
                      }
                    }

                    break

                  default:
                    clientField.admin[adminKey] = tab.admin[adminKey]
                }
              }
            } else {
              clientTab[key] = tabProp
            }
          }
          field.tabs[i] = clientTab
        }
      }

      break
    }

    default:
      break
  }

  return clientField
}

export const createClientFields = ({
  defaultIDType,
  disableAddingID,
  fields,
  i18n,
  importMap,
}: {
  defaultIDType: Payload['config']['db']['defaultIDType']
  disableAddingID?: boolean
  fields: Field[]
  i18n: I18nClient
  importMap: ImportMap
}): ClientField[] => {
  const clientFields: ClientField[] = []

  for (let i = 0; i < fields.length; i++) {
    const field = fields[i]

    const clientField = createClientField({
      defaultIDType,
      field,
      i18n,
      importMap,
    })

    clientFields.push(clientField)
  }

  const hasID = flattenTopLevelFields(fields).some((f) => fieldAffectsData(f) && f.name === 'id')

  if (!disableAddingID && !hasID) {
    clientFields.push({
      name: 'id',
      type: defaultIDType,
      admin: {
        description: 'The unique identifier for this document',
        disableBulkEdit: true,
        disabled: true,
        hidden: true,
      },
      hidden: true,
      label: 'ID',
    })
  }

  return clientFields
}
</file>

<file path="packages/payload/src/fields/config/sanitize.spec.ts">
import type { Config } from '../../config/types.js'
import type {
  ArrayField,
  Block,
  BlocksField,
  CheckboxField,
  Field,
  NumberField,
  TextField,
} from './types.js'

import { InvalidFieldName, InvalidFieldRelationship, MissingFieldType } from '../../errors/index.js'
import { sanitizeFields } from './sanitize.js'

describe('sanitizeFields', () => {
  const config = {} as Config
  it('should throw on missing type field', async () => {
    const fields: Field[] = [
      // @ts-expect-error
      {
        name: 'Some Collection',
        label: 'some-collection',
      },
    ]
    await expect(async () => {
      await sanitizeFields({
        config,
        fields,
        validRelationships: [],
      })
    }).rejects.toThrow(MissingFieldType)
  })
  it('should throw on invalid field name', async () => {
    const fields: Field[] = [
      {
        name: 'some.collection',
        type: 'text',
        label: 'some.collection',
      },
    ]
    await expect(async () => {
      await sanitizeFields({
        config,
        fields,
        validRelationships: [],
      })
    }).rejects.toThrow(InvalidFieldName)
  })

  describe('auto-labeling', () => {
    it('should populate label if missing', async () => {
      const fields: Field[] = [
        {
          name: 'someField',
          type: 'text',
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as TextField
      expect(sanitizedField.name).toStrictEqual('someField')
      expect(sanitizedField.label).toStrictEqual('Some Field')
      expect(sanitizedField.type).toStrictEqual('text')
    })
    it('should allow auto-label override', async () => {
      const fields: Field[] = [
        {
          name: 'someField',
          type: 'text',
          label: 'Do not label',
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as TextField
      expect(sanitizedField.name).toStrictEqual('someField')
      expect(sanitizedField.label).toStrictEqual('Do not label')
      expect(sanitizedField.type).toStrictEqual('text')
    })

    describe('opt-out', () => {
      it('should allow label opt-out', async () => {
        const fields: Field[] = [
          {
            name: 'someField',
            type: 'text',
            label: false,
          },
        ]
        const sanitizedField = (
          await sanitizeFields({
            config,
            fields,
            validRelationships: [],
          })
        )[0] as TextField
        expect(sanitizedField.name).toStrictEqual('someField')
        expect(sanitizedField.label).toStrictEqual(false)
        expect(sanitizedField.type).toStrictEqual('text')
      })

      it('should allow label opt-out for arrays', async () => {
        const arrayField: ArrayField = {
          name: 'items',
          type: 'array',
          fields: [
            {
              name: 'itemName',
              type: 'text',
            },
          ],
          label: false,
        }
        const sanitizedField = (
          await sanitizeFields({
            config,
            fields: [arrayField],
            validRelationships: [],
          })
        )[0] as ArrayField
        expect(sanitizedField.name).toStrictEqual('items')
        expect(sanitizedField.label).toStrictEqual(false)
        expect(sanitizedField.type).toStrictEqual('array')
        expect(sanitizedField.labels).toBeUndefined()
      })
      it('should allow label opt-out for blocks', async () => {
        const fields: Field[] = [
          {
            name: 'noLabelBlock',
            type: 'blocks',
            blocks: [
              {
                slug: 'number',
                fields: [
                  {
                    name: 'testNumber',
                    type: 'number',
                  },
                ],
              },
            ],
            label: false,
          },
        ]
        const sanitizedField = (
          await sanitizeFields({
            config,
            fields,
            validRelationships: [],
          })
        )[0] as BlocksField
        expect(sanitizedField.name).toStrictEqual('noLabelBlock')
        expect(sanitizedField.label).toStrictEqual(false)
        expect(sanitizedField.type).toStrictEqual('blocks')
        expect(sanitizedField.labels).toBeUndefined()
      })
    })

    it('should label arrays with plural and singular', async () => {
      const fields: Field[] = [
        {
          name: 'items',
          type: 'array',
          fields: [
            {
              name: 'itemName',
              type: 'text',
            },
          ],
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as ArrayField
      expect(sanitizedField.name).toStrictEqual('items')
      expect(sanitizedField.label).toStrictEqual('Items')
      expect(sanitizedField.type).toStrictEqual('array')
      expect(sanitizedField.labels).toMatchObject({ plural: 'Items', singular: 'Item' })
    })

    it('should label blocks with plural and singular', async () => {
      const fields: Field[] = [
        {
          name: 'specialBlock',
          type: 'blocks',
          blocks: [
            {
              slug: 'number',
              fields: [{ name: 'testNumber', type: 'number' }],
            },
          ],
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as BlocksField
      expect(sanitizedField.name).toStrictEqual('specialBlock')
      expect(sanitizedField.label).toStrictEqual('Special Block')
      expect(sanitizedField.type).toStrictEqual('blocks')
      expect(sanitizedField.labels).toMatchObject({
        plural: 'Special Blocks',
        singular: 'Special Block',
      })
      expect((sanitizedField.blocks[0].fields[0] as NumberField).label).toStrictEqual('Test Number')
    })
  })

  describe('relationships', () => {
    it('should not throw on valid relationship', async () => {
      const validRelationships = ['some-collection']
      const fields: Field[] = [
        {
          name: 'My Relationship',
          type: 'relationship',
          label: 'my-relationship',
          relationTo: 'some-collection',
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).not.toThrow()
    })

    it('should not throw on valid relationship - multiple', async () => {
      const validRelationships = ['some-collection', 'another-collection']
      const fields: Field[] = [
        {
          name: 'My Relationship',
          type: 'relationship',
          label: 'my-relationship',
          relationTo: ['some-collection', 'another-collection'],
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).not.toThrow()
    })

    it('should not throw on valid relationship inside blocks', async () => {
      const validRelationships = ['some-collection']
      const relationshipBlock: Block = {
        slug: 'relationshipBlock',
        fields: [
          {
            name: 'My Relationship',
            type: 'relationship',
            label: 'my-relationship',
            relationTo: 'some-collection',
          },
        ],
      }
      const fields: Field[] = [
        {
          name: 'layout',
          type: 'blocks',
          blocks: [relationshipBlock],
          label: 'Layout Blocks',
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).not.toThrow()
    })

    it('should throw on invalid relationship', async () => {
      const validRelationships = ['some-collection']
      const fields: Field[] = [
        {
          name: 'My Relationship',
          type: 'relationship',
          label: 'my-relationship',
          relationTo: 'not-valid',
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).rejects.toThrow(InvalidFieldRelationship)
    })

    it('should throw on invalid relationship - multiple', async () => {
      const validRelationships = ['some-collection', 'another-collection']
      const fields: Field[] = [
        {
          name: 'My Relationship',
          type: 'relationship',
          label: 'my-relationship',
          relationTo: ['some-collection', 'not-valid'],
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).rejects.toThrow(InvalidFieldRelationship)
    })

    it('should throw on invalid relationship inside blocks', async () => {
      const validRelationships = ['some-collection']
      const relationshipBlock: Block = {
        slug: 'relationshipBlock',
        fields: [
          {
            name: 'My Relationship',
            type: 'relationship',
            label: 'my-relationship',
            relationTo: 'not-valid',
          },
        ],
      }
      const fields: Field[] = [
        {
          name: 'layout',
          type: 'blocks',
          blocks: [relationshipBlock],
          label: 'Layout Blocks',
        },
      ]
      await expect(async () => {
        await sanitizeFields({ config, fields, validRelationships })
      }).rejects.toThrow(InvalidFieldRelationship)
    })

    it('should defaultValue of checkbox to false if required and undefined', async () => {
      const fields: Field[] = [
        {
          name: 'My Checkbox',
          type: 'checkbox',
          required: true,
        },
      ]

      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as CheckboxField
      expect(sanitizedField.defaultValue).toStrictEqual(false)
    })

    it('should return empty field array if no fields', async () => {
      const sanitizedFields = await sanitizeFields({
        config,
        fields: [],
        validRelationships: [],
      })
      expect(sanitizedFields).toStrictEqual([])
    })
  })
  describe('blocks', () => {
    it('should maintain admin.blockName true after sanitization', async () => {
      const fields: Field[] = [
        {
          name: 'noLabelBlock',
          type: 'blocks',
          blocks: [
            {
              slug: 'number',
              admin: {
                disableBlockName: true,
              },
              fields: [
                {
                  name: 'testNumber',
                  type: 'number',
                },
              ],
            },
          ],
          label: false,
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as BlocksField

      const sanitizedBlock = sanitizedField.blocks[0]

      expect(sanitizedBlock.admin?.disableBlockName).toStrictEqual(true)
    })
    it('should default admin.disableBlockName to true after sanitization', async () => {
      const fields: Field[] = [
        {
          name: 'noLabelBlock',
          type: 'blocks',
          blocks: [
            {
              slug: 'number',
              fields: [
                {
                  name: 'testNumber',
                  type: 'number',
                },
              ],
            },
          ],
          label: false,
        },
      ]
      const sanitizedField = (
        await sanitizeFields({
          config,
          fields,
          validRelationships: [],
        })
      )[0] as BlocksField

      const sanitizedBlock = sanitizedField.blocks[0]

      expect(sanitizedBlock.admin?.disableBlockName).toStrictEqual(undefined)
    })
  })
})
</file>

<file path="packages/payload/src/fields/config/sanitize.ts">
// @ts-strict-ignore
import { deepMergeSimple } from '@convexcms/translations/utilities'
import { v4 as uuid } from 'uuid'

import type {
  CollectionConfig,
  SanitizedJoin,
  SanitizedJoins,
} from '../../collections/config/types.js'
import type { Config, SanitizedConfig } from '../../config/types.js'
import type { Field } from './types.js'

import {
  DuplicateFieldName,
  InvalidFieldName,
  InvalidFieldRelationship,
  MissingEditorProp,
  MissingFieldType,
} from '../../errors/index.js'
import { formatLabels, toWords } from '../../utilities/formatLabels.js'
import { baseBlockFields } from '../baseFields/baseBlockFields.js'
import { baseIDField } from '../baseFields/baseIDField.js'
import { baseTimezoneField } from '../baseFields/timezone/baseField.js'
import { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'
import { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'
import { validations } from '../validations.js'
import { sanitizeJoinField } from './sanitizeJoinField.js'
import { fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'

type Args = {
  collectionConfig?: CollectionConfig
  config: Config
  existingFieldNames?: Set<string>
  fields: Field[]
  joinPath?: string
  /**
   * When not passed in, assume that join are not supported (globals, arrays, blocks)
   */
  joins?: SanitizedJoins
  parentIsLocalized: boolean
  polymorphicJoins?: SanitizedJoin[]

  /**
   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.
   *
   * @default false
   */
  requireFieldLevelRichTextEditor?: boolean
  /**
   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises
   * so that you can sanitize them together, after the config has been sanitized.
   */
  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>
  /**
   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.
   * This validation will be skipped if validRelationships is null.
   */
  validRelationships: null | string[]
}

export const sanitizeFields = async ({
  config,
  existingFieldNames = new Set(),
  fields,
  joinPath = '',
  joins,
  parentIsLocalized,
  polymorphicJoins,
  requireFieldLevelRichTextEditor = false,
  richTextSanitizationPromises,
  validRelationships,
}: Args): Promise<Field[]> => {
  if (!fields) {
    return []
  }

  for (let i = 0; i < fields.length; i++) {
    const field = fields[i]

    if ('_sanitized' in field && field._sanitized === true) {
      continue
    }
    if ('_sanitized' in field) {
      field._sanitized = true
    }

    if (!field.type) {
      throw new MissingFieldType(field)
    }

    // assert that field names do not contain forbidden characters
    if (fieldAffectsData(field) && field.name.includes('.')) {
      throw new InvalidFieldName(field, field.name)
    }

    // Auto-label
    if (
      'name' in field &&
      field.name &&
      typeof field.label !== 'object' &&
      typeof field.label !== 'string' &&
      typeof field.label !== 'function' &&
      field.label !== false
    ) {
      field.label = toWords(field.name)
    }

    if (
      field.type === 'checkbox' &&
      typeof field.defaultValue === 'undefined' &&
      field.required === true
    ) {
      field.defaultValue = false
    }

    if (field.type === 'join') {
      sanitizeJoinField({ config, field, joinPath, joins, parentIsLocalized, polymorphicJoins })
    }

    if (field.type === 'relationship' || field.type === 'upload') {
      if (validRelationships) {
        const relationships = Array.isArray(field.relationTo)
          ? field.relationTo
          : [field.relationTo]
        relationships.forEach((relationship: string) => {
          if (!validRelationships.includes(relationship)) {
            throw new InvalidFieldRelationship(field, relationship)
          }
        })
      }

      if (field.min && !field.minRows) {
        console.warn(
          `(payload): The "min" property is deprecated for the Relationship field "${field.name}" and will be removed in a future version. Please use "minRows" instead.`,
        )
        field.minRows = field.min
      }
      if (field.max && !field.maxRows) {
        console.warn(
          `(payload): The "max" property is deprecated for the Relationship field "${field.name}" and will be removed in a future version. Please use "maxRows" instead.`,
        )
        field.maxRows = field.max
      }
    }

    if (field.type === 'upload') {
      if (!field.admin || !('isSortable' in field.admin)) {
        field.admin = {
          isSortable: true,
          ...field.admin,
        }
      }
    }

    if (field.type === 'array' && field.fields) {
      field.fields.push(baseIDField)
    }

    if ((field.type === 'blocks' || field.type === 'array') && field.label) {
      field.labels = field.labels || formatLabels(field.name)
    }

    if (fieldAffectsData(field)) {
      if (existingFieldNames.has(field.name)) {
        throw new DuplicateFieldName(field.name)
      } else if (!['blockName', 'id'].includes(field.name)) {
        existingFieldNames.add(field.name)
      }

      if (typeof field.localized !== 'undefined') {
        let shouldDisableLocalized = !config.localization

        if (
          process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized !== 'true' &&
          parentIsLocalized &&
          // @todo PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY=true will be the default in 4.0
          process.env.PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY !== 'true'
        ) {
          shouldDisableLocalized = true
        }

        if (shouldDisableLocalized) {
          delete field.localized
        }
      }

      if (typeof field.validate === 'undefined') {
        const defaultValidate = validations[field.type]
        if (defaultValidate) {
          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })
        } else {
          field.validate = (): true => true
        }
      }

      if (!field.hooks) {
        field.hooks = {}
      }
      if (!field.access) {
        field.access = {}
      }

      setDefaultBeforeDuplicate(field, parentIsLocalized)
    }

    if (!field.admin) {
      field.admin = {}
    }

    // Make sure that the richText field has an editor
    if (field.type === 'richText') {
      const sanitizeRichText = async (_config: SanitizedConfig) => {
        if (!field.editor) {
          if (_config.editor && !requireFieldLevelRichTextEditor) {
            // config.editor should be sanitized at this point
            field.editor = _config.editor
          } else {
            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
          }
        }

        if (typeof field.editor === 'function') {
          field.editor = await field.editor({
            config: _config,
            isRoot: requireFieldLevelRichTextEditor,
            parentIsLocalized: parentIsLocalized || field.localized,
          })
        }

        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {
          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)
        }
      }
      if (richTextSanitizationPromises) {
        richTextSanitizationPromises.push(sanitizeRichText)
      } else {
        await sanitizeRichText(config as unknown as SanitizedConfig)
      }
    }

    if (field.type === 'blocks' && field.blocks) {
      if (field.blockReferences && field.blocks?.length) {
        throw new Error('You cannot have both blockReferences and blocks in the same blocks field')
      }

      for (const block of field.blockReferences ?? field.blocks) {
        if (typeof block === 'string') {
          continue
        }
        if (block._sanitized === true) {
          continue
        }
        block._sanitized = true
        block.fields = block.fields.concat(baseBlockFields)
        block.labels = !block.labels ? formatLabels(block.slug) : block.labels
        block.fields = await sanitizeFields({
          config,
          existingFieldNames: new Set(),
          fields: block.fields,
          parentIsLocalized: parentIsLocalized || field.localized,
          requireFieldLevelRichTextEditor,
          richTextSanitizationPromises,
          validRelationships,
        })
      }
    }

    if ('fields' in field && field.fields) {
      field.fields = await sanitizeFields({
        config,
        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,
        fields: field.fields,
        joinPath: fieldAffectsData(field)
          ? `${joinPath ? joinPath + '.' : ''}${field.name}`
          : joinPath,
        joins,
        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),
        polymorphicJoins,
        requireFieldLevelRichTextEditor,
        richTextSanitizationPromises,
        validRelationships,
      })
    }

    if (field.type === 'tabs') {
      for (let j = 0; j < field.tabs.length; j++) {
        const tab = field.tabs[j]
        if (tabHasName(tab) && typeof tab.label === 'undefined') {
          tab.label = toWords(tab.name)
        }

        if (
          'admin' in tab &&
          tab.admin?.condition &&
          typeof tab.admin.condition === 'function' &&
          !tab.id
        ) {
          // Always attach a UUID to tabs with a condition so there's no conflicts even if there are duplicate nested names
          tab.id = tabHasName(tab) ? `${tab.name}_${uuid()}` : uuid()
        }

        tab.fields = await sanitizeFields({
          config,
          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,
          fields: tab.fields,
          joinPath: tabHasName(tab) ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,
          joins,
          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),
          polymorphicJoins,
          requireFieldLevelRichTextEditor,
          richTextSanitizationPromises,
          validRelationships,
        })
        field.tabs[j] = tab
      }
    }

    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {
      field.admin.disableBulkEdit = true
    }

    fields[i] = field

    // Insert our field after assignment
    if (field.type === 'date' && field.timezone) {
      const name = field.name + '_tz'
      const defaultTimezone = config.admin.timezones.defaultTimezone

      const supportedTimezones = config.admin.timezones.supportedTimezones

      const options =
        typeof supportedTimezones === 'function'
          ? supportedTimezones({ defaultTimezones })
          : supportedTimezones

      // Need to set the options here manually so that any database enums are generated correctly
      // The UI component will import the options from the config
      const timezoneField = baseTimezoneField({
        name,
        defaultValue: defaultTimezone,
        options,
        required: field.required,
      })

      fields.splice(++i, 0, timezoneField)
    }
  }

  return fields
}
</file>

<file path="packages/payload/src/fields/config/sanitizeJoinField.ts">
// @ts-strict-ignore
import type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'
import type { Config, SanitizedConfig } from '../../config/types.js'

import { APIError } from '../../errors/index.js'
import { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'
import { flattenAllFields } from '../../utilities/flattenAllFields.js'
import { getFieldByPath } from '../../utilities/getFieldByPath.js'
import { traverseFields } from '../../utilities/traverseFields.js'
import {
  fieldShouldBeLocalized,
  type FlattenedJoinField,
  type JoinField,
  type RelationshipField,
  type UploadField,
} from './types.js'
export const sanitizeJoinField = ({
  config,
  field,
  joinPath,
  joins,
  parentIsLocalized,
  polymorphicJoins,
  validateOnly,
}: {
  config: Config
  field: FlattenedJoinField | JoinField
  joinPath?: string
  joins?: SanitizedJoins
  parentIsLocalized: boolean
  polymorphicJoins?: SanitizedJoin[]
  validateOnly?: boolean
}) => {
  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field
  if (typeof joins === 'undefined') {
    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')
  }
  if (typeof field.maxDepth === 'undefined') {
    field.maxDepth = 1
  }
  const join: SanitizedJoin = {
    field,
    joinPath: `${joinPath ? joinPath + '.' : ''}${field.name}`,
    parentIsLocalized,
    targetField: undefined,
  }

  if (Array.isArray(field.collection)) {
    for (const collection of field.collection) {
      const sanitizedField = {
        ...field,
        collection,
      } as FlattenedJoinField

      sanitizeJoinField({
        config,
        field: sanitizedField,
        joinPath,
        joins,
        parentIsLocalized,
        polymorphicJoins,
        validateOnly: true,
      })
    }

    if (Array.isArray(polymorphicJoins)) {
      polymorphicJoins.push(join)
    }

    return
  }

  const joinCollection = config.collections.find(
    (collection) => collection.slug === field.collection,
  )
  if (!joinCollection) {
    throw new InvalidFieldJoin(field)
  }

  const relationshipField = getFieldByPath({
    fields: flattenAllFields({ cache: true, fields: joinCollection.fields }),
    path: field.on,
  })

  if (
    !relationshipField ||
    (relationshipField.field.type !== 'relationship' && relationshipField.field.type !== 'upload')
  ) {
    throw new InvalidFieldJoin(join.field)
  }

  if (relationshipField.pathHasLocalized) {
    join.getForeignPath = ({ locale }) => {
      return relationshipField.localizedPath.replace('<locale>', locale)
    }
  }

  if (!relationshipField.field.index && !relationshipField.field.unique) {
    relationshipField.field.index = true
  }

  if (validateOnly) {
    return
  }

  join.targetField = relationshipField.field

  // override the join field localized property to use whatever the relationship field has
  // or if it's nested to a localized array / blocks / tabs / group
  field.localized = relationshipField.field.localized
  // override the join field hasMany property to use whatever the relationship field has
  field.hasMany = relationshipField.field.hasMany

  // @ts-expect-error converting JoinField to FlattenedJoinField to track targetField
  field.targetField = join.targetField

  if (!joins[field.collection]) {
    joins[field.collection] = [join]
  } else {
    joins[field.collection].push(join)
  }
}
</file>

<file path="packages/payload/src/fields/config/types.ts">
// @ts-strict-ignore
/* eslint-disable @typescript-eslint/no-explicit-any */

import type { EditorProps } from '@monaco-editor/react'
import type { JSONSchema4 } from 'json-schema'
import type { CSSProperties } from 'react'
import type React from 'react'
import type { DeepUndefinable, MarkRequired } from 'ts-essentials'

import type {
  JoinFieldClientProps,
  JoinFieldErrorClientComponent,
  JoinFieldErrorServerComponent,
  JoinFieldLabelClientComponent,
  JoinFieldLabelServerComponent,
} from '../../admin/fields/Join.js'
import type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'
import type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'
import type {
  ArrayFieldClientProps,
  ArrayFieldErrorClientComponent,
  ArrayFieldErrorServerComponent,
  ArrayFieldLabelClientComponent,
  ArrayFieldLabelServerComponent,
  BlocksFieldClientProps,
  BlocksFieldErrorClientComponent,
  BlocksFieldErrorServerComponent,
  BlocksFieldLabelClientComponent,
  BlocksFieldLabelServerComponent,
  CheckboxFieldClientProps,
  CheckboxFieldErrorClientComponent,
  CheckboxFieldErrorServerComponent,
  CheckboxFieldLabelClientComponent,
  CheckboxFieldLabelServerComponent,
  ClientTab,
  CodeFieldClientProps,
  CodeFieldErrorClientComponent,
  CodeFieldErrorServerComponent,
  CodeFieldLabelClientComponent,
  CodeFieldLabelServerComponent,
  CollapsibleFieldClientProps,
  CollapsibleFieldLabelClientComponent,
  CollapsibleFieldLabelServerComponent,
  ConditionalDateProps,
  DateFieldClientProps,
  DateFieldErrorClientComponent,
  DateFieldErrorServerComponent,
  DateFieldLabelClientComponent,
  DateFieldLabelServerComponent,
  DefaultCellComponentProps,
  DefaultServerCellComponentProps,
  Description,
  EmailFieldClientProps,
  EmailFieldErrorClientComponent,
  EmailFieldErrorServerComponent,
  EmailFieldLabelClientComponent,
  EmailFieldLabelServerComponent,
  FieldDescriptionClientProps,
  FieldDescriptionServerProps,
  FieldDiffClientProps,
  FieldDiffServerProps,
  GroupFieldClientProps,
  GroupFieldLabelClientComponent,
  GroupFieldLabelServerComponent,
  HiddenFieldProps,
  JSONFieldClientProps,
  JSONFieldErrorClientComponent,
  JSONFieldErrorServerComponent,
  JSONFieldLabelClientComponent,
  JSONFieldLabelServerComponent,
  NumberFieldClientProps,
  NumberFieldErrorClientComponent,
  NumberFieldErrorServerComponent,
  NumberFieldLabelClientComponent,
  NumberFieldLabelServerComponent,
  PointFieldClientProps,
  PointFieldErrorClientComponent,
  PointFieldErrorServerComponent,
  PointFieldLabelClientComponent,
  PointFieldLabelServerComponent,
  RadioFieldClientProps,
  RadioFieldErrorClientComponent,
  RadioFieldErrorServerComponent,
  RadioFieldLabelClientComponent,
  RadioFieldLabelServerComponent,
  RelationshipFieldClientProps,
  RelationshipFieldErrorClientComponent,
  RelationshipFieldErrorServerComponent,
  RelationshipFieldLabelClientComponent,
  RelationshipFieldLabelServerComponent,
  RichTextFieldClientProps,
  RowFieldClientProps,
  RowLabelComponent,
  SelectFieldClientProps,
  SelectFieldErrorClientComponent,
  SelectFieldErrorServerComponent,
  SelectFieldLabelClientComponent,
  SelectFieldLabelServerComponent,
  StaticDescription,
  TabsFieldClientProps,
  TextareaFieldClientProps,
  TextareaFieldErrorClientComponent,
  TextareaFieldErrorServerComponent,
  TextareaFieldLabelClientComponent,
  TextareaFieldLabelServerComponent,
  TextFieldClientProps,
  TextFieldErrorClientComponent,
  TextFieldErrorServerComponent,
  TextFieldLabelClientComponent,
  TextFieldLabelServerComponent,
  UploadFieldClientProps,
} from '../../admin/types.js'
import type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'
import type {
  CustomComponent,
  LabelFunction,
  PayloadComponent,
  StaticLabel,
} from '../../config/types.js'
import type { DBIdentifierName } from '../../database/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type {
  ArrayFieldValidation,
  BlocksFieldValidation,
  BlockSlug,
  CheckboxFieldValidation,
  CodeFieldValidation,
  CollectionSlug,
  DateFieldValidation,
  EmailFieldValidation,
  JSONFieldValidation,
  PointFieldValidation,
  RadioFieldValidation,
  RequestContext,
  Sort,
  TextareaFieldValidation,
} from '../../index.js'
import type { DocumentPreferences } from '../../preferences/types.js'
import type {
  DefaultValue,
  JsonObject,
  Operation,
  PayloadRequest,
  Where,
} from '../../types/index.js'
import type {
  NumberFieldManyValidation,
  NumberFieldSingleValidation,
  RelationshipFieldManyValidation,
  RelationshipFieldSingleValidation,
  SelectFieldManyValidation,
  SelectFieldSingleValidation,
  TextFieldManyValidation,
  TextFieldSingleValidation,
  UploadFieldManyValidation,
  UploadFieldSingleValidation,
} from '../validations.js'

export type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {
  /**
   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.
   */
  blockData: JsonObject | undefined
  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  /**
   * Only available in `afterRead` hooks
   */
  currentDepth?: number
  /**
   * Only available in `afterRead` hooks
   */
  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */
  data?: Partial<TData>
  /**
   * Only available in the `afterRead` hook.
   */
  depth?: number
  draft?: boolean
  /** The field which the hook is running against. */
  field: FieldAffectingData
  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */
  findMany?: boolean
  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */
  global: null | SanitizedGlobalConfig
  indexPath: number[]
  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */
  operation?: 'create' | 'delete' | 'read' | 'update'
  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */
  originalDoc?: TData
  overrideAccess?: boolean
  /**
   * The path of the field, e.g. ["group", "myArray", 1, "textField"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.
   */
  path: (number | string)[]
  /** The document before changes were applied, only in `afterChange` hooks. */
  previousDoc?: TData
  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */
  previousSiblingDoc?: TData
  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */
  previousValue?: TValue
  /** The Express request object. It is mocked for Local API operations. */
  req: PayloadRequest
  /**
   * The schemaPath of the field, e.g. ["group", "myArray", "textField"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.
   */
  schemaPath: string[]
  /**
   * Only available in the `afterRead` hook.
   */
  showHiddenFields?: boolean
  /** The sibling data passed to a field that the hook is running against. */
  siblingData: Partial<TSiblingData>
  /**
   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.
   */
  siblingDocWithLocales?: Record<string, unknown>
  /**
   * The sibling fields of the field which the hook is running against.
   */
  siblingFields: (Field | TabAsField)[]
  /** The value of the field. */
  value?: TValue
}

export type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (
  args: FieldHookArgs<TData, TValue, TSiblingData>,
) => Promise<TValue> | TValue

export type FieldAccessArgs<TData extends TypeWithID = any, TSiblingData = any> = {
  /**
   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.
   */
  blockData?: JsonObject | undefined
  /**
   * The incoming, top-level document data used to `create` or `update` the document with.
   */
  data?: Partial<TData>
  /**
   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.
   */
  doc?: TData
  /**
   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.
   */
  id?: number | string
  /** The `payload` object to interface with the payload API */
  req: PayloadRequest
  /**
   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.
   */
  siblingData?: Partial<TSiblingData>
}

export type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (
  args: FieldAccessArgs<TData, TSiblingData>,
) => boolean | Promise<boolean>

//TODO: In 4.0, we should replace the three parameters of the condition function with a single, named parameter object
export type Condition<TData extends TypeWithID = any, TSiblingData = any> = (
  /**
   * The top-level document data
   */
  data: Partial<TData>,
  /**
   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.
   */
  siblingData: Partial<TSiblingData>,
  {
    blockData,
    path,
    user,
  }: {
    /**
     * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.
     */
    blockData: Partial<TData>
    /**
     * The path of the field, e.g. ["group", "myArray", 1, "textField"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.
     */
    path: (number | string)[]
    user: PayloadRequest['user']
  },
) => boolean

export type FilterOptionsProps<TData = any> = {
  /**
   * The data of the nearest parent block. Will be `undefined` if the field is not within a block or when called on a `Filter` component within the list view.
   */
  blockData: TData
  /**
   * An object containing the full collection or global document currently being edited. Will be an empty object when called on a `Filter` component within the list view.
   */
  data: TData
  /**
   * The `id` of the current document being edited. Will be undefined during the `create` operation or when called on a `Filter` component within the list view.
   */
  id: number | string
  /**
   * The collection `slug` to filter against, limited to this field's `relationTo` property.
   */
  relationTo: CollectionSlug
  req: PayloadRequest
  /**
   * An object containing document data that is scoped to only fields within the same parent of this field. Will be an empty object when called on a `Filter` component within the list view.
   */
  siblingData: unknown
  /**
   * An object containing the currently authenticated user.
   */
  user: Partial<PayloadRequest['user']>
}

export type FilterOptionsFunc<TData = any> = (
  options: FilterOptionsProps<TData>,
) => boolean | Promise<boolean | Where> | Where

export type FilterOptions<TData = any> =
  | ((options: FilterOptionsProps<TData>) => boolean | Promise<boolean | Where> | Where)
  | null
  | Where

type Admin = {
  className?: string
  components?: {
    Cell?: PayloadComponent<DefaultServerCellComponentProps, DefaultCellComponentProps>
    Description?: PayloadComponent<FieldDescriptionServerProps, FieldDescriptionClientProps>
    Diff?: PayloadComponent<FieldDiffServerProps, FieldDiffClientProps>
    Field?: PayloadComponent<FieldClientComponent | FieldServerComponent>
    /**
     * The Filter component has to be a client component
     */
    Filter?: PayloadComponent
  }
  /**
   * You can programmatically show / hide fields based on what other fields are doing.
   * This is also run on the server, to determine if the field should be validated.
   */
  condition?: Condition
  /** Extension point to add your custom data. Available in server and client. */
  custom?: Record<string, any>
  /**
   * The field description will be displayed next to the field in the admin UI. Additionally,
   * we use the field description to generate JSDoc comments for the generated TypeScript types.
   */
  description?: Description
  disableBulkEdit?: boolean
  disabled?: boolean
  /**
   * Shows / hides fields from appearing in the list view column selector.
   * @type boolean
   */
  disableListColumn?: boolean
  /**
   * Shows / hides fields from appearing in the list view filter options.
   * @type boolean
   */
  disableListFilter?: boolean
  hidden?: boolean
  position?: 'sidebar'
  readOnly?: boolean
  style?: CSSProperties
  width?: CSSProperties['width']
}

export type AdminClient = {
  className?: string
  /** Extension point to add your custom data. Available in server and client. */
  custom?: Record<string, any>
  description?: StaticDescription
  disableBulkEdit?: boolean
  disabled?: boolean
  /**
   * Shows / hides fields from appearing in the list view column selector.
   * @type boolean
   */
  disableListColumn?: boolean
  /**
   * Shows / hides fields from appearing in the list view filter options.
   * @type boolean
   */
  disableListFilter?: boolean
  hidden?: boolean
  position?: 'sidebar'
  readOnly?: boolean
  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties
  width?: CSSProperties['width']
}

export type Labels = {
  plural: LabelFunction | StaticLabel
  singular: LabelFunction | StaticLabel
}

export type LabelsClient = {
  plural: StaticLabel
  singular: StaticLabel
}

export type BaseValidateOptions<TData, TSiblingData, TValue> = {
  /**
  /**
   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.
   */
  blockData: Partial<TData>
  collectionSlug?: string
  data: Partial<TData>
  event?: 'onChange' | 'submit'
  id?: number | string
  operation?: Operation
  /**
   * The path of the field, e.g. ["group", "myArray", 1, "textField"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.
   */
  path: (number | string)[]
  preferences: DocumentPreferences
  previousValue?: TValue
  req: PayloadRequest
  required?: boolean
  siblingData: Partial<TSiblingData>
}

export type ValidateOptions<
  TData,
  TSiblingData,
  TFieldConfig extends object,
  TValue,
> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig

export type Validate<
  TValue = any,
  TData = any,
  TSiblingData = any,
  TFieldConfig extends object = object,
> = (
  value: null | TValue | undefined,
  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,
) => Promise<string | true> | string | true

export type OptionLabel =
  | (() => React.JSX.Element)
  | LabelFunction
  | React.JSX.Element
  | StaticLabel

export type OptionObject = {
  label: OptionLabel
  value: string
}

export type Option = OptionObject | string

export type FieldGraphQLType = {
  graphQL?: {
    /**
     * Complexity for the query. This is used to limit the complexity of the join query.
     *
     * @default 10
     */
    complexity?: number
  }
}

export interface FieldBase {
  /**
   * Do not set this property manually. This is set to true during sanitization, to avoid
   * sanitizing the same field multiple times.
   */
  _sanitized?: boolean
  access?: {
    create?: FieldAccess
    read?: FieldAccess
    update?: FieldAccess
  }
  admin?: Admin
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  defaultValue?: DefaultValue
  hidden?: boolean
  hooks?: {
    afterChange?: FieldHook[]
    afterRead?: FieldHook[]
    beforeChange?: FieldHook[]
    /**
     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.
     */
    beforeDuplicate?: FieldHook[]
    beforeValidate?: FieldHook[]
  }
  index?: boolean
  label?: false | LabelFunction | StaticLabel
  localized?: boolean
  /**
   * The name of the field. Must be alphanumeric and cannot contain ' . '
   *
   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']
   * @link https://payloadcms.com/docs/fields/overview#field-names
   */
  name: string
  required?: boolean
  saveToJWT?: boolean | string
  /**
   * Allows you to modify the base JSON schema that is generated during generate:types for this field.
   * This JSON schema will be used to generate the TypeScript interface of this field.
   */
  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>
  unique?: boolean
  validate?: Validate
  /**
   * Pass `true` to disable field in the DB
   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):
   * A virtual field cannot be used in `admin.useAsTitle`
   */
  virtual?: boolean
}

export interface FieldBaseClient {
  admin?: AdminClient
  hidden?: boolean
  index?: boolean
  label?: StaticLabel
  localized?: boolean
  /**
   * The name of the field. Must be alphanumeric and cannot contain ' . '
   *
   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']
   * @link https://payloadcms.com/docs/fields/overview#field-names
   */
  name: string
  required?: boolean
  saveToJWT?: boolean | string
  /**
   * Allows you to modify the base JSON schema that is generated during generate:types for this field.
   * This JSON schema will be used to generate the TypeScript interface of this field.
   */
  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>
  unique?: boolean
}

export type NumberField = {
  admin?: {
    /** Set this property to a string that will be used for browser autocomplete. */
    autoComplete?: string
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>
      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>
    } & Admin['components']
    /** Set this property to define a placeholder string for the field. */
    placeholder?: Record<string, string> | string
    /** Set a value for the number field to increment / decrement using browser controls. */
    step?: number
  } & Admin
  /** Maximum value accepted. Used in the default `validate` function. */
  max?: number
  /** Minimum value accepted. Used in the default `validate` function. */
  min?: number
  type: 'number'
} & (
  | {
      /** Makes this field an ordered array of numbers instead of just a single number. */
      hasMany: true
      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */
      maxRows?: number
      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */
      minRows?: number
      validate?: NumberFieldManyValidation
    }
  | {
      /** Makes this field an ordered array of numbers instead of just a single number. */
      hasMany?: false | undefined
      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */
      maxRows?: undefined
      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */
      minRows?: undefined
      validate?: NumberFieldSingleValidation
    }
) &
  Omit<FieldBase, 'validate'>

export type NumberFieldClient = {
  admin?: AdminClient & Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>
} & FieldBaseClient &
  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>

export type TextField = {
  admin?: {
    autoComplete?: string
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>
      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>
    } & Admin['components']
    placeholder?: Record<string, string> | string
    rtl?: boolean
  } & Admin
  maxLength?: number
  minLength?: number
  type: 'text'
} & (
  | {
      /** Makes this field an ordered array of strings instead of just a single string. */
      hasMany: true
      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */
      maxRows?: number
      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */
      minRows?: number
      validate?: TextFieldManyValidation
    }
  | {
      /** Makes this field an ordered array of strings instead of just a single string. */
      hasMany?: false | undefined
      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */
      maxRows?: undefined
      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */
      minRows?: undefined
      validate?: TextFieldSingleValidation
    }
) &
  Omit<FieldBase, 'validate'>

export type TextFieldClient = {
  admin?: AdminClient & Pick<TextField['admin'], 'autoComplete' | 'placeholder' | 'rtl'>
} & FieldBaseClient &
  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>

export type EmailField = {
  admin?: {
    autoComplete?: string
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>
      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>
    } & Admin['components']
    placeholder?: Record<string, string> | string
  } & Admin
  type: 'email'
  validate?: EmailFieldValidation
} & Omit<FieldBase, 'validate'>

export type EmailFieldClient = {
  admin?: AdminClient & Pick<EmailField['admin'], 'autoComplete' | 'placeholder'>
} & FieldBaseClient &
  Pick<EmailField, 'type'>

export type TextareaField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>
      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>
    } & Admin['components']
    placeholder?: Record<string, string> | string
    rows?: number
    rtl?: boolean
  } & Admin
  maxLength?: number
  minLength?: number
  type: 'textarea'
  validate?: TextareaFieldValidation
} & Omit<FieldBase, 'validate'>

export type TextareaFieldClient = {
  admin?: AdminClient & Pick<TextareaField['admin'], 'placeholder' | 'rows' | 'rtl'>
} & FieldBaseClient &
  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>

export type CheckboxField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>
      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>
    } & Admin['components']
  } & Admin
  type: 'checkbox'
  validate?: CheckboxFieldValidation
} & Omit<FieldBase, 'validate'>

export type CheckboxFieldClient = {
  admin?: AdminClient
} & FieldBaseClient &
  Pick<CheckboxField, 'type'>

export type DateField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>
      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>
    } & Admin['components']
    date?: ConditionalDateProps
    placeholder?: Record<string, string> | string
  } & Admin
  /**
   * Enable timezone selection in the admin interface.
   */
  timezone?: true
  type: 'date'
  validate?: DateFieldValidation
} & Omit<FieldBase, 'validate'>

export type DateFieldClient = {
  admin?: AdminClient & Pick<DateField['admin'], 'date' | 'placeholder'>
} & FieldBaseClient &
  Pick<DateField, 'timezone' | 'type'>

export type GroupField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>
    } & Admin['components']
    hideGutter?: boolean
  } & Admin
  fields: Field[]
  /** Customize generated GraphQL and Typescript schema names.
   * By default, it is bound to the collection.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
  type: 'group'
  validate?: Validate<unknown, unknown, unknown, GroupField>
} & Omit<FieldBase, 'required' | 'validate'>

export type GroupFieldClient = {
  admin?: AdminClient & Pick<GroupField['admin'], 'hideGutter'>
  fields: ClientField[]
} & Omit<FieldBaseClient, 'required'> &
  Pick<GroupField, 'interfaceName' | 'type'>

export type RowField = {
  admin?: Omit<Admin, 'description'>
  fields: Field[]
  type: 'row'
} & Omit<FieldBase, 'admin' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>

export type RowFieldClient = {
  admin?: Omit<AdminClient, 'description'>
  fields: ClientField[]
} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &
  Pick<RowField, 'type'>

export type CollapsibleField = {
  fields: Field[]
  type: 'collapsible'
} & (
  | {
      admin: {
        components: {
          afterInput?: CustomComponent[]
          beforeInput?: CustomComponent[]
          Label: CustomComponent<
            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent
          >
        } & Admin['components']
        initCollapsed?: boolean
      } & Admin
      label?: Required<FieldBase['label']>
    }
  | {
      admin?: {
        components?: {
          afterInput?: CustomComponent[]
          beforeInput?: CustomComponent[]
          Label?: CustomComponent<
            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent
          >
        } & Admin['components']
        initCollapsed?: boolean
      } & Admin
      label: Required<FieldBase['label']>
    }
) &
  Omit<FieldBase, 'label' | 'localized' | 'name' | 'validate' | 'virtual'>

export type CollapsibleFieldClient = {
  admin?: {
    initCollapsed?: boolean
  } & AdminClient
  fields: ClientField[]
  label: StaticLabel
} & Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &
  Pick<CollapsibleField, 'type'>

type TabBase = {
  /**
   * @deprecated
   * Use `admin.description` instead. This will be removed in a future major version.
   */
  description?: LabelFunction | StaticDescription
  fields: Field[]
  id?: string
  interfaceName?: string
  saveToJWT?: boolean | string
} & Omit<FieldBase, 'required' | 'validate'>

export type NamedTab = {
  /** Customize generated GraphQL and Typescript schema names.
   * The slug is used by default.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
} & TabBase

export type UnnamedTab = {
  interfaceName?: never
  /**
   * Can be either:
   * - A string, which will be used as the tab's label.
   * - An object, where the key is the language code and the value is the label.
   */
  label:
    | {
        [selectedLanguage: string]: string
      }
    | LabelFunction
    | string
  localized?: never
} & Omit<TabBase, 'name' | 'virtual'>

export type Tab = NamedTab | UnnamedTab
export type TabsField = {
  admin?: Omit<Admin, 'description'>
  type: 'tabs'
} & {
  tabs: Tab[]
} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>

export type TabsFieldClient = {
  admin?: Omit<AdminClient, 'description'>
  tabs: ClientTab[]
} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &
  Pick<TabsField, 'type'>

export type TabAsField = {
  name?: string
  type: 'tab'
} & Tab

export type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>

export type UIField = {
  admin: {
    components?: {
      /**
       * Allow any custom components to be added to the UI field. This allows
       * the UI field to be used as a vessel for getting components rendered.
       */
      [key: string]: PayloadComponent | undefined
      Cell?: CustomComponent
      // Can be optional, in case the UI field is just used as a vessel for custom components
      Field?: CustomComponent
      /**
       * The Filter component has to be a client component
       */
      Filter?: PayloadComponent
    } & Admin['components']
    condition?: Condition
    /** Extension point to add your custom data. Available in server and client. */
    custom?: Record<string, any>
    /**
     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.
     * @default true
     */
    disableBulkEdit?: boolean
    /**
     * Shows / hides fields from appearing in the list view column selector.
     * @type boolean
     */
    disableListColumn?: boolean
    position?: string
    width?: CSSProperties['width']
  }
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  label?: Record<string, string> | string
  name: string
  type: 'ui'
}

export type UIFieldClient = {
  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))

  admin: DeepUndefinable<FieldBaseClient['admin']> &
    Pick<
      UIField['admin'],
      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'
    >
} & Omit<DeepUndefinable<FieldBaseClient>, 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))
  Pick<UIField, 'label' | 'name' | 'type'>

type SharedUploadProperties = {
  /**
   * Toggle the preview in the admin interface.
   */
  displayPreview?: boolean
  filterOptions?: FilterOptions
  /**
   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.
   *
   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}
   */
  maxDepth?: number
  type: 'upload'
} & (
  | {
      hasMany: true
      /**
       * @deprecated Use 'maxRows' instead
       */
      max?: number
      maxRows?: number
      /**
       * @deprecated Use 'minRows' instead
       */
      min?: number
      minRows?: number
      validate?: UploadFieldManyValidation
    }
  | {
      hasMany?: false | undefined
      /**
       * @deprecated Use 'maxRows' instead
       */
      max?: undefined
      maxRows?: undefined
      /**
       * @deprecated Use 'minRows' instead
       */
      min?: undefined
      minRows?: undefined
      validate?: UploadFieldSingleValidation
    }
) &
  FieldGraphQLType &
  Omit<FieldBase, 'validate'>

type SharedUploadPropertiesClient = FieldBaseClient &
  Pick<
    SharedUploadProperties,
    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'
  >

type UploadAdmin = {
  allowCreate?: boolean
  components?: {
    Error?: CustomComponent<
      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent
    >
    Label?: CustomComponent<
      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent
    >
  } & Admin['components']
  isSortable?: boolean
} & Admin

type UploadAdminClient = AdminClient & Pick<UploadAdmin, 'allowCreate' | 'isSortable'>

export type PolymorphicUploadField = {
  admin?: {
    sortOptions?: Partial<Record<CollectionSlug, string>>
  } & UploadAdmin
  relationTo: CollectionSlug[]
} & SharedUploadProperties

export type PolymorphicUploadFieldClient = {
  admin?: {
    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>
  } & UploadAdminClient
} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &
  SharedUploadPropertiesClient

export type SingleUploadField = {
  admin?: {
    sortOptions?: string
  } & UploadAdmin
  relationTo: CollectionSlug
} & SharedUploadProperties

export type SingleUploadFieldClient = {
  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient
} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &
  SharedUploadPropertiesClient

export type UploadField = /* PolymorphicUploadField | */ SingleUploadField

export type UploadFieldClient = /* PolymorphicUploadFieldClient | */ SingleUploadFieldClient

export type CodeField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>
      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>
    } & Admin['components']
    editorOptions?: EditorProps['options']
    language?: string
  } & Admin
  maxLength?: number
  minLength?: number
  type: 'code'
  validate?: CodeFieldValidation
} & Omit<FieldBase, 'admin' | 'validate'>

export type CodeFieldClient = {
  admin?: AdminClient & Pick<CodeField['admin'], 'editorOptions' | 'language'>
} & Omit<FieldBaseClient, 'admin'> &
  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>

export type JSONField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>
      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>
    } & Admin['components']
    editorOptions?: EditorProps['options']
    maxHeight?: number
  } & Admin

  jsonSchema?: {
    fileMatch: string[]
    schema: JSONSchema4
    uri: string
  }
  type: 'json'
  validate?: JSONFieldValidation
} & Omit<FieldBase, 'admin' | 'validate'>

export type JSONFieldClient = {
  admin?: AdminClient & Pick<JSONField['admin'], 'editorOptions' | 'maxHeight'>
} & Omit<FieldBaseClient, 'admin'> &
  Pick<JSONField, 'jsonSchema' | 'type'>

export type SelectField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>
      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>
    } & Admin['components']
    isClearable?: boolean
    isSortable?: boolean
  } & Admin
  /**
   * Customize the SQL table name
   */
  dbName?: DBIdentifierName
  /**
   * Customize the DB enum name
   */
  enumName?: DBIdentifierName
  hasMany?: boolean
  /** Customize generated GraphQL and Typescript schema names.
   * By default, it is bound to the collection.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
  options: Option[]
  type: 'select'
} & (
  | {
      hasMany: true
      validate?: SelectFieldManyValidation
    }
  | {
      hasMany?: false | undefined
      validate?: SelectFieldSingleValidation
    }
) &
  Omit<FieldBase, 'validate'>

export type SelectFieldClient = {
  admin?: AdminClient & Pick<SelectField['admin'], 'isClearable' | 'isSortable'>
} & FieldBaseClient &
  Pick<SelectField, 'hasMany' | 'interfaceName' | 'options' | 'type'>

type SharedRelationshipProperties = {
  filterOptions?: FilterOptions
  /**
   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.
   *
   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}
   */
  maxDepth?: number
  type: 'relationship'
} & (
  | {
      hasMany: true
      /**
       * @deprecated Use 'maxRows' instead
       */
      max?: number
      maxRows?: number
      /**
       * @deprecated Use 'minRows' instead
       */
      min?: number
      minRows?: number
      validate?: RelationshipFieldManyValidation
    }
  | {
      hasMany?: false | undefined
      /**
       * @deprecated Use 'maxRows' instead
       */
      max?: undefined
      maxRows?: undefined
      /**
       * @deprecated Use 'minRows' instead
       */
      min?: undefined
      minRows?: undefined
      validate?: RelationshipFieldSingleValidation
    }
) &
  FieldGraphQLType &
  Omit<FieldBase, 'validate'>

type SharedRelationshipPropertiesClient = FieldBaseClient &
  Pick<
    SharedRelationshipProperties,
    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'
  >

type RelationshipAdmin = {
  allowCreate?: boolean
  allowEdit?: boolean
  components?: {
    afterInput?: CustomComponent[]
    beforeInput?: CustomComponent[]
    Error?: CustomComponent<
      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent
    >
    Label?: CustomComponent<
      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent
    >
  } & Admin['components']
  isSortable?: boolean
} & Admin

type RelationshipAdminClient = AdminClient &
  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'isSortable'>

export type PolymorphicRelationshipField = {
  admin?: {
    sortOptions?: Partial<Record<CollectionSlug, string>>
  } & RelationshipAdmin
  relationTo: CollectionSlug[]
} & SharedRelationshipProperties

export type PolymorphicRelationshipFieldClient = {
  admin?: {
    sortOptions?: Pick<PolymorphicRelationshipField['admin'], 'sortOptions'>
  } & RelationshipAdminClient
} & Pick<PolymorphicRelationshipField, 'relationTo'> &
  SharedRelationshipPropertiesClient

export type SingleRelationshipField = {
  admin?: {
    sortOptions?: string
  } & RelationshipAdmin
  relationTo: CollectionSlug
} & SharedRelationshipProperties

export type SingleRelationshipFieldClient = {
  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient
} & Pick<SingleRelationshipField, 'relationTo'> &
  SharedRelationshipPropertiesClient

export type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField

export type RelationshipFieldClient =
  | PolymorphicRelationshipFieldClient
  | SingleRelationshipFieldClient

export type ValueWithRelation = {
  relationTo: CollectionSlug
  value: number | string
}

export function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {
  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value
}

export type RelationshipValue = RelationshipValueMany | RelationshipValueSingle

export type RelationshipValueMany = (number | string)[] | ValueWithRelation[]

export type RelationshipValueSingle = number | string | ValueWithRelation

export type RichTextField<
  TValue extends object = any,
  TAdapterProps = any,
  TExtraProperties = object,
> = {
  admin?: {
    components?: {
      Error?: CustomComponent
      Label?: CustomComponent
    } & Admin['components']
  } & Admin
  editor?:
    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>
    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>
  /**
   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.
   *
   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}
   */
  maxDepth?: number
  type: 'richText'
} & FieldBase &
  TExtraProperties

export type RichTextFieldClient<
  TValue extends object = any,
  TAdapterProps = any,
  TExtraProperties = object,
> = FieldBaseClient &
  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &
  TExtraProperties

export type ArrayField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>
      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>
      RowLabel?: RowLabelComponent
    } & Admin['components']
    initCollapsed?: boolean
    /**
     * Disable drag and drop sorting
     */
    isSortable?: boolean
  } & Admin
  /**
   * Customize the SQL table name
   */
  dbName?: DBIdentifierName
  fields: Field[]
  /** Customize generated GraphQL and Typescript schema names.
   * By default, it is bound to the collection.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
  labels?: Labels
  maxRows?: number
  minRows?: number
  type: 'array'
  validate?: ArrayFieldValidation
} & Omit<FieldBase, 'validate'>

export type ArrayFieldClient = {
  admin?: AdminClient & Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>
  fields: ClientField[]
  labels?: LabelsClient
} & FieldBaseClient &
  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>

export type RadioField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>
      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>
    } & Admin['components']
    layout?: 'horizontal' | 'vertical'
  } & Admin
  /**
   * Customize the SQL table name
   */
  dbName?: DBIdentifierName
  /**
   * Customize the DB enum name
   */
  enumName?: DBIdentifierName
  /** Customize generated GraphQL and Typescript schema names.
   * By default, it is bound to the collection.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
  options: Option[]
  type: 'radio'
  validate?: RadioFieldValidation
} & Omit<FieldBase, 'validate'>

export type RadioFieldClient = {
  admin?: AdminClient & Pick<RadioField['admin'], 'layout'>
} & FieldBaseClient &
  Pick<RadioField, 'interfaceName' | 'options' | 'type'>

type BlockFields = {
  [key: string]: any
  blockName?: string
  blockType?: string
}

export type BlockJSX = {
  /**
   * Override the default regex used to search for the start of the block in the JSX.
   * By default, it's <BlockSlugHere
   */
  customEndRegex?:
    | {
        /**
         * Whether the end match is optional. If true, the end match is
         * not required to match for the transformer to be triggered.
         * The entire text from regexpStart to the end of the document will then be matched.
         */
        optional?: true
        regExp: RegExp
      }
    | RegExp
  /**
   * Override the default regex used to search for the start of the block in the JSX.
   * By default, it's <BlockSlugHere/>
   */
  customStartRegex?: RegExp
  /**
   * By default, all spaces at the beginning and end of every line of the
   * children (text between the open and close match) are removed.
   * Set this to true to disable this behavior.
   */
  doNotTrimChildren?: boolean
  /**
   * Function that receives the data for a given block and returns a JSX representation of it.
   *
   * This is used to convert Lexical => JSX
   */
  export: (props: {
    fields: BlockFields
    lexicalToMarkdown: (props: { editorState: Record<string, any> }) => string
  }) =>
    | {
        children?: string
        props?: object
      }
    | false
    | string
  /**
   * Function that receives the markdown string and parsed
   * JSX props for a given matched block and returns a Lexical representation of it.
   *
   * This is used to convert JSX => Lexical
   */
  import: (props: {
    children: string
    closeMatch: null | RegExpMatchArray // Only available when customEndRegex is set
    htmlToLexical?: ((props: { html: string }) => any) | null
    markdownToLexical: (props: { markdown: string }) => Record<string, any>
    openMatch?: RegExpMatchArray
    props: Record<string, any>
  }) => BlockFields | false
}

export type Block = {
  /**
   * Do not set this property manually. This is set to true during sanitization, to avoid
   * sanitizing the same block multiple times.
   */
  _sanitized?: boolean
  admin?: {
    components?: {
      /**
       * This will replace the entire block component, including the block header / collapsible.
       */
      Block?: PayloadComponent<any, any>
      Label?: PayloadComponent<any, any>
    }
    /** Extension point to add your custom data. Available in server and client. */
    custom?: Record<string, any>
    /**
     * Hides the block name field from the Block's header
     *
     * @default false
     */
    disableBlockName?: boolean
    group?: Record<string, string> | string
    jsx?: PayloadComponent
  }
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  /**
   * Customize the SQL table name
   */
  dbName?: DBIdentifierName
  fields: Field[]
  /** @deprecated - please migrate to the interfaceName property instead. */
  graphQL?: {
    singularName?: string
  }
  imageAltText?: string
  /**
   * Preferred aspect ratio of the image is 3 : 2
   */
  imageURL?: string
  /** Customize generated GraphQL and Typescript schema names.
   * The slug is used by default.
   *
   * This is useful if you would like to generate a top level type to share amongst collections/fields.
   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.
   */
  interfaceName?: string
  jsx?: BlockJSX
  labels?: Labels
  slug: string
}

export type ClientBlock = {
  admin?: Pick<Block['admin'], 'custom' | 'disableBlockName' | 'group'>
  fields: ClientField[]
  labels?: LabelsClient
} & Pick<Block, 'imageAltText' | 'imageURL' | 'jsx' | 'slug'>

export type BlocksField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>
      Label?: CustomComponent<BlocksFieldLabelClientComponent | BlocksFieldLabelServerComponent>
    } & Admin['components']
    initCollapsed?: boolean
    /**
     * Disable drag and drop sorting
     */
    isSortable?: boolean
  } & Admin
  /**
   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.
   *
   * @todo `blockReferences` will be merged with `blocks` in 4.0
   */
  blockReferences?: (Block | BlockSlug)[]
  blocks: Block[]
  defaultValue?: DefaultValue
  labels?: Labels
  maxRows?: number
  minRows?: number
  type: 'blocks'
  validate?: BlocksFieldValidation
} & Omit<FieldBase, 'validate'>

export type BlocksFieldClient = {
  admin?: AdminClient & Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>
  /**
   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.
   *
   * @todo `blockReferences` will be merged with `blocks` in 4.0
   */
  blockReferences?: (ClientBlock | string)[]
  blocks: ClientBlock[]
  labels?: LabelsClient
} & FieldBaseClient &
  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>

export type PointField = {
  admin?: {
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>
      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>
    } & Admin['components']
    placeholder?: Record<string, string> | string
    step?: number
  } & Admin
  type: 'point'
  validate?: PointFieldValidation
} & Omit<FieldBase, 'validate'>

export type PointFieldClient = {
  admin?: AdminClient & Pick<PointField['admin'], 'placeholder' | 'step'>
} & FieldBaseClient &
  Pick<PointField, 'type'>

/**
 * A virtual field that loads in related collections by querying a relationship or upload field.
 */
export type JoinField = {
  access?: {
    create?: never
    read?: FieldAccess
    update?: never
  }
  admin?: {
    allowCreate?: boolean
    components?: {
      afterInput?: CustomComponent[]
      beforeInput?: CustomComponent[]
      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>
      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>
    } & Admin['components']
    defaultColumns?: string[]
    disableBulkEdit?: never
    readOnly?: never
  } & Admin
  /**
   * The slug of the collection to relate with.
   */
  collection: CollectionSlug | CollectionSlug[]
  defaultLimit?: number
  defaultSort?: Sort
  defaultValue?: never
  /**
   * This does not need to be set and will be overridden by the relationship field's hasMany property.
   */
  hasMany?: boolean
  hidden?: false
  index?: never
  /**
   * This does not need to be set and will be overridden by the relationship field's localized property.
   */
  localized?: boolean
  /**
   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.
   *
   * @see https://payloadcms.com/docs/getting-started/concepts#depth
   *
   * @default 1
   */
  maxDepth?: number
  /**
   * A string for the field in the collection being joined to.
   */
  on: string
  /**
   * If true, enables custom ordering for the collection with the relationship, and joined documents can be reordered via drag and drop.
   * New documents are inserted at the end of the list according to this parameter.
   *
   * Under the hood, a field with {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing|fractional indexing} is used to optimize inserts and reorderings.
   *
   * @default false
   *
   * @experimental There may be frequent breaking changes to this API
   */
  orderable?: boolean
  sanitizedMany?: JoinField[]
  type: 'join'
  validate?: never
  where?: Where
} & FieldBase &
  FieldGraphQLType

export type JoinFieldClient = {
  admin?: AdminClient &
    Pick<JoinField['admin'], 'allowCreate' | 'defaultColumns' | 'disableBulkEdit' | 'readOnly'>
} & { targetField: Pick<RelationshipFieldClient, 'relationTo'> } & FieldBaseClient &
  Pick<
    JoinField,
    | 'collection'
    | 'defaultLimit'
    | 'defaultSort'
    | 'index'
    | 'maxDepth'
    | 'on'
    | 'orderable'
    | 'type'
    | 'where'
  >

export type FlattenedBlock = {
  flattenedFields: FlattenedField[]
} & Block

export type FlattenedBlocksField = {
  /**
   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.
   *
   * @todo `blockReferences` will be merged with `blocks` in 4.0
   */
  blockReferences?: (FlattenedBlock | string)[]
  blocks: FlattenedBlock[]
} & Omit<BlocksField, 'blockReferences' | 'blocks'>

export type FlattenedGroupField = {
  flattenedFields: FlattenedField[]
} & GroupField

export type FlattenedArrayField = {
  flattenedFields: FlattenedField[]
} & ArrayField

export type FlattenedTabAsField = {
  flattenedFields: FlattenedField[]
} & MarkRequired<TabAsField, 'name'>

export type FlattenedJoinField = {
  targetField: RelationshipField | UploadField
} & JoinField

export type FlattenedField =
  | CheckboxField
  | CodeField
  | DateField
  | EmailField
  | FlattenedArrayField
  | FlattenedBlocksField
  | FlattenedGroupField
  | FlattenedJoinField
  | FlattenedTabAsField
  | JSONField
  | NumberField
  | PointField
  | RadioField
  | RelationshipField
  | RichTextField
  | SelectField
  | TextareaField
  | TextField
  | UploadField
export type Field =
  | ArrayField
  | BlocksField
  | CheckboxField
  | CodeField
  | CollapsibleField
  | DateField
  | EmailField
  | GroupField
  | JoinField
  | JSONField
  | NumberField
  | PointField
  | RadioField
  | RelationshipField
  | RichTextField
  | RowField
  | SelectField
  | TabsField
  | TextareaField
  | TextField
  | UIField
  | UploadField

export type ClientField =
  | ArrayFieldClient
  | BlocksFieldClient
  | CheckboxFieldClient
  | CodeFieldClient
  | CollapsibleFieldClient
  | DateFieldClient
  | EmailFieldClient
  | GroupFieldClient
  | JoinFieldClient
  | JSONFieldClient
  | NumberFieldClient
  | PointFieldClient
  | RadioFieldClient
  | RelationshipFieldClient
  | RichTextFieldClient
  | RowFieldClient
  | SelectFieldClient
  | TabsFieldClient
  | TextareaFieldClient
  | TextFieldClient
  | UIFieldClient
  | UploadFieldClient

export type ClientFieldProps =
  | ArrayFieldClientProps
  | BlocksFieldClientProps
  | CheckboxFieldClientProps
  | CodeFieldClientProps
  | CollapsibleFieldClientProps
  | DateFieldClientProps
  | EmailFieldClientProps
  | GroupFieldClientProps
  | HiddenFieldProps
  | JoinFieldClientProps
  | JSONFieldClientProps
  | NumberFieldClientProps
  | PointFieldClientProps
  | RadioFieldClientProps
  | RelationshipFieldClientProps
  | RichTextFieldClientProps
  | RowFieldClientProps
  | SelectFieldClientProps
  | TabsFieldClientProps
  | TextareaFieldClientProps
  | TextFieldClientProps
  | UploadFieldClientProps

type ExtractFieldTypes<T> = T extends { type: infer U } ? U : never

export type FieldTypes = ExtractFieldTypes<Field>

export type FieldAffectingData =
  | ArrayField
  | BlocksField
  | CheckboxField
  | CodeField
  | DateField
  | EmailField
  | GroupField
  | JoinField
  | JSONField
  | NumberField
  | PointField
  | RadioField
  | RelationshipField
  | RichTextField
  | SelectField
  | TabAsField
  | TextareaField
  | TextField
  | UploadField

export type FieldAffectingDataClient =
  | ArrayFieldClient
  | BlocksFieldClient
  | CheckboxFieldClient
  | CodeFieldClient
  | DateFieldClient
  | EmailFieldClient
  | GroupFieldClient
  | JoinFieldClient
  | JSONFieldClient
  | NumberFieldClient
  | PointFieldClient
  | RadioFieldClient
  | RelationshipFieldClient
  | RichTextFieldClient
  | SelectFieldClient
  | TabAsFieldClient
  | TextareaFieldClient
  | TextFieldClient
  | UploadFieldClient

export type NonPresentationalField =
  | ArrayField
  | BlocksField
  | CheckboxField
  | CodeField
  | CollapsibleField
  | DateField
  | EmailField
  | GroupField
  | JSONField
  | NumberField
  | PointField
  | RadioField
  | RelationshipField
  | RichTextField
  | RowField
  | SelectField
  | TabsField
  | TextareaField
  | TextField
  | UploadField

export type NonPresentationalFieldClient =
  | ArrayFieldClient
  | BlocksFieldClient
  | CheckboxFieldClient
  | CodeFieldClient
  | CollapsibleFieldClient
  | DateFieldClient
  | EmailFieldClient
  | GroupFieldClient
  | JSONFieldClient
  | NumberFieldClient
  | PointFieldClient
  | RadioFieldClient
  | RelationshipFieldClient
  | RichTextFieldClient
  | RowFieldClient
  | SelectFieldClient
  | TabsFieldClient
  | TextareaFieldClient
  | TextFieldClient
  | UploadFieldClient

export type FieldWithPath = {
  path?: string
} & Field

export type FieldWithPathClient = {
  path?: string
} & ClientField

export type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField

export type FieldWithSubFieldsClient =
  | ArrayFieldClient
  | CollapsibleFieldClient
  | GroupFieldClient
  | RowFieldClient

export type FieldPresentationalOnly = UIField
export type FieldPresentationalOnlyClient = UIFieldClient

export type FieldWithMany = RelationshipField | SelectField
export type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient

export type FieldWithMaxDepth = RelationshipField | UploadField
export type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient

export function fieldHasSubFields<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {
  return (
    field.type === 'group' ||
    field.type === 'array' ||
    field.type === 'row' ||
    field.type === 'collapsible'
  )
}

export function fieldIsArrayType<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {
  return field.type === 'array'
}

export function fieldIsBlockType<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {
  return field.type === 'blocks'
}

export function fieldIsGroupType<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {
  return field.type === 'group'
}

export function optionIsObject(option: Option): option is OptionObject {
  return typeof option === 'object'
}

export function optionsAreObjects(options: Option[]): options is OptionObject[] {
  return Array.isArray(options) && typeof options?.[0] === 'object'
}

export function optionIsValue(option: Option): option is string {
  return typeof option === 'string'
}

export function fieldSupportsMany<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {
  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'
}

export function fieldHasMaxDepth<TField extends ClientField | Field>(
  field: TField,
): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {
  return (
    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&
    typeof field.maxDepth === 'number'
  )
}

export function fieldIsPresentationalOnly<
  TField extends ClientField | Field | TabAsField | TabAsFieldClient,
>(
  field: TField,
): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {
  return field.type === 'ui'
}

export function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(
  field: TField,
): field is { admin: { position: 'sidebar' } } & TField {
  return 'admin' in field && 'position' in field.admin && field.admin.position === 'sidebar'
}

export function fieldIsID<TField extends ClientField | Field>(
  field: TField,
): field is { name: 'id' } & TField {
  return 'name' in field && field.name === 'id'
}

export function fieldIsHiddenOrDisabled<
  TField extends ClientField | Field | TabAsField | TabAsFieldClient,
>(field: TField): field is { admin: { hidden: true } } & TField {
  return (
    ('hidden' in field && field.hidden) ||
    ('admin' in field && 'disabled' in field.admin && field.admin.disabled)
  )
}

export function fieldAffectsData<
  TField extends ClientField | Field | TabAsField | TabAsFieldClient,
>(
  field: TField,
): field is TField &
  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {
  return 'name' in field && !fieldIsPresentationalOnly(field)
}

export function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {
  return 'name' in tab
}

/**
 * Check if a field has localized: true set. This does not check if a field *should*
 * be localized. To check if a field should be localized, use `fieldShouldBeLocalized`.
 *
 * @deprecated this will be removed or modified in v4.0, as `fieldIsLocalized` can easily lead to bugs due to
 * parent field localization not being taken into account.
 */
export function fieldIsLocalized(field: Field | Tab): boolean {
  return 'localized' in field && field.localized
}

/**
 * Similar to `fieldIsLocalized`, but returns `false` if any parent field is localized.
 */
export function fieldShouldBeLocalized({
  field,
  parentIsLocalized,
}: {
  field: ClientField | ClientTab | Field | Tab
  parentIsLocalized: boolean
}): boolean {
  return (
    'localized' in field &&
    field.localized &&
    (!parentIsLocalized ||
      process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized === 'true')
  )
}

export function fieldIsVirtual(field: Field | Tab): boolean {
  return 'virtual' in field && field.virtual
}

export type HookName =
  | 'afterChange'
  | 'afterRead'
  | 'beforeChange'
  | 'beforeRead'
  | 'beforeValidate'
</file>

<file path="packages/payload/src/fields/hooks/afterChange/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'

import { traverseFields } from './traverseFields.js'

type Args<T extends JsonObject> = {
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  /**
   * The data before hooks
   */
  data: T
  /**
   * The data after hooks
   */
  doc: T
  global: null | SanitizedGlobalConfig
  operation: 'create' | 'update'
  previousDoc: T
  req: PayloadRequest
}

/**
 * This function is responsible for the following actions, in order:
 * - Execute field hooks
 */
export const afterChange = async <T extends JsonObject>({
  collection,
  context,
  data,
  doc: incomingDoc,
  global,
  operation,
  previousDoc,
  req,
}: Args<T>): Promise<T> => {
  await traverseFields({
    collection,
    context,
    data,
    doc: incomingDoc,
    fields: collection?.fields || global?.fields,
    global,
    operation,
    parentIndexPath: '',
    parentIsLocalized: false,
    parentPath: '',
    parentSchemaPath: '',
    previousDoc,
    previousSiblingDoc: previousDoc,
    req,
    siblingData: data,
    siblingDoc: incomingDoc,
  })

  return incomingDoc
}
</file>

<file path="packages/payload/src/fields/hooks/afterChange/promise.ts">
// @ts-strict-ignore
import type { RichTextAdapter } from '../../../admin/RichText.js'
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'
import type { Block, Field, TabAsField } from '../../config/types.js'

import { MissingEditorProp } from '../../../errors/index.js'
import { fieldAffectsData, tabHasName } from '../../config/types.js'
import { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'
import { traverseFields } from './traverseFields.js'

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: JsonObject
  doc: JsonObject
  field: Field | TabAsField
  fieldIndex: number
  global: null | SanitizedGlobalConfig
  operation: 'create' | 'update'
  parentIndexPath: string
  parentIsLocalized: boolean
  parentPath: string
  parentSchemaPath: string
  previousDoc: JsonObject
  previousSiblingDoc: JsonObject
  req: PayloadRequest
  siblingData: JsonObject
  siblingDoc: JsonObject
  siblingFields?: (Field | TabAsField)[]
}

// This function is responsible for the following actions, in order:
// - Execute field hooks

export const promise = async ({
  blockData,
  collection,
  context,
  data,
  doc,
  field,
  fieldIndex,
  global,
  operation,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  previousDoc,
  previousSiblingDoc,
  req,
  siblingData,
  siblingDoc,
  siblingFields,
}: Args): Promise<void> => {
  const { indexPath, path, schemaPath } = getFieldPaths({
    field,
    index: fieldIndex,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
  })

  const pathSegments = path ? path.split('.') : []
  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []
  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []

  if (fieldAffectsData(field)) {
    // Execute hooks
    if (field.hooks?.afterChange) {
      for (const hook of field.hooks.afterChange) {
        const hookedValue = await hook({
          blockData,
          collection,
          context,
          data,
          field,
          global,
          indexPath: indexPathSegments,
          operation,
          originalDoc: doc,
          path: pathSegments,
          previousDoc,
          previousSiblingDoc,
          previousValue: previousDoc[field.name],
          req,
          schemaPath: schemaPathSegments,
          siblingData,
          siblingFields,
          value: siblingDoc[field.name],
        })

        if (hookedValue !== undefined) {
          siblingDoc[field.name] = hookedValue
        }
      }
    }
  }

  // Traverse subfields
  switch (field.type) {
    case 'array': {
      const rows = siblingDoc[field.name]

      if (Array.isArray(rows)) {
        const promises = []
        rows.forEach((row, rowIndex) => {
          promises.push(
            traverseFields({
              blockData,
              collection,
              context,
              data,
              doc,
              fields: field.fields,
              global,
              operation,
              parentIndexPath: '',
              parentIsLocalized: parentIsLocalized || field.localized,
              parentPath: path + '.' + rowIndex,
              parentSchemaPath: schemaPath,
              previousDoc,
              previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),
              req,
              siblingData: siblingData?.[field.name]?.[rowIndex] || {},
              siblingDoc: row ? { ...row } : {},
            }),
          )
        })
        await Promise.all(promises)
      }

      break
    }

    case 'blocks': {
      const rows = siblingDoc[field.name]

      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row, rowIndex) => {
          const blockTypeToMatch = (row as JsonObject).blockType

          const block: Block | undefined =
            req.payload.blocks[blockTypeToMatch] ??
            ((field.blockReferences ?? field.blocks).find(
              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
            ) as Block | undefined)

          if (block) {
            promises.push(
              traverseFields({
                blockData: siblingData?.[field.name]?.[rowIndex],
                collection,
                context,
                data,
                doc,
                fields: block.fields,
                global,
                operation,
                parentIndexPath: '',
                parentIsLocalized: parentIsLocalized || field.localized,
                parentPath: path + '.' + rowIndex,
                parentSchemaPath: schemaPath + '.' + block.slug,
                previousDoc,
                previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),
                req,
                siblingData: siblingData?.[field.name]?.[rowIndex] || {},
                siblingDoc: row ? { ...row } : {},
              }),
            )
          }
        })

        await Promise.all(promises)
      }

      break
    }

    case 'collapsible':
    case 'row': {
      await traverseFields({
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath: schemaPath,
        previousDoc,
        previousSiblingDoc: { ...previousSiblingDoc },
        req,
        siblingData: siblingData || {},
        siblingDoc: { ...siblingDoc },
      })

      break
    }

    case 'group': {
      await traverseFields({
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        parentIndexPath: '',
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        previousDoc,
        previousSiblingDoc: previousDoc[field.name] as JsonObject,
        req,
        siblingData: (siblingData?.[field.name] as JsonObject) || {},
        siblingDoc: siblingDoc[field.name] as JsonObject,
      })

      break
    }

    case 'richText': {
      if (!field?.editor) {
        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof field.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      const editor: RichTextAdapter = field.editor

      if (editor?.hooks?.afterChange?.length) {
        for (const hook of editor.hooks.afterChange) {
          const hookedValue = await hook({
            collection,
            context,
            data,
            field,
            global,
            indexPath: indexPathSegments,
            operation,
            originalDoc: doc,
            parentIsLocalized,
            path: pathSegments,
            previousDoc,
            previousSiblingDoc,
            previousValue: previousDoc[field.name],
            req,
            schemaPath: schemaPathSegments,
            siblingData,
            value: siblingDoc[field.name],
          })

          if (hookedValue !== undefined) {
            siblingDoc[field.name] = hookedValue
          }
        }
      }
      break
    }

    case 'tab': {
      let tabSiblingData = siblingData
      let tabSiblingDoc = siblingDoc
      let tabPreviousSiblingDoc = siblingDoc

      const isNamedTab = tabHasName(field)

      if (isNamedTab) {
        tabSiblingData = (siblingData[field.name] as JsonObject) ?? {}
        tabSiblingDoc = (siblingDoc[field.name] as JsonObject) ?? {}
        tabPreviousSiblingDoc = (previousDoc[field.name] as JsonObject) ?? {}
      }

      await traverseFields({
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        parentIndexPath: isNamedTab ? '' : indexPath,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: isNamedTab ? path : parentPath,
        parentSchemaPath: schemaPath,
        previousDoc,
        previousSiblingDoc: tabPreviousSiblingDoc,
        req,
        siblingData: tabSiblingData,
        siblingDoc: tabSiblingDoc,
      })

      break
    }

    case 'tabs': {
      await traverseFields({
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
        global,
        operation,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        previousDoc,
        previousSiblingDoc: { ...previousSiblingDoc },
        req,
        siblingData: siblingData || {},
        siblingDoc: { ...siblingDoc },
      })

      break
    }

    default: {
      break
    }
  }
}
</file>

<file path="packages/payload/src/fields/hooks/afterChange/traverseFields.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'
import type { Field, TabAsField } from '../../config/types.js'

import { promise } from './promise.js'

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: JsonObject
  doc: JsonObject
  fields: (Field | TabAsField)[]
  global: null | SanitizedGlobalConfig
  operation: 'create' | 'update'
  parentIndexPath: string
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized?: boolean
  parentPath: string
  parentSchemaPath: string
  previousDoc: JsonObject
  previousSiblingDoc: JsonObject
  req: PayloadRequest
  siblingData: JsonObject
  siblingDoc: JsonObject
  siblingFields?: (Field | TabAsField)[]
}

export const traverseFields = async ({
  blockData,
  collection,
  context,
  data,
  doc,
  fields,
  global,
  operation,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  previousDoc,
  previousSiblingDoc,
  req,
  siblingData,
  siblingDoc,
  siblingFields,
}: Args): Promise<void> => {
  const promises = []

  fields.forEach((field, fieldIndex) => {
    promises.push(
      promise({
        blockData,
        collection,
        context,
        data,
        doc,
        field,
        fieldIndex,
        global,
        operation,
        parentIndexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath,
        previousDoc,
        previousSiblingDoc,
        req,
        siblingData,
        siblingDoc,
        siblingFields,
      }),
    )
  })

  await Promise.all(promises)
}
</file>

<file path="packages/payload/src/fields/hooks/afterRead/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'

import { getSelectMode } from '../../../utilities/getSelectMode.js'
import { traverseFields } from './traverseFields.js'

type Args<T extends JsonObject> = {
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  currentDepth?: number
  depth: number
  doc: T
  draft: boolean
  fallbackLocale: null | string
  findMany?: boolean
  flattenLocales?: boolean
  global: null | SanitizedGlobalConfig
  locale: string
  overrideAccess: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields: boolean
}

/**
 * This function is responsible for the following actions, in order:
 * - Remove hidden fields from response
 * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.
 * - Sanitize outgoing data (point field, etc.)
 * - Execute field hooks
 * - Execute read access control
 * - Populate relationships
 */

export async function afterRead<T extends JsonObject>(args: Args<T>): Promise<T> {
  const {
    collection,
    context,
    currentDepth: incomingCurrentDepth,
    depth: incomingDepth,
    doc: incomingDoc,
    draft,
    fallbackLocale,
    findMany,
    flattenLocales = true,
    global,
    locale,
    overrideAccess,
    populate,
    req,
    select,
    showHiddenFields,
  } = args

  const fieldPromises = []
  const populationPromises = []

  let depth =
    incomingDepth || incomingDepth === 0
      ? parseInt(String(incomingDepth), 10)
      : req.payload.config.defaultDepth
  if (depth > req.payload.config.maxDepth) {
    depth = req.payload.config.maxDepth
  }

  const currentDepth = incomingCurrentDepth || 1

  traverseFields({
    collection,
    context,
    currentDepth,
    depth,
    doc: incomingDoc,
    draft,
    fallbackLocale,
    fieldPromises,
    fields: collection?.fields || global?.fields,
    findMany,
    flattenLocales,
    global,
    locale,
    overrideAccess,
    parentIndexPath: '',
    parentIsLocalized: false,
    parentPath: '',
    parentSchemaPath: '',
    populate,
    populationPromises,
    req,
    select,
    selectMode: select ? getSelectMode(select) : undefined,
    showHiddenFields,
    siblingDoc: incomingDoc,
  })

  /**
   * Await all field and population promises in parallel.
   * A field promise is able to add more field promises to the fieldPromises array, which will not be
   * awaited in the first run.
   * This is why we need to loop again to process the new field promises, until there are no more field promises left.
   */
  let iterations = 0
  while (fieldPromises.length > 0 || populationPromises.length > 0) {
    const currentFieldPromises = fieldPromises.splice(0, fieldPromises.length)
    const currentPopulationPromises = populationPromises.splice(0, populationPromises.length)

    await Promise.all(currentFieldPromises)
    await Promise.all(currentPopulationPromises)

    iterations++
    if (iterations >= 100) {
      throw new Error(
        'Infinite afterRead promise loop detected. A hook is likely adding field promises in an infinitely recursive way.',
      )
    }
  }
  return incomingDoc
}
</file>

<file path="packages/payload/src/fields/hooks/afterRead/promise.ts">
// @ts-strict-ignore
import type { RichTextAdapter } from '../../../admin/RichText.js'
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type {
  JsonObject,
  PayloadRequest,
  PopulateType,
  SelectMode,
  SelectType,
} from '../../../types/index.js'
import type { Block, Field, TabAsField } from '../../config/types.js'

import { MissingEditorProp } from '../../../errors/index.js'
import { getBlockSelect } from '../../../utilities/getBlockSelect.js'
import { stripUnselectedFields } from '../../../utilities/stripUnselectedFields.js'
import { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'
import { getDefaultValue } from '../../getDefaultValue.js'
import { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'
import { relationshipPopulationPromise } from './relationshipPopulationPromise.js'
import { traverseFields } from './traverseFields.js'

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  currentDepth: number
  depth: number
  doc: JsonObject
  draft: boolean
  fallbackLocale: null | string
  field: Field | TabAsField
  fieldIndex: number
  /**
   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises
   */
  fieldPromises: Promise<void>[]
  findMany: boolean
  flattenLocales: boolean
  global: null | SanitizedGlobalConfig
  locale: null | string
  overrideAccess: boolean
  parentIndexPath: string
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized?: boolean
  parentPath: string
  parentSchemaPath: string
  populate?: PopulateType
  populationPromises: Promise<void>[]
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  showHiddenFields: boolean
  siblingDoc: JsonObject
  siblingFields?: (Field | TabAsField)[]
  triggerAccessControl?: boolean
  triggerHooks?: boolean
}

// This function is responsible for the following actions, in order:
// - Remove hidden fields from response
// - Flatten locales into requested locale
// - Sanitize outgoing data (point field, etc.)
// - Execute field hooks
// - Execute read access control
// - Populate relationships

export const promise = async ({
  blockData,
  collection,
  context,
  currentDepth,
  depth,
  doc,
  draft,
  fallbackLocale,
  field,
  fieldIndex,
  fieldPromises,
  findMany,
  flattenLocales,
  global,
  locale,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  populate,
  populationPromises,
  req,
  select,
  selectMode,
  showHiddenFields,
  siblingDoc,
  siblingFields,
  triggerAccessControl = true,
  triggerHooks = true,
}: Args): Promise<void> => {
  const { indexPath, path, schemaPath } = getFieldPaths({
    field,
    index: fieldIndex,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
  })

  const pathSegments = path ? path.split('.') : []
  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []
  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []

  if (
    fieldAffectsData(field) &&
    field.hidden &&
    typeof siblingDoc[field.name] !== 'undefined' &&
    !showHiddenFields
  ) {
    delete siblingDoc[field.name]
  }

  if (path !== 'id') {
    const shouldContinue = stripUnselectedFields({
      field,
      select,
      selectMode,
      siblingDoc,
    })

    if (!shouldContinue) {
      return
    }
  }

  const shouldHoistLocalizedValue =
    flattenLocales &&
    fieldAffectsData(field) &&
    typeof siblingDoc[field.name] === 'object' &&
    siblingDoc[field.name] !== null &&
    fieldShouldBeLocalized({ field, parentIsLocalized }) &&
    locale !== 'all' &&
    req.payload.config.localization

  if (shouldHoistLocalizedValue) {
    // replace actual value with localized value before sanitizing
    // { [locale]: fields } -> fields
    const value = siblingDoc[field.name][locale]

    let hoistedValue = value

    if (fallbackLocale && fallbackLocale !== locale) {
      const fallbackValue = siblingDoc[field.name][fallbackLocale]
      const isNullOrUndefined = typeof value === 'undefined' || value === null

      if (fallbackValue) {
        switch (field.type) {
          case 'text':
          case 'textarea': {
            if (value === '' || isNullOrUndefined) {
              hoistedValue = fallbackValue
            }
            break
          }

          default: {
            if (isNullOrUndefined) {
              hoistedValue = fallbackValue
            }
            break
          }
        }
      }
    }

    siblingDoc[field.name] = hoistedValue
  }

  // Sanitize outgoing field value
  switch (field.type) {
    case 'group': {
      // Fill groups with empty objects so fields with hooks within groups can populate
      // themselves virtually as necessary
      if (typeof siblingDoc[field.name] === 'undefined') {
        siblingDoc[field.name] = {}
      }

      break
    }
    case 'point': {
      const pointDoc = siblingDoc[field.name] as Record<string, unknown>
      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {
        siblingDoc[field.name] = pointDoc.coordinates
      } else {
        siblingDoc[field.name] = undefined
      }

      break
    }

    case 'richText': {
      if (!field?.editor) {
        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }
      if (typeof field?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises
      break
    }

    case 'tabs': {
      field.tabs.forEach((tab) => {
        if (
          tabHasName(tab) &&
          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)
        ) {
          siblingDoc[tab.name] = {}
        }
      })

      break
    }

    default: {
      break
    }
  }

  if (fieldAffectsData(field)) {
    // Execute hooks
    if (triggerHooks && field.hooks?.afterRead) {
      for (const hook of field.hooks.afterRead) {
        const shouldRunHookOnAllLocales =
          fieldShouldBeLocalized({ field, parentIsLocalized }) &&
          (locale === 'all' || !flattenLocales) &&
          typeof siblingDoc[field.name] === 'object'

        if (shouldRunHookOnAllLocales) {
          const localesAndValues = Object.entries(siblingDoc[field.name])
          await Promise.all(
            localesAndValues.map(async ([localeKey, value]) => {
              const hookedValue = await hook({
                blockData,
                collection,
                context,
                currentDepth,
                data: doc,
                depth,
                draft,
                field,
                findMany,
                global,
                indexPath: indexPathSegments,
                operation: 'read',
                originalDoc: doc,
                overrideAccess,
                path: pathSegments,
                req,
                schemaPath: schemaPathSegments,
                showHiddenFields,
                siblingData: siblingDoc,
                siblingFields,
                value,
              })

              if (hookedValue !== undefined) {
                siblingDoc[field.name][localeKey] = hookedValue
              }
            }),
          )
        } else {
          const hookedValue = await hook({
            blockData,
            collection,
            context,
            currentDepth,
            data: doc,
            depth,
            draft,
            field,
            findMany,
            global,
            indexPath: indexPathSegments,
            operation: 'read',
            originalDoc: doc,
            overrideAccess,
            path: pathSegments,
            req,
            schemaPath: schemaPathSegments,
            showHiddenFields,
            siblingData: siblingDoc,
            siblingFields,
            value: siblingDoc[field.name],
          })

          if (hookedValue !== undefined) {
            siblingDoc[field.name] = hookedValue
          }
        }
      }
    }

    // Execute access control
    let allowDefaultValue = true
    if (triggerAccessControl && field.access && field.access.read) {
      const result = overrideAccess
        ? true
        : await field.access.read({
            id: doc.id as number | string,
            blockData,
            data: doc,
            doc,
            req,
            siblingData: siblingDoc,
          })

      if (!result) {
        allowDefaultValue = false
        delete siblingDoc[field.name]
      }
    }

    // Set defaultValue on the field for globals being returned without being first created
    // or collection documents created prior to having a default
    if (
      allowDefaultValue &&
      typeof siblingDoc[field.name] === 'undefined' &&
      typeof field.defaultValue !== 'undefined'
    ) {
      siblingDoc[field.name] = await getDefaultValue({
        defaultValue: field.defaultValue,
        locale,
        req,
        user: req.user,
        value: siblingDoc[field.name],
      })
    }

    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {
      populationPromises.push(
        relationshipPopulationPromise({
          currentDepth,
          depth,
          draft,
          fallbackLocale,
          field,
          locale,
          overrideAccess,
          parentIsLocalized,
          populate,
          req,
          showHiddenFields,
          siblingDoc,
        }),
      )
    }
  }

  switch (field.type) {
    case 'array': {
      const rows = siblingDoc[field.name] as JsonObject

      let arraySelect = select?.[field.name]

      if (selectMode === 'include' && typeof arraySelect === 'object') {
        arraySelect = {
          ...arraySelect,
          id: true,
        }
      }

      if (Array.isArray(rows)) {
        rows.forEach((row, rowIndex) => {
          traverseFields({
            blockData,
            collection,
            context,
            currentDepth,
            depth,
            doc,
            draft,
            fallbackLocale,
            fieldPromises,
            fields: field.fields,
            findMany,
            flattenLocales,
            global,
            locale,
            overrideAccess,
            parentIndexPath: '',
            parentIsLocalized: parentIsLocalized || field.localized,
            parentPath: path + '.' + rowIndex,
            parentSchemaPath: schemaPath,
            populate,
            populationPromises,
            req,
            select: typeof arraySelect === 'object' ? arraySelect : undefined,
            selectMode,
            showHiddenFields,
            siblingDoc: row || {},
            triggerAccessControl,
            triggerHooks,
          })
        })
      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {
        Object.values(rows).forEach((localeRows) => {
          if (Array.isArray(localeRows)) {
            localeRows.forEach((row, rowIndex) => {
              traverseFields({
                blockData,
                collection,
                context,
                currentDepth,
                depth,
                doc,
                draft,
                fallbackLocale,
                fieldPromises,
                fields: field.fields,
                findMany,
                flattenLocales,
                global,
                locale,
                overrideAccess,
                parentIndexPath: '',
                parentIsLocalized: parentIsLocalized || field.localized,
                parentPath: path + '.' + rowIndex,
                parentSchemaPath: schemaPath,
                populate,
                populationPromises,
                req,
                showHiddenFields,
                siblingDoc: (row as JsonObject) || {},
                triggerAccessControl,
                triggerHooks,
              })
            })
          }
        })
      } else {
        siblingDoc[field.name] = []
      }
      break
    }

    case 'blocks': {
      const rows = siblingDoc[field.name]

      if (Array.isArray(rows)) {
        rows.forEach((row, rowIndex) => {
          const blockTypeToMatch = (row as JsonObject).blockType

          const block: Block | undefined =
            req.payload.blocks[blockTypeToMatch] ??
            ((field.blockReferences ?? field.blocks).find(
              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
            ) as Block | undefined)

          const { blockSelect, blockSelectMode } = getBlockSelect({
            block,
            select: select?.[field.name],
            selectMode,
          })

          if (block) {
            traverseFields({
              blockData: row,
              collection,
              context,
              currentDepth,
              depth,
              doc,
              draft,
              fallbackLocale,
              fieldPromises,
              fields: block.fields,
              findMany,
              flattenLocales,
              global,
              locale,
              overrideAccess,
              parentIndexPath: '',
              parentIsLocalized: parentIsLocalized || field.localized,
              parentPath: path + '.' + rowIndex,
              parentSchemaPath: schemaPath + '.' + block.slug,
              populate,
              populationPromises,
              req,
              select: typeof blockSelect === 'object' ? blockSelect : undefined,
              selectMode: blockSelectMode,
              showHiddenFields,
              siblingDoc: (row as JsonObject) || {},
              triggerAccessControl,
              triggerHooks,
            })
          }
        })
      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {
        Object.values(rows).forEach((localeRows) => {
          if (Array.isArray(localeRows)) {
            localeRows.forEach((row, rowIndex) => {
              const blockTypeToMatch = row.blockType

              const block: Block | undefined =
                req.payload.blocks[blockTypeToMatch] ??
                ((field.blockReferences ?? field.blocks).find(
                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
                ) as Block | undefined)

              if (block) {
                traverseFields({
                  blockData: row,
                  collection,
                  context,
                  currentDepth,
                  depth,
                  doc,
                  draft,
                  fallbackLocale,
                  fieldPromises,
                  fields: block.fields,
                  findMany,
                  flattenLocales,
                  global,
                  locale,
                  overrideAccess,
                  parentIndexPath: '',
                  parentIsLocalized: parentIsLocalized || field.localized,
                  parentPath: path + '.' + rowIndex,
                  parentSchemaPath: schemaPath + '.' + block.slug,
                  populate,
                  populationPromises,
                  req,
                  showHiddenFields,
                  siblingDoc: (row as JsonObject) || {},
                  triggerAccessControl,
                  triggerHooks,
                })
              }
            })
          }
        })
      } else {
        siblingDoc[field.name] = []
      }

      break
    }

    case 'collapsible':
    case 'row': {
      traverseFields({
        blockData,
        collection,
        context,
        currentDepth,
        depth,
        doc,
        draft,
        fallbackLocale,
        fieldPromises,
        fields: field.fields,
        findMany,
        flattenLocales,
        global,
        locale,
        overrideAccess,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath: schemaPath,
        populate,
        populationPromises,
        req,
        select,
        selectMode,
        showHiddenFields,
        siblingDoc,
        triggerAccessControl,
        triggerHooks,
      })

      break
    }

    case 'group': {
      let groupDoc = siblingDoc[field.name] as JsonObject

      if (typeof siblingDoc[field.name] !== 'object') {
        groupDoc = {}
      }

      const groupSelect = select?.[field.name]

      traverseFields({
        blockData,
        collection,
        context,
        currentDepth,
        depth,
        doc,
        draft,
        fallbackLocale,
        fieldPromises,
        fields: field.fields,
        findMany,
        flattenLocales,
        global,
        locale,
        overrideAccess,
        parentIndexPath: '',
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        populate,
        populationPromises,
        req,
        select: typeof groupSelect === 'object' ? groupSelect : undefined,
        selectMode,
        showHiddenFields,
        siblingDoc: groupDoc,
        triggerAccessControl,
        triggerHooks,
      })

      break
    }

    case 'richText': {
      if (!field?.editor) {
        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof field?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      const editor: RichTextAdapter = field?.editor

      if (editor?.hooks?.afterRead?.length) {
        for (const hook of editor.hooks.afterRead) {
          const shouldRunHookOnAllLocales =
            fieldShouldBeLocalized({ field, parentIsLocalized }) &&
            (locale === 'all' || !flattenLocales) &&
            typeof siblingDoc[field.name] === 'object'

          if (shouldRunHookOnAllLocales) {
            const localesAndValues = Object.entries(siblingDoc[field.name])

            await Promise.all(
              localesAndValues.map(async ([locale, value]) => {
                const hookedValue = await hook({
                  collection,
                  context,
                  currentDepth,
                  data: doc,
                  depth,
                  draft,
                  fallbackLocale,
                  field,
                  fieldPromises,
                  findMany,
                  flattenLocales,
                  global,
                  indexPath: indexPathSegments,
                  locale,
                  operation: 'read',
                  originalDoc: doc,
                  overrideAccess,
                  parentIsLocalized,
                  path: pathSegments,
                  populate,
                  populationPromises,
                  req,
                  schemaPath: schemaPathSegments,
                  showHiddenFields,
                  siblingData: siblingDoc,
                  triggerAccessControl,
                  triggerHooks,
                  value,
                })

                if (hookedValue !== undefined) {
                  siblingDoc[field.name][locale] = hookedValue
                }
              }),
            )
          } else {
            const hookedValue = await hook({
              collection,
              context,
              currentDepth,
              data: doc,
              depth,
              draft,
              fallbackLocale,
              field,
              fieldPromises,
              findMany,
              flattenLocales,
              global,
              indexPath: indexPathSegments,
              locale,
              operation: 'read',
              originalDoc: doc,
              overrideAccess,
              parentIsLocalized,
              path: pathSegments,
              populate,
              populationPromises,
              req,
              schemaPath: schemaPathSegments,
              showHiddenFields,
              siblingData: siblingDoc,
              triggerAccessControl,
              triggerHooks,
              value: siblingDoc[field.name],
            })

            if (hookedValue !== undefined) {
              siblingDoc[field.name] = hookedValue
            }
          }
        }
      }
      break
    }

    case 'tab': {
      let tabDoc = siblingDoc
      let tabSelect: SelectType | undefined

      const isNamedTab = tabHasName(field)

      if (isNamedTab) {
        tabDoc = siblingDoc[field.name] as JsonObject

        if (typeof siblingDoc[field.name] !== 'object') {
          tabDoc = {}
        }

        if (typeof select?.[field.name] === 'object') {
          tabSelect = select?.[field.name] as SelectType
        }
      } else {
        tabSelect = select
      }

      traverseFields({
        blockData,
        collection,
        context,
        currentDepth,
        depth,
        doc,
        draft,
        fallbackLocale,
        fieldPromises,
        fields: field.fields,
        findMany,
        flattenLocales,
        global,
        locale,
        overrideAccess,
        parentIndexPath: isNamedTab ? '' : indexPath,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: isNamedTab ? path : parentPath,
        parentSchemaPath: schemaPath,
        populate,
        populationPromises,
        req,
        select: tabSelect,
        selectMode,
        showHiddenFields,
        siblingDoc: tabDoc,
        triggerAccessControl,
        triggerHooks,
      })

      break
    }

    case 'tabs': {
      traverseFields({
        blockData,
        collection,
        context,
        currentDepth,
        depth,
        doc,
        draft,
        fallbackLocale,
        fieldPromises,
        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
        findMany,
        flattenLocales,
        global,
        locale,
        overrideAccess,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        populate,
        populationPromises,
        req,
        select,
        selectMode,
        showHiddenFields,
        siblingDoc,
        triggerAccessControl,
        triggerHooks,
      })

      break
    }
    default: {
      break
    }
  }
}
</file>

<file path="packages/payload/src/fields/hooks/afterRead/relationshipPopulationPromise.ts">
// @ts-strict-ignore
import type { PayloadRequest, PopulateType } from '../../../types/index.js'
import type { JoinField, RelationshipField, UploadField } from '../../config/types.js'

import { createDataloaderCacheKey } from '../../../collections/dataloader.js'
import { fieldHasMaxDepth, fieldShouldBeLocalized, fieldSupportsMany } from '../../config/types.js'

type PopulateArgs = {
  currentDepth: number
  data: Record<string, unknown>
  dataReference: Record<string, any>
  depth: number
  draft: boolean
  fallbackLocale: null | string
  field: JoinField | RelationshipField | UploadField
  index?: number
  key?: string
  locale: null | string
  overrideAccess: boolean
  populateArg?: PopulateType
  req: PayloadRequest
  showHiddenFields: boolean
}

// TODO: this function is mess, refactor logic
const populate = async ({
  currentDepth,
  data,
  dataReference,
  depth,
  draft,
  fallbackLocale,
  field,
  index,
  key,
  locale,
  overrideAccess,
  populateArg,
  req,
  showHiddenFields,
}: PopulateArgs) => {
  const dataToUpdate = dataReference
  let relation
  if (field.type === 'join') {
    relation = Array.isArray(field.collection) ? data.relationTo : field.collection
  } else {
    relation = Array.isArray(field.relationTo) ? (data.relationTo as string) : field.relationTo
  }

  const relatedCollection = req.payload.collections[relation]

  if (relatedCollection) {
    let id: unknown

    if (field.type === 'join' && Array.isArray(field.collection)) {
      id = data.value
    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {
      id = data.value
    } else {
      id = data
    }

    let relationshipValue
    const shouldPopulate = depth && currentDepth <= depth

    if (
      typeof id !== 'string' &&
      typeof id !== 'number' &&
      typeof id?.toString === 'function' &&
      typeof id !== 'object'
    ) {
      id = id.toString()
    }

    if (shouldPopulate) {
      relationshipValue = await req.payloadDataLoader.load(
        createDataloaderCacheKey({
          collectionSlug: relatedCollection.config.slug,
          currentDepth: currentDepth + 1,
          depth,
          docID: id as string,
          draft,
          fallbackLocale,
          locale,
          overrideAccess,
          populate: populateArg,
          select:
            populateArg?.[relatedCollection.config.slug] ??
            relatedCollection.config.defaultPopulate,
          showHiddenFields,
          transactionID: req.transactionID,
        }),
      )
    }

    if (!relationshipValue) {
      // ids are visible regardless of access controls
      relationshipValue = id
    }
    if (typeof index === 'number' && typeof key === 'string') {
      if (field.type !== 'join' && Array.isArray(field.relationTo)) {
        dataToUpdate[field.name][key][index].value = relationshipValue
      } else {
        if (field.type === 'join' && Array.isArray(field.collection)) {
          dataToUpdate[field.name][key][index].value = relationshipValue
        } else {
          dataToUpdate[field.name][key][index] = relationshipValue
        }
      }
    } else if (typeof index === 'number' || typeof key === 'string') {
      if (field.type === 'join') {
        if (!Array.isArray(field.collection)) {
          dataToUpdate[field.name].docs[index ?? key] = relationshipValue
        } else {
          dataToUpdate[field.name].docs[index ?? key].value = relationshipValue
        }
      } else if (Array.isArray(field.relationTo)) {
        dataToUpdate[field.name][index ?? key].value = relationshipValue
      } else {
        dataToUpdate[field.name][index ?? key] = relationshipValue
      }
    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {
      dataToUpdate[field.name].value = relationshipValue
    } else {
      if (field.type === 'join' && Array.isArray(field.collection)) {
        dataToUpdate[field.name].value = relationshipValue
      } else {
        dataToUpdate[field.name] = relationshipValue
      }
    }
  }
}

type PromiseArgs = {
  currentDepth: number
  depth: number
  draft: boolean
  fallbackLocale: null | string
  field: JoinField | RelationshipField | UploadField
  locale: null | string
  overrideAccess: boolean
  parentIsLocalized: boolean
  populate?: PopulateType
  req: PayloadRequest
  showHiddenFields: boolean
  siblingDoc: Record<string, any>
}

export const relationshipPopulationPromise = async ({
  currentDepth,
  depth,
  draft,
  fallbackLocale,
  field,
  locale,
  overrideAccess,
  parentIsLocalized,
  populate: populateArg,
  req,
  showHiddenFields,
  siblingDoc,
}: PromiseArgs): Promise<void> => {
  const resultingDoc = siblingDoc
  const populateDepth = fieldHasMaxDepth(field) && field.maxDepth < depth ? field.maxDepth : depth
  const rowPromises = []

  if (field.type === 'join' || (fieldSupportsMany(field) && field.hasMany)) {
    if (
      fieldShouldBeLocalized({ field, parentIsLocalized }) &&
      locale === 'all' &&
      typeof siblingDoc[field.name] === 'object' &&
      siblingDoc[field.name] !== null
    ) {
      Object.keys(siblingDoc[field.name]).forEach((localeKey) => {
        if (Array.isArray(siblingDoc[field.name][localeKey])) {
          siblingDoc[field.name][localeKey].forEach((relatedDoc, index) => {
            const rowPromise = async () => {
              await populate({
                currentDepth,
                data: siblingDoc[field.name][localeKey][index],
                dataReference: resultingDoc,
                depth: populateDepth,
                draft,
                fallbackLocale,
                field,
                index,
                key: localeKey,
                locale,
                overrideAccess,
                populateArg,
                req,
                showHiddenFields,
              })
            }
            rowPromises.push(rowPromise())
          })
        }
      })
    } else if (
      Array.isArray(siblingDoc[field.name]) ||
      Array.isArray(siblingDoc[field.name]?.docs)
    ) {
      ;(Array.isArray(siblingDoc[field.name])
        ? siblingDoc[field.name]
        : siblingDoc[field.name].docs
      ).forEach((relatedDoc, index) => {
        const rowPromise = async () => {
          if (relatedDoc) {
            await populate({
              currentDepth,
              data:
                !(field.type === 'join' && Array.isArray(field.collection)) && relatedDoc?.id
                  ? relatedDoc.id
                  : relatedDoc,
              dataReference: resultingDoc,
              depth: populateDepth,
              draft,
              fallbackLocale,
              field,
              index,
              locale,
              overrideAccess,
              populateArg,
              req,
              showHiddenFields,
            })
          }
        }

        rowPromises.push(rowPromise())
      })
    }
  } else if (
    field.localized &&
    locale === 'all' &&
    typeof siblingDoc[field.name] === 'object' &&
    siblingDoc[field.name] !== null
  ) {
    Object.keys(siblingDoc[field.name]).forEach((localeKey) => {
      const rowPromise = async () => {
        await populate({
          currentDepth,
          data: siblingDoc[field.name][localeKey],
          dataReference: resultingDoc,
          depth: populateDepth,
          draft,
          fallbackLocale,
          field,
          key: localeKey,
          locale,
          overrideAccess,
          populateArg,
          req,
          showHiddenFields,
        })
      }
      rowPromises.push(rowPromise())
    })

    await Promise.all(rowPromises)
  } else if (siblingDoc[field.name]) {
    await populate({
      currentDepth,
      data: siblingDoc[field.name],
      dataReference: resultingDoc,
      depth: populateDepth,
      draft,
      fallbackLocale,
      field,
      locale,
      overrideAccess,
      populateArg,
      req,
      showHiddenFields,
    })
  }
  await Promise.all(rowPromises)
}
</file>

<file path="packages/payload/src/fields/hooks/afterRead/traverseFields.ts">
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type {
  JsonObject,
  PayloadRequest,
  PopulateType,
  SelectMode,
  SelectType,
} from '../../../types/index.js'
import type { Field, TabAsField } from '../../config/types.js'

import { promise } from './promise.js'

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  currentDepth: number
  depth: number
  doc: JsonObject
  draft: boolean
  fallbackLocale: null | string
  /**
   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises
   */
  fieldPromises: Promise<void>[]
  fields: (Field | TabAsField)[]
  findMany: boolean
  flattenLocales: boolean
  global: null | SanitizedGlobalConfig
  locale: null | string
  overrideAccess: boolean
  parentIndexPath: string
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized?: boolean
  parentPath: string
  parentSchemaPath: string
  populate?: PopulateType
  populationPromises: Promise<void>[]
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  showHiddenFields: boolean
  siblingDoc: JsonObject
  triggerAccessControl?: boolean
  triggerHooks?: boolean
}

export const traverseFields = ({
  blockData,
  collection,
  context,
  currentDepth,
  depth,
  doc,
  draft,
  fallbackLocale,
  fieldPromises,
  fields,
  findMany,
  flattenLocales,
  global,
  locale,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  populate,
  populationPromises,
  req,
  select,
  selectMode,
  showHiddenFields,
  siblingDoc,
  triggerAccessControl = true,
  triggerHooks = true,
}: Args): void => {
  fields.forEach((field, fieldIndex) => {
    fieldPromises.push(
      promise({
        blockData,
        collection,
        context,
        currentDepth,
        depth,
        doc,
        draft,
        fallbackLocale,
        field,
        fieldIndex,
        fieldPromises,
        findMany,
        flattenLocales,
        global,
        locale,
        overrideAccess,
        parentIndexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath,
        populate,
        populationPromises,
        req,
        select,
        selectMode,
        showHiddenFields,
        siblingDoc,
        siblingFields: fields,
        triggerAccessControl,
        triggerHooks,
      }),
    )
  })
}
</file>

<file path="packages/payload/src/fields/hooks/beforeChange/cloneDataFromOriginalDoc.ts">
import type { JsonArray, JsonObject } from '../../../types/index.js'

export const cloneDataFromOriginalDoc = (
  originalDocData: JsonArray | JsonObject,
): JsonArray | JsonObject => {
  if (Array.isArray(originalDocData)) {
    return originalDocData.map((row) => {
      if (typeof row === 'object' && row != null) {
        return {
          ...row,
        }
      }

      return row
    })
  }

  if (typeof originalDocData === 'object' && originalDocData !== null) {
    return { ...originalDocData }
  }

  return originalDocData
}
</file>

<file path="packages/payload/src/fields/hooks/beforeChange/getExistingRowDoc.ts">
/**
 * If there is an incoming row id,
 * and it matches the existing sibling doc id,
 * this is an existing row, so it should be merged.
 * Otherwise, return an empty object.
 */
import type { JsonObject } from '../../../types/index.js'

export const getExistingRowDoc = (incomingRow: JsonObject, existingRows?: unknown): JsonObject => {
  if (incomingRow.id && Array.isArray(existingRows)) {
    const matchedExistingRow = existingRows.find((existingRow) => {
      if (typeof existingRow === 'object' && 'id' in existingRow) {
        if (existingRow.id === incomingRow.id) {
          return existingRow
        }
      }

      return false
    })

    if (matchedExistingRow) {
      return matchedExistingRow
    }
  }

  return {}
}
</file>

<file path="packages/payload/src/fields/hooks/beforeChange/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { ValidationFieldError } from '../../../errors/index.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'

import { ValidationError } from '../../../errors/index.js'
import { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'
import { traverseFields } from './traverseFields.js'
export type Args<T extends JsonObject> = {
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: T
  doc: T
  docWithLocales: JsonObject
  global: null | SanitizedGlobalConfig
  id?: number | string
  operation: Operation
  req: PayloadRequest
  skipValidation?: boolean
}

/**
 * This function is responsible for the following actions, in order:
 * - Run condition
 * - Execute field hooks
 * - Validate data
 * - Transform data for storage
 * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.
 */

export const beforeChange = async <T extends JsonObject>({
  id,
  collection,
  context,
  data: incomingData,
  doc,
  docWithLocales,
  global,
  operation,
  req,
  skipValidation,
}: Args<T>): Promise<T> => {
  const data = deepCopyObjectSimple(incomingData)
  const mergeLocaleActions = []
  const errors: ValidationFieldError[] = []

  await traverseFields({
    id,
    collection,
    context,
    data,
    doc,
    docWithLocales,
    errors,
    fieldLabelPath: '',
    fields: collection?.fields || global?.fields,
    global,
    mergeLocaleActions,
    operation,
    parentIndexPath: '',
    parentIsLocalized: false,
    parentPath: '',
    parentSchemaPath: '',
    req,
    siblingData: data,
    siblingDoc: doc,
    siblingDocWithLocales: docWithLocales,
    skipValidation,
  })

  if (errors.length > 0) {
    throw new ValidationError(
      {
        id,
        collection: collection?.slug,
        errors,
        global: global?.slug,
        req,
      },
      req.t,
    )
  }

  for (const action of mergeLocaleActions) {
    await action()
  }

  return data
}
</file>

<file path="packages/payload/src/fields/hooks/beforeChange/promise.ts">
// @ts-strict-ignore
import type { RichTextAdapter } from '../../../admin/RichText.js'
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { ValidationFieldError } from '../../../errors/index.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'
import type { Block, Field, TabAsField, Validate } from '../../config/types.js'

import { MissingEditorProp } from '../../../errors/index.js'
import { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'
import { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'
import { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'
import { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'
import { getExistingRowDoc } from './getExistingRowDoc.js'
import { traverseFields } from './traverseFields.js'

function buildFieldLabel(parentLabel: string, label: string): string {
  const capitalizedLabel = label.charAt(0).toUpperCase() + label.slice(1)
  return parentLabel && capitalizedLabel
    ? `${parentLabel} > ${capitalizedLabel}`
    : capitalizedLabel || parentLabel
}

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: JsonObject
  doc: JsonObject
  docWithLocales: JsonObject
  errors: ValidationFieldError[]
  field: Field | TabAsField
  fieldIndex: number
  /**
   * Built up labels of parent fields
   *
   * @example "Group Field > Tab Field > Text Field"
   */
  fieldLabelPath: string
  global: null | SanitizedGlobalConfig
  id?: number | string
  mergeLocaleActions: (() => Promise<void> | void)[]
  operation: Operation
  parentIndexPath: string
  parentIsLocalized: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingData: JsonObject
  siblingDoc: JsonObject
  siblingDocWithLocales?: JsonObject
  siblingFields?: (Field | TabAsField)[]
  skipValidation: boolean
}

// This function is responsible for the following actions, in order:
// - Run condition
// - Execute field hooks
// - Validate data
// - Transform data for storage
// - beforeDuplicate hooks (if duplicate)
// - Unflatten locales

export const promise = async ({
  id,
  blockData,
  collection,
  context,
  data,
  doc,
  docWithLocales,
  errors,
  field,
  fieldIndex,
  fieldLabelPath,
  global,
  mergeLocaleActions,
  operation,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingData,
  siblingDoc,
  siblingDocWithLocales,
  siblingFields,
  skipValidation,
}: Args): Promise<void> => {
  const { indexPath, path, schemaPath } = getFieldPaths({
    field,
    index: fieldIndex,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
  })

  const { localization } = req.payload.config
  const defaultLocale = localization ? localization?.defaultLocale : 'en'
  const operationLocale = req.locale || defaultLocale

  const pathSegments = path ? path.split('.') : []
  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []
  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []

  const passesCondition = field.admin?.condition
    ? Boolean(
        field.admin.condition(data, siblingData, { blockData, path: pathSegments, user: req.user }),
      )
    : true
  let skipValidationFromHere = skipValidation || !passesCondition

  if (fieldAffectsData(field)) {
    // skip validation if the field is localized and the incoming data is null
    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && operationLocale !== defaultLocale) {
      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {
        skipValidationFromHere = true
      }
    }

    // Execute hooks
    if (field.hooks?.beforeChange) {
      for (const hook of field.hooks.beforeChange) {
        const hookedValue = await hook({
          blockData,
          collection,
          context,
          data,
          field,
          global,
          indexPath: indexPathSegments,
          operation,
          originalDoc: doc,
          path: pathSegments,
          previousSiblingDoc: siblingDoc,
          previousValue: siblingDoc[field.name],
          req,
          schemaPath: schemaPathSegments,
          siblingData,
          siblingDocWithLocales,
          siblingFields,
          value: siblingData[field.name],
        })

        if (hookedValue !== undefined) {
          siblingData[field.name] = hookedValue
        }
      }
    }

    // Validate
    if (!skipValidationFromHere && 'validate' in field && field.validate) {
      const valueToValidate = siblingData[field.name]
      let jsonError: object

      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {
        try {
          JSON.parse(siblingData[field.name] as string)
        } catch (e) {
          jsonError = e
        }
      }

      const validateFn: Validate<object, object, object, object> = field.validate as Validate<
        object,
        object,
        object,
        object
      >
      const validationResult = await validateFn(valueToValidate as never, {
        ...field,
        id,
        blockData,
        collectionSlug: collection?.slug,
        data: deepMergeWithSourceArrays(doc, data),
        event: 'submit',
        // @ts-expect-error
        jsonError,
        operation,
        path: pathSegments,
        preferences: { fields: {} },
        previousValue: siblingDoc[field.name],
        req,
        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),
      })

      if (typeof validationResult === 'string') {
        const fieldLabel = buildFieldLabel(
          fieldLabelPath,
          getTranslatedLabel(field?.label || field?.name, req.i18n),
        )

        errors.push({
          label: fieldLabel,
          message: validationResult,
          path,
        })
      }
    }

    // Push merge locale action if applicable
    if (localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {
      mergeLocaleActions.push(() => {
        const localeData = {}

        for (const locale of localization.localeCodes) {
          const fieldValue =
            locale === req.locale
              ? siblingData[field.name]
              : siblingDocWithLocales?.[field.name]?.[locale]

          // update locale value if it's not undefined
          if (typeof fieldValue !== 'undefined') {
            localeData[locale] = fieldValue
          }
        }

        // If there are locales with data, set the data
        if (Object.keys(localeData).length > 0) {
          siblingData[field.name] = localeData
        }
      })
    }
  }

  switch (field.type) {
    case 'array': {
      const rows = siblingData[field.name]

      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row, rowIndex) => {
          promises.push(
            traverseFields({
              id,
              blockData,
              collection,
              context,
              data,
              doc,
              docWithLocales,
              errors,
              fieldLabelPath:
                field?.label === false
                  ? fieldLabelPath
                  : buildFieldLabel(
                      fieldLabelPath,
                      `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,
                    ),
              fields: field.fields,
              global,
              mergeLocaleActions,
              operation,
              parentIndexPath: '',
              parentIsLocalized: parentIsLocalized || field.localized,
              parentPath: path + '.' + rowIndex,
              parentSchemaPath: schemaPath,
              req,
              siblingData: row as JsonObject,
              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),
              siblingDocWithLocales: getExistingRowDoc(
                row as JsonObject,
                siblingDocWithLocales[field.name],
              ),
              skipValidation: skipValidationFromHere,
            }),
          )
        })

        await Promise.all(promises)
      }

      break
    }

    case 'blocks': {
      const rows = siblingData[field.name]
      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row, rowIndex) => {
          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])

          const rowSiblingDocWithLocales = getExistingRowDoc(
            row as JsonObject,
            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},
          )

          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType

          const block: Block | undefined =
            req.payload.blocks[blockTypeToMatch] ??
            ((field.blockReferences ?? field.blocks).find(
              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
            ) as Block | undefined)

          if (block) {
            promises.push(
              traverseFields({
                id,
                blockData: row,
                collection,
                context,
                data,
                doc,
                docWithLocales,
                errors,
                fieldLabelPath:
                  field?.label === false
                    ? fieldLabelPath
                    : buildFieldLabel(
                        fieldLabelPath,
                        `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,
                      ),
                fields: block.fields,
                global,
                mergeLocaleActions,
                operation,
                parentIndexPath: '',
                parentIsLocalized: parentIsLocalized || field.localized,
                parentPath: path + '.' + rowIndex,
                parentSchemaPath: schemaPath + '.' + block.slug,
                req,
                siblingData: row as JsonObject,
                siblingDoc: rowSiblingDoc,
                siblingDocWithLocales: rowSiblingDocWithLocales,
                skipValidation: skipValidationFromHere,
              }),
            )
          }
        })

        await Promise.all(promises)
      }

      break
    }

    case 'collapsible':
    case 'row': {
      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        docWithLocales,
        errors,
        fieldLabelPath:
          field.type === 'row' || field?.label === false
            ? fieldLabelPath
            : buildFieldLabel(
                fieldLabelPath,
                getTranslatedLabel(field?.label || field?.type, req.i18n),
              ),
        fields: field.fields,
        global,
        mergeLocaleActions,
        operation,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath: schemaPath,
        req,
        siblingData,
        siblingDoc,
        siblingDocWithLocales,
        skipValidation: skipValidationFromHere,
      })

      break
    }

    case 'group': {
      if (typeof siblingData[field.name] !== 'object') {
        siblingData[field.name] = {}
      }

      if (typeof siblingDoc[field.name] !== 'object') {
        siblingDoc[field.name] = {}
      }

      if (typeof siblingDocWithLocales[field.name] !== 'object') {
        siblingDocWithLocales[field.name] = {}
      }

      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        docWithLocales,
        errors,
        fieldLabelPath:
          field?.label === false
            ? fieldLabelPath
            : buildFieldLabel(
                fieldLabelPath,
                getTranslatedLabel(field?.label || field?.name, req.i18n),
              ),
        fields: field.fields,
        global,
        mergeLocaleActions,
        operation,
        parentIndexPath: '',
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        req,
        siblingData: siblingData[field.name] as JsonObject,
        siblingDoc: siblingDoc[field.name] as JsonObject,
        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,
        skipValidation: skipValidationFromHere,
      })

      break
    }

    case 'point': {
      // Transform point data for storage
      if (
        Array.isArray(siblingData[field.name]) &&
        siblingData[field.name][0] !== null &&
        siblingData[field.name][1] !== null
      ) {
        siblingData[field.name] = {
          type: 'Point',
          coordinates: [
            parseFloat(siblingData[field.name][0]),
            parseFloat(siblingData[field.name][1]),
          ],
        }
      }

      break
    }

    case 'richText': {
      if (!field?.editor) {
        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof field?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      const editor: RichTextAdapter = field?.editor

      if (editor?.hooks?.beforeChange?.length) {
        for (const hook of editor.hooks.beforeChange) {
          const hookedValue = await hook({
            collection,
            context,
            data,
            docWithLocales,
            errors,
            field,
            fieldLabelPath:
              field?.label === false
                ? fieldLabelPath
                : buildFieldLabel(
                    fieldLabelPath,
                    getTranslatedLabel(field?.label || field?.name, req.i18n),
                  ),
            global,
            indexPath: indexPathSegments,
            mergeLocaleActions,
            operation,
            originalDoc: doc,
            parentIsLocalized,
            path: pathSegments,
            previousSiblingDoc: siblingDoc,
            previousValue: siblingDoc[field.name],
            req,
            schemaPath: schemaPathSegments,
            siblingData,
            siblingDocWithLocales,
            skipValidation,
            value: siblingData[field.name],
          })

          if (hookedValue !== undefined) {
            siblingData[field.name] = hookedValue
          }
        }
      }

      break
    }

    case 'tab': {
      let tabSiblingData = siblingData
      let tabSiblingDoc = siblingDoc
      let tabSiblingDocWithLocales = siblingDocWithLocales

      const isNamedTab = tabHasName(field)

      if (isNamedTab) {
        if (typeof siblingData[field.name] !== 'object') {
          siblingData[field.name] = {}
        }

        if (typeof siblingDoc[field.name] !== 'object') {
          siblingDoc[field.name] = {}
        }

        if (typeof siblingDocWithLocales[field.name] !== 'object') {
          siblingDocWithLocales[field.name] = {}
        }

        tabSiblingData = siblingData[field.name] as JsonObject
        tabSiblingDoc = siblingDoc[field.name] as JsonObject
        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject
      }

      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        docWithLocales,
        errors,
        fieldLabelPath:
          field?.label === false
            ? fieldLabelPath
            : buildFieldLabel(
                fieldLabelPath,
                getTranslatedLabel(field?.label || field?.name, req.i18n),
              ),
        fields: field.fields,
        global,
        mergeLocaleActions,
        operation,
        parentIndexPath: isNamedTab ? '' : indexPath,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: isNamedTab ? path : parentPath,
        parentSchemaPath: schemaPath,
        req,
        siblingData: tabSiblingData,
        siblingDoc: tabSiblingDoc,
        siblingDocWithLocales: tabSiblingDocWithLocales,
        skipValidation: skipValidationFromHere,
      })

      break
    }

    case 'tabs': {
      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        docWithLocales,
        errors,
        fieldLabelPath:
          field?.label === false
            ? fieldLabelPath
            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(field?.label || '', req.i18n)),
        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
        global,
        mergeLocaleActions,
        operation,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        req,
        siblingData,
        siblingDoc,
        siblingDocWithLocales,
        skipValidation: skipValidationFromHere,
      })

      break
    }

    default: {
      break
    }
  }
}
</file>

<file path="packages/payload/src/fields/hooks/beforeChange/traverseFields.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { ValidationFieldError } from '../../../errors/index.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'
import type { Field, TabAsField } from '../../config/types.js'

import { promise } from './promise.js'

type Args = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: JsonObject
  /**
   * The original data (not modified by any hooks)
   */
  doc: JsonObject
  /**
   * The original data with locales (not modified by any hooks)
   */
  docWithLocales: JsonObject
  errors: ValidationFieldError[]
  /**
   * Built up labels of parent fields
   *
   * @example "Group Field > Tab Field > Text Field"
   */
  fieldLabelPath: string
  fields: (Field | TabAsField)[]
  global: null | SanitizedGlobalConfig
  id?: number | string
  mergeLocaleActions: (() => Promise<void> | void)[]
  operation: Operation
  parentIndexPath: string
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized?: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingData: JsonObject
  /**
   * The original siblingData (not modified by any hooks)
   */
  siblingDoc: JsonObject
  /**
   * The original siblingData with locales (not modified by any hooks)
   */
  siblingDocWithLocales: JsonObject
  skipValidation?: boolean
}

/**
 * This function is responsible for the following actions, in order:
 * - Run condition
 * - Execute field hooks
 * - Validate data
 * - Transform data for storage
 * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.
 */
export const traverseFields = async ({
  id,
  blockData,
  collection,
  context,
  data,
  doc,
  docWithLocales,
  errors,
  fieldLabelPath,
  fields,
  global,
  mergeLocaleActions,
  operation,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingData,
  siblingDoc,
  siblingDocWithLocales,
  skipValidation,
}: Args): Promise<void> => {
  const promises = []

  fields.forEach((field, fieldIndex) => {
    promises.push(
      promise({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        docWithLocales,
        errors,
        field,
        fieldIndex,
        fieldLabelPath,
        global,
        mergeLocaleActions,
        operation,
        parentIndexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath,
        req,
        siblingData,
        siblingDoc,
        siblingDocWithLocales,
        siblingFields: fields,
        skipValidation,
      }),
    )
  })

  await Promise.all(promises)
}
</file>

<file path="packages/payload/src/fields/hooks/beforeDuplicate/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'

import { traverseFields } from './traverseFields.js'

type Args<T extends JsonObject> = {
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  doc?: T
  id?: number | string
  overrideAccess: boolean
  req: PayloadRequest
}

/**
 * This function is responsible for running beforeDuplicate hooks
 * against a document including all locale data.
 * It will run each field's beforeDuplicate hook
 * and return the resulting docWithLocales.
 */
export const beforeDuplicate = async <T extends JsonObject>({
  id,
  collection,
  context,
  doc,
  overrideAccess,
  req,
}: Args<T>): Promise<T> => {
  await traverseFields({
    id,
    collection,
    context,
    doc,
    fields: collection?.fields,
    overrideAccess,
    parentIndexPath: '',
    parentIsLocalized: false,
    parentPath: '',
    parentSchemaPath: '',
    req,
    siblingDoc: doc,
  })

  return doc
}
</file>

<file path="packages/payload/src/fields/hooks/beforeDuplicate/promise.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'
import type { Block, Field, FieldHookArgs, TabAsField } from '../../config/types.js'

import { fieldAffectsData, fieldShouldBeLocalized } from '../../config/types.js'
import { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'
import { traverseFields } from './traverseFields.js'

type Args<T> = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  doc: T
  field: Field | TabAsField
  fieldIndex: number
  id?: number | string
  overrideAccess: boolean
  parentIndexPath: string
  parentIsLocalized: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingDoc: JsonObject
  siblingFields?: (Field | TabAsField)[]
}

export const promise = async <T>({
  id,
  blockData,
  collection,
  context,
  doc,
  field,
  fieldIndex,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingDoc,
  siblingFields,
}: Args<T>): Promise<void> => {
  const { indexPath, path, schemaPath } = getFieldPaths({
    field,
    index: fieldIndex,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
  })

  const { localization } = req.payload.config

  const pathSegments = path ? path.split('.') : []
  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []
  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []

  if (fieldAffectsData(field)) {
    let fieldData = siblingDoc?.[field.name]
    const fieldIsLocalized = localization && fieldShouldBeLocalized({ field, parentIsLocalized })

    // Run field beforeDuplicate hooks
    if (Array.isArray(field.hooks?.beforeDuplicate)) {
      if (fieldIsLocalized) {
        const localeData: JsonObject = {}

        for (const locale of localization.localeCodes) {
          const beforeDuplicateArgs: FieldHookArgs = {
            blockData,
            collection,
            context,
            data: doc,
            field,
            global: undefined,
            indexPath: indexPathSegments,
            path: pathSegments,
            previousSiblingDoc: siblingDoc,
            previousValue: siblingDoc[field.name]?.[locale],
            req,
            schemaPath: schemaPathSegments,
            siblingData: siblingDoc,
            siblingDocWithLocales: siblingDoc,
            siblingFields,
            value: siblingDoc[field.name]?.[locale],
          }

          let hookResult
          for (const hook of field.hooks.beforeDuplicate) {
            hookResult = await hook(beforeDuplicateArgs)
          }

          if (typeof hookResult !== 'undefined') {
            localeData[locale] = hookResult
          }
        }

        siblingDoc[field.name] = localeData
      } else {
        const beforeDuplicateArgs: FieldHookArgs = {
          blockData,
          collection,
          context,
          data: doc,
          field,
          global: undefined,
          indexPath: indexPathSegments,
          path: pathSegments,
          previousSiblingDoc: siblingDoc,
          previousValue: siblingDoc[field.name],
          req,
          schemaPath: schemaPathSegments,
          siblingData: siblingDoc,
          siblingDocWithLocales: siblingDoc,
          siblingFields,
          value: siblingDoc[field.name],
        }

        let hookResult
        for (const hook of field.hooks.beforeDuplicate) {
          hookResult = await hook(beforeDuplicateArgs)
        }

        if (typeof hookResult !== 'undefined') {
          siblingDoc[field.name] = hookResult
        }
      }
    }

    // First, for any localized fields, we will loop over locales
    // and if locale data is present, traverse the sub fields.
    // There are only a few different fields where this is possible.
    if (fieldIsLocalized) {
      if (typeof fieldData !== 'object' || fieldData === null) {
        siblingDoc[field.name] = {}
        fieldData = siblingDoc[field.name]
      }

      const promises = []

      localization.localeCodes.forEach((locale) => {
        if (fieldData[locale]) {
          switch (field.type) {
            case 'array': {
              const rows = fieldData[locale]

              if (Array.isArray(rows)) {
                const promises = []

                rows.forEach((row, rowIndex) => {
                  promises.push(
                    traverseFields({
                      id,
                      blockData,
                      collection,
                      context,
                      doc,
                      fields: field.fields,
                      overrideAccess,
                      parentIndexPath: '',
                      parentIsLocalized: parentIsLocalized || field.localized,
                      parentPath: path + '.' + rowIndex,
                      parentSchemaPath: schemaPath,
                      req,
                      siblingDoc: row,
                    }),
                  )
                })
              }

              break
            }

            case 'blocks': {
              const rows = fieldData[locale]

              if (Array.isArray(rows)) {
                const promises = []

                rows.forEach((row, rowIndex) => {
                  const blockTypeToMatch = row.blockType

                  const block: Block | undefined =
                    req.payload.blocks[blockTypeToMatch] ??
                    ((field.blockReferences ?? field.blocks).find(
                      (curBlock) =>
                        typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
                    ) as Block | undefined)

                  promises.push(
                    traverseFields({
                      id,
                      blockData: row,
                      collection,
                      context,
                      doc,
                      fields: block.fields,
                      overrideAccess,
                      parentIndexPath: '',
                      parentIsLocalized: parentIsLocalized || field.localized,
                      parentPath: path + '.' + rowIndex,
                      parentSchemaPath: schemaPath + '.' + block.slug,
                      req,
                      siblingDoc: row,
                    }),
                  )
                })
              }
              break
            }

            case 'group':
            case 'tab': {
              promises.push(
                traverseFields({
                  id,
                  blockData,
                  collection,
                  context,
                  doc,
                  fields: field.fields,
                  overrideAccess,
                  parentIndexPath: '',
                  parentIsLocalized: parentIsLocalized || field.localized,
                  parentPath: path,
                  parentSchemaPath: schemaPath,
                  req,
                  siblingDoc: fieldData[locale],
                }),
              )

              break
            }
          }
        }
      })

      await Promise.all(promises)
    } else {
      // If the field is not localized, but it affects data,
      // we need to further traverse its children
      // so the child fields can run beforeDuplicate hooks
      switch (field.type) {
        case 'array': {
          const rows = siblingDoc[field.name]

          if (Array.isArray(rows)) {
            const promises = []

            rows.forEach((row, rowIndex) => {
              promises.push(
                traverseFields({
                  id,
                  blockData,
                  collection,
                  context,
                  doc,
                  fields: field.fields,
                  overrideAccess,
                  parentIndexPath: '',
                  parentIsLocalized: parentIsLocalized || field.localized,
                  parentPath: path + '.' + rowIndex,
                  parentSchemaPath: schemaPath,
                  req,
                  siblingDoc: row,
                }),
              )
            })

            await Promise.all(promises)
          }

          break
        }

        case 'blocks': {
          const rows = siblingDoc[field.name]

          if (Array.isArray(rows)) {
            const promises = []

            rows.forEach((row, rowIndex) => {
              const blockTypeToMatch = row.blockType

              const block: Block | undefined =
                req.payload.blocks[blockTypeToMatch] ??
                ((field.blockReferences ?? field.blocks).find(
                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
                ) as Block | undefined)

              if (block) {
                ;(row as JsonObject).blockType = blockTypeToMatch

                promises.push(
                  traverseFields({
                    id,
                    blockData: row,
                    collection,
                    context,
                    doc,
                    fields: block.fields,
                    overrideAccess,
                    parentIndexPath: '',
                    parentIsLocalized: parentIsLocalized || field.localized,
                    parentPath: path + '.' + rowIndex,
                    parentSchemaPath: schemaPath + '.' + block.slug,
                    req,
                    siblingDoc: row,
                  }),
                )
              }
            })

            await Promise.all(promises)
          }

          break
        }

        case 'group': {
          if (typeof siblingDoc[field.name] !== 'object') {
            siblingDoc[field.name] = {}
          }

          const groupDoc = siblingDoc[field.name] as JsonObject

          await traverseFields({
            id,
            blockData,
            collection,
            context,
            doc,
            fields: field.fields,
            overrideAccess,
            parentIndexPath: '',
            parentIsLocalized: parentIsLocalized || field.localized,
            parentPath: path,
            parentSchemaPath: schemaPath,
            req,
            siblingDoc: groupDoc,
          })

          break
        }

        case 'tab': {
          if (typeof siblingDoc[field.name] !== 'object') {
            siblingDoc[field.name] = {}
          }

          const tabDoc = siblingDoc[field.name] as JsonObject

          await traverseFields({
            id,
            blockData,
            collection,
            context,
            doc,
            fields: field.fields,
            overrideAccess,
            parentIndexPath: '',
            parentIsLocalized: parentIsLocalized || field.localized,
            parentPath: path,
            parentSchemaPath: schemaPath,
            req,
            siblingDoc: tabDoc,
          })

          break
        }
      }
    }
  } else {
    // Finally, we traverse fields which do not affect data here
    switch (field.type) {
      case 'collapsible':
      case 'row': {
        await traverseFields({
          id,
          blockData,
          collection,
          context,
          doc,
          fields: field.fields,
          overrideAccess,
          parentIndexPath: indexPath,
          parentIsLocalized,
          parentPath,
          parentSchemaPath: schemaPath,
          req,
          siblingDoc,
        })

        break
      }

      // Unnamed Tab
      // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField
      case 'tab': {
        await traverseFields({
          id,
          blockData,
          collection,
          context,
          doc,
          // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField
          fields: field.fields,
          overrideAccess,
          parentIndexPath: indexPath,
          parentIsLocalized,
          parentPath,
          parentSchemaPath: schemaPath,
          req,
          siblingDoc,
        })

        break
      }

      case 'tabs': {
        await traverseFields({
          id,
          blockData,
          collection,
          context,
          doc,
          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
          overrideAccess,
          parentIndexPath: indexPath,
          parentIsLocalized,
          parentPath: path,
          parentSchemaPath: schemaPath,
          req,
          siblingDoc,
        })

        break
      }

      default: {
        break
      }
    }
  }
}
</file>

<file path="packages/payload/src/fields/hooks/beforeDuplicate/traverseFields.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'
import type { Field, TabAsField } from '../../config/types.js'

import { promise } from './promise.js'

type Args<T> = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  doc: T
  fields: (Field | TabAsField)[]
  id?: number | string
  overrideAccess: boolean
  parentIndexPath: string
  parentIsLocalized: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingDoc: JsonObject
}

export const traverseFields = async <T>({
  id,
  blockData,
  collection,
  context,
  doc,
  fields,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingDoc,
}: Args<T>): Promise<void> => {
  const promises = []

  fields.forEach((field, fieldIndex) => {
    promises.push(
      promise({
        id,
        blockData,
        collection,
        context,
        doc,
        field,
        fieldIndex,
        overrideAccess,
        parentIndexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath,
        req,
        siblingDoc,
        siblingFields: fields,
      }),
    )
  })
  await Promise.all(promises)
}
</file>

<file path="packages/payload/src/fields/hooks/beforeValidate/getFallbackValue.ts">
import type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'
import type { FieldAffectingData } from '../../config/types.js'

import { getDefaultValue } from '../../getDefaultValue.js'
import { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'

export async function getFallbackValue({
  field,
  req,
  siblingDoc,
}: {
  field: FieldAffectingData
  req: PayloadRequest
  siblingDoc: JsonObject
}): Promise<JsonValue> {
  let fallbackValue = undefined
  if ('name' in field && field.name) {
    if (typeof siblingDoc[field.name] !== 'undefined') {
      fallbackValue = cloneDataFromOriginalDoc(siblingDoc[field.name])
    } else if ('defaultValue' in field && typeof field.defaultValue !== 'undefined') {
      fallbackValue = await getDefaultValue({
        defaultValue: field.defaultValue,
        locale: req.locale || '',
        req,
        user: req.user,
      })
    }
  }

  return fallbackValue
}
</file>

<file path="packages/payload/src/fields/hooks/beforeValidate/index.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'

import { type RequestContext } from '../../../index.js'
import { traverseFields } from './traverseFields.js'

type Args<T extends JsonObject> = {
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: T
  doc?: T
  duplicate?: boolean
  global: null | SanitizedGlobalConfig
  id?: number | string
  operation: 'create' | 'update'
  overrideAccess: boolean
  req: PayloadRequest
}

/**
 * This function is responsible for the following actions, in order:
 * - Sanitize incoming data
 * - Execute field hooks
 * - Execute field access control
 * - Merge original document data into incoming data
 * - Compute default values for undefined fields
 */
export const beforeValidate = async <T extends JsonObject>({
  id,
  collection,
  context,
  data: incomingData,
  doc,
  global,
  operation,
  overrideAccess,
  req,
}: Args<T>): Promise<T> => {
  await traverseFields({
    id,
    collection,
    context,
    data: incomingData,
    doc,
    fields: collection?.fields || global?.fields,
    global,
    operation,
    overrideAccess,
    parentIndexPath: '',
    parentIsLocalized: false,
    parentPath: '',
    parentSchemaPath: '',
    req,
    siblingData: incomingData,
    siblingDoc: doc,
  })

  return incomingData
}
</file>

<file path="packages/payload/src/fields/hooks/beforeValidate/promise.ts">
// @ts-strict-ignore
import type { RichTextAdapter } from '../../../admin/RichText.js'
import type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'
import type { Block, Field, TabAsField } from '../../config/types.js'

import { MissingEditorProp } from '../../../errors/index.js'
import { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'
import { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'
import { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'
import { getFallbackValue } from './getFallbackValue.js'
import { traverseFields } from './traverseFields.js'

type Args<T> = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: T
  /**
   * The original data (not modified by any hooks)
   */
  doc: T
  field: Field | TabAsField
  fieldIndex: number
  global: null | SanitizedGlobalConfig
  id?: number | string
  operation: 'create' | 'update'
  overrideAccess: boolean
  parentIndexPath: string
  parentIsLocalized: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingData: JsonObject
  /**
   * The original siblingData (not modified by any hooks)
   */
  siblingDoc: JsonObject
  siblingFields?: (Field | TabAsField)[]
}

// This function is responsible for the following actions, in order:
// - Sanitize incoming data
// - Execute field hooks
// - Execute field access control
// - Merge original document data into incoming data
// - Compute default values for undefined fields

export const promise = async <T>({
  id,
  blockData,
  collection,
  context,
  data,
  doc,
  field,
  fieldIndex,
  global,
  operation,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingData,
  siblingDoc,
  siblingFields,
}: Args<T>): Promise<void> => {
  const { indexPath, path, schemaPath } = getFieldPaths({
    field,
    index: fieldIndex,
    parentIndexPath,
    parentPath,
    parentSchemaPath,
  })

  const pathSegments = path ? path.split('.') : []
  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []
  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []

  if (fieldAffectsData(field)) {
    if (field.name === 'id') {
      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {
        const value = siblingData[field.name] as string

        siblingData[field.name] = parseFloat(value)
      }

      if (
        field.type === 'text' &&
        typeof siblingData[field.name]?.toString === 'function' &&
        typeof siblingData[field.name] !== 'string'
      ) {
        siblingData[field.name] = siblingData[field.name].toString()
      }
    }

    // Sanitize incoming data
    switch (field.type) {
      case 'array':
      case 'blocks': {
        // Handle cases of arrays being intentionally set to 0
        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {
          siblingData[field.name] = []
        }

        break
      }

      case 'checkbox': {
        if (siblingData[field.name] === 'true') {
          siblingData[field.name] = true
        }
        if (siblingData[field.name] === 'false') {
          siblingData[field.name] = false
        }
        if (siblingData[field.name] === '') {
          siblingData[field.name] = false
        }

        break
      }

      case 'number': {
        if (typeof siblingData[field.name] === 'string') {
          const value = siblingData[field.name] as string
          const trimmed = value.trim()
          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)
        }

        break
      }

      case 'point': {
        if (Array.isArray(siblingData[field.name])) {
          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {
            if (typeof coordinate === 'string') {
              const value = siblingData[field.name][i] as string
              const trimmed = value.trim()
              return trimmed.length === 0 ? null : parseFloat(trimmed)
            }
            return coordinate
          })
        }

        break
      }
      case 'relationship':
      case 'upload': {
        if (
          siblingData[field.name] === '' ||
          siblingData[field.name] === 'none' ||
          siblingData[field.name] === 'null' ||
          siblingData[field.name] === null
        ) {
          if (field.hasMany === true) {
            siblingData[field.name] = []
          } else {
            siblingData[field.name] = null
          }
        }

        const value = siblingData[field.name]

        if (Array.isArray(field.relationTo)) {
          if (Array.isArray(value)) {
            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {
              const relatedCollection = req.payload.collections?.[relatedDoc.relationTo]?.config

              if (
                typeof relatedDoc.value === 'object' &&
                relatedDoc.value &&
                'id' in relatedDoc.value
              ) {
                relatedDoc.value = relatedDoc.value.id
              }

              if (relatedCollection?.fields) {
                const relationshipIDField = relatedCollection.fields.find(
                  (collectionField) =>
                    fieldAffectsData(collectionField) && collectionField.name === 'id',
                )
                if (relationshipIDField?.type === 'number') {
                  siblingData[field.name][i] = {
                    ...relatedDoc,
                    value: parseFloat(relatedDoc.value as string),
                  }
                }
              }
            })
          }
          if (field.hasMany !== true && valueIsValueWithRelation(value)) {
            const relatedCollection = req.payload.collections?.[value.relationTo]?.config

            if (typeof value.value === 'object' && value.value && 'id' in value.value) {
              value.value = (value.value as TypeWithID).id
            }

            if (relatedCollection?.fields) {
              const relationshipIDField = relatedCollection.fields.find(
                (collectionField) =>
                  fieldAffectsData(collectionField) && collectionField.name === 'id',
              )
              if (relationshipIDField?.type === 'number') {
                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }
              }
            }
          }
        } else {
          if (Array.isArray(value)) {
            value.forEach((relatedDoc: unknown, i) => {
              const relatedCollection = Array.isArray(field.relationTo)
                ? undefined
                : req.payload.collections?.[field.relationTo]?.config

              if (typeof relatedDoc === 'object' && relatedDoc && 'id' in relatedDoc) {
                value[i] = relatedDoc.id
              }

              if (relatedCollection?.fields) {
                const relationshipIDField = relatedCollection.fields.find(
                  (collectionField) =>
                    fieldAffectsData(collectionField) && collectionField.name === 'id',
                )
                if (relationshipIDField?.type === 'number') {
                  siblingData[field.name][i] = parseFloat(relatedDoc as string)
                }
              }
            })
          }
          if (field.hasMany !== true && value) {
            const relatedCollection = req.payload.collections?.[field.relationTo]?.config

            if (typeof value === 'object' && value && 'id' in value) {
              siblingData[field.name] = value.id
            }

            if (relatedCollection?.fields) {
              const relationshipIDField = relatedCollection.fields.find(
                (collectionField) =>
                  fieldAffectsData(collectionField) && collectionField.name === 'id',
              )
              if (relationshipIDField?.type === 'number') {
                siblingData[field.name] = parseFloat(value as string)
              }
            }
          }
        }
        break
      }
      case 'richText': {
        if (typeof siblingData[field.name] === 'string') {
          try {
            const richTextJSON = JSON.parse(siblingData[field.name] as string)
            siblingData[field.name] = richTextJSON
          } catch {
            // Disregard this data as it is not valid.
            // Will be reported to user by field validation
          }
        }

        break
      }

      default: {
        break
      }
    }

    // ensure the fallback value is only computed one time
    // either here or when access control returns false
    const fallbackResult = {
      executed: false,
      value: undefined,
    }
    if (typeof siblingData[field.name] === 'undefined') {
      fallbackResult.value = await getFallbackValue({ field, req, siblingDoc })
      fallbackResult.executed = true
    }

    // Execute hooks
    if (field.hooks?.beforeValidate) {
      for (const hook of field.hooks.beforeValidate) {
        const hookedValue = await hook({
          blockData,
          collection,
          context,
          data,
          field,
          global,
          indexPath: indexPathSegments,
          operation,
          originalDoc: doc,
          overrideAccess,
          path: pathSegments,
          previousSiblingDoc: siblingDoc,
          previousValue: siblingDoc[field.name],
          req,
          schemaPath: schemaPathSegments,
          siblingData,
          siblingFields,
          value:
            typeof siblingData[field.name] === 'undefined'
              ? fallbackResult.value
              : siblingData[field.name],
        })

        if (hookedValue !== undefined) {
          siblingData[field.name] = hookedValue
        }
      }
    }

    // Execute access control
    if (field.access && field.access[operation]) {
      const result = overrideAccess
        ? true
        : await field.access[operation]({ id, blockData, data, doc, req, siblingData })

      if (!result) {
        delete siblingData[field.name]
      }
    }

    if (typeof siblingData[field.name] === 'undefined') {
      siblingData[field.name] = !fallbackResult.executed
        ? await getFallbackValue({ field, req, siblingDoc })
        : fallbackResult.value
    }
  }

  // Traverse subfields
  switch (field.type) {
    case 'array': {
      const rows = siblingData[field.name]

      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row, rowIndex) => {
          promises.push(
            traverseFields({
              id,
              blockData,
              collection,
              context,
              data,
              doc,
              fields: field.fields,
              global,
              operation,
              overrideAccess,
              parentIndexPath: '',
              parentIsLocalized: parentIsLocalized || field.localized,
              parentPath: path + '.' + rowIndex,
              parentSchemaPath: schemaPath,
              req,
              siblingData: row as JsonObject,
              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),
            }),
          )
        })

        await Promise.all(promises)
      }
      break
    }

    case 'blocks': {
      const rows = siblingData[field.name]

      if (Array.isArray(rows)) {
        const promises = []

        rows.forEach((row, rowIndex) => {
          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])
          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType

          const block: Block | undefined =
            req.payload.blocks[blockTypeToMatch] ??
            ((field.blockReferences ?? field.blocks).find(
              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,
            ) as Block | undefined)

          if (block) {
            ;(row as JsonObject).blockType = blockTypeToMatch

            promises.push(
              traverseFields({
                id,
                blockData: row,
                collection,
                context,
                data,
                doc,
                fields: block.fields,
                global,
                operation,
                overrideAccess,
                parentIndexPath: '',
                parentIsLocalized: parentIsLocalized || field.localized,
                parentPath: path + '.' + rowIndex,
                parentSchemaPath: schemaPath + '.' + block.slug,
                req,
                siblingData: row as JsonObject,
                siblingDoc: rowSiblingDoc,
              }),
            )
          }
        })

        await Promise.all(promises)
      }

      break
    }

    case 'collapsible':
    case 'row': {
      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        overrideAccess,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath: schemaPath,
        req,
        siblingData,
        siblingDoc,
      })

      break
    }

    case 'group': {
      if (typeof siblingData[field.name] !== 'object') {
        siblingData[field.name] = {}
      }

      if (typeof siblingDoc[field.name] !== 'object') {
        siblingDoc[field.name] = {}
      }

      const groupData = siblingData[field.name] as Record<string, unknown>
      const groupDoc = siblingDoc[field.name] as Record<string, unknown>

      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        overrideAccess,
        parentIndexPath: '',
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        req,
        siblingData: groupData as JsonObject,
        siblingDoc: groupDoc as JsonObject,
      })

      break
    }

    case 'richText': {
      if (!field?.editor) {
        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
      }

      if (typeof field?.editor === 'function') {
        throw new Error('Attempted to access unsanitized rich text editor.')
      }

      const editor: RichTextAdapter = field?.editor

      if (editor?.hooks?.beforeValidate?.length) {
        for (const hook of editor.hooks.beforeValidate) {
          const hookedValue = await hook({
            collection,
            context,
            data,
            field,
            global,
            indexPath: indexPathSegments,
            operation,
            originalDoc: doc,
            overrideAccess,
            parentIsLocalized,
            path: pathSegments,
            previousSiblingDoc: siblingDoc,
            previousValue: siblingData[field.name],
            req,
            schemaPath: schemaPathSegments,
            siblingData,
            value: siblingData[field.name],
          })

          if (hookedValue !== undefined) {
            siblingData[field.name] = hookedValue
          }
        }
      }
      break
    }

    case 'tab': {
      let tabSiblingData
      let tabSiblingDoc

      const isNamedTab = tabHasName(field)

      if (isNamedTab) {
        if (typeof siblingData[field.name] !== 'object') {
          siblingData[field.name] = {}
        }

        if (typeof siblingDoc[field.name] !== 'object') {
          siblingDoc[field.name] = {}
        }

        tabSiblingData = siblingData[field.name] as Record<string, unknown>
        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>
      } else {
        tabSiblingData = siblingData
        tabSiblingDoc = siblingDoc
      }

      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.fields,
        global,
        operation,
        overrideAccess,
        parentIndexPath: isNamedTab ? '' : indexPath,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentPath: isNamedTab ? path : parentPath,
        parentSchemaPath: schemaPath,
        req,
        siblingData: tabSiblingData,
        siblingDoc: tabSiblingDoc,
      })

      break
    }

    case 'tabs': {
      await traverseFields({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),
        global,
        operation,
        overrideAccess,
        parentIndexPath: indexPath,
        parentIsLocalized,
        parentPath: path,
        parentSchemaPath: schemaPath,
        req,
        siblingData,
        siblingDoc,
      })

      break
    }

    default: {
      break
    }
  }
}
</file>

<file path="packages/payload/src/fields/hooks/beforeValidate/traverseFields.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../../../globals/config/types.js'
import type { RequestContext } from '../../../index.js'
import type { JsonObject, PayloadRequest } from '../../../types/index.js'
import type { Field, TabAsField } from '../../config/types.js'

import { promise } from './promise.js'

type Args<T> = {
  /**
   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`
   */
  blockData?: JsonObject
  collection: null | SanitizedCollectionConfig
  context: RequestContext
  data: T
  /**
   * The original data (not modified by any hooks)
   */
  doc: T
  fields: (Field | TabAsField)[]
  global: null | SanitizedGlobalConfig
  id?: number | string
  operation: 'create' | 'update'
  overrideAccess: boolean
  parentIndexPath: string
  /**
   * @todo make required in v4.0
   */
  parentIsLocalized?: boolean
  parentPath: string
  parentSchemaPath: string
  req: PayloadRequest
  siblingData: JsonObject
  /**
   * The original siblingData (not modified by any hooks)
   */
  siblingDoc: JsonObject
}

export const traverseFields = async <T>({
  id,
  blockData,
  collection,
  context,
  data,
  doc,
  fields,
  global,
  operation,
  overrideAccess,
  parentIndexPath,
  parentIsLocalized,
  parentPath,
  parentSchemaPath,
  req,
  siblingData,
  siblingDoc,
}: Args<T>): Promise<void> => {
  const promises = []

  fields.forEach((field, fieldIndex) => {
    promises.push(
      promise({
        id,
        blockData,
        collection,
        context,
        data,
        doc,
        field,
        fieldIndex,
        global,
        operation,
        overrideAccess,
        parentIndexPath,
        parentIsLocalized,
        parentPath,
        parentSchemaPath,
        req,
        siblingData,
        siblingDoc,
        siblingFields: fields,
      }),
    )
  })

  await Promise.all(promises)
}
</file>

<file path="packages/payload/src/fields/getDefaultValue.ts">
import type { DefaultValue, JsonValue, PayloadRequest } from '../types/index.js'

import { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'

type Args = {
  defaultValue: DefaultValue
  locale: string | undefined
  req: PayloadRequest
  user: PayloadRequest['user']
  value?: JsonValue
}

export const getDefaultValue = async ({
  defaultValue,
  locale,
  req,
  user,
  value,
}: Args): Promise<JsonValue> => {
  if (typeof value !== 'undefined') {
    return value
  }

  if (defaultValue && typeof defaultValue === 'function') {
    return await defaultValue({ locale, req, user })
  }

  if (typeof defaultValue === 'object') {
    return deepCopyObjectSimple(defaultValue)
  }

  return defaultValue
}
</file>

<file path="packages/payload/src/fields/getFieldPaths.ts">
// @ts-strict-ignore
import type { ClientField, Field, Tab, TabAsFieldClient } from './config/types.js'

type Args = {
  field: ClientField | Field | Tab | TabAsFieldClient
  index: number
  parentIndexPath: string
  parentPath: string
  parentSchemaPath: string
}

type FieldPaths = {
  /**
   * A string of '-' separated indexes representing where
   * to find this field in a given field schema array.
   * It will always be complete and accurate.
   */
  indexPath: string
  /**
   * Path for this field relative to its position in the data.
   */
  path: string
  /**
   * Path for this field relative to its position in the schema.
   */
  schemaPath: string
}

export function getFieldPaths({
  field,
  index,
  parentIndexPath,
  parentPath,
  parentSchemaPath,
}: Args): FieldPaths {
  if ('name' in field) {
    return {
      indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,
      path: `${parentPath ? parentPath + '.' : ''}${field.name}`,
      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,
    }
  }

  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`

  return {
    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,
    path: `${parentPath ? parentPath + '.' : ''}${indexSuffix}`,
    schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,
  }
}

export function getFieldPathsModified({
  field,
  index,
  parentIndexPath,
  parentPath,
  parentSchemaPath,
}: Args): FieldPaths {
  const parentPathSegments = parentPath.split('.')

  const parentIsUnnamed = parentPathSegments[parentPathSegments.length - 1].startsWith('_index-')

  const parentWithoutIndex = parentIsUnnamed
    ? parentPathSegments.slice(0, -1).join('.')
    : parentPath

  const parentPathToUse = parentIsUnnamed ? parentWithoutIndex : parentPath

  if ('name' in field) {
    return {
      indexPath: '',
      path: `${parentPathToUse ? parentPathToUse + '.' : ''}${field.name}`,
      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,
    }
  }

  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`

  return {
    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,
    path: `${parentPathToUse ? parentPathToUse + '.' : ''}${indexSuffix}`,
    schemaPath: `${!parentIsUnnamed && parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,
  }
}
</file>

<file path="packages/payload/src/fields/mergeBaseFields.ts">
// @ts-strict-ignore
import type { Field, FieldWithSubFields } from './config/types.js'

import { deepMergeWithReactComponents } from '../utilities/deepMerge.js'
import { fieldAffectsData, fieldHasSubFields } from './config/types.js'

const mergeBaseFields = (fields: Field[], baseFields: Field[]): Field[] => {
  const mergedFields = [...(fields || [])]

  baseFields.forEach((baseField) => {
    let matchedIndex = null

    if (fieldAffectsData(baseField)) {
      const match = mergedFields.find((field, i) => {
        if (fieldAffectsData(field) && field.name === baseField.name) {
          matchedIndex = i
          return true
        }

        return false
      })

      if (match) {
        const matchCopy: Field = { ...match }
        mergedFields.splice(matchedIndex, 1)

        const mergedField = deepMergeWithReactComponents<Field>(baseField, matchCopy)

        if (fieldHasSubFields(baseField) && fieldHasSubFields(matchCopy)) {
          ;(mergedField as FieldWithSubFields).fields = mergeBaseFields(
            matchCopy.fields,
            baseField.fields,
          )
        }

        mergedFields.push(mergedField)
      } else {
        mergedFields.push(baseField)
      }
    }
  })

  return mergedFields
}

export default mergeBaseFields
</file>

<file path="packages/payload/src/fields/setDefaultBeforeDuplicate.ts">
// @ts-strict-ignore
// default beforeDuplicate hook for required and unique fields
import { type FieldAffectingData, type FieldHook, fieldShouldBeLocalized } from './config/types.js'

const isStringValue = (value) => typeof value === 'string' && value.trim() !== ''
const unique: FieldHook = ({ value }) => (isStringValue(value) ? `${value} - Copy` : undefined)
const localizedUnique: FieldHook = ({ req, value }) =>
  isStringValue(value) ? `${value} - ${req?.t('general:copy') ?? 'Copy'}` : undefined

export const setDefaultBeforeDuplicate = (
  field: FieldAffectingData,
  parentIsLocalized: boolean,
) => {
  if (
    (('required' in field && field.required) || field.unique) &&
    (!field.hooks?.beforeDuplicate ||
      (Array.isArray(field.hooks.beforeDuplicate) && field.hooks.beforeDuplicate.length === 0))
  ) {
    if (field.unique) {
      if (['email', 'number', 'point', 'relationship', 'select', 'upload'].includes(field.type)) {
        field.hooks.beforeDuplicate = [() => undefined]
      } else if (['code', 'json', 'text', 'textarea'].includes(field.type)) {
        field.hooks.beforeDuplicate = fieldShouldBeLocalized({ field, parentIsLocalized })
          ? [localizedUnique]
          : [unique]
      }
    }
  }
}
</file>

<file path="packages/payload/src/fields/sortableFieldTypes.ts">
export default ['text', 'textarea', 'code', 'json', 'number', 'email', 'radio', 'select', 'date']
</file>

<file path="packages/payload/src/fields/validations.spec.ts">
import { jest } from '@jest/globals'

import type { ValidateOptions } from './config/types.js'

import { number, password, point, relationship, select, text, textarea } from './validations.js'

const t = jest.fn((string) => string)

let options: ValidateOptions<any, any, any> = {
  data: undefined,
  operation: 'create',
  req: {
    context: {},
    payload: {
      config: {
        db: {
          defaultIDType: 'text',
          init: () => null,
        },
      },
    },
    t,
  },
  siblingData: undefined,
}

describe('Field Validations', () => {
  describe('text', () => {
    it('should validate', () => {
      const val = 'test'
      const result = text(val, options)
      expect(result).toBe(true)
    })
    it('should show required message', () => {
      const val = undefined
      const result = text(val, { ...options, required: true })
      expect(result).toBe('validation:required')
    })
    it('should handle undefined', () => {
      const val = undefined
      const result = text(val, options)
      expect(result).toBe(true)
    })
    it('should validate maxLength', () => {
      const val = 'toolong'
      const result = text(val, { ...options, maxLength: 5 })
      expect(result).toBe('validation:shorterThanMax')
    })
    it('should validate minLength', () => {
      const val = 'short'
      const result = text(val, { ...options, minLength: 10 })
      expect(result).toBe('validation:longerThanMin')
    })
    it('should validate maxLength with no value', () => {
      const val = undefined
      const result = text(val, { ...options, maxLength: 5 })
      expect(result).toBe(true)
    })
    it('should validate minLength with no value', () => {
      const val = undefined
      const result = text(val, { ...options, minLength: 10 })
      expect(result).toBe(true)
    })
    it('should validate an array of texts', async () => {
      const val = ['test']
      const result = text(val, { ...options, hasMany: true })
      expect(result).toBe(true)
    })
    it('should handle required array of texts', async () => {
      const val = ['test']
      const result = text(val, { ...options, hasMany: true, required: true })
      expect(result).toBe(true)
    })
  })

  describe('textarea', () => {
    options = { ...options, field: { name: 'test', type: 'textarea' } }
    it('should validate', () => {
      const val = 'test'
      const result = textarea(val, options)
      expect(result).toBe(true)
    })
    it('should show required message', () => {
      const val = undefined
      const result = textarea(val, { ...options, required: true })
      expect(result).toBe('validation:required')
    })

    it('should handle undefined', () => {
      const val = undefined
      const result = textarea(val, options)
      expect(result).toBe(true)
    })
    it('should validate maxLength', () => {
      const val = 'toolong'
      const result = textarea(val, { ...options, maxLength: 5 })
      expect(result).toBe('validation:shorterThanMax')
    })

    it('should validate minLength', () => {
      const val = 'short'
      const result = textarea(val, { ...options, minLength: 10 })
      expect(result).toBe('validation:longerThanMin')
    })
    it('should validate maxLength with no value', () => {
      const val = undefined
      const result = textarea(val, { ...options, maxLength: 5 })
      expect(result).toBe(true)
    })
    it('should validate minLength with no value', () => {
      const val = undefined
      const result = textarea(val, { ...options, minLength: 10 })
      expect(result).toBe(true)
    })
  })

  describe('password', () => {
    const passwordOptions = {
      ...options,
      name: 'test',
      type: 'password',
    }
    it('should validate', () => {
      const val = 'test'
      const result = password(val, passwordOptions)
      expect(result).toBe(true)
    })
    it('should show required message', () => {
      const val = undefined
      const result = password(val, { ...passwordOptions, required: true })
      expect(result).toBe('validation:required')
    })
    it('should handle undefined', () => {
      const val = undefined
      const result = password(val, passwordOptions)
      expect(result).toBe(true)
    })
    it('should validate maxLength', () => {
      const val = 'toolong'
      const result = password(val, { ...passwordOptions, maxLength: 5 })
      expect(result).toBe('validation:shorterThanMax')
    })
    it('should validate minLength', () => {
      const val = 'short'
      const result = password(val, { ...passwordOptions, minLength: 10 })
      expect(result).toBe('validation:longerThanMin')
    })
    it('should validate maxLength with no value', () => {
      const val = undefined
      const result = password(val, { ...passwordOptions, maxLength: 5 })
      expect(result).toBe(true)
    })
    it('should validate minLength with no value', () => {
      const val = undefined
      const result = password(val, { ...passwordOptions, minLength: 10 })
      expect(result).toBe(true)
    })
  })

  describe('point', () => {
    const pointOptions = {
      ...options,
      name: 'point',
      type: 'point',
    }
    it('should validate numbers', () => {
      const val = ['0.1', '0.2']
      const result = point(val, pointOptions)
      expect(result).toBe(true)
    })
    it('should validate strings that could be numbers', () => {
      const val = ['0.1', '0.2']
      const result = point(val, pointOptions)
      expect(result).toBe(true)
    })
    it('should show required message when undefined', () => {
      const val = undefined
      const result = point(val, { ...pointOptions, required: true })
      expect(result).not.toBe(true)
    })
    it('should show required message when array', () => {
      const val = []
      const result = point(val, { ...pointOptions, required: true })
      expect(result).not.toBe(true)
    })
    it('should show required message when array of undefined', () => {
      const val = [undefined, undefined]
      const result = point(val, { ...pointOptions, required: true })
      expect(result).not.toBe(true)
    })
    it('should handle undefined not required', () => {
      const val = undefined
      const result = password(val, pointOptions)
      expect(result).toBe(true)
    })
    it('should handle empty array not required', () => {
      const val = []
      const result = point(val, pointOptions)
      expect(result).toBe(true)
    })
    it('should handle array of undefined not required', () => {
      const val = [undefined, undefined]
      const result = point(val, pointOptions)
      expect(result).toBe(true)
    })
    it('should prevent text input', () => {
      const val = ['bad', 'input']
      const result = point(val, pointOptions)
      expect(result).not.toBe(true)
    })
    it('should prevent missing value', () => {
      const val = [0.1]
      const result = point(val, pointOptions)
      expect(result).not.toBe(true)
    })
  })

  describe('relationship', () => {
    const relationCollection = {
      slug: 'relation',
      fields: [
        {
          name: 'id',
          type: 'text',
        },
      ],
    }

    const relationshipOptions = {
      ...options,
      relationTo: 'relation',
      req: {
        ...options.req,
        payload: {
          ...options.req.payload,
          collections: {
            relation: {
              config: relationCollection,
            },
          },
          config: {
            collections: [relationCollection],
          },
        },
      },
    }
    it('should handle required', async () => {
      const val = undefined
      const result = await relationship(val, { ...relationshipOptions, required: true })
      expect(result).not.toBe(true)
    })
    it('should handle required with hasMany', async () => {
      const val = []
      const result = await relationship(val, {
        ...relationshipOptions,
        hasMany: true,
        required: true,
      })
      expect(result).not.toBe(true)
    })
    it('should enforce hasMany min', async () => {
      const minOptions = {
        ...relationshipOptions,
        hasMany: true,
        minRows: 2,
      }

      const val = ['a']

      const result = await relationship(val, minOptions)
      expect(result).not.toBe(true)

      const allowed = await relationship(['a', 'b'], minOptions)
      expect(allowed).toStrictEqual(true)
    })
    it('should enforce hasMany max', async () => {
      const maxOptions = {
        ...relationshipOptions,
        hasMany: true,
        maxRows: 2,
      }
      let val = ['a', 'b', 'c']

      const result = await relationship(val, maxOptions)
      expect(result).not.toBe(true)

      val = ['a']
      const allowed = await relationship(val, maxOptions)
      expect(allowed).toStrictEqual(true)
    })
  })

  describe('select', () => {
    const selectOptions = {
      ...options,
      type: 'select',
      options: ['one', 'two', 'three'],
    }
    const optionsRequired = {
      ...selectOptions,
      options: [
        {
          label: 'One',
          value: 'one',
        },
        {
          label: 'two',
          value: 'two',
        },
        {
          label: 'three',
          value: 'three',
        },
      ],
      required: true,
    }
    const optionsWithEmptyString = {
      ...selectOptions,
      options: [
        {
          label: 'None',
          value: '',
        },
        {
          label: 'Option',
          value: 'option',
        },
      ],
    }
    it('should allow valid input', () => {
      const val = 'one'
      const result = select(val, selectOptions)
      expect(result).toStrictEqual(true)
    })
    it('should prevent invalid input', () => {
      const val = 'bad'
      const result = select(val, selectOptions)
      expect(result).not.toStrictEqual(true)
    })
    it('should allow null input', () => {
      const val = null
      const result = select(val, selectOptions)
      expect(result).toStrictEqual(true)
    })
    it('should allow undefined input', () => {
      let val
      const result = select(val, selectOptions)
      expect(result).toStrictEqual(true)
    })
    it('should prevent empty string input', () => {
      const val = ''
      const result = select(val, selectOptions)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent undefined input with required', () => {
      let val
      const result = select(val, optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent empty string input with required', () => {
      const result = select('', optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent undefined input with required and hasMany', () => {
      let val
      options.hasMany = true
      const result = select(val, optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent empty array input with required and hasMany', () => {
      optionsRequired.hasMany = true
      const result = select([], optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent empty string array input with required and hasMany', () => {
      options.hasMany = true
      const result = select([''], optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should prevent null input with required and hasMany', () => {
      const val = null
      options.hasMany = true
      const result = select(val, optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should allow valid input with option objects', () => {
      const val = 'one'
      options.hasMany = false
      const result = select(val, optionsRequired)
      expect(result).toStrictEqual(true)
    })
    it('should prevent invalid input with option objects', () => {
      const val = 'bad'
      options.hasMany = false
      const result = select(val, optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
    it('should allow empty string input with option object', () => {
      const val = ''
      const result = select(val, optionsWithEmptyString)
      expect(result).toStrictEqual(true)
    })
    it('should allow empty string input with option object and required', () => {
      const val = ''
      optionsWithEmptyString.required = true
      const result = select(val, optionsWithEmptyString)
      expect(result).toStrictEqual(true)
    })
    it('should allow valid input with hasMany', () => {
      const val = ['one', 'two']
      const result = select(val, selectOptions)
      expect(result).toStrictEqual(true)
    })
    it('should prevent invalid input with hasMany', () => {
      const val = ['one', 'bad']
      const result = select(val, selectOptions)
      expect(result).not.toStrictEqual(true)
    })
    it('should allow valid input with hasMany option objects', () => {
      const val = ['one', 'three']
      optionsRequired.hasMany = true
      const result = select(val, optionsRequired)
      expect(result).toStrictEqual(true)
    })
    it('should prevent invalid input with hasMany option objects', () => {
      const val = ['three', 'bad']
      optionsRequired.hasMany = true
      const result = select(val, optionsRequired)
      expect(result).not.toStrictEqual(true)
    })
  })
  describe('number', () => {
    const numberOptions = {
      ...options,
      name: 'test',
      type: 'number',
    }
    it('should validate', () => {
      const val = 1
      const result = number(val, numberOptions)
      expect(result).toBe(true)
    })
    it('should validate 0', () => {
      const val = 0
      const result = number(val, { ...numberOptions, required: true })
      expect(result).toBe(true)
    })
    it('should validate 2', () => {
      const val = 1.5
      const result = number(val, numberOptions)
      expect(result).toBe(true)
    })
    it('should show invalid number message', () => {
      const val = 'test'
      const result = number(val, { ...numberOptions })
      expect(result).toBe('validation:enterNumber')
    })
    it('should handle empty value', () => {
      const val = ''
      const result = number(val, { ...numberOptions })
      expect(result).toBe(true)
    })
    it('should handle required value', () => {
      const val = ''
      const result = number(val, { ...numberOptions, required: true })
      expect(result).toBe('validation:required')
    })
    it('should validate minValue', () => {
      const val = 2.4
      const result = number(val, { ...numberOptions, min: 2.5 })
      expect(result).toBe('validation:lessThanMin')
    })
    it('should validate maxValue', () => {
      const val = 1.25
      const result = number(val, { ...numberOptions, max: 1 })
      expect(result).toBe('validation:greaterThanMax')
    })
    it('should validate an array of numbers', async () => {
      const val = [1.25, 2.5]
      const result = number(val, { ...numberOptions, hasMany: true })
      expect(result).toBe(true)
    })
    it('should validate an array of numbers using min', async () => {
      const val = [1.25, 2.5]
      const result = number(val, { ...numberOptions, hasMany: true, min: 3 })
      expect(result).toBe('validation:lessThanMin')
    })
    it('should validate an array of numbers using max', async () => {
      const val = [1.25, 2.5]
      const result = number(val, { ...numberOptions, hasMany: true, max: 1 })
      expect(result).toBe('validation:greaterThanMax')
    })
    it('should validate an array of numbers using minRows', async () => {
      const val = [1.25, 2.5]
      const result = number(val, { ...numberOptions, hasMany: true, minRows: 4 })
      expect(result).toBe('validation:requiresAtLeast')
    })
    it('should validate an array of numbers using maxRows', async () => {
      const val = [1.25, 2.5, 3.5]
      const result = number(val, { ...numberOptions, hasMany: true, maxRows: 2 })
      expect(result).toBe('validation:requiresNoMoreThan')
    })
  })
})
</file>

<file path="packages/payload/src/fields/validations.ts">
// @ts-strict-ignore
import Ajv from 'ajv'
import ObjectIdImport from 'bson-objectid'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

import type { RichTextAdapter } from '../admin/types.js'
import type { CollectionSlug } from '../index.js'
import type { Where } from '../types/index.js'
import type {
  ArrayField,
  BlocksField,
  CheckboxField,
  CodeField,
  DateField,
  EmailField,
  JSONField,
  NumberField,
  PointField,
  RadioField,
  RelationshipField,
  RelationshipValue,
  RelationshipValueMany,
  RelationshipValueSingle,
  RichTextField,
  SelectField,
  TextareaField,
  TextField,
  UploadField,
  Validate,
} from './config/types.js'

import { isNumber } from '../utilities/isNumber.js'
import { isValidID } from '../utilities/isValidID.js'

export type TextFieldValidation = Validate<string, unknown, unknown, TextField>

export type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>

export type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>

export const text: TextFieldValidation = (
  value,
  {
    hasMany,
    maxLength: fieldMaxLength,
    maxRows,
    minLength,
    minRows,
    req: {
      payload: { config },
      t,
    },
    required,
  },
) => {
  let maxLength: number

  if (!required) {
    if (!value) {
      return true
    }
  }

  if (hasMany === true) {
    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })
    if (typeof lengthValidationResult === 'string') {
      return lengthValidationResult
    }
  }

  if (typeof config?.defaultMaxTextLength === 'number') {
    maxLength = config.defaultMaxTextLength
  }
  if (typeof fieldMaxLength === 'number') {
    maxLength = fieldMaxLength
  }

  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]

  for (const stringValue of stringsToValidate) {
    const length = stringValue?.length || 0

    if (typeof maxLength === 'number' && length > maxLength) {
      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })
    }

    if (typeof minLength === 'number' && length < minLength) {
      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })
    }
  }

  if (required) {
    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {
      return t('validation:required')
    }
  }

  return true
}

export type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>

export const password: PasswordFieldValidation = (
  value,
  {
    maxLength: fieldMaxLength,
    minLength = 3,
    req: {
      payload: { config },
      t,
    },
    required,
  },
) => {
  let maxLength: number

  if (typeof config?.defaultMaxTextLength === 'number') {
    maxLength = config.defaultMaxTextLength
  }
  if (typeof fieldMaxLength === 'number') {
    maxLength = fieldMaxLength
  }

  if (value && maxLength && value.length > maxLength) {
    return t('validation:shorterThanMax', { maxLength })
  }

  if (value && minLength && value.length < minLength) {
    return t('validation:longerThanMin', { minLength })
  }

  if (required && !value) {
    return t('validation:required')
  }

  return true
}

export type ConfirmPasswordFieldValidation = Validate<
  string,
  unknown,
  { password: string },
  TextField
>

export const confirmPassword: ConfirmPasswordFieldValidation = (
  value,
  { req: { t }, required, siblingData },
) => {
  if (required && !value) {
    return t('validation:required')
  }

  if (value && value !== siblingData.password) {
    return t('fields:passwordsDoNotMatch')
  }

  return true
}

export type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>

export const email: EmailFieldValidation = (
  value,
  {
    collectionSlug,
    req: {
      payload: { collections, config },
      t,
    },
    required,
    siblingData,
  },
) => {
  if (collectionSlug) {
    const collection =
      collections?.[collectionSlug]?.config ??
      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available

    if (
      collection.auth.loginWithUsername &&
      !collection.auth.loginWithUsername?.requireUsername &&
      !collection.auth.loginWithUsername?.requireEmail
    ) {
      if (!value && !siblingData?.username) {
        return t('validation:required')
      }
    }
  }

  /**
   * Disallows emails with double quotes (e.g., "user"@example.com, user@"example.com", "user@example.com")
   * Rejects spaces anywhere in the email (e.g., user @example.com, user@ example.com, user name@example.com)
   * Prevents consecutive dots in the local or domain part (e.g., user..name@example.com, user@example..com)
   * Disallows domains that start or end with a hyphen (e.g., user@-example.com, user@example-.com)
   * Allows standard email formats (e.g., user@example.com, user.name+alias@example.co.uk, user-name@example.org)
   * Allows domains with consecutive hyphens as long as they are not leading/trailing (e.g., user@ex--ample.com)
   * Supports multiple subdomains (e.g., user@sub.domain.example.com)
   */
  const emailRegex =
    /^(?!.*\.\.)[\w.%+-]+@[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)*\.[a-z]{2,}$/i

  if ((value && !emailRegex.test(value)) || (!value && required)) {
    return t('validation:emailAddress')
  }

  return true
}

export type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>

export const username: UsernameFieldValidation = (
  value,
  {
    collectionSlug,
    req: {
      payload: { collections, config },
      t,
    },
    required,
    siblingData,
  },
) => {
  let maxLength: number

  if (collectionSlug) {
    const collection =
      collections?.[collectionSlug]?.config ??
      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available

    if (
      collection.auth.loginWithUsername &&
      !collection.auth.loginWithUsername?.requireUsername &&
      !collection.auth.loginWithUsername?.requireEmail
    ) {
      if (!value && !siblingData?.email) {
        return t('validation:required')
      }
    }
  }

  if (typeof config?.defaultMaxTextLength === 'number') {
    maxLength = config.defaultMaxTextLength
  }

  if (value && maxLength && value.length > maxLength) {
    return t('validation:shorterThanMax', { maxLength })
  }

  if (!value && required) {
    return t('validation:required')
  }

  return true
}

export type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>

export const textarea: TextareaFieldValidation = (
  value,
  {
    maxLength: fieldMaxLength,
    minLength,
    req: {
      payload: { config },
      t,
    },
    required,
  },
) => {
  let maxLength: number

  if (typeof config?.defaultMaxTextLength === 'number') {
    maxLength = config.defaultMaxTextLength
  }
  if (typeof fieldMaxLength === 'number') {
    maxLength = fieldMaxLength
  }
  if (value && maxLength && value.length > maxLength) {
    return t('validation:shorterThanMax', { maxLength })
  }

  if (value && minLength && value.length < minLength) {
    return t('validation:longerThanMin', { minLength })
  }

  if (required && !value) {
    return t('validation:required')
  }

  return true
}

export type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>

export const code: CodeFieldValidation = (value, { req: { t }, required }) => {
  if (required && value === undefined) {
    return t('validation:required')
  }

  return true
}

export type JSONFieldValidation = Validate<
  string,
  unknown,
  unknown,
  { jsonError?: string } & JSONField
>

export const json: JSONFieldValidation = async (
  value,
  { jsonError, jsonSchema, req: { t }, required },
) => {
  const isNotEmpty = (value) => {
    if (value === undefined || value === null) {
      return false
    }

    if (Array.isArray(value) && value.length === 0) {
      return false
    }

    if (typeof value === 'object' && Object.keys(value).length === 0) {
      return false
    }

    return true
  }

  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {
    if (uri && schema) {
      return schema
    }
    // @ts-expect-error
    return fetch(uri)
      .then((response) => {
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      })
      .then((json) => {
        const jsonSchemaSanitizations = {
          id: undefined,
          $id: json.id,
          $schema: 'http://json-schema.org/draft-07/schema#',
        }

        return Object.assign(json, jsonSchemaSanitizations)
      })
  }

  if (required && !value) {
    return t('validation:required')
  }

  if (jsonError !== undefined) {
    return t('validation:invalidInput')
  }

  if (jsonSchema && isNotEmpty(value)) {
    try {
      jsonSchema.schema = await fetchSchema(jsonSchema)
      const { schema } = jsonSchema
      // @ts-expect-error
      const ajv = new Ajv()

      if (!ajv.validate(schema, value)) {
        return ajv.errorsText()
      }
    } catch (error) {
      return error.message
    }
  }
  return true
}

export type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>

export const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {
  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {
    return t('validation:trueOrFalse')
  }

  return true
}

export type DateFieldValidation = Validate<Date, unknown, unknown, DateField>

export const date: DateFieldValidation = (
  value,
  { name, req: { t }, required, siblingData, timezone },
) => {
  const validDate = value && !isNaN(Date.parse(value.toString()))

  // We need to also check for the timezone data based on this field's config
  // We cannot do this inside the timezone field validation as it's visually hidden
  const hasRequiredTimezone = timezone && required
  const selectedTimezone: string = siblingData?.[`${name}_tz`]
  // Always resolve to true if the field is not required, as timezone may be optional too then
  const validTimezone = hasRequiredTimezone ? Boolean(selectedTimezone) : true

  if (validDate && validTimezone) {
    return true
  }

  if (validDate && !validTimezone) {
    return t('validation:timezoneRequired')
  }

  if (value) {
    return t('validation:notValidDate', { value })
  }

  if (required) {
    return t('validation:required')
  }

  return true
}

export type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>

export const richText: RichTextFieldValidation = async (value, options) => {
  if (!options?.editor) {
    throw new Error('richText field has no editor property.')
  }
  if (typeof options?.editor === 'function') {
    throw new Error('Attempted to access unsanitized rich text editor.')
  }

  const editor: RichTextAdapter = options?.editor

  return editor.validate(value, options)
}

const validateArrayLength = (
  value,
  options: {
    maxRows?: number
    minRows?: number
    required?: boolean
    t: (key: string, options?: { [key: string]: number | string }) => string
  },
) => {
  const { maxRows, minRows, required, t } = options

  const arrayLength = Array.isArray(value) ? value.length : value || 0

  if (!required && arrayLength === 0) {
    return true
  }

  if (minRows && arrayLength < minRows) {
    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })
  }

  if (maxRows && arrayLength > maxRows) {
    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })
  }

  if (required && !arrayLength) {
    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })
  }

  return true
}

export type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>

export type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>

export type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>

export const number: NumberFieldValidation = (
  value,
  { hasMany, max, maxRows, min, minRows, req: { t }, required },
) => {
  if (hasMany === true) {
    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })
    if (typeof lengthValidationResult === 'string') {
      return lengthValidationResult
    }
  }

  if (!value && !isNumber(value)) {
    // if no value is present, validate based on required
    if (required) {
      return t('validation:required')
    }
    if (!required) {
      return true
    }
  }

  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]

  for (const number of numbersToValidate) {
    if (!isNumber(number)) {
      return t('validation:enterNumber')
    }

    const numberValue = parseFloat(number as unknown as string)

    if (typeof max === 'number' && numberValue > max) {
      return t('validation:greaterThanMax', { label: t('general:value'), max, value })
    }

    if (typeof min === 'number' && numberValue < min) {
      return t('validation:lessThanMin', { label: t('general:value'), min, value })
    }
  }

  return true
}

export type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>

export const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {
  return validateArrayLength(value, { maxRows, minRows, required, t })
}

export type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>

export const blocks: BlocksFieldValidation = (
  value,
  { maxRows, minRows, req: { t }, required },
) => {
  return validateArrayLength(value, { maxRows, minRows, required, t })
}

const validateFilterOptions: Validate<
  unknown,
  unknown,
  unknown,
  RelationshipField | UploadField
> = async (
  value,
  { id, blockData, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },
) => {
  if (typeof filterOptions !== 'undefined' && value) {
    const options: {
      [collection: string]: (number | string)[]
    } = {}

    const falseCollections: CollectionSlug[] = []
    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo
    const values = Array.isArray(value) ? value : [value]

    for (const collection of collections) {
      try {
        let optionFilter =
          typeof filterOptions === 'function'
            ? await filterOptions({
                id,
                blockData,
                data,
                relationTo: collection,
                req,
                siblingData,
                user,
              })
            : filterOptions

        if (optionFilter === true) {
          optionFilter = null
        }

        const valueIDs: (number | string)[] = []

        values.forEach((val) => {
          if (typeof val === 'object') {
            if (val?.value) {
              valueIDs.push(val.value)
            } else if (ObjectId.isValid(val)) {
              valueIDs.push(new ObjectId(val).toHexString())
            }
          }

          if (typeof val === 'string' || typeof val === 'number') {
            valueIDs.push(val)
          }
        })

        if (valueIDs.length > 0) {
          const findWhere: Where = {
            and: [{ id: { in: valueIDs } }],
          }

          if (optionFilter && optionFilter !== true) {
            findWhere.and.push(optionFilter)
          }

          if (optionFilter === false) {
            falseCollections.push(collection)
          }

          const result = await req.payloadDataLoader.find({
            collection,
            depth: 0,
            limit: 0,
            pagination: false,
            req,
            where: findWhere,
          })

          options[collection] = result.docs.map((doc) => doc.id)
        } else {
          options[collection] = []
        }
      } catch (err) {
        req.payload.logger.error({
          err,
          msg: `Error validating filter options for collection ${collection}`,
        })
        options[collection] = []
      }
    }

    const invalidRelationships = values.filter((val) => {
      let collection: string
      let requestedID: number | string

      if (typeof relationTo === 'string') {
        collection = relationTo

        if (typeof val === 'string' || typeof val === 'number') {
          requestedID = val
        }

        if (typeof val === 'object' && ObjectId.isValid(val)) {
          requestedID = new ObjectId(val).toHexString()
        }
      }

      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {
        collection = val.relationTo
        requestedID = val.value
      }

      if (falseCollections.find((slug) => relationTo === slug)) {
        return true
      }

      if (!options[collection]) {
        return true
      }

      return options[collection].indexOf(requestedID) === -1
    })

    if (invalidRelationships.length > 0) {
      return invalidRelationships.reduce((err, invalid, i) => {
        return `${err} ${JSON.stringify(invalid)}${
          invalidRelationships.length === i + 1 ? ',' : ''
        } `
      }, t('validation:invalidSelections')) as string
    }

    return true
  }

  return true
}

export type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>

export type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>

export type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>

export const upload: UploadFieldValidation = async (value, options) => {
  const {
    event,
    maxRows,
    minRows,
    relationTo,
    req: { payload, t },
    required,
  } = options

  if (
    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&
    required
  ) {
    return t('validation:required')
  }

  if (Array.isArray(value) && value.length > 0) {
    if (minRows && value.length < minRows) {
      return t('validation:lessThanMin', {
        label: t('general:rows'),
        min: minRows,
        value: value.length,
      })
    }

    if (maxRows && value.length > maxRows) {
      return t('validation:greaterThanMax', {
        label: t('general:rows'),
        max: maxRows,
        value: value.length,
      })
    }
  }

  if (typeof value !== 'undefined' && value !== null) {
    const values = Array.isArray(value) ? value : [value]

    const invalidRelationships = values.filter((val) => {
      let collectionSlug: string
      let requestedID

      if (typeof relationTo === 'string') {
        collectionSlug = relationTo

        // custom id
        if (val || typeof val === 'number') {
          requestedID = val
        }
      }

      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {
        collectionSlug = val.relationTo
        requestedID = val.value
      }

      if (requestedID === null) {
        return false
      }

      const idType =
        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'

      return !isValidID(requestedID, idType)
    })

    if (invalidRelationships.length > 0) {
      return `This relationship field has the following invalid relationships: ${invalidRelationships
        .map((err, invalid) => {
          return `${err} ${JSON.stringify(invalid)}`
        })
        .join(', ')}`
    }
  }

  if (event === 'onChange') {
    return true
  }

  return validateFilterOptions(value, options)
}

export type RelationshipFieldValidation = Validate<
  RelationshipValue,
  unknown,
  unknown,
  RelationshipField
>

export type RelationshipFieldManyValidation = Validate<
  RelationshipValueMany,
  unknown,
  unknown,
  RelationshipField
>

export type RelationshipFieldSingleValidation = Validate<
  RelationshipValueSingle,
  unknown,
  unknown,
  RelationshipField
>

export const relationship: RelationshipFieldValidation = async (value, options) => {
  const {
    event,
    maxRows,
    minRows,
    relationTo,
    req: { payload, t },
    required,
  } = options

  if (
    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&
    required
  ) {
    return t('validation:required')
  }

  if (Array.isArray(value) && value.length > 0) {
    if (minRows && value.length < minRows) {
      return t('validation:lessThanMin', {
        label: t('general:rows'),
        min: minRows,
        value: value.length,
      })
    }

    if (maxRows && value.length > maxRows) {
      return t('validation:greaterThanMax', {
        label: t('general:rows'),
        max: maxRows,
        value: value.length,
      })
    }
  }

  if (typeof value !== 'undefined' && value !== null) {
    const values = Array.isArray(value) ? value : [value]

    const invalidRelationships = values.filter((val) => {
      let collectionSlug: string
      let requestedID

      if (typeof relationTo === 'string') {
        collectionSlug = relationTo

        // custom id
        if (val || typeof val === 'number') {
          requestedID = val
        }
      }

      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {
        collectionSlug = val.relationTo
        requestedID = val.value
      }

      if (requestedID === null) {
        return false
      }

      const idType =
        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'

      return !isValidID(requestedID, idType)
    })

    if (invalidRelationships.length > 0) {
      return `This relationship field has the following invalid relationships: ${invalidRelationships
        .map((err, invalid) => {
          return `${err} ${JSON.stringify(invalid)}`
        })
        .join(', ')}`
    }
  }

  if (event === 'onChange') {
    return true
  }

  return validateFilterOptions(value, options)
}

export type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>

export type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>

export type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>

export const select: SelectFieldValidation = (
  value,
  { hasMany, options, req: { t }, required },
) => {
  if (
    Array.isArray(value) &&
    value.some(
      (input) =>
        !options.some(
          (option) => option === input || (typeof option !== 'string' && option?.value === input),
        ),
    )
  ) {
    return t('validation:invalidSelection')
  }

  if (
    typeof value === 'string' &&
    !options.some(
      (option) => option === value || (typeof option !== 'string' && option.value === value),
    )
  ) {
    return t('validation:invalidSelection')
  }

  if (
    required &&
    (typeof value === 'undefined' ||
      value === null ||
      (hasMany && Array.isArray(value) && (value as [])?.length === 0))
  ) {
    return t('validation:required')
  }

  return true
}

export type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>

export const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {
  if (value) {
    const valueMatchesOption = options.some(
      (option) => option === value || (typeof option !== 'string' && option.value === value),
    )
    return valueMatchesOption || t('validation:invalidSelection')
  }

  return required ? t('validation:required') : true
}

export type PointFieldValidation = Validate<
  [number | string, number | string],
  unknown,
  unknown,
  PointField
>

export const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {
  const lng = parseFloat(String(value[0]))
  const lat = parseFloat(String(value[1]))
  if (
    required &&
    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||
      Number.isNaN(lng) ||
      Number.isNaN(lat) ||
      (Array.isArray(value) && value.length !== 2))
  ) {
    return t('validation:requiresTwoNumbers')
  }

  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {
    return t('validation:invalidInput')
  }

  return true
}

/**
 * Built-in field validations used by Payload
 *
 * These can be re-used in custom validations
 */
export const validations = {
  array,
  blocks,
  checkbox,
  code,
  confirmPassword,
  date,
  email,
  json,
  number,
  password,
  point,
  radio,
  relationship,
  richText,
  select,
  text,
  textarea,
  upload,
}
</file>

<file path="packages/payload/src/globals/config/client.ts">
// @ts-strict-ignore
import type { I18nClient } from '@convexcms/translations'

import type { ImportMap } from '../../bin/generateImportMap/index.js'
import type {
  LivePreviewConfig,
  SanitizedConfig,
  ServerOnlyLivePreviewProperties,
} from '../../config/types.js'
import type { Payload } from '../../types/index.js'
import type { SanitizedGlobalConfig } from './types.js'

import { type ClientField, createClientFields } from '../../fields/config/client.js'

export type ServerOnlyGlobalProperties = keyof Pick<
  SanitizedGlobalConfig,
  'access' | 'admin' | 'custom' | 'endpoints' | 'fields' | 'flattenedFields' | 'hooks'
>

export type ServerOnlyGlobalAdminProperties = keyof Pick<
  SanitizedGlobalConfig['admin'],
  'components' | 'hidden'
>

export type ClientGlobalConfig = {
  admin: {
    components: null
    livePreview?: Omit<LivePreviewConfig, ServerOnlyLivePreviewProperties>
    preview?: boolean
  } & Omit<
    SanitizedGlobalConfig['admin'],
    'components' | 'livePreview' | 'preview' | ServerOnlyGlobalAdminProperties
  >
  fields: ClientField[]
} & Omit<SanitizedGlobalConfig, 'admin' | 'fields' | ServerOnlyGlobalProperties>

const serverOnlyProperties: Partial<ServerOnlyGlobalProperties>[] = [
  'hooks',
  'access',
  'endpoints',
  'custom',
  'flattenedFields',
  // `admin` is handled separately
]

const serverOnlyGlobalAdminProperties: Partial<ServerOnlyGlobalAdminProperties>[] = [
  'hidden',
  'components',
]

export const createClientGlobalConfig = ({
  defaultIDType,
  global,
  i18n,
  importMap,
}: {
  defaultIDType: Payload['config']['db']['defaultIDType']
  global: SanitizedConfig['globals'][0]
  i18n: I18nClient
  importMap: ImportMap
}): ClientGlobalConfig => {
  const clientGlobal = {} as ClientGlobalConfig

  for (const key in global) {
    if (serverOnlyProperties.includes(key as any)) {
      continue
    }
    switch (key) {
      case 'admin':
        if (!global.admin) {
          break
        }
        clientGlobal.admin = {} as ClientGlobalConfig['admin']
        for (const adminKey in global.admin) {
          if (serverOnlyGlobalAdminProperties.includes(adminKey as any)) {
            continue
          }
          switch (adminKey) {
            case 'livePreview':
              if (!global.admin.livePreview) {
                break
              }
              clientGlobal.admin.livePreview = {}
              if (global.admin.livePreview.breakpoints) {
                clientGlobal.admin.livePreview.breakpoints = global.admin.livePreview.breakpoints
              }
              break
            case 'preview':
              if (global.admin.preview) {
                clientGlobal.admin.preview = true
              }
              break
            default:
              clientGlobal.admin[adminKey] = global.admin[adminKey]
          }
        }
        break
      case 'fields':
        clientGlobal.fields = createClientFields({
          defaultIDType,
          fields: global.fields,
          i18n,
          importMap,
        })
        break
      case 'label':
        clientGlobal.label =
          typeof global.label === 'function' ? global.label({ i18n, t: i18n.t }) : global.label
        break
      default: {
        clientGlobal[key] = global[key]
        break
      }
    }
  }

  return clientGlobal
}

export const createClientGlobalConfigs = ({
  defaultIDType,
  globals,
  i18n,
  importMap,
}: {
  defaultIDType: Payload['config']['db']['defaultIDType']
  globals: SanitizedConfig['globals']
  i18n: I18nClient
  importMap: ImportMap
}): ClientGlobalConfig[] => {
  const clientGlobals = new Array(globals.length)

  for (let i = 0; i < globals.length; i++) {
    const global = globals[i]

    clientGlobals[i] = createClientGlobalConfig({
      defaultIDType,
      global,
      i18n,
      importMap,
    })
  }

  return clientGlobals
}
</file>

<file path="packages/payload/src/globals/config/sanitize.ts">
// @ts-strict-ignore
import type { Config, SanitizedConfig } from '../../config/types.js'
import type { GlobalConfig, SanitizedGlobalConfig } from './types.js'

import defaultAccess from '../../auth/defaultAccess.js'
import { sanitizeFields } from '../../fields/config/sanitize.js'
import { fieldAffectsData } from '../../fields/config/types.js'
import mergeBaseFields from '../../fields/mergeBaseFields.js'
import { flattenAllFields } from '../../utilities/flattenAllFields.js'
import { toWords } from '../../utilities/formatLabels.js'
import baseVersionFields from '../../versions/baseFields.js'
import { versionDefaults } from '../../versions/defaults.js'
import { defaultGlobalEndpoints } from '../endpoints/index.js'

export const sanitizeGlobal = async (
  config: Config,
  global: GlobalConfig,
  /**
   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises
   * so that you can sanitize them together, after the config has been sanitized.
   */
  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>,
  _validRelationships?: string[],
): Promise<SanitizedGlobalConfig> => {
  if (global._sanitized) {
    return global as SanitizedGlobalConfig
  }
  global._sanitized = true

  global.label = global.label || toWords(global.slug)

  // /////////////////////////////////
  // Ensure that collection has required object structure
  // /////////////////////////////////

  global.endpoints = global.endpoints ?? []
  if (!global.hooks) {
    global.hooks = {}
  }
  if (!global.access) {
    global.access = {}
  }
  if (!global.admin) {
    global.admin = {}
  }

  if (!global.access.read) {
    global.access.read = defaultAccess
  }
  if (!global.access.update) {
    global.access.update = defaultAccess
  }

  if (!global.hooks.beforeValidate) {
    global.hooks.beforeValidate = []
  }
  if (!global.hooks.beforeChange) {
    global.hooks.beforeChange = []
  }
  if (!global.hooks.afterChange) {
    global.hooks.afterChange = []
  }
  if (!global.hooks.beforeRead) {
    global.hooks.beforeRead = []
  }
  if (!global.hooks.afterRead) {
    global.hooks.afterRead = []
  }

  // Sanitize fields
  const validRelationships = _validRelationships ?? config.collections.map((c) => c.slug) ?? []

  global.fields = await sanitizeFields({
    config,
    fields: global.fields,
    parentIsLocalized: false,
    richTextSanitizationPromises,
    validRelationships,
  })

  if (global.endpoints !== false) {
    if (!global.endpoints) {
      global.endpoints = []
    }

    for (const endpoint of defaultGlobalEndpoints) {
      global.endpoints.push(endpoint)
    }
  }

  if (global.versions) {
    if (global.versions === true) {
      global.versions = { drafts: false, max: 100 }
    }

    global.versions.max = typeof global.versions.max === 'number' ? global.versions.max : 100

    if (global.versions.drafts) {
      if (global.versions.drafts === true) {
        global.versions.drafts = {
          autosave: false,
          validate: false,
        }
      }

      if (global.versions.drafts.autosave === true) {
        global.versions.drafts.autosave = {
          interval: versionDefaults.autosaveInterval,
        }
      }

      if (global.versions.drafts.validate === undefined) {
        global.versions.drafts.validate = false
      }

      global.fields = mergeBaseFields(global.fields, baseVersionFields)
    }
  }

  if (!global.custom) {
    global.custom = {}
  }

  // /////////////////////////////////
  // Sanitize fields
  // /////////////////////////////////
  let hasUpdatedAt = null
  let hasCreatedAt = null
  global.fields.some((field) => {
    if (fieldAffectsData(field)) {
      if (field.name === 'updatedAt') {
        hasUpdatedAt = true
      }
      if (field.name === 'createdAt') {
        hasCreatedAt = true
      }
    }
    return hasCreatedAt && hasUpdatedAt
  })
  if (!hasUpdatedAt) {
    global.fields.push({
      name: 'updatedAt',
      type: 'date',
      admin: {
        disableBulkEdit: true,
        hidden: true,
      },
      label: ({ t }) => t('general:updatedAt'),
    })
  }
  if (!hasCreatedAt) {
    global.fields.push({
      name: 'createdAt',
      type: 'date',
      admin: {
        disableBulkEdit: true,
        hidden: true,
      },
      label: ({ t }) => t('general:createdAt'),
    })
  }

  ;(global as SanitizedGlobalConfig).flattenedFields = flattenAllFields({ fields: global.fields })

  return global as SanitizedGlobalConfig
}
</file>

<file path="packages/payload/src/globals/config/types.ts">
import type { GraphQLNonNull, GraphQLObjectType } from 'graphql'
import type { DeepRequired, IsAny } from 'ts-essentials'

import type {
  CustomPreviewButton,
  CustomPublishButton,
  CustomSaveButton,
  CustomSaveDraftButton,
} from '../../admin/types.js'
import type {
  Access,
  EditConfig,
  Endpoint,
  EntityDescription,
  EntityDescriptionComponent,
  GeneratePreviewURL,
  LabelFunction,
  LivePreviewConfig,
  MetaConfig,
  StaticLabel,
} from '../../config/types.js'
import type { DBIdentifierName } from '../../database/types.js'
import type { Field, FlattenedField } from '../../fields/config/types.js'
import type { GlobalSlug, RequestContext, TypedGlobal, TypedGlobalSelect } from '../../index.js'
import type { PayloadRequest, SelectIncludeType, Where } from '../../types/index.js'
import type { IncomingGlobalVersions, SanitizedGlobalVersions } from '../../versions/types.js'

export type DataFromGlobalSlug<TSlug extends GlobalSlug> = TypedGlobal[TSlug]

export type SelectFromGlobalSlug<TSlug extends GlobalSlug> = TypedGlobalSelect[TSlug]

export type BeforeValidateHook = (args: {
  context: RequestContext
  data?: any
  /** The global which this hook is being run on */
  global: SanitizedGlobalConfig
  originalDoc?: any
  req: PayloadRequest
}) => any

export type BeforeChangeHook = (args: {
  context: RequestContext
  data: any
  /** The global which this hook is being run on */
  global: SanitizedGlobalConfig
  originalDoc?: any
  req: PayloadRequest
}) => any

export type AfterChangeHook = (args: {
  context: RequestContext
  doc: any
  /** The global which this hook is being run on */
  global: SanitizedGlobalConfig
  previousDoc: any
  req: PayloadRequest
}) => any

export type BeforeReadHook = (args: {
  context: RequestContext
  doc: any
  /** The global which this hook is being run on */
  global: SanitizedGlobalConfig
  req: PayloadRequest
}) => any

export type AfterReadHook = (args: {
  context: RequestContext
  doc: any
  findMany?: boolean
  /** The global which this hook is being run on */
  global: SanitizedGlobalConfig
  query?: Where
  req: PayloadRequest
}) => any

export type GlobalAdminOptions = {
  /**
   * Custom admin components
   */
  components?: {
    elements?: {
      Description?: EntityDescriptionComponent
      /**
       * Replaces the "Preview" button
       */
      PreviewButton?: CustomPreviewButton
      /**
       * Replaces the "Publish" button
       * + drafts must be enabled
       */
      PublishButton?: CustomPublishButton
      /**
       * Replaces the "Save" button
       * + drafts must be disabled
       */
      SaveButton?: CustomSaveButton
      /**
       * Replaces the "Save Draft" button
       * + drafts must be enabled
       * + autosave must be disabled
       */
      SaveDraftButton?: CustomSaveDraftButton
    }
    views?: {
      /**
       * Set to a React component to replace the entire Edit View, including all nested routes.
       * Set to an object to replace or modify individual nested routes, or to add new ones.
       */
      edit?: EditConfig
    }
  }
  /** Extension point to add your custom data. Available in server and client. */
  custom?: Record<string, any>
  /**
   * Custom description for collection
   */
  description?: EntityDescription
  /**
   * Specify a navigational group for globals in the admin sidebar.
   * - Provide a string to place the entity in a custom group.
   * - Provide a record to define localized group names.
   * - Set to `false` to exclude the entity from the sidebar / dashboard without disabling its routes.
   */
  group?: false | Record<string, string> | string
  /**
   * Exclude the global from the admin nav and routes
   */
  hidden?: ((args: { user: PayloadRequest['user'] }) => boolean) | boolean
  /**
   * Hide the API URL within the Edit View
   */
  hideAPIURL?: boolean
  /**
   * Live preview options
   */
  livePreview?: LivePreviewConfig
  meta?: MetaConfig
  /**
   * Function to generate custom preview URL
   */
  preview?: GeneratePreviewURL
}

export type GlobalConfig<TSlug extends GlobalSlug = any> = {
  /**
   * Do not set this property manually. This is set to true during sanitization, to avoid
   * sanitizing the same global multiple times.
   */
  _sanitized?: boolean
  access?: {
    read?: Access
    readDrafts?: Access
    readVersions?: Access
    update?: Access
  }
  admin?: GlobalAdminOptions
  /** Extension point to add your custom data. Server only. */
  custom?: Record<string, any>
  /**
   * Customize the SQL table name
   */
  dbName?: DBIdentifierName
  endpoints?: false | Omit<Endpoint, 'root'>[]
  fields: Field[]
  /**
   * Specify which fields should be selected always, regardless of the `select` query which can be useful that the field exists for access control / hooks
   */
  forceSelect?: IsAny<SelectFromGlobalSlug<TSlug>> extends true
    ? SelectIncludeType
    : SelectFromGlobalSlug<TSlug>
  graphQL?:
    | {
        disableMutations?: true
        disableQueries?: true
        name?: string
      }
    | false
  hooks?: {
    afterChange?: AfterChangeHook[]
    afterRead?: AfterReadHook[]
    beforeChange?: BeforeChangeHook[]
    beforeRead?: BeforeReadHook[]
    beforeValidate?: BeforeValidateHook[]
  }
  label?: LabelFunction | StaticLabel
  /**
   * Enables / Disables the ability to lock documents while editing
   * @default true
   */
  lockDocuments?:
    | {
        duration: number
      }
    | false
  slug: string
  /**
   * Options used in typescript generation
   */
  typescript?: {
    /**
     * Typescript generation name given to the interface type
     */
    interface?: string
  }
  versions?: boolean | IncomingGlobalVersions
}

export interface SanitizedGlobalConfig
  extends Omit<DeepRequired<GlobalConfig>, 'endpoints' | 'fields' | 'slug' | 'versions'> {
  endpoints: Endpoint[] | false

  fields: Field[]

  /**
   * Fields in the database schema structure
   * Rows / collapsible / tabs w/o name `fields` merged to top, UIs are excluded
   */
  flattenedFields: FlattenedField[]
  slug: GlobalSlug
  versions: SanitizedGlobalVersions
}

export type Globals = {
  config: SanitizedGlobalConfig[]
  graphQL?:
    | {
        [slug: string]: {
          mutationInputType: GraphQLNonNull<any>
          type: GraphQLObjectType
          versionType?: GraphQLObjectType
        }
      }
    | false
}
</file>

<file path="packages/payload/src/globals/endpoints/docAccess.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { docAccessOperation } from '../operations/docAccess.js'

export const docAccessHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const result = await docAccessOperation({
    globalConfig,
    req,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/globals/endpoints/findOne.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findOneOperation } from '../operations/findOne.js'

export const findOneHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const result = await findOneOperation({
    slug: globalConfig.slug,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    globalConfig,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/globals/endpoints/findVersionByID.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionByIDOperation } from '../operations/findVersionByID.js'

export const findVersionByIDHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const result = await findVersionByIDOperation({
    id: req.routeParams.id as string,
    depth: isNumber(depth) ? Number(depth) : undefined,
    globalConfig,
    populate: sanitizePopulateParam(req.query.populate),
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/globals/endpoints/findVersions.ts">
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { Where } from '../../types/index.js'

import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { findVersionsOperation } from '../operations/findVersions.js'

export const findVersionsHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { depth, limit, page, pagination, populate, select, sort, where } = req.query as {
    depth?: string
    limit?: string
    page?: string
    pagination?: string
    populate?: Record<string, unknown>
    select?: Record<string, unknown>
    sort?: string
    where?: Where
  }

  const result = await findVersionsOperation({
    depth: isNumber(depth) ? Number(depth) : undefined,
    globalConfig,
    limit: isNumber(limit) ? Number(limit) : undefined,
    page: isNumber(page) ? Number(page) : undefined,
    pagination: pagination === 'false' ? false : undefined,
    populate: sanitizePopulateParam(populate),
    req,
    select: sanitizeSelectParam(select),
    sort: typeof sort === 'string' ? sort.split(',') : undefined,
    where,
  })

  return Response.json(result, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/globals/endpoints/index.ts">
import type { Endpoint } from '../../config/types.js'

import { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'
import { docAccessHandler } from './docAccess.js'
import { findOneHandler } from './findOne.js'
import { findVersionByIDHandler } from './findVersionByID.js'
import { findVersionsHandler } from './findVersions.js'
import { previewHandler } from './preview.js'
import { restoreVersionHandler } from './restoreVersion.js'
import { updateHandler } from './update.js'

export const defaultGlobalEndpoints: Endpoint[] = wrapInternalEndpoints([
  {
    handler: docAccessHandler,
    method: 'post',
    path: '/access',
  },
  {
    handler: findOneHandler,
    method: 'get',
    path: '/',
  },
  {
    handler: findVersionByIDHandler,
    method: 'get',
    path: '/versions/:id',
  },
  {
    handler: findVersionsHandler,
    method: 'get',
    path: '/versions',
  },
  {
    handler: previewHandler,
    method: 'get',
    path: '/preview',
  },
  {
    handler: restoreVersionHandler,
    method: 'post',
    path: '/versions/:id',
  },
  {
    handler: updateHandler,
    method: 'post',
    path: '/',
  },
])
</file>

<file path="packages/payload/src/globals/endpoints/preview.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { extractJWT } from '../../auth/extractJWT.js'
import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { findOneOperation } from '../operations/findOne.js'

export const previewHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')

  const doc = await findOneOperation({
    slug: globalConfig.slug,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: searchParams.get('draft') === 'true',
    globalConfig,
    req,
  })

  let previewURL: string

  const generatePreviewURL = req.payload.config.globals.find(
    (config) => config.slug === globalConfig.slug,
  )?.admin?.preview

  const token = extractJWT(req)

  if (typeof generatePreviewURL === 'function') {
    previewURL = await generatePreviewURL(doc, {
      locale: req.locale,
      req,
      token,
    })
  }

  return Response.json(previewURL, {
    headers: headersWithCors({
      headers: new Headers(),
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/globals/endpoints/restoreVersion.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { restoreVersionOperationGlobal, sanitizePopulateParam } from '../../index.js'
import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'

export const restoreVersionHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const draft = searchParams.get('draft')

  const doc = await restoreVersionOperationGlobal({
    id: req.routeParams.id as string,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft: draft === 'true' ? true : undefined,
    globalConfig,
    populate: sanitizePopulateParam(req.query.populate),
    req,
  })

  return Response.json(
    {
      doc,
      message: req.t('version:restoredSuccessfully'),
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/globals/endpoints/update.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'

import { getRequestGlobal } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'
import { isNumber } from '../../utilities/isNumber.js'
import { sanitizePopulateParam } from '../../utilities/sanitizePopulateParam.js'
import { sanitizeSelectParam } from '../../utilities/sanitizeSelectParam.js'
import { updateOperation } from '../operations/update.js'

export const updateHandler: PayloadHandler = async (req) => {
  const globalConfig = getRequestGlobal(req)
  const { searchParams } = req
  const depth = searchParams.get('depth')
  const draft = searchParams.get('draft') === 'true'
  const autosave = searchParams.get('autosave') === 'true'
  const publishSpecificLocale = req.query.publishSpecificLocale as string | undefined

  const result = await updateOperation({
    slug: globalConfig.slug,
    autosave,
    data: req.data,
    depth: isNumber(depth) ? Number(depth) : undefined,
    draft,
    globalConfig,
    populate: sanitizePopulateParam(req.query.populate),
    publishSpecificLocale,
    req,
    select: sanitizeSelectParam(req.query.select),
  })

  let message = req.t('general:updatedSuccessfully')

  if (draft) {
    message = req.t('version:draftSavedSuccessfully')
  }
  if (autosave) {
    message = req.t('version:autosavedSuccessfully')
  }

  return Response.json(
    {
      message,
      result,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/globals/operations/local/countGlobalVersions.ts">
// @ts-strict-ignore
import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, Where } from '../../../types/index.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { countGlobalVersionsOperation } from '../countGlobalVersions.js'

export type CountGlobalVersionsOptions<TSlug extends GlobalSlug> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   */
  disableErrors?: boolean
  /**
   * the Global slug to operate against.
   */
  global: TSlug
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

// eslint-disable-next-line no-restricted-exports
export default async function countGlobalVersionsLocal<TSlug extends GlobalSlug>(
  payload: Payload,
  options: CountGlobalVersionsOptions<TSlug>,
): Promise<{ totalDocs: number }> {
  const { disableErrors, global: globalSlug, overrideAccess = true, where } = options

  const global = payload.globals.config.find(({ slug }) => slug === globalSlug)

  if (!global) {
    throw new APIError(
      `The global with slug ${String(globalSlug)} can't be found. Count Global Versions Operation.`,
    )
  }

  return countGlobalVersionsOperation<TSlug>({
    disableErrors,
    global,
    overrideAccess,
    req: await createLocalReq(options, payload),
    where,
  })
}
</file>

<file path="packages/payload/src/globals/operations/local/findOne.ts">
// @ts-strict-ignore
import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformGlobalWithSelect,
} from '../../../types/index.js'
import type { SelectFromGlobalSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findOneOperation } from '../findOne.js'

export type Options<TSlug extends GlobalSlug, TSelect extends SelectType> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Whether the document should be queried from the versions table/collection or not. [More](https://payloadcms.com/docs/versions/drafts#draft-api)
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Include info about the lock status to the result with fields: `_isLocked` and `_userEditing`
   */
  includeLockStatus?: boolean
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * the Global slug to operate against.
   */
  slug: TSlug
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function findOneLocal<
  TSlug extends GlobalSlug,
  TSelect extends SelectFromGlobalSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformGlobalWithSelect<TSlug, TSelect>> {
  const {
    slug: globalSlug,
    depth,
    draft = false,
    includeLockStatus,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)
  }

  return findOneOperation({
    slug: globalSlug as string,
    depth,
    draft,
    globalConfig,
    includeLockStatus,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/globals/operations/local/findVersionByID.ts">
// @ts-strict-ignore
import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromGlobalSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionByIDOperation } from '../findVersionByID.js'

export type Options<TSlug extends GlobalSlug> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * When set to `true`, errors will not be thrown.
   * `null` will be returned instead, if the document on this ID was not found.
   */
  disableErrors?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to find.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * the Global slug to operate against.
   */
  slug: TSlug
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

// eslint-disable-next-line no-restricted-exports
export default async function findVersionByIDLocal<TSlug extends GlobalSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> {
  const {
    id,
    slug: globalSlug,
    depth,
    disableErrors = false,
    overrideAccess = true,
    populate,
    select,
    showHiddenFields,
  } = options

  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)
  }

  return findVersionByIDOperation({
    id,
    depth,
    disableErrors,
    globalConfig,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/globals/operations/local/findVersions.ts">
// @ts-strict-ignore
/* eslint-disable no-restricted-exports */
import type { PaginatedDocs } from '../../../database/types.js'
import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  Sort,
  Where,
} from '../../../types/index.js'
import type { TypeWithVersion } from '../../../versions/types.js'
import type { DataFromGlobalSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { findVersionsOperation } from '../findVersions.js'

export type Options<TSlug extends GlobalSlug> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The maximum related documents to be returned.
   * Defaults unless `defaultLimit` is specified for the collection config
   * @default 10
   */
  limit?: number
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Get a specific page number
   * @default 1
   */
  page?: number
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: SelectType
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * the Global slug to operate against.
   */
  slug: TSlug
  /**
   * Sort the documents, can be a string or an array of strings
   * @example '-version.createdAt' // Sort DESC by createdAt
   * @example ['version.group', '-version.createdAt'] // sort by 2 fields, ASC group and DESC createdAt
   */
  sort?: Sort
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
  /**
   * A filter [query](https://payloadcms.com/docs/queries/overview)
   */
  where?: Where
}

export default async function findVersionsLocal<TSlug extends GlobalSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> {
  const {
    slug: globalSlug,
    depth,
    limit,
    overrideAccess = true,
    page,
    populate,
    select,
    showHiddenFields,
    sort,
    where,
  } = options

  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)
  }

  return findVersionsOperation({
    depth,
    globalConfig,
    limit,
    overrideAccess,
    page,
    populate,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
    sort,
    where,
  })
}
</file>

<file path="packages/payload/src/globals/operations/local/index.ts">
import countGlobalVersions from './countGlobalVersions.js'
import findOne from './findOne.js'
import findVersionByID from './findVersionByID.js'
import findVersions from './findVersions.js'
import restoreVersion from './restoreVersion.js'
import update from './update.js'

export default {
  countGlobalVersions,
  findOne,
  findVersionByID,
  findVersions,
  restoreVersion,
  update,
}
</file>

<file path="packages/payload/src/globals/operations/local/restoreVersion.ts">
// @ts-strict-ignore
/* eslint-disable no-restricted-exports */
import type { GlobalSlug, Payload, RequestContext, TypedLocale } from '../../../index.js'
import type { Document, PayloadRequest, PopulateType } from '../../../types/index.js'
import type { DataFromGlobalSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { restoreVersionOperation } from '../restoreVersion.js'

export type Options<TSlug extends GlobalSlug> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * The ID of the version to restore.
   */
  id: string
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * the Global slug to operate against.
   */
  slug: TSlug
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function restoreVersionLocal<TSlug extends GlobalSlug>(
  payload: Payload,
  options: Options<TSlug>,
): Promise<DataFromGlobalSlug<TSlug>> {
  const { id, slug: globalSlug, depth, overrideAccess = true, populate, showHiddenFields } = options

  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)
  }

  return restoreVersionOperation({
    id,
    depth,
    globalConfig,
    overrideAccess,
    populate,
    req: await createLocalReq(options, payload),
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/globals/operations/local/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type {
  Document,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformGlobalWithSelect,
} from '../../../types/index.js'
import type { DataFromGlobalSlug, SelectFromGlobalSlug } from '../../config/types.js'

import { APIError } from '../../../errors/index.js'
import {
  deepCopyObjectSimple,
  type GlobalSlug,
  type Payload,
  type RequestContext,
  type TypedLocale,
} from '../../../index.js'
import { createLocalReq } from '../../../utilities/createLocalReq.js'
import { updateOperation } from '../update.js'

export type Options<TSlug extends GlobalSlug, TSelect extends SelectType> = {
  /**
   * [Context](https://payloadcms.com/docs/hooks/context), which will then be passed to `context` and `req.context`,
   * which can be read by hooks. Useful if you want to pass additional information to the hooks which
   * shouldn't be necessarily part of the document, for example a `triggerBeforeChange` option which can be read by the BeforeChange hook
   * to determine if it should run or not.
   */
  context?: RequestContext
  /**
   * The global data to update.
   */
  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>
  /**
   * [Control auto-population](https://payloadcms.com/docs/queries/depth) of nested relationship and upload fields.
   */
  depth?: number
  /**
   * Update documents to a draft.
   */
  draft?: boolean
  /**
   * Specify a [fallback locale](https://payloadcms.com/docs/configuration/localization) to use for any returned documents.
   */
  fallbackLocale?: false | TypedLocale
  /**
   * Specify [locale](https://payloadcms.com/docs/configuration/localization) for any returned documents.
   */
  locale?: 'all' | TypedLocale
  /**
   * Skip access control.
   * Set to `false` if you want to respect Access Control for the operation, for example when fetching data for the fron-end.
   * @default true
   */
  overrideAccess?: boolean
  /**
   * If you are uploading a file and would like to replace
   * the existing file instead of generating a new filename,
   * you can set the following property to `true`
   */
  overrideLock?: boolean
  /**
   * Specify [populate](https://payloadcms.com/docs/queries/select#populate) to control which fields to include to the result from populated documents.
   */
  populate?: PopulateType
  /**
   * Publish the document / documents with a specific locale.
   */
  publishSpecificLocale?: TypedLocale
  /**
   * The `PayloadRequest` object. You can pass it to thread the current [transaction](https://payloadcms.com/docs/database/transactions), user and locale to the operation.
   * Recommended to pass when using the Local API from hooks, as usually you want to execute the operation within the current transaction.
   */
  req?: Partial<PayloadRequest>
  /**
   * Specify [select](https://payloadcms.com/docs/queries/select) to control which fields to include to the result.
   */
  select?: TSelect
  /**
   * Opt-in to receiving hidden fields. By default, they are hidden from returned documents in accordance to your config.
   * @default false
   */
  showHiddenFields?: boolean
  /**
   * the Global slug to operate against.
   */
  slug: TSlug
  /**
   * If you set `overrideAccess` to `false`, you can pass a user to use against the access control checks.
   */
  user?: Document
}

export default async function updateLocal<
  TSlug extends GlobalSlug,
  TSelect extends SelectFromGlobalSlug<TSlug>,
>(
  payload: Payload,
  options: Options<TSlug, TSelect>,
): Promise<TransformGlobalWithSelect<TSlug, TSelect>> {
  const {
    slug: globalSlug,
    data,
    depth,
    draft,
    overrideAccess = true,
    overrideLock,
    populate,
    publishSpecificLocale,
    select,
    showHiddenFields,
  } = options

  const globalConfig = payload.globals.config.find((config) => config.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`The global with slug ${String(globalSlug)} can't be found.`)
  }

  return updateOperation<TSlug, TSelect>({
    slug: globalSlug as string,
    data: deepCopyObjectSimple(data), // Ensure mutation of data in create operation hooks doesn't affect the original data
    depth,
    draft,
    globalConfig,
    overrideAccess,
    overrideLock,
    populate,
    publishSpecificLocale,
    req: await createLocalReq(options, payload),
    select,
    showHiddenFields,
  })
}
</file>

<file path="packages/payload/src/globals/operations/countGlobalVersions.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, Where } from '../../types/index.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import {
  buildVersionGlobalFields,
  type GlobalSlug,
  type SanitizedGlobalConfig,
} from '../../index.js'
import { killTransaction } from '../../utilities/killTransaction.js'

export type Arguments = {
  disableErrors?: boolean
  global: SanitizedGlobalConfig
  overrideAccess?: boolean
  req?: PayloadRequest
  where?: Where
}

export const countGlobalVersionsOperation = async <TSlug extends GlobalSlug>(
  args: Arguments,
): Promise<{ totalDocs: number }> => {
  try {
    const {
      disableErrors,
      global,
      overrideAccess,
      req: { payload },
      req,
      where,
    } = args

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ disableErrors, req }, global.access.readVersions)

      // If errors are disabled, and access returns false, return empty results
      if (accessResult === false) {
        return {
          totalDocs: 0,
        }
      }
    }

    const fullWhere = combineQueries(where, accessResult)

    const versionFields = buildVersionGlobalFields(payload.config, global, true)

    await validateQueryPaths({
      globalConfig: global,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    const result = await payload.db.countGlobalVersions({
      global: global.slug,
      req,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return result
  } catch (error: unknown) {
    await killTransaction(args.req)
    throw error
  }
}
</file>

<file path="packages/payload/src/globals/operations/docAccess.ts">
// @ts-strict-ignore
import type { SanitizedGlobalPermission } from '../../auth/index.js'
import type { AllOperations, PayloadRequest } from '../../types/index.js'
import type { SanitizedGlobalConfig } from '../config/types.js'

import { commitTransaction } from '../../utilities/commitTransaction.js'
import { getEntityPolicies } from '../../utilities/getEntityPolicies.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizePermissions } from '../../utilities/sanitizePermissions.js'

type Arguments = {
  globalConfig: SanitizedGlobalConfig
  req: PayloadRequest
}

export const docAccessOperation = async (args: Arguments): Promise<SanitizedGlobalPermission> => {
  const { globalConfig, req } = args

  const globalOperations: AllOperations[] = ['read', 'update']

  if (globalConfig.versions) {
    globalOperations.push('readVersions')
  }

  try {
    const shouldCommit = await initTransaction(req)
    const result = await getEntityPolicies({
      type: 'global',
      blockPolicies: {},
      entity: globalConfig,
      operations: globalOperations,
      req,
    })
    if (shouldCommit) {
      await commitTransaction(req)
    }
    const sanitizedPermissions = sanitizePermissions({
      globals: {
        [globalConfig.slug]: result,
      },
    })

    return sanitizedPermissions?.globals?.[globalConfig.slug]
  } catch (e: unknown) {
    await killTransaction(req)
    throw e
  }
}
</file>

<file path="packages/payload/src/globals/operations/findOne.ts">
// @ts-strict-ignore
import type { AccessResult } from '../../config/types.js'
import type { PayloadRequest, PopulateType, SelectType, Where } from '../../types/index.js'
import type { SanitizedGlobalConfig } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { lockedDocumentsCollectionSlug } from '../../locked-documents/config.js'
import { getSelectMode } from '../../utilities/getSelectMode.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import replaceWithDraftIfAvailable from '../../versions/drafts/replaceWithDraftIfAvailable.js'

type Args = {
  depth?: number
  draft?: boolean
  globalConfig: SanitizedGlobalConfig
  includeLockStatus?: boolean
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  slug: string
}

export const findOneOperation = async <T extends Record<string, unknown>>(
  args: Args,
): Promise<T> => {
  const {
    slug,
    depth,
    draft: draftEnabled = false,
    globalConfig,
    includeLockStatus,
    overrideAccess = false,
    populate,
    req: { fallbackLocale, locale },
    req,
    select: incomingSelect,
    showHiddenFields,
  } = args

  try {
    // /////////////////////////////////////
    // Retrieve and execute access
    // /////////////////////////////////////

    let accessResult: AccessResult

    if (!overrideAccess) {
      accessResult = await executeAccess({ req }, globalConfig.access.read)
    }

    const select = sanitizeSelect({
      forceSelect: globalConfig.forceSelect,
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Perform database operation
    // /////////////////////////////////////

    let doc = await req.payload.db.findGlobal({
      slug,
      locale,
      req,
      select,
      where: overrideAccess ? undefined : (accessResult as Where),
    })
    if (!doc) {
      doc = {}
    }

    // /////////////////////////////////////
    // Include Lock Status if required
    // /////////////////////////////////////
    if (includeLockStatus && slug) {
      let lockStatus = null

      try {
        const lockDocumentsProp = globalConfig?.lockDocuments

        const lockDurationDefault = 300 // Default 5 minutes in seconds
        const lockDuration =
          typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault
        const lockDurationInMilliseconds = lockDuration * 1000

        const lockedDocument = await req.payload.find({
          collection: lockedDocumentsCollectionSlug,
          depth: 1,
          limit: 1,
          overrideAccess: false,
          pagination: false,
          req,
          where: {
            and: [
              {
                globalSlug: {
                  equals: slug,
                },
              },
              {
                updatedAt: {
                  greater_than: new Date(new Date().getTime() - lockDurationInMilliseconds),
                },
              },
            ],
          },
        })

        if (lockedDocument && lockedDocument.docs.length > 0) {
          lockStatus = lockedDocument.docs[0]
        }
      } catch {
        // swallow error
      }

      doc._isLocked = !!lockStatus
      doc._userEditing = lockStatus?.user?.value ?? null
    }

    // /////////////////////////////////////
    // Replace document with draft if available
    // /////////////////////////////////////

    if (globalConfig.versions?.drafts && draftEnabled) {
      doc = await replaceWithDraftIfAvailable({
        accessResult,
        doc,
        entity: globalConfig,
        entityType: 'global',
        overrideAccess,
        req,
        select,
      })
    }

    // /////////////////////////////////////
    // Execute before global hook
    // /////////////////////////////////////

    if (globalConfig.hooks?.beforeRead?.length) {
      for (const hook of globalConfig.hooks.beforeRead) {
        doc =
          (await hook({
            context: req.context,
            doc,
            global: globalConfig,
            req,
          })) || doc
      }
    }

    // /////////////////////////////////////
    // Execute globalType field if not selected
    // /////////////////////////////////////
    if (select && doc.globalType) {
      const selectMode = getSelectMode(select)
      if (
        (selectMode === 'include' && !select['globalType']) ||
        (selectMode === 'exclude' && select['globalType'] === false)
      ) {
        delete doc['globalType']
      }
    }

    // /////////////////////////////////////
    // Execute field-level hooks and access
    // /////////////////////////////////////

    doc = await afterRead({
      collection: null,
      context: req.context,
      depth,
      doc,
      draft: draftEnabled,
      fallbackLocale,
      global: globalConfig,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // Execute after global hook
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterRead?.length) {
      for (const hook of globalConfig.hooks.afterRead) {
        doc =
          (await hook({
            context: req.context,
            doc,
            global: globalConfig,
            req,
          })) || doc
      }
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    return doc
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/globals/operations/findVersionByID.ts">
// @ts-strict-ignore
import type { FindGlobalVersionsArgs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { SanitizedGlobalConfig } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { Forbidden, NotFound } from '../../errors/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { deepCopyObjectSimple } from '../../utilities/deepCopyObject.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  currentDepth?: number
  depth?: number
  disableErrors?: boolean
  globalConfig: SanitizedGlobalConfig
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
}

export const findVersionByIDOperation = async <T extends TypeWithVersion<T> = any>(
  args: Arguments,
): Promise<T> => {
  const {
    id,
    currentDepth,
    depth,
    disableErrors,
    globalConfig,
    overrideAccess,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
  } = args

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ id, disableErrors, req }, globalConfig.access.readVersions)
      : true

    // If errors are disabled, and access returns false, return null
    if (accessResults === false) {
      return null
    }

    const hasWhereAccess = typeof accessResults === 'object'

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),
      select: incomingSelect,
    })

    const findGlobalVersionsArgs: FindGlobalVersionsArgs = {
      global: globalConfig.slug,
      limit: 1,
      locale,
      req,
      select,
      where: combineQueries({ id: { equals: id } }, accessResults),
    }

    // /////////////////////////////////////
    // Find by ID
    // /////////////////////////////////////

    if (!findGlobalVersionsArgs.where.and[0].id) {
      throw new NotFound(req.t)
    }

    const { docs: results } = await payload.db.findGlobalVersions(findGlobalVersionsArgs)
    if (!results || results?.length === 0) {
      if (!disableErrors) {
        if (!hasWhereAccess) {
          throw new NotFound(req.t)
        }
        if (hasWhereAccess) {
          throw new Forbidden(req.t)
        }
      }

      return null
    }

    // Clone the result - it may have come back memoized
    let result: any = deepCopyObjectSimple(results[0])

    if (!result.version) {
      result.version = {}
    }

    // Patch globalType onto version doc
    result.version.globalType = globalConfig.slug

    // /////////////////////////////////////
    // beforeRead - Collection
    // /////////////////////////////////////

    if (globalConfig.hooks?.beforeRead?.length) {
      for (const hook of globalConfig.hooks.beforeRead) {
        result =
          (await hook({
            context: req.context,
            doc: result.version,
            global: globalConfig,
            req,
          })) || result.version
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result.version = await afterRead({
      collection: null,
      context: req.context,
      currentDepth,
      depth,
      doc: result.version,
      draft: undefined,
      fallbackLocale,
      global: globalConfig,
      locale,
      overrideAccess,
      populate,
      req,
      select: typeof select?.version === 'object' ? select.version : undefined,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterRead?.length) {
      for (const hook of globalConfig.hooks.afterRead) {
        result.version =
          (await hook({
            context: req.context,
            doc: result.version,
            global: globalConfig,
            query: findGlobalVersionsArgs.where,
            req,
          })) || result.version
      }
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/globals/operations/findVersions.ts">
// @ts-strict-ignore
import type { PaginatedDocs } from '../../database/types.js'
import type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { SanitizedGlobalConfig } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { combineQueries } from '../../database/combineQueries.js'
import { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { buildVersionGlobalFields } from '../../versions/buildGlobalFields.js'
import { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'

export type Arguments = {
  depth?: number
  globalConfig: SanitizedGlobalConfig
  limit?: number
  overrideAccess?: boolean
  page?: number
  pagination?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  sort?: Sort
  where?: Where
}

export const findVersionsOperation = async <T extends TypeWithVersion<T>>(
  args: Arguments,
): Promise<PaginatedDocs<T>> => {
  const {
    depth,
    globalConfig,
    limit,
    overrideAccess,
    page,
    pagination = true,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
    sort,
    where,
  } = args

  const versionFields = buildVersionGlobalFields(payload.config, globalConfig, true)

  try {
    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess({ req }, globalConfig.access.readVersions)
      : true

    await validateQueryPaths({
      globalConfig,
      overrideAccess,
      req,
      versionFields,
      where,
    })

    const fullWhere = combineQueries(where, accessResults)

    const select = sanitizeSelect({
      forceSelect: getQueryDraftsSelect({ select: globalConfig.forceSelect }),
      select: incomingSelect,
    })

    // /////////////////////////////////////
    // Find
    // /////////////////////////////////////

    const paginatedDocs = await payload.db.findGlobalVersions<T>({
      global: globalConfig.slug,
      limit: limit ?? 10,
      locale,
      page: page || 1,
      pagination,
      req,
      select,
      sort,
      where: fullWhere,
    })

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    let result = {
      ...paginatedDocs,
      docs: await Promise.all(
        paginatedDocs.docs.map(async (data) => {
          if (!data.version) {
            // Fallback if not selected
            ;(data as any).version = {}
          }
          return {
            ...data,
            version: await afterRead<T>({
              collection: null,
              context: req.context,
              depth,
              doc: {
                ...data.version,
                // Patch globalType onto version doc
                globalType: globalConfig.slug,
              },
              draft: undefined,
              fallbackLocale,
              findMany: true,
              global: globalConfig,
              locale,
              overrideAccess,
              populate,
              req,
              select,
              showHiddenFields,
            }),
          }
        }),
      ),
    } as PaginatedDocs<T>

    // /////////////////////////////////////
    // afterRead - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterRead?.length) {
      result.docs = await Promise.all(
        result.docs.map(async (doc) => {
          const docRef = doc

          for (const hook of globalConfig.hooks.afterRead) {
            docRef.version =
              (await hook({
                context: req.context,
                doc: doc.version,
                findMany: true,
                global: globalConfig,
                query: fullWhere,
                req,
              })) || doc.version
          }

          return docRef
        }),
      )
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    result = {
      ...result,
      docs: result.docs.map((doc) => sanitizeInternalFields<T>(doc)),
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/globals/operations/restoreVersion.ts">
// @ts-strict-ignore
import type { PayloadRequest, PopulateType } from '../../types/index.js'
import type { TypeWithVersion } from '../../versions/types.js'
import type { SanitizedGlobalConfig } from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { NotFound } from '../../errors/index.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'

export type Arguments = {
  depth?: number
  draft?: boolean
  globalConfig: SanitizedGlobalConfig
  id: number | string
  overrideAccess?: boolean
  populate?: PopulateType
  req?: PayloadRequest
  showHiddenFields?: boolean
}

export const restoreVersionOperation = async <T extends TypeWithVersion<T> = any>(
  args: Arguments,
): Promise<T> => {
  const {
    id,
    depth,
    draft,
    globalConfig,
    overrideAccess,
    populate,
    req: { fallbackLocale, locale, payload },
    req,
    showHiddenFields,
  } = args

  try {
    const shouldCommit = await initTransaction(req)

    // /////////////////////////////////////
    // Access
    // /////////////////////////////////////

    if (!overrideAccess) {
      await executeAccess({ req }, globalConfig.access.update)
    }

    // /////////////////////////////////////
    // Retrieve original raw version
    // /////////////////////////////////////

    const { docs: versionDocs } = await payload.db.findGlobalVersions<any>({
      global: globalConfig.slug,
      limit: 1,
      req,
      where: { id: { equals: id } },
    })

    if (!versionDocs || versionDocs.length === 0) {
      throw new NotFound(req.t)
    }

    const rawVersion = versionDocs[0]

    // Patch globalType onto version doc
    rawVersion.version.globalType = globalConfig.slug

    // Overwrite draft status if draft is true

    if (draft) {
      rawVersion.version._status = 'draft'
    }
    // /////////////////////////////////////
    // fetch previousDoc
    // /////////////////////////////////////

    const previousDoc = await payload.findGlobal({
      slug: globalConfig.slug,
      depth,
      req,
    })

    // /////////////////////////////////////
    // Update global
    // /////////////////////////////////////

    const global = await payload.db.findGlobal({
      slug: globalConfig.slug,
      req,
    })

    let result = rawVersion.version

    if (global) {
      result = await payload.db.updateGlobal({
        slug: globalConfig.slug,
        data: result,
        req,
      })

      const now = new Date().toISOString()

      result = await payload.db.createGlobalVersion({
        autosave: false,
        createdAt: result.createdAt ? new Date(result.createdAt).toISOString() : now,
        globalSlug: globalConfig.slug,
        parent: id,
        req,
        updatedAt: draft ? now : new Date(result.updatedAt).toISOString(),
        versionData: result,
      })
    } else {
      result = await payload.db.createGlobal({
        slug: globalConfig.slug,
        data: result,
        req,
      })
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: null,
      context: req.context,
      depth,
      doc: result,
      draft: undefined,
      fallbackLocale,
      global: globalConfig,
      locale,
      overrideAccess,
      populate,
      req,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterRead?.length) {
      for (const hook of globalConfig.hooks.afterRead) {
        result =
          (await hook({
            context: req.context,
            doc: result,
            global: globalConfig,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: null,
      context: req.context,
      data: result,
      doc: result,
      global: globalConfig,
      operation: 'update',
      previousDoc,
      req,
    })

    // /////////////////////////////////////
    // afterChange - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterChange?.length) {
      for (const hook of globalConfig.hooks.afterChange) {
        result =
          (await hook({
            context: req.context,
            doc: result,
            global: globalConfig,
            previousDoc,
            req,
          })) || result
      }
    }

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/globals/operations/update.ts">
// @ts-strict-ignore
import type { DeepPartial } from 'ts-essentials'

import type { GlobalSlug, JsonObject } from '../../index.js'
import type {
  Operation,
  PayloadRequest,
  PopulateType,
  SelectType,
  TransformGlobalWithSelect,
  Where,
} from '../../types/index.js'
import type {
  DataFromGlobalSlug,
  SanitizedGlobalConfig,
  SelectFromGlobalSlug,
} from '../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { afterChange } from '../../fields/hooks/afterChange/index.js'
import { afterRead } from '../../fields/hooks/afterRead/index.js'
import { beforeChange } from '../../fields/hooks/beforeChange/index.js'
import { beforeValidate } from '../../fields/hooks/beforeValidate/index.js'
import { deepCopyObjectSimple } from '../../index.js'
import { checkDocumentLockStatus } from '../../utilities/checkDocumentLockStatus.js'
import { commitTransaction } from '../../utilities/commitTransaction.js'
import { getSelectMode } from '../../utilities/getSelectMode.js'
import { initTransaction } from '../../utilities/initTransaction.js'
import { killTransaction } from '../../utilities/killTransaction.js'
import { sanitizeSelect } from '../../utilities/sanitizeSelect.js'
import { getLatestGlobalVersion } from '../../versions/getLatestGlobalVersion.js'
import { saveVersion } from '../../versions/saveVersion.js'

type Args<TSlug extends GlobalSlug> = {
  autosave?: boolean
  data: DeepPartial<Omit<DataFromGlobalSlug<TSlug>, 'id'>>
  depth?: number
  disableTransaction?: boolean
  draft?: boolean
  globalConfig: SanitizedGlobalConfig
  overrideAccess?: boolean
  overrideLock?: boolean
  populate?: PopulateType
  publishSpecificLocale?: string
  req: PayloadRequest
  select?: SelectType
  showHiddenFields?: boolean
  slug: string
}

export const updateOperation = async <
  TSlug extends GlobalSlug,
  TSelect extends SelectFromGlobalSlug<TSlug>,
>(
  args: Args<TSlug>,
): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {
  if (args.publishSpecificLocale) {
    args.req.locale = args.publishSpecificLocale
  }

  const {
    slug,
    autosave,
    depth,
    disableTransaction,
    draft: draftArg,
    globalConfig,
    overrideAccess,
    overrideLock,
    populate,
    publishSpecificLocale,
    req: { fallbackLocale, locale, payload },
    req,
    select: incomingSelect,
    showHiddenFields,
  } = args

  try {
    const shouldCommit = !disableTransaction && (await initTransaction(req))

    let { data } = args

    const shouldSaveDraft = Boolean(draftArg && globalConfig.versions?.drafts)

    // /////////////////////////////////////
    // 1. Retrieve and execute access
    // /////////////////////////////////////

    const accessResults = !overrideAccess
      ? await executeAccess(
          {
            data,
            req,
          },
          globalConfig.access.update,
        )
      : true

    // /////////////////////////////////////
    // Retrieve document
    // /////////////////////////////////////

    const query: Where = overrideAccess ? undefined : (accessResults as Where)

    // /////////////////////////////////////
    // 2. Retrieve document
    // /////////////////////////////////////
    const globalVersion = await getLatestGlobalVersion({
      slug,
      config: globalConfig,
      locale,
      payload,
      req,
      where: query,
    })
    const { global, globalExists } = globalVersion || {}

    let globalJSON: JsonObject = {}

    if (globalVersion && globalVersion.global) {
      globalJSON = deepCopyObjectSimple(global)

      if (globalJSON._id) {
        delete globalJSON._id
      }
    }

    const originalDoc = await afterRead({
      collection: null,
      context: req.context,
      depth: 0,
      doc: deepCopyObjectSimple(globalJSON),
      draft: draftArg,
      fallbackLocale,
      global: globalConfig,
      locale,
      overrideAccess: true,
      req,
      showHiddenFields,
    })

    // ///////////////////////////////////////////
    // Handle potentially locked global documents
    // ///////////////////////////////////////////

    await checkDocumentLockStatus({
      globalSlug: slug,
      lockErrorMessage: `Global with slug "${slug}" is currently locked by another user and cannot be updated.`,
      overrideLock,
      req,
    })

    // /////////////////////////////////////
    // beforeValidate - Fields
    // /////////////////////////////////////

    data = await beforeValidate({
      collection: null,
      context: req.context,
      data,
      doc: originalDoc,
      global: globalConfig,
      operation: 'update',
      overrideAccess,
      req,
    })

    // /////////////////////////////////////
    // beforeValidate - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.beforeValidate?.length) {
      for (const hook of globalConfig.hooks.beforeValidate) {
        data =
          (await hook({
            context: req.context,
            data,
            global: globalConfig,
            originalDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.beforeChange?.length) {
      for (const hook of globalConfig.hooks.beforeChange) {
        data =
          (await hook({
            context: req.context,
            data,
            global: globalConfig,
            originalDoc,
            req,
          })) || data
      }
    }

    // /////////////////////////////////////
    // beforeChange - Fields
    // /////////////////////////////////////
    let publishedDocWithLocales = globalJSON
    let versionSnapshotResult

    const beforeChangeArgs = {
      collection: null,
      context: req.context,
      data,
      doc: originalDoc,
      docWithLocales: undefined,
      global: globalConfig,
      operation: 'update' as Operation,
      req,
      skipValidation:
        shouldSaveDraft && globalConfig.versions.drafts && !globalConfig.versions.drafts.validate,
    }

    if (publishSpecificLocale) {
      const latestVersion = await getLatestGlobalVersion({
        slug,
        config: globalConfig,
        payload,
        published: true,
        req,
        where: query,
      })

      publishedDocWithLocales = latestVersion?.global || {}

      versionSnapshotResult = await beforeChange({
        ...beforeChangeArgs,
        docWithLocales: globalJSON,
      })
    }

    let result = await beforeChange({
      ...beforeChangeArgs,
      docWithLocales: publishedDocWithLocales,
    })

    // /////////////////////////////////////
    // Update
    // /////////////////////////////////////

    const select = sanitizeSelect({
      forceSelect: globalConfig.forceSelect,
      select: incomingSelect,
    })

    if (!shouldSaveDraft) {
      // Ensure global has createdAt
      if (!result.createdAt) {
        result.createdAt = new Date().toISOString()
      }

      if (globalExists) {
        result = await payload.db.updateGlobal({
          slug,
          data: result,
          req,
          select,
        })
      } else {
        result = await payload.db.createGlobal({
          slug,
          data: result,
          req,
        })
      }
    }

    // /////////////////////////////////////
    // Create version
    // /////////////////////////////////////
    if (globalConfig.versions) {
      const { globalType } = result
      result = await saveVersion({
        autosave,
        docWithLocales: result,
        draft: shouldSaveDraft,
        global: globalConfig,
        payload,
        publishSpecificLocale,
        req,
        select,
        snapshot: versionSnapshotResult,
      })

      result = {
        ...result,
        globalType,
      }
    }

    // /////////////////////////////////////
    // Execute globalType field if not selected
    // /////////////////////////////////////
    if (select && result.globalType) {
      const selectMode = getSelectMode(select)
      if (
        (selectMode === 'include' && !select['globalType']) ||
        (selectMode === 'exclude' && select['globalType'] === false)
      ) {
        delete result['globalType']
      }
    }

    // /////////////////////////////////////
    // afterRead - Fields
    // /////////////////////////////////////

    result = await afterRead({
      collection: null,
      context: req.context,
      depth,
      doc: result,
      draft: draftArg,
      fallbackLocale: null,
      global: globalConfig,
      locale,
      overrideAccess,
      populate,
      req,
      select,
      showHiddenFields,
    })

    // /////////////////////////////////////
    // afterRead - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterRead?.length) {
      for (const hook of globalConfig.hooks.afterRead) {
        result =
          (await hook({
            context: req.context,
            doc: result,
            global: globalConfig,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // afterChange - Fields
    // /////////////////////////////////////

    result = await afterChange({
      collection: null,
      context: req.context,
      data,
      doc: result,
      global: globalConfig,
      operation: 'update',
      previousDoc: originalDoc,
      req,
    })

    // /////////////////////////////////////
    // afterChange - Global
    // /////////////////////////////////////

    if (globalConfig.hooks?.afterChange?.length) {
      for (const hook of globalConfig.hooks.afterChange) {
        result =
          (await hook({
            context: req.context,
            doc: result,
            global: globalConfig,
            previousDoc: originalDoc,
            req,
          })) || result
      }
    }

    // /////////////////////////////////////
    // Return results
    // /////////////////////////////////////

    if (shouldCommit) {
      await commitTransaction(req)
    }

    return result as TransformGlobalWithSelect<TSlug, TSelect>
  } catch (error: unknown) {
    await killTransaction(req)
    throw error
  }
}
</file>

<file path="packages/payload/src/locked-documents/config.ts">
// @ts-strict-ignore
import type { CollectionConfig } from '../collections/config/types.js'
import type { Config } from '../config/types.js'

import defaultAccess from '../auth/defaultAccess.js'

export const lockedDocumentsCollectionSlug = 'payload-locked-documents'

export const getLockedDocumentsCollection = (config: Config): CollectionConfig => ({
  slug: lockedDocumentsCollectionSlug,
  access: {
    create: defaultAccess,
    delete: defaultAccess,
    read: defaultAccess,
    update: defaultAccess,
  },
  admin: {
    hidden: true,
  },
  fields: [
    {
      name: 'document',
      type: 'relationship',
      index: true,
      maxDepth: 0,
      relationTo: [...config.collections.map((collectionConfig) => collectionConfig.slug)],
    },
    {
      name: 'globalSlug',
      type: 'text',
      index: true,
    },
    {
      name: 'user',
      type: 'relationship',
      maxDepth: 1,
      relationTo: config.collections
        .filter((collectionConfig) => collectionConfig.auth)
        .map((collectionConfig) => collectionConfig.slug),
      required: true,
    },
  ],
  lockDocuments: false,
})
</file>

<file path="packages/payload/src/preferences/operations/delete.ts">
import type { Document, Where } from '../../types/index.js'
import type { PreferenceRequest } from '../types.js'

import { NotFound } from '../../errors/NotFound.js'
import { UnauthorizedError } from '../../errors/UnauthorizedError.js'
import { preferencesCollectionSlug } from '../config.js'

export async function deleteOperation(args: PreferenceRequest): Promise<Document> {
  const {
    key,
    req: { payload },
    req,
    user,
  } = args

  if (!user) {
    throw new UnauthorizedError(req.t)
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const result = await payload.db.deleteOne({
    collection: preferencesCollectionSlug,
    req,
    where,
  })

  if (result) {
    return result
  }
  throw new NotFound(req.t)
}
</file>

<file path="packages/payload/src/preferences/operations/findOne.ts">
// @ts-strict-ignore
import type { TypedCollection } from '../../index.js'
import type { Where } from '../../types/index.js'
import type { PreferenceRequest } from '../types.js'

import { preferencesCollectionSlug } from '../config.js'

export async function findOne(args: PreferenceRequest): Promise<TypedCollection['_preference']> {
  const {
    key,
    req: { payload },
    req,
    user,
  } = args

  if (!user) {
    return null
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const { docs } = await payload.db.find({
    collection: preferencesCollectionSlug,
    limit: 1,
    pagination: false,
    req,
    sort: '-updatedAt',
    where,
  })

  return docs?.[0] || null
}
</file>

<file path="packages/payload/src/preferences/operations/update.ts">
import type { Where } from '../../types/index.js'
import type { PreferenceUpdateRequest } from '../types.js'

import { UnauthorizedError } from '../../errors/UnauthorizedError.js'
import { preferencesCollectionSlug } from '../config.js'

export async function update(args: PreferenceUpdateRequest) {
  const {
    key,
    req: { payload },
    req,
    user,
    value,
  } = args

  if (!user) {
    throw new UnauthorizedError(req.t)
  }

  const where: Where = {
    and: [
      { key: { equals: key } },
      { 'user.value': { equals: user.id } },
      { 'user.relationTo': { equals: user.collection } },
    ],
  }

  const preference = {
    key,
    user: {
      relationTo: user.collection,
      value: user.id,
    },
    value,
  }

  return await payload.db.upsert({
    collection: preferencesCollectionSlug,
    data: preference,
    req,
    where,
  })
}
</file>

<file path="packages/payload/src/preferences/requestHandlers/delete.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { deleteOperation } from '../operations/delete.js'

export const deleteHandler: PayloadHandler = async (incomingReq): Promise<Response> => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (error) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const result = await deleteOperation({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData.user,
  })

  return Response.json(
    {
      ...result,
      message: reqWithData.t('general:deletedSuccessfully'),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/preferences/requestHandlers/findOne.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { findOne } from '../operations/findOne.js'

export const findByIDHandler: PayloadHandler = async (incomingReq): Promise<Response> => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (error) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const result = await findOne({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData.user,
  })

  return Response.json(
    {
      ...(result
        ? result
        : {
            message: reqWithData.t('general:notFound'),
            value: null,
          }),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/preferences/requestHandlers/update.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'

import type { PayloadHandler } from '../../config/types.js'
import type { PayloadRequest } from '../../types/index.js'

import { update } from '../operations/update.js'

export const updateHandler: PayloadHandler = async (incomingReq) => {
  // We cannot import the addDataAndFileToRequest utility here from the 'next' package because of dependency issues
  // However that utility should be used where possible instead of manually appending the data
  let data

  try {
    data = await incomingReq.json()
  } catch (_err) {
    data = {}
  }

  const reqWithData: PayloadRequest = incomingReq

  if (data) {
    reqWithData.data = data
    reqWithData.json = () => Promise.resolve(data)
  }

  const doc = await update({
    key: reqWithData.routeParams?.key as string,
    req: reqWithData,
    user: reqWithData?.user,
    value: reqWithData.data.value || reqWithData.data,
  })

  return Response.json(
    {
      doc,
      message: reqWithData.t('general:updatedSuccessfully'),
    },
    {
      status: httpStatus.OK,
    },
  )
}
</file>

<file path="packages/payload/src/preferences/config.ts">
// @ts-strict-ignore
import type { CollectionConfig } from '../collections/config/types.js'
import type { Access, Config } from '../config/types.js'

import { deleteHandler } from './requestHandlers/delete.js'
import { findByIDHandler } from './requestHandlers/findOne.js'
import { updateHandler } from './requestHandlers/update.js'

const preferenceAccess: Access = ({ req }) => {
  if (!req.user) {
    return false
  }

  return {
    'user.value': {
      equals: req?.user?.id,
    },
  }
}

export const preferencesCollectionSlug = 'payload-preferences'

export const getPreferencesCollection = (config: Config): CollectionConfig => ({
  slug: preferencesCollectionSlug,
  access: {
    delete: preferenceAccess,
    read: preferenceAccess,
  },
  admin: {
    hidden: true,
  },
  endpoints: [
    {
      handler: findByIDHandler,
      method: 'get',
      path: '/:key',
    },
    {
      handler: deleteHandler,
      method: 'delete',
      path: '/:key',
    },
    {
      handler: updateHandler,
      method: 'post',
      path: '/:key',
    },
  ],
  fields: [
    {
      name: 'user',
      type: 'relationship',
      hooks: {
        beforeValidate: [
          ({ req }) => {
            if (!req?.user) {
              return null
            }

            return {
              relationTo: req?.user.collection,
              value: req?.user.id,
            }
          },
        ],
      },
      index: true,
      relationTo: config.collections
        .filter((collectionConfig) => collectionConfig.auth)
        .map((collectionConfig) => collectionConfig.slug),
      required: true,
    },
    {
      name: 'key',
      type: 'text',
      index: true,
    },
    {
      name: 'value',
      type: 'json',
      validate: (value) => {
        if (value) {
          try {
            JSON.parse(JSON.stringify(value))
          } catch {
            return 'Invalid JSON'
          }
        }

        return true
      },
    },
  ],
  lockDocuments: false,
})
</file>

<file path="packages/payload/src/preferences/deleteUserPreferences.ts">
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { Payload } from '../index.js'
import type { PayloadRequest } from '../types/index.js'

import { preferencesCollectionSlug } from './config.js'

type Args = {
  collectionConfig: SanitizedCollectionConfig
  /**
   * User IDs to delete
   */
  ids: (number | string)[]
  payload: Payload
  req: PayloadRequest
}
export const deleteUserPreferences = async ({ collectionConfig, ids, payload, req }: Args) => {
  if (collectionConfig.auth) {
    await payload.db.deleteMany({
      collection: preferencesCollectionSlug,
      req,
      where: {
        or: [
          {
            and: [
              {
                'user.value': { in: ids },
              },
              {
                'user.relationTo': { equals: collectionConfig.slug },
              },
            ],
          },
          {
            key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },
          },
        ],
      },
    })
  } else {
    await payload.db.deleteMany({
      collection: preferencesCollectionSlug,
      req,
      where: {
        key: { in: ids.map((id) => `collection-${collectionConfig.slug}-${id}`) },
      },
    })
  }
}
</file>

<file path="packages/payload/src/preferences/types.ts">
import type { DefaultDocumentIDType } from '../index.js'
import type { PayloadRequest } from '../types/index.js'

export type PreferenceRequest = {
  key: string
  overrideAccess?: boolean
  req: PayloadRequest
  user: PayloadRequest['user']
}

export type PreferenceUpdateRequest = { value: unknown } & PreferenceRequest

export type CollapsedPreferences = string[]

export type TabsPreferences = Array<{
  [path: string]: number
}>

export type InsideFieldsPreferences = {
  collapsed: CollapsedPreferences
  tabIndex: number
}

export type FieldsPreferences = {
  [key: string]: InsideFieldsPreferences
}

export type DocumentPreferences = {
  fields: FieldsPreferences
}

export type ColumnPreference = {
  accessor: string
  active: boolean
}

export type ListPreferences = {
  columns?: ColumnPreference[]
  limit?: number
  preset?: DefaultDocumentIDType
  sort?: string
}
</file>

<file path="packages/payload/src/query-presets/access.ts">
import type { Access, Config } from '../config/types.js'
import type { Operation } from '../types/index.js'

import defaultAccess from '../auth/defaultAccess.js'

const operations: Operation[] = ['delete', 'read', 'update', 'create'] as const

const defaultCollectionAccess = {
  create: defaultAccess,
  delete: defaultAccess,
  read: defaultAccess,
  unlock: defaultAccess,
  update: defaultAccess,
}

export const getAccess = (config: Config): Record<Operation, Access> =>
  operations.reduce(
    (acc, operation) => {
      acc[operation] = async (args) => {
        const { req } = args

        const collectionAccess = config?.queryPresets?.access?.[operation]
          ? await config.queryPresets.access[operation](args)
          : defaultCollectionAccess?.[operation]
            ? defaultCollectionAccess[operation](args)
            : true

        // If collection-level access control is `false`, no need to continue to document-level access
        if (collectionAccess === false) {
          return false
        }

        // The `create` operation does not affect the document-level access control
        if (operation === 'create') {
          return collectionAccess
        }

        return {
          and: [
            {
              or: [
                // Default access control ensures a user exists, but custom access control may not
                ...(req?.user
                  ? [
                      {
                        and: [
                          {
                            [`access.${operation}.users`]: {
                              in: [req.user.id],
                            },
                          },
                          {
                            [`access.${operation}.constraint`]: {
                              in: ['onlyMe', 'specificUsers'],
                            },
                          },
                        ],
                      },
                    ]
                  : []),
                {
                  [`access.${operation}.constraint`]: {
                    equals: 'everyone',
                  },
                },
                ...(await Promise.all(
                  (config?.queryPresets?.constraints?.[operation] || []).map(async (constraint) => {
                    const constraintAccess = constraint.access
                      ? await constraint.access(args)
                      : undefined

                    return {
                      and: [
                        ...(typeof constraintAccess === 'object' ? [constraintAccess] : []),
                        {
                          [`access.${operation}.constraint`]: {
                            equals: constraint.value,
                          },
                        },
                      ],
                    }
                  }),
                )),
              ],
            },
            ...(typeof collectionAccess === 'object' ? [collectionAccess] : []),
          ],
        }
      }

      return acc
    },
    {} as Record<Operation, Access>,
  )
</file>

<file path="packages/payload/src/query-presets/config.ts">
import type { CollectionConfig } from '../collections/config/types.js'
import type { Config } from '../config/types.js'
import type { Option } from '../fields/config/types.js'

import { transformWhereQuery } from '../utilities/transformWhereQuery.js'
import { validateWhereQuery } from '../utilities/validateWhereQuery.js'
import { getAccess } from './access.js'
import { getConstraints } from './constraints.js'
import { operations, type QueryPreset } from './types.js'

export const queryPresetsCollectionSlug = 'payload-query-presets'

export const getQueryPresetsConfig = (config: Config): CollectionConfig => ({
  slug: queryPresetsCollectionSlug,
  access: getAccess(config),
  admin: {
    defaultColumns: ['title', 'isShared', 'access', 'where', 'columns'],
    hidden: true,
    useAsTitle: 'title',
  },
  fields: [
    {
      name: 'title',
      type: 'text',
      required: true,
    },
    {
      name: 'isShared',
      type: 'checkbox',
      defaultValue: false,
      validate: (isShared, { data }) => {
        const typedData = data as QueryPreset

        // ensure the `isShared` is only true if all constraints are 'onlyMe'
        if (typedData?.access) {
          const someOperationsAreShared = Object.values(typedData.access).some(
            (operation) => operation.constraint !== 'onlyMe',
          )

          if (!isShared && someOperationsAreShared) {
            return 'If any constraint is not "onlyMe", the preset must be shared'
          }
        }

        return true
      },
    },
    getConstraints(config),
    {
      name: 'where',
      type: 'json',
      admin: {
        components: {
          Cell: '@payloadcms/ui#QueryPresetsWhereCell',
          Field: '@payloadcms/ui#QueryPresetsWhereField',
        },
      },
      hooks: {
        beforeValidate: [
          ({ data }) => {
            // transform the "where" query here so that the client-side doesn't have to
            if (data?.where) {
              if (validateWhereQuery(data.where)) {
                return data.where
              } else {
                return transformWhereQuery(data.where)
              }
            }

            return data?.where
          },
        ],
      },
      label: 'Filters',
    },
    {
      name: 'columns',
      type: 'json',
      admin: {
        components: {
          Cell: '@payloadcms/ui#QueryPresetsColumnsCell',
          Field: '@payloadcms/ui#QueryPresetsColumnField',
        },
      },
      validate: (value) => {
        if (value) {
          try {
            JSON.parse(JSON.stringify(value))
          } catch {
            return 'Invalid JSON'
          }
        }

        return true
      },
    },
    {
      name: 'relatedCollection',
      type: 'select',
      admin: {
        hidden: true,
      },
      options: config.collections
        ? config.collections.reduce((acc, collection) => {
            if (collection.enableQueryPresets) {
              acc.push({
                label: collection.labels?.plural || collection.slug,
                value: collection.slug,
              })
            }
            return acc
          }, [] as Option[])
        : [],
      required: true,
    },
  ],
  hooks: {
    beforeValidate: [
      ({ data, operation, req }) => {
        // TODO: type this
        const typedData = data as any

        if (operation === 'create' || operation === 'update') {
          // Ensure all operations have a constraint
          operations.forEach((operation) => {
            if (!typedData.access) {
              typedData.access = {}
            }

            if (!typedData.access?.[operation]) {
              typedData[operation] = {}
            }

            // Ensure all operations have a constraint
            if (!typedData.access[operation]?.constraint) {
              typedData.access[operation] = {
                ...typedData.access[operation],
                constraint: 'onlyMe',
              }
            }
          })

          // If at least one constraint is not `onlyMe` then `isShared` must be true
          if (typedData?.access) {
            const someOperationsAreShared = Object.values(typedData.access).some(
              // TODO: remove the `any` here
              (operation: any) => operation.constraint !== 'onlyMe',
            )

            typedData.isShared = someOperationsAreShared
          }
        }

        return typedData
      },
    ],
  },
  labels: {
    plural: 'Presets',
    singular: 'Preset',
    ...(config.queryPresets?.labels || {}),
  },
  lockDocuments: false,
})
</file>

<file path="packages/payload/src/query-presets/constraints.ts">
import { getTranslation } from '@convexcms/translations'

import type { Config } from '../config/types.js'
import type { Field } from '../fields/config/types.js'

import { fieldAffectsData } from '../fields/config/types.js'
import { toWords } from '../utilities/formatLabels.js'
import { operations, type QueryPresetConstraint } from './types.js'

export const getConstraints = (config: Config): Field => ({
  name: 'access',
  type: 'group',
  admin: {
    components: {
      Cell: '@payloadcms/ui#QueryPresetsAccessCell',
    },
    condition: (data) => Boolean(data?.isShared),
  },
  fields: operations.map((operation) => ({
    type: 'collapsible',
    fields: [
      {
        name: operation,
        type: 'group',
        admin: {
          hideGutter: true,
        },
        fields: [
          {
            name: 'constraint',
            type: 'select',
            defaultValue: 'onlyMe',
            label: ({ i18n }) =>
              `Specify who can ${operation} this ${getTranslation(config.queryPresets?.labels?.singular || 'Preset', i18n)}`,
            options: [
              {
                label: 'Everyone',
                value: 'everyone',
              },
              {
                label: 'Only Me',
                value: 'onlyMe',
              },
              {
                label: 'Specific Users',
                value: 'specificUsers',
              },
              ...(config?.queryPresets?.constraints?.[operation]?.map(
                (option: QueryPresetConstraint) => ({
                  label: option.label,
                  value: option.value,
                }),
              ) || []),
            ],
          },
          {
            name: 'users',
            type: 'relationship',
            admin: {
              condition: (data) =>
                Boolean(data?.access?.[operation]?.constraint === 'specificUsers'),
            },
            hasMany: true,
            hooks: {
              beforeChange: [
                ({ data, req }) => {
                  if (data?.access?.[operation]?.constraint === 'onlyMe') {
                    if (req.user) {
                      return [req.user.id]
                    }
                  }

                  return data?.access?.[operation]?.users
                },
              ],
            },
            relationTo: 'users',
          },
          ...(config?.queryPresets?.constraints?.[operation]?.reduce(
            (acc: Field[], option: QueryPresetConstraint) => {
              option.fields.forEach((field, index) => {
                acc.push({ ...field })

                if (fieldAffectsData(field)) {
                  acc[index].admin = {
                    ...(acc[index]?.admin || {}),
                    condition: (data) =>
                      Boolean(data?.access?.[operation]?.constraint === option.value),
                  }
                }
              })

              return acc
            },
            [] as Field[],
          ) || []),
        ],
        label: false,
      },
    ],
    label: () => toWords(operation),
  })),
  label: 'Sharing settings',
})
</file>

<file path="packages/payload/src/query-presets/types.ts">
import type { Field } from '../fields/config/types.js'
import type { Access, CollectionSlug } from '../index.js'
import type { ListPreferences } from '../preferences/types.js'
import type { Where } from '../types/index.js'

// Note: order matters here as it will change the rendered order in the UI
export const operations = ['read', 'update', 'delete'] as const

type Operation = (typeof operations)[number]

export type QueryPreset = {
  access: {
    [operation in Operation]: {
      constraint: 'everyone' | 'onlyMe' | 'specificUsers'
      users?: string[]
    }
  }
  columns: ListPreferences['columns']
  id: number | string
  isShared: boolean
  relatedCollection: CollectionSlug
  title: string
  where: Where
}

export type QueryPresetConstraint = {
  access: Access<QueryPreset>
  fields: Field[]
  label: string
  value: string
}

export type QueryPresetConstraints = QueryPresetConstraint[]
</file>

<file path="packages/payload/src/queues/config/types/index.ts">
import type { CollectionConfig } from '../../../index.js'
import type { Payload, PayloadRequest, Sort } from '../../../types/index.js'
import type { RunJobsArgs } from '../../operations/runJobs/index.js'
import type { TaskConfig } from './taskTypes.js'
import type { WorkflowConfig } from './workflowTypes.js'

export type CronConfig = {
  /**
   * The cron schedule for the job.
   * @default '* * * * *' (every minute).
   *
   * @example
   *     ┌───────────── minute (0 - 59)
   *     │ ┌───────────── hour (0 - 23)
   *     │ │ ┌───────────── day of the month (1 - 31)
   *     │ │ │ ┌───────────── month (1 - 12)
   *     │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
   *     │ │ │ │ │
   *     │ │ │ │ │
   *  - '0 * * * *' every hour at minute 0
   *  - '0 0 * * *' daily at midnight
   *  - '0 0 * * 0' weekly at midnight on Sundays
   *  - '0 0 1 * *' monthly at midnight on the 1st day of the month
   *  - '0/5 * * * *' every 5 minutes
   */
  cron?: string
  /**
   * The limit for the job. This can be overridden by the user. Defaults to 10.
   */
  limit?: number
  /**
   * The queue name for the job.
   */
  queue?: string
}

export type RunJobAccessArgs = {
  req: PayloadRequest
}

export type RunJobAccess = (args: RunJobAccessArgs) => boolean | Promise<boolean>

export type JobsConfig = {
  /**
   * Specify access control to determine who can interact with jobs.
   */
  access?: {
    /**
     * By default, all logged-in users can trigger jobs.
     */
    run?: RunJobAccess
  }
  /** Adds information about the parent job to the task log. This is useful for debugging and tracking the flow of tasks.
   *
   * In 4.0, this will default to `true`.
   *
   * @default false
   */
  addParentToTaskLog?: boolean
  /**
   * Queue cron jobs automatically on payload initialization.
   * @remark this property should not be used on serverless platforms like Vercel
   */
  autoRun?: ((payload: Payload) => CronConfig[] | Promise<CronConfig[]>) | CronConfig[]
  /**
   * Determine whether or not to delete a job after it has successfully completed.
   */
  deleteJobOnComplete?: boolean
  /**
   * Specify depth for retrieving jobs from the queue.
   * This should be as low as possible in order for job retrieval
   * to be as efficient as possible. Setting it to anything higher than
   * 0 will drastically affect performance, as less efficient database
   * queries will be used.
   *
   * @default 0
   */
  depth?: number
  /**
   * Override any settings on the default Jobs collection. Accepts the default collection and allows you to return
   * a new collection.
   */
  jobsCollectionOverrides?: (args: { defaultJobsCollection: CollectionConfig }) => CollectionConfig
  /**
   * Adjust the job processing order using a Payload sort string. This can be set globally or per queue.
   *
   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.
   *
   * @default all jobs for all queues will be executed in FIFO order.
   */
  processingOrder?:
    | ((args: RunJobsArgs) => Promise<Sort> | Sort)
    | {
        default?: Sort
        queues: {
          [queue: string]: Sort
        }
      }
    | Sort
  /**
   * By default, the job system uses direct database calls for optimal performance.
   * If you added custom hooks to your jobs collection, you can set this to true to
   * use the standard Payload API for all job operations. This is discouraged, as it will
   * drastically affect performance.
   *
   * @default false
   */
  runHooks?: boolean
  /**
   * A function that will be executed before Payload picks up jobs which are configured by the `jobs.autorun` function.
   * If this function returns true, jobs will be queried and picked up. If it returns false, jobs will not be run.
   * @param payload
   * @returns boolean
   */
  shouldAutoRun?: (payload: Payload) => boolean | Promise<boolean>
  /**
   * Define all possible tasks here
   */
  tasks: TaskConfig<any>[]
  /**
   * Define all the workflows here. Workflows orchestrate the flow of multiple tasks.
   */
  workflows?: WorkflowConfig<any>[]
}
</file>

<file path="packages/payload/src/queues/config/types/taskTypes.ts">
import type { Field, PayloadRequest, StringKeyOf, TypedJobs } from '../../../index.js'
import type { BaseJob, RunningJob, RunningJobSimple, SingleTaskStatus } from './workflowTypes.js'

export type TaskInputOutput = {
  input: object
  output: object
}
export type TaskHandlerResult<
  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,
> =
  | {
      errorMessage?: string
      state: 'failed'
    }
  | {
      output: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks']
        ? TypedJobs['tasks'][TTaskSlugOrInputOutput]['output']
        : TTaskSlugOrInputOutput extends TaskInputOutput // Check if it's actually TaskInputOutput type
          ? TTaskSlugOrInputOutput['output']
          : never
      state?: 'succeeded'
    }

export type TaskHandlerArgs<
  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,
  TWorkflowSlug extends keyof TypedJobs['workflows'] = string,
> = {
  /**
   * Use this function to run a sub-task from within another task.
   */
  inlineTask: RunInlineTaskFunction
  input: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks']
    ? TypedJobs['tasks'][TTaskSlugOrInputOutput]['input']
    : TTaskSlugOrInputOutput extends TaskInputOutput // Check if it's actually TaskInputOutput type
      ? TTaskSlugOrInputOutput['input']
      : never
  job: RunningJob<TWorkflowSlug>
  req: PayloadRequest
  tasks: RunTaskFunctions
}

/**
 * Inline tasks in JSON workflows have no input, as they can just get the input from job.taskStatus
 */
export type TaskHandlerArgsNoInput<TWorkflowInput extends object> = {
  job: RunningJobSimple<TWorkflowInput>
  req: PayloadRequest
}

export type TaskHandler<
  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,
  TWorkflowSlug extends keyof TypedJobs['workflows'] = string,
> = (
  args: TaskHandlerArgs<TTaskSlugOrInputOutput, TWorkflowSlug>,
) => Promise<TaskHandlerResult<TTaskSlugOrInputOutput>> | TaskHandlerResult<TTaskSlugOrInputOutput>

export type TaskType = StringKeyOf<TypedJobs['tasks']>

// Extracts the type of `input` corresponding to each task
export type TaskInput<T extends keyof TypedJobs['tasks']> = TypedJobs['tasks'][T]['input']

export type TaskOutput<T extends keyof TypedJobs['tasks']> = TypedJobs['tasks'][T]['output']

export type TaskHandlerResults = {
  [TTaskSlug in keyof TypedJobs['tasks']]: {
    [id: string]: TaskHandlerResult<TTaskSlug>
  }
}

// Helper type to create correct argument type for the function corresponding to each task.
export type RunTaskFunctionArgs<TTaskSlug extends keyof TypedJobs['tasks']> = {
  input?: TaskInput<TTaskSlug>
  /**
   * Specify the number of times that this task should be retried if it fails for any reason.
   * If this is undefined, the task will either inherit the retries from the workflow or have no retries.
   * If this is 0, the task will not be retried.
   *
   * @default By default, tasks are not retried and `retries` is `undefined`.
   */
  retries?: number | RetryConfig | undefined
}

export type RunTaskFunction<TTaskSlug extends keyof TypedJobs['tasks']> = (
  taskID: string,
  taskArgs?: RunTaskFunctionArgs<TTaskSlug>,
) => Promise<TaskOutput<TTaskSlug>>

export type RunTaskFunctions = {
  [TTaskSlug in keyof TypedJobs['tasks']]: RunTaskFunction<TTaskSlug>
}

type MaybePromise<T> = Promise<T> | T

export type RunInlineTaskFunction = <TTaskInput extends object, TTaskOutput extends object>(
  taskID: string,
  taskArgs: {
    input?: TTaskInput
    /**
     * Specify the number of times that this task should be retried if it fails for any reason.
     * If this is undefined, the task will either inherit the retries from the workflow or have no retries.
     * If this is 0, the task will not be retried.
     *
     * @default By default, tasks are not retried and `retries` is `undefined`.
     */
    retries?: number | RetryConfig | undefined
    // This is the same as TaskHandler, but typed out explicitly in order to improve type inference
    task: (args: {
      inlineTask: RunInlineTaskFunction
      input: TTaskInput
      job: RunningJob<any>
      req: PayloadRequest
      tasks: RunTaskFunctions
    }) => MaybePromise<
      | {
          errorMessage?: string
          state: 'failed'
        }
      | {
          output: TTaskOutput
          state?: 'succeeded'
        }
    >
  },
) => Promise<TTaskOutput>

export type ShouldRestoreFn = (args: {
  /**
   * Input data passed to the task
   */
  input: object
  job: BaseJob
  req: PayloadRequest
  taskStatus: SingleTaskStatus<string>
}) => boolean | Promise<boolean>

export type RetryConfig = {
  /**
   * This controls how many times the task should be retried if it fails.
   *
   * @default undefined - attempts are either inherited from the workflow retry config or set to 0.
   */
  attempts?: number
  /**
   * The backoff strategy to use when retrying the task. This determines how long to wait before retrying the task.
   *
   * If this is set on a single task, the longest backoff time of a task will determine the time until the entire workflow is retried.
   */
  backoff?: {
    /**
     * Base delay between running jobs in ms
     */
    delay?: number
    /**
     * @default fixed
     *
     * The backoff strategy to use when retrying the task. This determines how long to wait before retrying the task.
     * If fixed (default) is used, the delay will be the same between each retry.
     *
     * If exponential is used, the delay will increase exponentially with each retry.
     *
     * @example
     * delay = 1000
     * attempts = 3
     * type = 'fixed'
     *
     * The task will be retried 3 times with a delay of 1000ms between each retry.
     *
     * @example
     * delay = 1000
     * attempts = 3
     * type = 'exponential'
     *
     * The task will be retried 3 times with a delay of 1000ms, 2000ms, and 4000ms between each retry.
     */
    type: 'exponential' | 'fixed'
  }
  /**
   * This controls whether the task output should be restored if the task previously succeeded and the workflow is being retried.
   *
   * If this is set to false, the task will be re-run even if it previously succeeded, ignoring the maximum number of retries.
   *
   * If this is set to true, the task will only be re-run if it previously failed.
   *
   * If this is a function, the return value of the function will determine whether the task should be re-run. This can be used for more complex restore logic,
   * e.g you may want to re-run a task up until a certain point and then restore it, or only re-run a task if the input has changed.
   *
   * @default true - the task output will be restored if the task previously succeeded.
   */
  shouldRestore?: boolean | ShouldRestoreFn
}

export type TaskConfig<
  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput = TaskType,
> = {
  /**
   * The function that should be responsible for running the job.
   * You can either pass a string-based path to the job function file, or the job function itself.
   *
   * If you are using large dependencies within your job, you might prefer to pass the string path
   * because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature
   * that may require a sophisticated build pipeline in order to work.
   */
  handler: string | TaskHandler<TTaskSlugOrInputOutput>
  /**
   * Define the input field schema - payload will generate a type for this schema.
   */
  inputSchema?: Field[]
  /**
   * You can use interfaceName to change the name of the interface that is generated for this task. By default, this is "Task" + the capitalized task slug.
   */
  interfaceName?: string
  /**
   * Define a human-friendly label for this task.
   */
  label?: string
  /**
   * Function to be executed if the task fails.
   */
  onFail?: () => Promise<void> | void
  /**
   * Function to be executed if the task succeeds.
   */
  onSuccess?: () => Promise<void> | void
  /**
   * Define the output field schema - payload will generate a type for this schema.
   */
  outputSchema?: Field[]
  /**
   * Specify the number of times that this step should be retried if it fails.
   * If this is undefined, the task will either inherit the retries from the workflow or have no retries.
   * If this is 0, the task will not be retried.
   *
   * @default By default, tasks are not retried and `retries` is `undefined`.
   */
  retries?: number | RetryConfig | undefined
  /**
   * Define a slug-based name for this job. This slug needs to be unique among both tasks and workflows.
   */
  slug: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] ? TTaskSlugOrInputOutput : string
}
</file>

<file path="packages/payload/src/queues/config/types/workflowJSONTypes.ts">
import type { RunningJob, TaskHandlerResult, TypedJobs } from '../../../index.js'
import type { RetryConfig, TaskHandlerArgsNoInput } from './taskTypes.js'

export type WorkflowStep<
  TTaskSlug extends keyof TypedJobs['tasks'],
  TWorkflowSlug extends keyof TypedJobs['workflows'],
> = {
  /**
   * If this step is completed, the workflow will be marked as completed
   */
  completesJob?: boolean
  condition?: (args: { job: RunningJob<TWorkflowSlug> }) => boolean
  /**
   * Each task needs to have a unique ID to track its status
   */
  id: string
  /**
   * Specify the number of times that this workflow should be retried if it fails for any reason.
   *
   * @default By default, workflows are not retried and `retries` is `0`.
   */
  retries?: number | RetryConfig
} & (
  | {
      inlineTask?: (
        args: TaskHandlerArgsNoInput<TypedJobs['workflows'][TWorkflowSlug]['input']>,
      ) => Promise<TaskHandlerResult<TTaskSlug>> | TaskHandlerResult<TTaskSlug>
    }
  | {
      input: (args: { job: RunningJob<TWorkflowSlug> }) => TypedJobs['tasks'][TTaskSlug]['input']
      task: TTaskSlug
    }
)

type AllWorkflowSteps<TWorkflowSlug extends keyof TypedJobs['workflows']> = {
  [TTaskSlug in keyof TypedJobs['tasks']]: WorkflowStep<TTaskSlug, TWorkflowSlug>
}[keyof TypedJobs['tasks']]

export type WorkflowJSON<TWorkflowSlug extends keyof TypedJobs['workflows']> = Array<
  AllWorkflowSteps<TWorkflowSlug>
>
</file>

<file path="packages/payload/src/queues/config/types/workflowTypes.ts">
import type { Field } from '../../../fields/config/types.js'
import type { PayloadRequest, StringKeyOf, TypedCollection, TypedJobs } from '../../../index.js'
import type { TaskParent } from '../../operations/runJobs/runJob/getRunTaskFunction.js'
import type {
  RetryConfig,
  RunInlineTaskFunction,
  RunTaskFunctions,
  TaskInput,
  TaskOutput,
  TaskType,
} from './taskTypes.js'
import type { WorkflowJSON } from './workflowJSONTypes.js'

export type JobLog = {
  completedAt: string
  error?: unknown
  executedAt: string
  /**
   * ID added by the array field when the log is saved in the database
   */
  id: string
  input?: Record<string, any>
  output?: Record<string, any>
  /**
   * Sub-tasks (tasks that are run within a task) will have a parent task ID
   */
  parent?: TaskParent
  state: 'failed' | 'succeeded'
  taskID: string
  taskSlug: string
}

export type BaseJob = {
  completedAt?: string
  error?: unknown
  hasError?: boolean
  id: number | string
  input?: any
  log: JobLog[]
  processing?: boolean
  queue: string
  taskSlug?: string
  taskStatus?: JobTaskStatus
  totalTried: number
  waitUntil?: string
  workflowSlug?: string
}

export type WorkflowTypes = StringKeyOf<TypedJobs['workflows']>

// TODO: Type job.taskStatus once available - for JSON-defined workflows
export type RunningJob<TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] | object> = {
  input: TWorkflowSlugOrInput extends keyof TypedJobs['workflows']
    ? TypedJobs['workflows'][TWorkflowSlugOrInput]['input']
    : TWorkflowSlugOrInput
  taskStatus: JobTaskStatus
} & Omit<TypedCollection['payload-jobs'], 'input' | 'taskStatus'>

export type RunningJobSimple<TWorkflowInput extends object> = {
  input: TWorkflowInput
} & TypedCollection['payload-jobs']

// Simplified version of RunningJob that doesn't break TypeScript (TypeScript seems to stop evaluating RunningJob when it's too complex)
export type RunningJobFromTask<TTaskSlug extends keyof TypedJobs['tasks']> = {
  input: TypedJobs['tasks'][TTaskSlug]['input']
} & TypedCollection['payload-jobs']

export type WorkflowHandler<TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] | object> =
  (args: {
    inlineTask: RunInlineTaskFunction
    job: RunningJob<TWorkflowSlugOrInput>
    req: PayloadRequest
    tasks: RunTaskFunctions
  }) => Promise<void>

export type SingleTaskStatus<T extends keyof TypedJobs['tasks']> = {
  complete: boolean
  input: TaskInput<T>
  output: TaskOutput<T>
  taskSlug: TaskType
  totalTried: number
}

/**
 * Task IDs mapped to their status
 */
export type JobTaskStatus = {
  // Wrap in taskSlug to improve typing
  [taskSlug in TaskType]: {
    [taskID: string]: SingleTaskStatus<taskSlug>
  }
}

export type WorkflowConfig<TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] | object> = {
  /**
   * You can either pass a string-based path to the workflow function file, or the workflow function itself.
   *
   * If you are using large dependencies within your workflow control flow, you might prefer to pass the string path
   * because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature
   * that may require a sophisticated build pipeline in order to work.
   */
  handler:
    | string
    | WorkflowHandler<TWorkflowSlugOrInput>
    | WorkflowJSON<TWorkflowSlugOrInput extends object ? string : TWorkflowSlugOrInput>
  /**
   * Define the input field schema  - payload will generate a type for this schema.
   */
  inputSchema?: Field[]
  /**
   * You can use interfaceName to change the name of the interface that is generated for this workflow. By default, this is "Workflow" + the capitalized workflow slug.
   */
  interfaceName?: string
  /**
   * Define a human-friendly label for this workflow.
   */
  label?: string
  /**
   * Optionally, define the default queue name that this workflow should be tied to.
   * Defaults to "default".
   * Can be overridden when queuing jobs via Local API.
   */
  queue?: string
  /**
   * You can define `retries` on the workflow level, which will enforce that the workflow can only fail up to that number of retries. If a task does not have retries specified, it will inherit the retry count as specified on the workflow.
   *
   * You can specify `0` as `workflow` retries, which will disregard all `task` retry specifications and fail the entire workflow on any task failure.
   * You can leave `workflow` retries as undefined, in which case, the workflow will respect what each task dictates as their own retry count.
   *
   * @default undefined. By default, workflows retries are defined by their tasks
   */
  retries?: number | RetryConfig | undefined
  /**
   * Define a slug-based name for this job.
   */
  slug: TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] ? TWorkflowSlugOrInput : string
}

type AllWorkflowConfigs = {
  [TWorkflowSlug in keyof TypedJobs['workflows']]: WorkflowConfig<TWorkflowSlug>
}[keyof TypedJobs['workflows']]
</file>

<file path="packages/payload/src/queues/config/generateJobsJSONSchemas.ts">
// @ts-strict-ignore
import type { I18n } from '@convexcms/translations'
import type { JSONSchema4 } from 'json-schema'

import type { SanitizedConfig } from '../../config/types.js'
import type { JobsConfig } from './types/index.js'

import { fieldsToJSONSchema } from '../../utilities/configToJSONSchema.js'
import { flattenAllFields } from '../../utilities/flattenAllFields.js'
export function generateJobsJSONSchemas(
  config: SanitizedConfig,
  jobsConfig: JobsConfig,
  interfaceNameDefinitions: Map<string, JSONSchema4>,
  /**
   * Used for relationship fields, to determine whether to use a string or number type for the ID.
   * While there is a default ID field type set by the db adapter, they can differ on a collection-level
   * if they have custom ID fields.
   */
  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },
  i18n?: I18n,
): {
  definitions?: Map<string, JSONSchema4>
  properties?: { tasks: JSONSchema4 }
} {
  const properties: { tasks: JSONSchema4; workflows: JSONSchema4 } = {
    tasks: {},
    workflows: {},
  }
  const definitions: Map<string, JSONSchema4> = new Map()

  if (jobsConfig?.tasks?.length) {
    for (const task of jobsConfig.tasks) {
      const fullTaskJsonSchema: JSONSchema4 = {
        type: 'object',
        additionalProperties: false,
        properties: {
          input: {},
          output: {},
        },
        required: [],
      }
      if (task?.inputSchema?.length) {
        const inputJsonSchema = fieldsToJSONSchema(
          collectionIDFieldTypes,
          flattenAllFields({ fields: task.inputSchema }),
          interfaceNameDefinitions,
          config,
          i18n,
        )

        const fullInputJsonSchema: JSONSchema4 = {
          type: 'object',
          additionalProperties: false,
          properties: inputJsonSchema.properties,
          required: inputJsonSchema.required,
        }

        fullTaskJsonSchema.properties.input = fullInputJsonSchema
        ;(fullTaskJsonSchema.required as string[]).push('input')
      }
      if (task?.outputSchema?.length) {
        const outputJsonSchema = fieldsToJSONSchema(
          collectionIDFieldTypes,
          flattenAllFields({ fields: task.outputSchema }),
          interfaceNameDefinitions,
          config,
          i18n,
        )

        const fullOutputJsonSchema: JSONSchema4 = {
          type: 'object',
          additionalProperties: false,
          properties: outputJsonSchema.properties,
          required: outputJsonSchema.required,
        }

        fullTaskJsonSchema.properties.output = fullOutputJsonSchema
        ;(fullTaskJsonSchema.required as string[]).push('output')
      }

      const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)

      definitions.set(task.interfaceName ?? `Task${normalizedTaskSlug}`, fullTaskJsonSchema)
    }
    // Now add properties.tasks definition that references the types in definitions keyed by task slug:
    properties.tasks = {
      type: 'object',
      additionalProperties: false,
      properties: {
        ...Object.fromEntries(
          jobsConfig.tasks.map((task) => {
            const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)

            const toReturn: JSONSchema4 = {
              $ref: task.interfaceName
                ? `#/definitions/${task.interfaceName}`
                : `#/definitions/Task${normalizedTaskSlug}`,
            }

            return [task.slug, toReturn]
          }),
        ),
        inline: {
          type: 'object',
          additionalProperties: false,
          properties: {
            input: {},
            output: {},
          },
          required: ['input', 'output'],
        },
      },
      required: [...jobsConfig.tasks.map((task) => task.slug), 'inline'],
    }
  }

  if (jobsConfig?.workflows?.length) {
    for (const workflow of jobsConfig.workflows) {
      const fullWorkflowJsonSchema: JSONSchema4 = {
        type: 'object',
        additionalProperties: false,
        properties: {
          input: {},
        },
        required: [],
      }

      if (workflow?.inputSchema?.length) {
        const inputJsonSchema = fieldsToJSONSchema(
          collectionIDFieldTypes,
          flattenAllFields({ fields: workflow.inputSchema }),
          interfaceNameDefinitions,
          config,
          i18n,
        )

        const fullInputJsonSchema: JSONSchema4 = {
          type: 'object',
          additionalProperties: false,
          properties: inputJsonSchema.properties,
          required: inputJsonSchema.required,
        }

        fullWorkflowJsonSchema.properties.input = fullInputJsonSchema
        ;(fullWorkflowJsonSchema.required as string[]).push('input')
      }
      const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)

      definitions.set(
        workflow.interfaceName ?? `Workflow${normalizedWorkflowSlug}`,
        fullWorkflowJsonSchema,
      )

      properties.workflows = {
        type: 'object',
        additionalProperties: false,
        properties: Object.fromEntries(
          jobsConfig.workflows.map((workflow) => {
            const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)

            const toReturn: JSONSchema4 = {
              $ref: workflow.interfaceName
                ? `#/definitions/${workflow.interfaceName}`
                : `#/definitions/Workflow${normalizedWorkflowSlug}`,
            }

            return [workflow.slug, toReturn]
          }),
        ),
        required: jobsConfig.workflows.map((workflow) => workflow.slug),
      }
    }
  }

  return {
    definitions,
    properties,
  }
}
</file>

<file path="packages/payload/src/queues/config/index.ts">
import type { CollectionConfig } from '../../collections/config/types.js'
import type { Config, SanitizedConfig } from '../../config/types.js'
import type { Field } from '../../fields/config/types.js'
import type { BaseJob } from './types/workflowTypes.js'

import { runJobsEndpoint } from '../restEndpointRun.js'
import { getJobTaskStatus } from '../utilities/getJobTaskStatus.js'

export const jobsCollectionSlug = 'payload-jobs'

export const getDefaultJobsCollection: (config: Config) => CollectionConfig | null = (config) => {
  const workflowSlugs: Set<string> = new Set()
  const taskSlugs: Set<string> = new Set(['inline'])

  if (config.jobs?.workflows?.length) {
    config.jobs?.workflows.forEach((workflow) => {
      workflowSlugs.add(workflow.slug)
    })
  }

  if (config.jobs?.tasks?.length) {
    config.jobs.tasks.forEach((task) => {
      if (workflowSlugs.has(task.slug)) {
        throw new Error(
          `Task slug "${task.slug}" is already used by a workflow. No tasks are allowed to have the same slug as a workflow.`,
        )
      }
      taskSlugs.add(task.slug)
    })
  }

  const logFields: Field[] = [
    {
      name: 'executedAt',
      type: 'date',
      required: true,
    },
    {
      name: 'completedAt',
      type: 'date',
      required: true,
    },
    {
      name: 'taskSlug',
      type: 'select',
      options: [...taskSlugs],
      required: true,
    },
    {
      name: 'taskID',
      type: 'text',
      required: true,
    },
    {
      name: 'input',
      type: 'json',
    },
    {
      name: 'output',
      type: 'json',
    },
    {
      name: 'state',
      type: 'radio',
      options: ['failed', 'succeeded'],
      required: true,
    },
    {
      name: 'error',
      type: 'json',
      admin: {
        condition: (_, data) => data.state === 'failed',
      },
      required: true,
    },
  ]

  if (config?.jobs?.addParentToTaskLog) {
    logFields.push({
      name: 'parent',
      type: 'group',
      fields: [
        {
          name: 'taskSlug',
          type: 'select',
          options: [...taskSlugs],
        },
        {
          name: 'taskID',
          type: 'text',
        },
      ],
    })
  }

  const jobsCollection: CollectionConfig = {
    slug: jobsCollectionSlug,
    admin: {
      group: 'System',
      hidden: true,
    },
    endpoints: [runJobsEndpoint],
    fields: [
      {
        name: 'input',
        type: 'json',
        admin: {
          description: 'Input data provided to the job',
        },
      },
      {
        name: 'taskStatus',
        type: 'json',
        virtual: true,
      },
      {
        type: 'tabs',
        tabs: [
          {
            fields: [
              {
                name: 'completedAt',
                type: 'date',
                index: true,
              },
              {
                name: 'totalTried',
                type: 'number',
                defaultValue: 0,
                index: true,
              },
              {
                name: 'hasError',
                type: 'checkbox',
                admin: {
                  description: 'If hasError is true this job will not be retried',
                },
                defaultValue: false,
                index: true,
              },
              {
                name: 'error',
                type: 'json',
                admin: {
                  condition: (data) => data.hasError,
                  description: 'If hasError is true, this is the error that caused it',
                },
              },
              {
                name: 'log',
                type: 'array',
                admin: {
                  description: 'Task execution log',
                },
                fields: logFields,
              },
            ],
            label: 'Status',
          },
        ],
      },
      // only include the workflowSlugs field if workflows exist
      ...((workflowSlugs.size > 0
        ? [
            {
              name: 'workflowSlug',
              type: 'select',
              admin: {
                position: 'sidebar',
              },
              index: true,
              options: [...workflowSlugs],
            },
          ]
        : []) as Field[]),
      {
        name: 'taskSlug',
        type: 'select',
        admin: {
          position: 'sidebar',
        },
        index: true,
        options: [...taskSlugs],
        required: false,
      },
      {
        name: 'queue',
        type: 'text',
        admin: {
          position: 'sidebar',
        },
        defaultValue: 'default',
        index: true,
      },
      {
        name: 'waitUntil',
        type: 'date',
        index: true,
      },
      {
        name: 'processing',
        type: 'checkbox',
        admin: {
          position: 'sidebar',
        },
        defaultValue: false,
        index: true,
      },
    ],
    hooks: {
      afterRead: [
        ({ doc, req }) => {
          // This hook is used to add the virtual `tasks` field to the document, that is computed from the `log` field

          return jobAfterRead({ config: req.payload.config, doc })
        },
      ],
      /**
       * If another update comes in after a job as already been cancelled, we need to make sure that update doesn't
       * change the state of the job.
       */
      beforeChange: [
        ({ data, originalDoc }) => {
          if (originalDoc?.error?.cancelled) {
            data.processing = false
            data.hasError = true
            delete data.completedAt
            delete data.waitUntil
          }
          return data
        },
      ],
    },
    lockDocuments: false,
  }

  return jobsCollection
}

export function jobAfterRead({ config, doc }: { config: SanitizedConfig; doc: BaseJob }): BaseJob {
  doc.taskStatus = getJobTaskStatus({
    jobLog: doc.log || [],
    tasksConfig: config.jobs.tasks,
  })
  return doc
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/calculateBackoffWaitUntil.ts">
import type { RetryConfig } from '../../../config/types/taskTypes.js'

export function calculateBackoffWaitUntil({
  retriesConfig,
  totalTried,
}: {
  retriesConfig: number | RetryConfig
  totalTried: number
}): Date {
  let waitUntil: Date = new Date()
  if (typeof retriesConfig === 'object') {
    if (retriesConfig.backoff) {
      if (retriesConfig.backoff.type === 'fixed') {
        waitUntil = retriesConfig.backoff.delay
          ? new Date(new Date().getTime() + retriesConfig.backoff.delay)
          : new Date()
      } else if (retriesConfig.backoff.type === 'exponential') {
        // 2 ^ (attempts - 1) * delay (current attempt is not included in totalTried, thus no need for -1)
        const delay = retriesConfig.backoff.delay ? retriesConfig.backoff.delay : 0
        waitUntil = new Date(new Date().getTime() + Math.pow(2, totalTried) * delay)
      }
    }
  }

  /*
  const differenceInMSBetweenNowAndWaitUntil = waitUntil.getTime() - new Date().getTime()

  const differenceInSBetweenNowAndWaitUntil = differenceInMSBetweenNowAndWaitUntil / 1000
  console.log('Calculated backoff', {
    differenceInMSBetweenNowAndWaitUntil,
    differenceInSBetweenNowAndWaitUntil,
    retriesConfig,
    totalTried,
  })*/
  return waitUntil
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/getRunTaskFunction.ts">
import ObjectIdImport from 'bson-objectid'

// @ts-strict-ignore
import type { PayloadRequest } from '../../../../types/index.js'
import type {
  RetryConfig,
  RunInlineTaskFunction,
  RunTaskFunction,
  RunTaskFunctions,
  TaskConfig,
  TaskHandler,
  TaskHandlerResult,
  TaskType,
} from '../../../config/types/taskTypes.js'
import type {
  BaseJob,
  RunningJob,
  SingleTaskStatus,
  WorkflowConfig,
  WorkflowTypes,
} from '../../../config/types/workflowTypes.js'
import type { UpdateJobFunction } from './getUpdateJobFunction.js'

import { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'
import { importHandlerPath } from './importHandlerPath.js'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

// Helper object type to force being passed by reference
export type RunTaskFunctionState = {
  reachedMaxRetries: boolean
}

async function getTaskHandlerFromConfig(taskConfig: TaskConfig<string>) {
  let handler: TaskHandler<TaskType>

  if (typeof taskConfig.handler === 'function') {
    handler = taskConfig.handler
  } else {
    handler = await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)
  }
  return handler
}

export async function handleTaskFailed({
  error,
  executedAt,
  input,
  job,
  maxRetries,
  output,
  parent,
  req,
  retriesConfig,
  state,
  taskConfig,
  taskHandlerResult,
  taskID,
  taskSlug,
  taskStatus,
  updateJob,
}: {
  error?: Error
  executedAt: Date
  input: object
  job: BaseJob
  maxRetries: number
  output: object
  parent?: TaskParent
  req: PayloadRequest
  retriesConfig: number | RetryConfig
  state: RunTaskFunctionState
  taskConfig?: TaskConfig<string>
  taskHandlerResult?: TaskHandlerResult<string>
  taskID: string
  taskSlug: string
  taskStatus: null | SingleTaskStatus<string>
  updateJob: UpdateJobFunction
}): Promise<never> {
  req.payload.logger.error({ err: error, job, msg: `Error running task ${taskID}`, taskSlug })

  if (taskConfig?.onFail) {
    await taskConfig.onFail()
  }

  if (!job.log) {
    job.log = []
  }
  const errorJSON = error
    ? {
        name: error.name,
        message: error.message,
        stack: error.stack,
      }
    : {
        message:
          taskHandlerResult.state === 'failed'
            ? (taskHandlerResult.errorMessage ?? taskHandlerResult.state)
            : 'failed',
      }

  job.log.push({
    id: new ObjectId().toHexString(),
    completedAt: new Date().toISOString(),
    error: errorJSON,
    executedAt: executedAt.toISOString(),
    input,
    output,
    parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,
    state: 'failed',
    taskID,
    taskSlug,
  })

  if (job.waitUntil) {
    // Check if waitUntil is in the past
    const waitUntil = new Date(job.waitUntil)
    if (waitUntil < new Date()) {
      // Outdated waitUntil, remove it
      delete job.waitUntil
    }
  }

  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {
    state.reachedMaxRetries = true

    await updateJob({
      error,
      hasError: true,
      log: job.log,
      processing: false,
      waitUntil: job.waitUntil,
    })

    throw new Error(
      `Task ${taskSlug} has failed more than the allowed retries in workflow ${job.workflowSlug}${error ? `. Error: ${String(error)}` : ''}`,
    )
  } else {
    // Job will retry. Let's determine when!
    const waitUntil: Date = calculateBackoffWaitUntil({
      retriesConfig,
      totalTried: taskStatus?.totalTried ?? 0,
    })

    // Update job's waitUntil only if this waitUntil is later than the current one
    if (!job.waitUntil || waitUntil > new Date(job.waitUntil)) {
      job.waitUntil = waitUntil.toISOString()
    }

    await updateJob({
      log: job.log,
      processing: false,
      waitUntil: job.waitUntil,
    })
    throw error ?? new Error('Task failed')
  }
}

export type TaskParent = {
  taskID: string
  taskSlug: string
}

export const getRunTaskFunction = <TIsInline extends boolean>(
  state: RunTaskFunctionState,
  job: BaseJob,
  workflowConfig: WorkflowConfig<string>,
  req: PayloadRequest,
  isInline: TIsInline,
  updateJob: UpdateJobFunction,
  parent?: TaskParent,
): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {
  const runTask: <TTaskSlug extends string>(
    taskSlug: TTaskSlug,
  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (
    taskSlug,
  ) =>
    (async (
      taskID: Parameters<RunInlineTaskFunction>[0],
      {
        input,
        retries,
        task,
      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],
    ) => {
      const executedAt = new Date()

      let inlineRunner: TaskHandler<TaskType> = null
      if (isInline) {
        inlineRunner = task
      }

      let taskConfig: TaskConfig<string>
      if (!isInline) {
        taskConfig = req.payload.config.jobs.tasks.find((t) => t.slug === taskSlug)

        if (!taskConfig) {
          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)
        }
      }

      const retriesConfigFromPropsNormalized =
        retries == undefined || retries == null
          ? {}
          : typeof retries === 'number'
            ? { attempts: retries }
            : retries
      const retriesConfigFromTaskConfigNormalized = taskConfig
        ? typeof taskConfig.retries === 'number'
          ? { attempts: taskConfig.retries }
          : taskConfig.retries
        : {}

      const finalRetriesConfig: RetryConfig = {
        ...retriesConfigFromTaskConfigNormalized,
        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence
      }

      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]
        ? job.taskStatus[taskSlug][taskID]
        : null

      // Handle restoration of task if it succeeded in a previous run
      if (taskStatus && taskStatus.complete === true) {
        let shouldRestore = true
        if (finalRetriesConfig?.shouldRestore === false) {
          shouldRestore = false
        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {
          shouldRestore = await finalRetriesConfig.shouldRestore({ input, job, req, taskStatus })
        }
        if (shouldRestore) {
          return taskStatus.output
        }
      }

      let runner: TaskHandler<TaskType>
      if (isInline) {
        runner = inlineRunner
      } else {
        if (!taskConfig) {
          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)
        }
        runner = await getTaskHandlerFromConfig(taskConfig)
      }

      if (!runner || typeof runner !== 'function') {
        const errorMessage = isInline
          ? `Can't find runner for inline task with ID ${taskID}`
          : `Can't find runner while importing with the path ${typeof workflowConfig.handler === 'string' ? workflowConfig.handler : 'unknown - no string path'} in job type ${job.workflowSlug} for task ${taskSlug}.`
        req.payload.logger.error(errorMessage)

        await updateJob({
          error: {
            error: errorMessage,
          },
          hasError: true,
          log: [
            ...job.log,
            {
              id: new ObjectId().toHexString(),
              completedAt: new Date().toISOString(),
              error: errorMessage,
              executedAt: executedAt.toISOString(),
              parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,
              state: 'failed',
              taskID,
              taskSlug,
            },
          ],
          processing: false,
        })

        throw new Error(errorMessage)
      }

      let maxRetries: number | undefined = finalRetriesConfig?.attempts

      if (maxRetries === undefined || maxRetries === null) {
        // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured
        if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {
          maxRetries =
            typeof workflowConfig.retries === 'object'
              ? workflowConfig.retries.attempts
              : workflowConfig.retries
        } else {
          maxRetries = 0
        }
      }

      let taskHandlerResult: TaskHandlerResult<string>
      let output: object = {}

      try {
        taskHandlerResult = await runner({
          inlineTask: getRunTaskFunction(state, job, workflowConfig, req, true, updateJob, {
            taskID,
            taskSlug,
          }),
          input,
          job: job as unknown as RunningJob<WorkflowTypes>, // TODO: Type this better
          req,
          tasks: getRunTaskFunction(state, job, workflowConfig, req, false, updateJob, {
            taskID,
            taskSlug,
          }),
        })
      } catch (err) {
        await handleTaskFailed({
          error: err,
          executedAt,
          input,
          job,
          maxRetries,
          output,
          parent,
          req,
          retriesConfig: finalRetriesConfig,
          state,
          taskConfig,
          taskID,
          taskSlug,
          taskStatus,
          updateJob,
        })
        throw new Error('Task failed')
      }

      if (taskHandlerResult.state === 'failed') {
        await handleTaskFailed({
          executedAt,
          input,
          job,
          maxRetries,
          output,
          parent,
          req,
          retriesConfig: finalRetriesConfig,
          state,
          taskConfig,
          taskHandlerResult,
          taskID,
          taskSlug,
          taskStatus,
          updateJob,
        })
        throw new Error('Task failed')
      } else {
        output = taskHandlerResult.output
      }

      if (taskConfig?.onSuccess) {
        await taskConfig.onSuccess()
      }

      if (!job.log) {
        job.log = []
      }
      job.log.push({
        id: new ObjectId().toHexString(),
        completedAt: new Date().toISOString(),
        executedAt: executedAt.toISOString(),
        input,
        output,
        parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,
        state: 'succeeded',
        taskID,
        taskSlug,
      })

      await updateJob({
        log: job.log,
      })

      return output
    }) as any

  if (isInline) {
    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions
  } else {
    const tasks: RunTaskFunctions = {}
    for (const task of req?.payload?.config?.jobs?.tasks ?? []) {
      tasks[task.slug] = runTask(task.slug)
    }
    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions
  }
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/getUpdateJobFunction.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../../../../types/index.js'
import type { BaseJob } from '../../../config/types/workflowTypes.js'

import { updateJob } from '../../../utilities/updateJob.js'

export type UpdateJobFunction = (jobData: Partial<BaseJob>) => Promise<BaseJob>

export function getUpdateJobFunction(job: BaseJob, req: PayloadRequest): UpdateJobFunction {
  return async (jobData) => {
    const updatedJob = await updateJob({
      id: job.id,
      data: jobData,
      depth: req.payload.config.jobs.depth,
      disableTransaction: true,
      req,
    })

    // Update job object like this to modify the original object - that way, incoming changes (e.g. taskStatus field that will be re-generated through the hook) will be reflected in the calling function
    for (const key in updatedJob) {
      if (key === 'log') {
        if (!job.log) {
          job.log = []
        }
        // Add all new log entries to the original job.log object. Do not delete any existing log entries.
        // Do not update existing log entries, as existing log entries should be immutable.
        for (const logEntry of updatedJob.log) {
          if (!job.log.some((entry) => entry.id === logEntry.id)) {
            job.log.push(logEntry)
          }
        }
      } else {
        job[key] = updatedJob[key]
      }
    }

    if ((updatedJob.error as Record<string, unknown>)?.cancelled) {
      const cancelledError = new Error('Job cancelled') as { cancelled: boolean } & Error
      cancelledError.cancelled = true
      throw cancelledError
    }

    return updatedJob
  }
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/handleWorkflowError.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../../../../types/index.js'
import type { BaseJob, WorkflowConfig, WorkflowTypes } from '../../../config/types/workflowTypes.js'
import type { RunTaskFunctionState } from './getRunTaskFunction.js'

import { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'

/**
 * This is called if a workflow catches an error. It determines if it's a final error
 * or not and handles logging.
 */
export function handleWorkflowError({
  error,
  job,
  req,
  state,
  workflowConfig,
}: {
  error: Error
  job: BaseJob
  req: PayloadRequest
  state: RunTaskFunctionState
  workflowConfig: WorkflowConfig<WorkflowTypes>
}): {
  hasFinalError: boolean
} {
  const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`

  let hasFinalError = state.reachedMaxRetries || !!('cancelled' in error && error.cancelled) // If any TASK reached max retries, the job has an error
  const maxWorkflowRetries: number =
    (typeof workflowConfig.retries === 'object'
      ? workflowConfig.retries.attempts
      : workflowConfig.retries) ?? undefined

  if (
    maxWorkflowRetries !== undefined &&
    maxWorkflowRetries !== null &&
    job.totalTried >= maxWorkflowRetries
  ) {
    hasFinalError = true
    state.reachedMaxRetries = true
  }

  // Now let's handle workflow retries
  if (!hasFinalError) {
    if (job.waitUntil) {
      // Check if waitUntil is in the past
      const waitUntil = new Date(job.waitUntil)
      if (waitUntil < new Date()) {
        // Outdated waitUntil, remove it
        delete job.waitUntil
      }
    }

    // Job will retry. Let's determine when!
    const waitUntil: Date = calculateBackoffWaitUntil({
      retriesConfig: workflowConfig.retries,
      totalTried: job.totalTried ?? 0,
    })

    // Update job's waitUntil only if this waitUntil is later than the current one
    if (!job.waitUntil || waitUntil > new Date(job.waitUntil)) {
      job.waitUntil = waitUntil.toISOString()
    }
  }

  req.payload.logger.error({
    err: error,
    msg: `Error running job ${jobLabel} id: ${job.id} attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,
  })

  return {
    hasFinalError,
  }
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/importHandlerPath.ts">
// @ts-strict-ignore
import { pathToFileURL } from 'url'

export async function importHandlerPath<T>(path: string): Promise<T> {
  let runner: T
  const [runnerPath, runnerImportName] = path.split('#')

  let runnerModule
  try {
    // We need to check for `require` for compatibility with outdated frameworks that do not
    // properly support ESM, like Jest. This is not done to support projects without "type": "module" set
    runnerModule =
      typeof require === 'function'
        ? await eval(`require('${runnerPath.replaceAll('\\', '/')}')`)
        : await eval(`import('${pathToFileURL(runnerPath).href}')`)
  } catch (e) {
    throw new Error(
      `Error importing job queue handler module for path ${path}. This is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js. Import Error: \n${e.message}`,
    )
  }

  // If the path has indicated an #exportName, try to get it
  if (runnerImportName && runnerModule[runnerImportName]) {
    runner = runnerModule[runnerImportName]
  }

  // If there is a default export, use it
  if (!runner && runnerModule.default) {
    runner = runnerModule.default
  }

  // Finally, use whatever was imported
  if (!runner) {
    runner = runnerModule
  }

  return runner
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJob/index.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../../../../types/index.js'
import type {
  BaseJob,
  RunningJob,
  WorkflowConfig,
  WorkflowHandler,
  WorkflowTypes,
} from '../../../config/types/workflowTypes.js'
import type { RunTaskFunctionState } from './getRunTaskFunction.js'
import type { UpdateJobFunction } from './getUpdateJobFunction.js'

import { getRunTaskFunction } from './getRunTaskFunction.js'
import { handleWorkflowError } from './handleWorkflowError.js'

type Args = {
  job: BaseJob
  req: PayloadRequest
  updateJob: UpdateJobFunction
  workflowConfig: WorkflowConfig<WorkflowTypes>
  workflowHandler: WorkflowHandler<WorkflowTypes>
}

export type JobRunStatus = 'error' | 'error-reached-max-retries' | 'success'

export type RunJobResult = {
  status: JobRunStatus
}

export const runJob = async ({
  job,
  req,
  updateJob,
  workflowConfig,
  workflowHandler,
}: Args): Promise<RunJobResult> => {
  // Object so that we can pass contents by reference, not value.
  // We want any mutations to be reflected in here.
  const state: RunTaskFunctionState = {
    reachedMaxRetries: false,
  }

  // Run the job
  try {
    await workflowHandler({
      inlineTask: getRunTaskFunction(state, job, workflowConfig, req, true, updateJob),
      job: job as unknown as RunningJob<WorkflowTypes>, //TODO: Type this better
      req,
      tasks: getRunTaskFunction(state, job, workflowConfig, req, false, updateJob),
    })
  } catch (err) {
    const { hasFinalError } = handleWorkflowError({
      error: err,
      job,
      req,
      state,
      workflowConfig,
    })

    const errorJSON = hasFinalError
      ? {
          name: err.name,
          cancelled: Boolean('cancelled' in err && err.cancelled),
          message: err.message,
          stack: err.stack,
        }
      : undefined
    // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)
    // we need to ensure the job is updated to reflect the error
    await updateJob({
      error: errorJSON,
      hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried
      log: job.log,
      processing: false,
      totalTried: (job.totalTried ?? 0) + 1,
    })

    return {
      status: hasFinalError ? 'error-reached-max-retries' : 'error',
    }
  }

  // Workflow has completed
  await updateJob({
    completedAt: new Date().toISOString(),
    log: job.log,
    processing: false,
    totalTried: (job.totalTried ?? 0) + 1,
  })

  return {
    status: 'success',
  }
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/runJSONJob/index.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../../../../types/index.js'
import type { WorkflowJSON, WorkflowStep } from '../../../config/types/workflowJSONTypes.js'
import type {
  BaseJob,
  RunningJob,
  WorkflowConfig,
  WorkflowTypes,
} from '../../../config/types/workflowTypes.js'
import type { UpdateJobFunction } from '../runJob/getUpdateJobFunction.js'
import type { JobRunStatus } from '../runJob/index.js'

import { getRunTaskFunction, type RunTaskFunctionState } from '../runJob/getRunTaskFunction.js'
import { handleWorkflowError } from '../runJob/handleWorkflowError.js'

type Args = {
  job: BaseJob
  req: PayloadRequest
  updateJob: UpdateJobFunction
  workflowConfig: WorkflowConfig<WorkflowTypes>
  workflowHandler: WorkflowJSON<WorkflowTypes>
}

export type RunJSONJobResult = {
  status: JobRunStatus
}

export const runJSONJob = async ({
  job,
  req,
  updateJob,
  workflowConfig,
  workflowHandler,
}: Args): Promise<RunJSONJobResult> => {
  // Object so that we can pass contents by reference, not value.
  // We want any mutations to be reflected in here.
  const state: RunTaskFunctionState = {
    reachedMaxRetries: false,
  }

  const stepsToRun: WorkflowStep<string, string>[] = []

  for (const step of workflowHandler) {
    if ('task' in step) {
      if (job?.taskStatus?.[step.task]?.[step.id]?.complete) {
        continue
      }
    } else {
      if (job?.taskStatus?.['inline']?.[step.id]?.complete) {
        continue
      }
    }
    if (step.condition && !step.condition({ job: job as RunningJob<any> })) {
      // TODO: Improve RunningJob type see todo below
      continue
    }
    stepsToRun.push(step)
  }

  const tasks = getRunTaskFunction(state, job, workflowConfig, req, false, updateJob)
  const inlineTask = getRunTaskFunction(state, job, workflowConfig, req, true, updateJob)

  // Run the job
  let hasFinalError = false
  let error: Error | undefined
  try {
    await Promise.all(
      stepsToRun.map(async (step) => {
        if ('task' in step) {
          await tasks[step.task](step.id, {
            input: step.input ? step.input({ job: job as RunningJob<any> }) : {}, // TODO: Type better. We should use RunningJob anywhere and make TypedCollection['payload-jobs'] be BaseJob if type not generated
            retries: step.retries,
          })
        } else {
          await inlineTask(step.id, {
            retries: step.retries,
            task: step.inlineTask as any, // TODO: Fix type
          })
        }
      }),
    )
  } catch (err) {
    const errorResult = handleWorkflowError({
      error: err,
      job,
      req,
      state,
      workflowConfig,
    })
    error = err
    hasFinalError = errorResult.hasFinalError
  }

  // Check if workflow has completed
  let workflowCompleted = false
  for (const [slug, map] of Object.entries(job.taskStatus)) {
    for (const [id, taskStatus] of Object.entries(map)) {
      if (taskStatus.complete) {
        const step = workflowHandler.find((step) => {
          if ('task' in step) {
            return step.task === slug && step.id === id
          } else {
            return step.id === id && slug === 'inline'
          }
        })
        if (step.completesJob) {
          workflowCompleted = true
          break
        }
      }
    }
  }

  if (workflowCompleted) {
    if (error) {
      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)
      // we need to ensure the job is updated to reflect the error
      await updateJob({
        completedAt: new Date().toISOString(),
        error: hasFinalError ? error : undefined,
        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried
        processing: false,
        totalTried: (job.totalTried ?? 0) + 1,
      })
    } else {
      await updateJob({
        completedAt: new Date().toISOString(),
        processing: false,
        totalTried: (job.totalTried ?? 0) + 1,
      })
    }

    return {
      status: 'success',
    }
  } else {
    if (error) {
      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)
      // we need to ensure the job is updated to reflect the error
      await updateJob({
        error: hasFinalError ? error : undefined,
        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried
        processing: false,
        totalTried: (job.totalTried ?? 0) + 1,
      })
      return {
        status: hasFinalError ? 'error-reached-max-retries' : 'error',
      }
    } else {
      // Retry the job - no need to bump processing or totalTried as this does not count as a retry. A condition of a different task might have just opened up!
      return await runJSONJob({
        job,
        req,
        updateJob,
        workflowConfig,
        workflowHandler,
      })
    }
  }
}
</file>

<file path="packages/payload/src/queues/operations/runJobs/index.ts">
// @ts-strict-ignore
import type { PayloadRequest, Sort, Where } from '../../../types/index.js'
import type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'
import type {
  BaseJob,
  WorkflowConfig,
  WorkflowHandler,
  WorkflowTypes,
} from '../../config/types/workflowTypes.js'
import type { RunJobResult } from './runJob/index.js'

import { Forbidden } from '../../../errors/Forbidden.js'
import isolateObjectProperty from '../../../utilities/isolateObjectProperty.js'
import { jobsCollectionSlug } from '../../config/index.js'
import { updateJob, updateJobs } from '../../utilities/updateJob.js'
import { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'
import { importHandlerPath } from './runJob/importHandlerPath.js'
import { runJob } from './runJob/index.js'
import { runJSONJob } from './runJSONJob/index.js'

export type RunJobsArgs = {
  /**
   * ID of the job to run
   */
  id?: number | string
  limit?: number
  overrideAccess?: boolean
  /**
   * Adjust the job processing order
   *
   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.
   *
   * @default all jobs for all queues will be executed in FIFO order.
   */
  processingOrder?: Sort
  queue?: string
  req: PayloadRequest
  /**
   * By default, jobs are run in parallel.
   * If you want to run them in sequence, set this to true.
   */
  sequential?: boolean
  where?: Where
}

export type RunJobsResult = {
  jobStatus?: Record<string, RunJobResult>
  /**
   * If this is false, there for sure are no jobs remaining, regardless of the limit
   */
  noJobsRemaining?: boolean
  /**
   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?
   */
  remainingJobsFromQueried: number
}

export const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {
  const {
    id,
    limit = 10,
    overrideAccess,
    processingOrder,
    queue,
    req,
    sequential,
    where: whereFromProps,
  } = args

  if (!overrideAccess) {
    const hasAccess = await req.payload.config.jobs.access.run({ req })
    if (!hasAccess) {
      throw new Forbidden(req.t)
    }
  }
  const where: Where = {
    and: [
      {
        completedAt: {
          exists: false,
        },
      },
      {
        hasError: {
          not_equals: true,
        },
      },
      {
        processing: {
          equals: false,
        },
      },
      {
        or: [
          {
            waitUntil: {
              exists: false,
            },
          },
          {
            waitUntil: {
              less_than: new Date().toISOString(),
            },
          },
        ],
      },
    ],
  }

  if (queue) {
    where.and.push({
      queue: {
        equals: queue,
      },
    })
  }

  if (whereFromProps) {
    where.and.push(whereFromProps)
  }

  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of
  // the same job being picked up by another worker
  const jobsQuery: {
    docs: BaseJob[]
  } = { docs: [] }

  if (id) {
    // Only one job to run
    jobsQuery.docs = [
      await updateJob({
        id,
        data: {
          processing: true,
        },
        depth: req.payload.config.jobs.depth,
        disableTransaction: true,
        req,
        returning: true,
      }),
    ]
  } else {
    let defaultProcessingOrder: Sort =
      req.payload.collections[jobsCollectionSlug].config.defaultSort ?? 'createdAt'

    const processingOrderConfig = req.payload.config.jobs?.processingOrder
    if (typeof processingOrderConfig === 'function') {
      defaultProcessingOrder = await processingOrderConfig(args)
    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {
      if (queue && processingOrderConfig.queues && processingOrderConfig.queues[queue]) {
        defaultProcessingOrder = processingOrderConfig.queues[queue]
      } else if (processingOrderConfig.default) {
        defaultProcessingOrder = processingOrderConfig.default
      }
    } else if (typeof processingOrderConfig === 'string') {
      defaultProcessingOrder = processingOrderConfig
    }
    const updatedDocs = await updateJobs({
      data: {
        processing: true,
      },
      depth: req.payload.config.jobs.depth,
      disableTransaction: true,
      limit,
      req,
      returning: true,
      sort: processingOrder ?? defaultProcessingOrder,
      where,
    })

    if (updatedDocs) {
      jobsQuery.docs = updatedDocs
    }
  }

  /**
   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).
   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.
   */
  const { existingJobs, newJobs } = jobsQuery.docs.reduce(
    (acc, job) => {
      if (job.totalTried > 0) {
        acc.existingJobs.push(job)
      } else {
        acc.newJobs.push(job)
      }
      return acc
    },
    { existingJobs: [], newJobs: [] },
  )

  if (!jobsQuery.docs.length) {
    return {
      noJobsRemaining: true,
      remainingJobsFromQueried: 0,
    }
  }

  if (jobsQuery?.docs?.length) {
    req.payload.logger.info({
      msg: `Running ${jobsQuery.docs.length} jobs.`,
      new: newJobs?.length,
      retrying: existingJobs?.length,
    })
  }
  const jobsToDelete: (number | string)[] | undefined = req.payload.config.jobs.deleteJobOnComplete
    ? []
    : undefined

  const runSingleJob = async (job) => {
    if (!job.workflowSlug && !job.taskSlug) {
      throw new Error('Job must have either a workflowSlug or a taskSlug')
    }
    const jobReq = isolateObjectProperty(req, 'transactionID')

    const workflowConfig: WorkflowConfig<WorkflowTypes> = job.workflowSlug
      ? req.payload.config.jobs?.workflows.find(({ slug }) => slug === job.workflowSlug)
      : {
          slug: 'singleTask',
          handler: async ({ job, tasks }) => {
            await tasks[job.taskSlug as string]('1', {
              input: job.input,
            })
          },
        }

    if (!workflowConfig) {
      return null // Skip jobs with no workflow configuration
    }

    const updateJob = getUpdateJobFunction(job, jobReq)

    // the runner will either be passed to the config
    // OR it will be a path, which we will need to import via eval to avoid
    // Next.js compiler dynamic import expression errors
    let workflowHandler: WorkflowHandler<WorkflowTypes> | WorkflowJSON<WorkflowTypes>

    if (
      typeof workflowConfig.handler === 'function' ||
      (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))
    ) {
      workflowHandler = workflowConfig.handler
    } else {
      workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)

      if (!workflowHandler) {
        const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`
        const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`
        req.payload.logger.error(errorMessage)

        await updateJob({
          error: {
            error: errorMessage,
          },
          hasError: true,
          processing: false,
        })

        return
      }
    }

    if (typeof workflowHandler === 'function') {
      const result = await runJob({
        job,
        req: jobReq,
        updateJob,
        workflowConfig,
        workflowHandler,
      })

      if (result.status !== 'error' && jobsToDelete) {
        jobsToDelete.push(job.id)
      }

      return { id: job.id, result }
    } else {
      const result = await runJSONJob({
        job,
        req: jobReq,
        updateJob,
        workflowConfig,
        workflowHandler,
      })

      if (result.status !== 'error' && jobsToDelete) {
        jobsToDelete.push(job.id)
      }

      return { id: job.id, result }
    }
  }

  let resultsArray: { id: number | string; result: RunJobResult }[] = []
  if (sequential) {
    for (const job of jobsQuery.docs) {
      const result = await runSingleJob(job)
      if (result !== null) {
        resultsArray.push(result)
      }
    }
  } else {
    const jobPromises = jobsQuery.docs.map(runSingleJob)
    resultsArray = await Promise.all(jobPromises)
  }

  if (jobsToDelete && jobsToDelete.length > 0) {
    try {
      if (req.payload.config.jobs.runHooks) {
        await req.payload.delete({
          collection: jobsCollectionSlug,
          depth: 0, // can be 0 since we're not returning anything
          disableTransaction: true,
          where: { id: { in: jobsToDelete } },
        })
      } else {
        await req.payload.db.deleteMany({
          collection: jobsCollectionSlug,
          where: { id: { in: jobsToDelete } },
        })
      }
    } catch (err) {
      req.payload.logger.error({
        err,
        msg: `failed to delete jobs ${jobsToDelete.join(', ')} on complete`,
      })
    }
  }

  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce((acc, cur) => {
    if (cur !== null) {
      // Check if there's a valid result to include
      acc[cur.id] = cur.result
    }
    return acc
  }, {})

  let remainingJobsFromQueried = 0
  for (const jobID in resultsObject) {
    const jobResult = resultsObject[jobID]
    if (jobResult.status === 'error') {
      remainingJobsFromQueried++ // Can be retried
    }
  }

  return {
    jobStatus: resultsObject,
    remainingJobsFromQueried,
  }
}
</file>

<file path="packages/payload/src/queues/utilities/getJobTaskStatus.ts">
// @ts-strict-ignore
import type { TaskConfig, TaskType } from '../config/types/taskTypes.js'
import type { BaseJob, JobTaskStatus } from '../config/types/workflowTypes.js'

type Args = {
  jobLog: BaseJob['log']
  tasksConfig: TaskConfig<TaskType>[]
}

export const getJobTaskStatus = ({ jobLog }: Args): JobTaskStatus => {
  const taskStatus: JobTaskStatus = {}

  // First, add (in order) the steps from the config to
  // our status map
  for (const loggedJob of jobLog) {
    if (!taskStatus[loggedJob.taskSlug]) {
      taskStatus[loggedJob.taskSlug] = {}
    }
    if (!taskStatus[loggedJob.taskSlug][loggedJob.taskID]) {
      taskStatus[loggedJob.taskSlug][loggedJob.taskID] = {
        complete: loggedJob.state === 'succeeded',
        input: loggedJob.input,
        output: loggedJob.output,
        taskSlug: loggedJob.taskSlug,
        totalTried: 1,
      }
    } else {
      const newTaskStatus = taskStatus[loggedJob.taskSlug][loggedJob.taskID]
      newTaskStatus.totalTried += 1

      if (loggedJob.state === 'succeeded') {
        newTaskStatus.complete = true
        // As the task currently saved in taskStatus has likely failed and thus has no
        // Output data, we need to update it with the new data from the successful task
        newTaskStatus.output = loggedJob.output
        newTaskStatus.input = loggedJob.input
        newTaskStatus.taskSlug = loggedJob.taskSlug
      }
      taskStatus[loggedJob.taskSlug][loggedJob.taskID] = newTaskStatus
    }
  }

  return taskStatus
}
</file>

<file path="packages/payload/src/queues/utilities/updateJob.ts">
import type { ManyOptions } from '../../collections/operations/local/update.js'
import type { UpdateJobsArgs } from '../../database/types.js'
import type { PayloadRequest, Sort, Where } from '../../types/index.js'
import type { BaseJob } from '../config/types/workflowTypes.js'

import { jobAfterRead, jobsCollectionSlug } from '../config/index.js'

type BaseArgs = {
  data: Partial<BaseJob>
  depth?: number
  disableTransaction?: boolean
  limit?: number
  req: PayloadRequest
  returning?: boolean
}

type ArgsByID = {
  id: number | string
  limit?: never
  sort?: never
  where?: never
}

type ArgsWhere = {
  id?: never
  limit?: number
  sort?: Sort
  where: Where
}

type RunJobsArgs = (ArgsByID | ArgsWhere) & BaseArgs

/**
 * Convenience method for updateJobs by id
 */
export async function updateJob(args: ArgsByID & BaseArgs) {
  const result = await updateJobs(args)
  if (result) {
    return result[0]
  }
}

export async function updateJobs({
  id,
  data,
  depth,
  disableTransaction,
  limit: limitArg,
  req,
  returning,
  sort,
  where: whereArg,
}: RunJobsArgs): Promise<BaseJob[] | null> {
  const limit = id ? 1 : limitArg
  const where = id ? { id: { equals: id } } : whereArg

  if (depth || req.payload.config?.jobs?.runHooks) {
    const result = await req.payload.update({
      id,
      collection: jobsCollectionSlug,
      data,
      depth,
      disableTransaction,
      limit,
      req,
      where,
    } as ManyOptions<any, any>)
    if (returning === false || !result) {
      return null
    }
    return result.docs as BaseJob[]
  }

  const jobReq = {
    transactionID:
      req.payload.db.name !== 'mongoose'
        ? ((await req.payload.db.beginTransaction()) as string)
        : undefined,
  }

  const args: UpdateJobsArgs = id
    ? {
        id,
        data,
        req: jobReq,
        returning,
      }
    : {
        data,
        limit,
        req: jobReq,
        returning,
        sort,
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        where: where as Where,
      }

  const updatedJobs: BaseJob[] | null = await req.payload.db.updateJobs(args)

  if (req.payload.db.name !== 'mongoose' && jobReq.transactionID) {
    await req.payload.db.commitTransaction(jobReq.transactionID)
  }

  if (returning === false || !updatedJobs?.length) {
    return null
  }

  return updatedJobs.map((updatedJob) => {
    return jobAfterRead({
      config: req.payload.config,
      doc: updatedJob,
    })
  })
}
</file>

<file path="packages/payload/src/queues/localAPI.ts">
import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'

import {
  createLocalReq,
  type Payload,
  type PayloadRequest,
  type RunningJob,
  type Sort,
  type TypedJobs,
  type Where,
} from '../index.js'
import { jobAfterRead, jobsCollectionSlug } from './config/index.js'
import { runJobs } from './operations/runJobs/index.js'
import { updateJob, updateJobs } from './utilities/updateJob.js'

export const getJobsLocalAPI = (payload: Payload) => ({
  queue: async <
    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents
    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],
  >(
    args:
      | {
          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']
          queue?: string
          req?: PayloadRequest
          // TTaskOrWorkflowlug with keyof TypedJobs['workflows'] removed:
          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never
          waitUntil?: Date
          workflow?: never
        }
      | {
          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']
          queue?: string
          req?: PayloadRequest
          task?: never
          waitUntil?: Date
          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']
            ? TTaskOrWorkflowSlug
            : never
        },
  ): Promise<
    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']
      ? RunningJob<TTaskOrWorkflowSlug>
      : RunningJobFromTask<TTaskOrWorkflowSlug>
  > => {
    let queue: string | undefined = undefined

    // If user specifies queue, use that
    if (args.queue) {
      queue = args.queue
    } else if (args.workflow) {
      // Otherwise, if there is a workflow specified, and it has a default queue to use,
      // use that
      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)
      if (workflow?.queue) {
        queue = workflow.queue
      }
    }

    const data: Partial<BaseJob> = {
      input: args.input,
    }

    if (queue) {
      data.queue = queue
    }
    if (args.waitUntil) {
      data.waitUntil = args.waitUntil?.toISOString()
    }
    if (args.workflow) {
      data.workflowSlug = args.workflow as string
    }
    if (args.task) {
      data.taskSlug = args.task as string
    }

    type ReturnType = TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']
      ? RunningJob<TTaskOrWorkflowSlug>
      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here

    if (payload?.config?.jobs?.depth || payload?.config?.jobs?.runHooks) {
      return (await payload.create({
        collection: jobsCollectionSlug,
        data,
        depth: payload.config.jobs.depth ?? 0,
        req: args.req,
      })) as ReturnType
    } else {
      return jobAfterRead({
        config: payload.config,
        doc: await payload.db.create({
          collection: jobsCollectionSlug,
          data,
          req: args.req,
        }),
      }) as unknown as ReturnType
    }
  },

  run: async (args?: {
    limit?: number
    overrideAccess?: boolean
    /**
     * Adjust the job processing order using a Payload sort string.
     *
     * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.
     */
    processingOrder?: Sort
    queue?: string
    req?: PayloadRequest
    /**
     * By default, jobs are run in parallel.
     * If you want to run them in sequence, set this to true.
     */
    sequential?: boolean
    where?: Where
  }): Promise<ReturnType<typeof runJobs>> => {
    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))

    return await runJobs({
      limit: args?.limit,
      overrideAccess: args?.overrideAccess !== false,
      processingOrder: args?.processingOrder,
      queue: args?.queue,
      req: newReq,
      sequential: args?.sequential,
      where: args?.where,
    })
  },

  runByID: async (args: {
    id: number | string
    overrideAccess?: boolean
    req?: PayloadRequest
  }): Promise<ReturnType<typeof runJobs>> => {
    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))

    return await runJobs({
      id: args.id,
      overrideAccess: args.overrideAccess !== false,
      req: newReq,
    })
  },

  cancel: async (args: {
    overrideAccess?: boolean
    queue?: string
    req?: PayloadRequest
    where: Where
  }): Promise<void> => {
    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))

    const and: Where[] = [
      args.where,
      {
        completedAt: {
          exists: false,
        },
      },
      {
        hasError: {
          not_equals: true,
        },
      },
    ]

    if (args.queue) {
      and.push({
        queue: {
          equals: args.queue,
        },
      })
    }

    await updateJobs({
      data: {
        completedAt: null,
        error: {
          cancelled: true,
        },
        hasError: true,
        processing: false,
        waitUntil: null,
      } as {
        completedAt: null
        waitUntil: null
      } & BaseJob,
      depth: 0, // No depth, since we're not returning
      disableTransaction: true,
      req: newReq,
      returning: false,
      where: { and },
    })
  },

  cancelByID: async (args: {
    id: number | string
    overrideAccess?: boolean
    req?: PayloadRequest
  }): Promise<void> => {
    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))

    await updateJob({
      id: args.id,
      data: {
        completedAt: null,
        error: {
          cancelled: true,
        },
        hasError: true,
        processing: false,
        waitUntil: null,
      } as {
        completedAt: null
        waitUntil: null
      } & BaseJob,
      depth: 0, // No depth, since we're not returning
      disableTransaction: true,
      req: newReq,
      returning: false,
    })
  },
})
</file>

<file path="packages/payload/src/queues/restEndpointRun.ts">
// @ts-strict-ignore
import type { Endpoint, SanitizedConfig } from '../config/types.js'

import { runJobs, type RunJobsArgs } from './operations/runJobs/index.js'

const configHasJobs = (config: SanitizedConfig): boolean => {
  if (!config.jobs) {
    return false
  }

  if (config.jobs.tasks.length > 0) {
    return true
  }
  if (Array.isArray(config.jobs.workflows) && config.jobs.workflows.length > 0) {
    return true
  }

  return false
}

export const runJobsEndpoint: Endpoint = {
  handler: async (req) => {
    if (!configHasJobs(req.payload.config)) {
      return Response.json(
        {
          message: 'No jobs to run.',
        },
        { status: 200 },
      )
    }

    const hasAccess = await req.payload.config.jobs.access.run({ req })

    if (!hasAccess) {
      return Response.json(
        {
          message: req.i18n.t('error:unauthorized'),
        },
        { status: 401 },
      )
    }

    const { limit, queue } = req.query

    const runJobsArgs: RunJobsArgs = {
      queue: 'default',
      req,
      // We are checking access above, so we can override it here
      overrideAccess: true,
    }

    if (typeof queue === 'string') {
      runJobsArgs.queue = queue
    }

    if (typeof limit !== 'undefined') {
      runJobsArgs.limit = Number(limit)
    }

    let noJobsRemaining = false
    let remainingJobsFromQueried = 0
    try {
      const result = await runJobs(runJobsArgs)
      noJobsRemaining = result.noJobsRemaining
      remainingJobsFromQueried = result.remainingJobsFromQueried
    } catch (err) {
      req.payload.logger.error({
        err,
        msg: 'There was an error running jobs:',
        queue: runJobsArgs.queue,
      })

      return Response.json(
        {
          message: req.i18n.t('error:unknown'),
          noJobsRemaining: true,
          remainingJobsFromQueried,
        },
        { status: 500 },
      )
    }

    return Response.json(
      {
        message: req.i18n.t('general:success'),
        noJobsRemaining,
        remainingJobsFromQueried,
      },
      { status: 200 },
    )
  },
  method: 'get',
  path: '/run',
}
</file>

<file path="packages/payload/src/translations/getLocalI18n.ts">
import type { AcceptedLanguages } from '@convexcms/translations'

import { initI18n } from '@convexcms/translations'

import type { SanitizedConfig } from '../config/types.js'

export const getLocalI18n = async ({
  config,
  language,
}: {
  config: SanitizedConfig
  language: AcceptedLanguages
}) =>
  initI18n({
    config: config.i18n,
    context: 'api',
    language,
  })
</file>

<file path="packages/payload/src/types/constants.ts">
export const validOperators = [
  'equals',
  'contains',
  'not_equals',
  'in',
  'all',
  'not_in',
  'exists',
  'greater_than',
  'greater_than_equal',
  'less_than',
  'less_than_equal',
  'like',
  'not_like',
  'within',
  'intersects',
  'near',
] as const

export type Operator = (typeof validOperators)[number]

export const validOperatorSet = new Set<Operator>(validOperators)
</file>

<file path="packages/payload/src/types/index.ts">
// @ts-strict-ignore
import type { I18n, TFunction } from '@convexcms/translations'
import type DataLoader from 'dataloader'
import type { URL } from 'url'

import type {
  DataFromCollectionSlug,
  TypeWithID,
  TypeWithTimestamps,
} from '../collections/config/types.js'
import type payload from '../index.js'
import type {
  CollectionSlug,
  DataFromGlobalSlug,
  GlobalSlug,
  Payload,
  RequestContext,
  TypedCollectionJoins,
  TypedCollectionSelect,
  TypedLocale,
  TypedUser,
} from '../index.js'
import type { Operator } from './constants.js'
export type { Payload } from '../index.js'

export type CustomPayloadRequestProperties = {
  context: RequestContext
  /** The locale that should be used for a field when it is not translated to the requested locale */
  fallbackLocale?: string
  i18n: I18n
  /**
   * The requested locale if specified
   * Only available for localized collections
   *
   * Suppressing warning below as it is a valid use case - won't be an issue if generated types exist
   */
  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
  locale?: 'all' | TypedLocale
  /**
   * The payload object
   */
  payload: typeof payload
  /**
   * The context in which the request is being made
   */
  payloadAPI: 'GraphQL' | 'local' | 'REST'
  /** Optimized document loader */
  payloadDataLoader: {
    /**
     * Wraps `payload.find` with a cache to deduplicate requests
     * @experimental This is may be replaced by a more robust cache strategy in future versions
     * By calling this method with the same arguments many times in one request, it will only be handled one time
     * const result = await req.payloadDataLoader.find({
     *  collection,
     *  req,
     *  where: findWhere,
     * })
     */
    find: Payload['find']
  } & DataLoader<string, TypeWithID>
  /** Resized versions of the image that was uploaded during this request */
  payloadUploadSizes?: Record<string, Buffer>
  /** Query params on the request */
  query: Record<string, unknown>
  /** Any response headers that are required to be set when a response is sent */
  responseHeaders?: Headers
  /** The route parameters
   * @example
   * /:collection/:id -> /posts/123
   * { collection: 'posts', id: '123' }
   */
  routeParams?: Record<string, unknown>
  /** Translate function - duplicate of i18n.t */
  t: TFunction
  /**
   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.
   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.
   */
  transactionID?: number | Promise<number | string> | string
  /**
   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request
   * @deprecated This is not used anywhere, instead `transactionID` is used for the above. Will be removed in next major version.
   */
  transactionIDPromise?: Promise<void>
  /** The signed-in user */
  user: null | TypedUser
} & Pick<
  URL,
  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'
>
type PayloadRequestData = {
  /**
   * Data from the request body
   *
   * Within Payload operations, i.e. hooks, data will be there
   * BUT in custom endpoints it will not be, you will need to
   * use either:
   *  1. `const data = await req.json()`
   *
   *  2. import { addDataAndFileToRequest } from '@convexcms/core'
   *    `await addDataAndFileToRequest(req)`
   * */
  data?: JsonObject
  /** The file on the request, same rules apply as the `data` property */
  file?: {
    /**
     * Context of the file when it was uploaded via client side.
     */
    clientUploadContext?: unknown
    data: Buffer
    mimetype: string
    name: string
    size: number
    tempFilePath?: string
  }
}
export type PayloadRequest = CustomPayloadRequestProperties &
  Partial<Request> &
  PayloadRequestData &
  Required<Pick<Request, 'headers'>>

export type { Operator }

// Makes it so things like passing new Date() will error
export type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this

export type JsonArray = Array<JsonValue>

export interface JsonObject {
  [key: string]: any
}

export type WhereField = {
  // any json-serializable value
  [key in Operator]?: JsonValue
}

export type Where = {
  [key: string]: Where[] | WhereField
  and?: Where[]
  or?: Where[]
}

export type Sort = Array<string> | string

type SerializableValue = boolean | number | object | string
export type DefaultValue =
  | ((args: {
      locale?: TypedLocale
      req: PayloadRequest
      user: PayloadRequest['user']
    }) => SerializableValue)
  | SerializableValue

/**
 * Applies pagination for join fields for including collection relationships
 */
export type JoinQuery<TSlug extends CollectionSlug = string> =
  TypedCollectionJoins[TSlug] extends Record<string, string>
    ?
        | false
        | Partial<{
            [K in keyof TypedCollectionJoins[TSlug]]:
              | {
                  count?: boolean
                  limit?: number
                  page?: number
                  sort?: string
                  where?: Where
                }
              | false
          }>
    : never

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type Document = any

export type Operation = 'create' | 'delete' | 'read' | 'update'
export type VersionOperations = 'readVersions'
export type AuthOperations = 'unlock'
export type AllOperations = AuthOperations | Operation | VersionOperations

export function docHasTimestamps(doc: any): doc is TypeWithTimestamps {
  return doc?.createdAt && doc?.updatedAt
}

export type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'
export type IsAny<T> = IfAny<T, true, false>
export type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T

export type SelectIncludeType = {
  [k: string]: SelectIncludeType | true
}

export type SelectExcludeType = {
  [k: string]: false | SelectExcludeType
}

export type SelectMode = 'exclude' | 'include'

export type SelectType = SelectExcludeType | SelectIncludeType

export type ApplyDisableErrors<T, DisableErrors = false> = false extends DisableErrors
  ? T
  : null | T

export type TransformDataWithSelect<
  Data extends Record<string, any>,
  Select extends SelectType,
> = Select extends never
  ? Data
  : string extends keyof Select
    ? Data
    : // START Handle types when they aren't generated
      // For example in any package in this repository outside of tests / plugins
      // This stil gives us autocomplete when using include select mode, i.e select: {title :true} returns type {title: any, id: string | number}
      string extends keyof Omit<Data, 'id'>
      ? Select extends SelectIncludeType
        ? {
            [K in Data extends TypeWithID ? 'id' | keyof Select : keyof Select]: K extends 'id'
              ? number | string
              : unknown
          }
        : Data
      : // END Handle types when they aren't generated
        // Handle include mode
        Select extends SelectIncludeType
        ? {
            [K in keyof Data as K extends keyof Select
              ? Select[K] extends object | true
                ? K
                : never
              : // select 'id' always
                K extends 'id'
                ? K
                : never]: Data[K]
          }
        : // Handle exclude mode
          {
            [K in keyof Data as K extends keyof Select
              ? Select[K] extends object | undefined
                ? K
                : never
              : K]: Data[K]
          }

export type TransformCollectionWithSelect<
  TSlug extends CollectionSlug,
  TSelect extends SelectType,
> = TSelect extends SelectType
  ? TransformDataWithSelect<DataFromCollectionSlug<TSlug>, TSelect>
  : DataFromCollectionSlug<TSlug>

export type TransformGlobalWithSelect<
  TSlug extends GlobalSlug,
  TSelect extends SelectType,
> = TSelect extends SelectType
  ? TransformDataWithSelect<DataFromGlobalSlug<TSlug>, TSelect>
  : DataFromGlobalSlug<TSlug>

export type PopulateType = Partial<TypedCollectionSelect>

export type ResolvedFilterOptions = { [collection: string]: Where }
</file>

<file path="packages/payload/src/uploads/endpoints/getFile.ts">
import type { Stats } from 'fs'

// @ts-strict-ignore
import { fileTypeFromFile } from 'file-type'
import fsPromises from 'fs/promises'
import { status as httpStatus } from 'http-status'
import path from 'path'

import type { PayloadHandler } from '../../config/types.js'

import { APIError } from '../../errors/APIError.js'
import { checkFileAccess } from '../../uploads/checkFileAccess.js'
import { streamFile } from '../../uploads/fetchAPI-stream-file/index.js'
import { getFileTypeFallback } from '../../uploads/getFileTypeFallback.js'
import { getRequestCollection } from '../../utilities/getRequestEntity.js'
import { headersWithCors } from '../../utilities/headersWithCors.js'

export const getFileHandler: PayloadHandler = async (req) => {
  const collection = getRequestCollection(req)

  const filename = req.routeParams.filename as string

  if (!collection.config.upload) {
    throw new APIError(
      `This collection is not an upload collection: ${collection.config.slug}`,
      httpStatus.BAD_REQUEST,
    )
  }

  const accessResult = await checkFileAccess({
    collection,
    filename,
    req,
  })

  if (accessResult instanceof Response) {
    return accessResult
  }

  if (collection.config.upload.handlers?.length) {
    let customResponse = null
    for (const handler of collection.config.upload.handlers) {
      customResponse = await handler(req, {
        doc: accessResult,
        params: {
          collection: collection.config.slug,
          filename,
        },
      })
    }

    if (customResponse instanceof Response) {
      return customResponse
    }
  }

  const fileDir = collection.config.upload?.staticDir || collection.config.slug
  const filePath = path.resolve(`${fileDir}/${filename}`)
  let stats: Stats

  try {
    stats = await fsPromises.stat(filePath)
  } catch (err) {
    if (err.code === 'ENOENT') {
      req.payload.logger.error(
        `File ${filename} for collection ${collection.config.slug} is missing on the disk. Expected path: ${filePath}`,
      )

      // Omit going to the routeError handler by returning response instead of
      // throwing an error to cut down log noise. The response still matches what you get with APIError to not leak details to the user.
      return Response.json(
        {
          errors: [
            {
              message: 'Something went wrong.',
            },
          ],
        },
        {
          headers: headersWithCors({
            headers: new Headers(),
            req,
          }),
          status: 500,
        },
      )
    }

    throw err
  }

  const data = streamFile(filePath)
  const fileTypeResult = (await fileTypeFromFile(filePath)) || getFileTypeFallback(filePath)

  let headers = new Headers()
  headers.set('Content-Type', fileTypeResult.mime)
  headers.set('Content-Length', stats.size + '')
  headers = collection.config.upload?.modifyResponseHeaders
    ? collection.config.upload.modifyResponseHeaders({ headers })
    : headers

  return new Response(data, {
    headers: headersWithCors({
      headers,
      req,
    }),
    status: httpStatus.OK,
  })
}
</file>

<file path="packages/payload/src/uploads/endpoints/getFileFromURL.ts">
// @ts-strict-ignore
import type { PayloadHandler } from '../../config/types.js'

import executeAccess from '../../auth/executeAccess.js'
import { APIError } from '../../errors/APIError.js'
import { Forbidden } from '../../errors/Forbidden.js'
import { getRequestCollectionWithID } from '../../utilities/getRequestEntity.js'
import { isURLAllowed } from '../../utilities/isURLAllowed.js'

// If doc id is provided, it means we are updating the doc
// /:collectionSlug/paste-url/:doc-id?src=:fileUrl

// If doc id is not provided, it means we are creating a new doc
// /:collectionSlug/paste-url?src=:fileUrl

export const getFileFromURLHandler: PayloadHandler = async (req) => {
  const { id, collection } = getRequestCollectionWithID(req, { optionalID: true })

  if (!req.user) {
    throw new Forbidden(req.t)
  }

  const config = collection?.config

  if (id) {
    // updating doc
    const accessResult = await executeAccess({ req }, config.access.update)
    if (!accessResult) {
      throw new Forbidden(req.t)
    }
  } else {
    // creating doc
    const accessResult = await executeAccess({ req }, config.access?.create)
    if (!accessResult) {
      throw new Forbidden(req.t)
    }
  }
  try {
    if (!req.url) {
      throw new APIError('Request URL is missing.', 400)
    }

    const { searchParams } = new URL(req.url)
    const src = searchParams.get('src')

    if (!src || typeof src !== 'string') {
      throw new APIError('A valid URL string is required.', 400)
    }

    const validatedUrl = new URL(src)

    if (
      typeof config.upload?.pasteURL === 'object' &&
      !isURLAllowed(validatedUrl.href, config.upload.pasteURL.allowList)
    ) {
      throw new APIError(`The provided URL (${validatedUrl.href}) is not allowed.`, 400)
    }

    // Fetch the file with no compression
    const response = await fetch(validatedUrl.href, {
      headers: {
        'Accept-Encoding': 'identity',
      },
    })

    if (!response.ok) {
      throw new APIError(`Failed to fetch file from ${validatedUrl.href}`, response.status)
    }

    const decodedFileName = decodeURIComponent(validatedUrl.pathname.split('/').pop() || '')

    return new Response(response.body, {
      headers: {
        'Content-Disposition': `attachment; filename="${decodedFileName}"`,
        'Content-Length': response.headers.get('content-length') || '',
        'Content-Type': response.headers.get('content-type') || 'application/octet-stream',
      },
    })
  } catch (error) {
    throw new APIError(`Error fetching file: ${error.message}`, 500)
  }
}
</file>

<file path="packages/payload/src/uploads/endpoints/index.ts">
import type { Endpoint } from '../../config/types.js'

import { wrapInternalEndpoints } from '../../utilities/wrapInternalEndpoints.js'
import { getFileHandler } from './getFile.js'
import { getFileFromURLHandler } from './getFileFromURL.js'

export const uploadCollectionEndpoints: Endpoint[] = wrapInternalEndpoints([
  {
    handler: getFileFromURLHandler,
    method: 'get',
    path: '/paste-url/:id?',
  },
  {
    handler: getFileHandler,
    method: 'get',
    path: '/file/:filename',
  },
])
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/fileFactory.ts">
import type { FetchAPIFileUploadOptions } from '../../config/types.js'
import type { FileShape } from './index.js'

import {
  checkAndMakeDir,
  debugLog,
  isFunc,
  moveFile,
  promiseCallback,
  saveBufferToFile,
} from './utilities.js'

type MoveFile = (
  filePath: string,
  options: FileFactoryOptions,
  fileUploadOptions: FetchAPIFileUploadOptions,
) => (resolve: () => void, reject: () => void) => void

/**
 * Returns Local function that moves the file to a different location on the filesystem
 * which takes two function arguments to make it compatible w/ Promise or Callback APIs
 */
const moveFromTemp: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {
  debugLog(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`)
  moveFile(options.tempFilePath, filePath, promiseCallback(resolve, reject))
}

/**
 * Returns Local function that moves the file from buffer to a different location on the filesystem
 * which takes two function arguments to make it compatible w/ Promise or Callback APIs
 */
const moveFromBuffer: MoveFile = (filePath, options, fileUploadOptions) => (resolve, reject) => {
  debugLog(fileUploadOptions, `Moving uploaded buffer to ${filePath}`)
  saveBufferToFile(options.buffer, filePath, promiseCallback(resolve, reject))
}

type FileFactoryOptions = {
  buffer: Buffer
  encoding: string
  hash: Buffer | string
  mimetype: string
  name: string
  size: number
  tempFilePath: string
  truncated: boolean
}
type FileFactory = (
  options: FileFactoryOptions,
  fileUploadOptions: FetchAPIFileUploadOptions,
) => FileShape
export const fileFactory: FileFactory = (options, fileUploadOptions) => {
  // see: https://github.com/richardgirges/express-fileupload/issues/14
  // firefox uploads empty file in case of cache miss when f5ing page.
  // resulting in unexpected behavior. if there is no file data, the file is invalid.
  // if (!fileUploadOptions.useTempFiles && !options.buffer.length) return;

  // Create and return file object.
  return {
    name: options.name,
    data: options.buffer,
    encoding: options.encoding,
    md5: options.hash,
    mimetype: options.mimetype,
    mv: (filePath: string, callback) => {
      // Define a proper move function.
      const moveFunc = fileUploadOptions.useTempFiles
        ? moveFromTemp(filePath, options, fileUploadOptions)
        : moveFromBuffer(filePath, options, fileUploadOptions)
      // Create a folder for a file.
      checkAndMakeDir(fileUploadOptions, filePath)
      // If callback is passed in, use the callback API, otherwise return a promise.
      const defaultReject = () => undefined
      return isFunc(callback) ? moveFunc(callback, defaultReject) : new Promise(moveFunc)
    },
    size: options.size,
    tempFilePath: options.tempFilePath,
    truncated: options.truncated,
  }
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/handlers.ts">
// @ts-strict-ignore
import crypto from 'crypto'
import fs, { WriteStream } from 'fs'
import path from 'path'

import type { FetchAPIFileUploadOptions } from '../../config/types.js'

import { checkAndMakeDir, debugLog, deleteFile, getTempFilename } from './utilities.js'

type Handler = (
  options: FetchAPIFileUploadOptions,
  fieldname: string,
  filename: string,
) => {
  cleanup: () => void
  complete: () => Buffer
  dataHandler: (data: Buffer) => void
  getFilePath: () => string
  getFileSize: () => number
  getHash: () => string
  getWritePromise: () => Promise<boolean>
}

export const tempFileHandler: Handler = (options, fieldname, filename) => {
  const dir = path.normalize(options.tempFileDir)
  const tempFilePath = path.join(process.cwd(), dir, getTempFilename())
  checkAndMakeDir({ createParentPath: true }, tempFilePath)

  debugLog(options, `Temporary file path is ${tempFilePath}`)

  const hash = crypto.createHash('md5')
  let fileSize = 0
  let completed = false

  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`)
  const writeStream = fs.createWriteStream(tempFilePath)
  const writePromise = new Promise<boolean>((resolve, reject) => {
    writeStream.on('finish', () => resolve(true))
    writeStream.on('error', (err) => {
      debugLog(options, `Error write temp file: ${err}`)
      reject(err)
    })
  })

  return {
    cleanup: () => {
      completed = true
      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`)
      writeStream.end()
      deleteFile(tempFilePath, (err) =>
        err
          ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`)
          : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`),
      )
    },
    complete: () => {
      completed = true
      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)
      if (writeStream instanceof WriteStream) {
        writeStream.end()
      }
      // Return empty buff since data was uploaded into a temp file.
      return Buffer.concat([])
    },
    dataHandler: (data) => {
      if (completed === true) {
        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)
        return
      }
      writeStream.write(data)
      hash.update(data)
      fileSize += data.length
      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)
    },
    getFilePath: () => tempFilePath,
    getFileSize: () => fileSize,
    getHash: () => hash.digest('hex'),
    getWritePromise: () => writePromise,
  }
}

export const memHandler: Handler = (options, fieldname, filename) => {
  const buffers: Buffer[] = []
  const hash = crypto.createHash('md5')
  let fileSize = 0
  let completed = false

  const getBuffer = () => Buffer.concat(buffers, fileSize)

  return {
    cleanup: () => {
      completed = true
    },
    complete: () => {
      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`)
      completed = true
      return getBuffer()
    },
    dataHandler: (data) => {
      if (completed === true) {
        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`)
        return
      }
      buffers.push(data)
      hash.update(data)
      fileSize += data.length
      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`)
    },
    getFilePath: () => '',
    getFileSize: () => fileSize,
    getHash: () => hash.digest('hex'),
    getWritePromise: () => Promise.resolve(true),
  }
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/index.ts">
// @ts-strict-ignore
import path from 'path'

import type { FetchAPIFileUploadOptions } from '../../config/types.js'

import { APIError } from '../../errors/APIError.js'
import { isEligibleRequest } from './isEligibleRequest.js'
import { processMultipart } from './processMultipart.js'
import { debugLog } from './utilities.js'

const DEFAULT_OPTIONS: FetchAPIFileUploadOptions = {
  abortOnLimit: false,
  createParentPath: false,
  debug: false,
  defParamCharset: 'utf8',
  limitHandler: false,
  parseNested: false,
  preserveExtension: false,
  responseOnLimit: 'File size limit has been reached',
  safeFileNames: false,
  tempFileDir: path.join(process.cwd(), 'tmp'),
  uploadTimeout: 60000,
  uriDecodeFileNames: false,
  useTempFiles: false,
}

export type FileShape = {
  data: Buffer
  encoding: string
  md5: Buffer | string
  mimetype: string
  mv: (filePath: string, callback: () => void) => Promise<void> | void
  name: string
  size: number
  tempFilePath: string
  truncated: boolean
}

type FetchAPIFileUploadResponseFile = {
  data: Buffer
  mimetype: string
  name: string
  size: number
  tempFilePath?: string
}

export type FetchAPIFileUploadResponse = {
  error?: APIError
  fields: Record<string, string>
  files: Record<string, FetchAPIFileUploadResponseFile>
}

type FetchAPIFileUpload = (args: {
  options?: FetchAPIFileUploadOptions
  request: Request
}) => Promise<FetchAPIFileUploadResponse>
export const fetchAPIFileUpload: FetchAPIFileUpload = async ({ options, request }) => {
  const uploadOptions: FetchAPIFileUploadOptions = { ...DEFAULT_OPTIONS, ...options }
  if (!isEligibleRequest(request)) {
    debugLog(uploadOptions, 'Request is not eligible for file upload!')
    return {
      error: new APIError('Request is not eligible for file upload', 500),
      fields: undefined,
      files: undefined,
    }
  } else {
    return processMultipart({ options: uploadOptions, request })
  }
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/isEligibleRequest.ts">
// @ts-strict-ignore
// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/no-obscure-range
const ACCEPTABLE_CONTENT_TYPE = /multipart\/['"()+-_]+(?:; ?['"()+-_]*)+$/i
const UNACCEPTABLE_METHODS = new Set(['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'TRACE'])

const hasBody = (req: Request): boolean => {
  return Boolean(
    req.headers.get('transfer-encoding') ||
      (req.headers.get('content-length') && req.headers.get('content-length') !== '0'),
  )
}

const hasAcceptableMethod = (req: Request): boolean => !UNACCEPTABLE_METHODS.has(req.method)

const hasAcceptableContentType = (req: Request): boolean => {
  const contType = req.headers.get('content-type')
  return contType.includes('boundary=') && ACCEPTABLE_CONTENT_TYPE.test(contType)
}

export const isEligibleRequest = (req: Request): boolean => {
  try {
    return hasBody(req) && hasAcceptableMethod(req) && hasAcceptableContentType(req)
  } catch (e) {
    return false
  }
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/LICENSE.md">
The MIT License (MIT)

Copyright (c) 2015 Richard Girges

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project uses a modified version of the `express-fileupload` package, which is distributed under the terms of the MIT License. The modifications made to the original code are as follows:

I converted the code to TypeScript, and made some minor changes since we needed this to work with the [Web Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) instead of the Node HTTP Request. Express-fileupload relied on req.pipe, which does not exist on the Web Request.
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/processMultipart.ts">
// @ts-strict-ignore
import type { Readable } from 'stream'

import Busboy from 'busboy'
import { status as httpStatus } from 'http-status'

import type { FetchAPIFileUploadOptions } from '../../config/types.js'
import type { FetchAPIFileUploadResponse } from './index.js'

import { APIError } from '../../errors/APIError.js'
import { fileFactory } from './fileFactory.js'
import { memHandler, tempFileHandler } from './handlers.js'
import { processNested } from './processNested.js'
import { createUploadTimer } from './uploadTimer.js'
import { buildFields, debugLog, isFunc, parseFileName } from './utilities.js'

const waitFlushProperty = Symbol('wait flush property symbol')

type ProcessMultipart = (args: {
  options: FetchAPIFileUploadOptions
  request: Request
}) => Promise<FetchAPIFileUploadResponse>
export const processMultipart: ProcessMultipart = async ({ options, request }) => {
  let parsingRequest = true

  let shouldAbortProccessing = false
  let fileCount = 0
  let filesCompleted = 0
  let allFilesHaveResolved: (value?: unknown) => void
  let failedResolvingFiles: (err: Error) => void

  const allFilesComplete = new Promise((res, rej) => {
    allFilesHaveResolved = res
    failedResolvingFiles = rej
  })

  const result: FetchAPIFileUploadResponse = {
    fields: undefined,
    files: undefined,
  }

  const headersObject = {}
  request.headers.forEach((value, name) => {
    headersObject[name] = value
  })

  const reader = request.body.getReader()

  const busboy = Busboy({ ...options, headers: headersObject })

  function abortAndDestroyFile(file: Readable, err: APIError) {
    file.destroy()
    shouldAbortProccessing = true
    failedResolvingFiles(err)
  }

  // Build multipart req.body fields
  busboy.on('field', (field, val) => {
    result.fields = buildFields(result.fields, field, val)
  })

  // Build req.files fields
  busboy.on('file', (field, file, info) => {
    fileCount += 1
    // Parse file name(cutting huge names, decoding, etc..).
    const { encoding, filename: name, mimeType: mime } = info
    const filename = parseFileName(options, name)

    // Define methods and handlers for upload process.
    const { cleanup, complete, dataHandler, getFilePath, getFileSize, getHash, getWritePromise } =
      options.useTempFiles
        ? tempFileHandler(options, field, filename) // Upload into temporary file.
        : memHandler(options, field, filename) // Upload into RAM.

    const writePromise = options.useTempFiles
      ? getWritePromise().catch((err) => {
          busboy.end()
          cleanup()
        })
      : getWritePromise()

    const uploadTimer = createUploadTimer(options.uploadTimeout, () => {
      return abortAndDestroyFile(
        file,
        new APIError(`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`),
      )
    })

    file.on('limit', () => {
      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`)
      uploadTimer.clear()

      if (isFunc(options.limitHandler)) {
        options.limitHandler({ request, size: getFileSize() })
      }

      // Return error and cleanup files if abortOnLimit set.
      if (options.abortOnLimit) {
        debugLog(options, `Upload file size limit reached ${field}->${filename}.`)
        cleanup()
        abortAndDestroyFile(
          file,
          new APIError(options.responseOnLimit, httpStatus.REQUEST_ENTITY_TOO_LARGE, {
            size: getFileSize(),
          }),
        )
      }
    })

    file.on('data', (data) => {
      uploadTimer.set()
      dataHandler(data)
    })

    file.on('end', () => {
      const size = getFileSize()
      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`)
      uploadTimer.clear()

      if (!name && size === 0) {
        fileCount -= 1
        if (options.useTempFiles) {
          cleanup()
          debugLog(options, `Removing the empty file ${field}->${filename}`)
        }
        return debugLog(options, `Don't add file instance if original name and size are empty`)
      }

      filesCompleted += 1

      result.files = buildFields(
        result.files,
        field,
        fileFactory(
          {
            name: filename,
            buffer: complete(),
            encoding,
            hash: getHash(),
            mimetype: mime,
            size,
            tempFilePath: getFilePath(),
            truncated: Boolean('truncated' in file && file.truncated) || false,
          },
          options,
        ),
      )

      if (!request[waitFlushProperty]) {
        request[waitFlushProperty] = []
      }
      request[waitFlushProperty].push(writePromise)

      if (filesCompleted === fileCount) {
        allFilesHaveResolved()
      }
    })

    file.on('error', (err) => {
      uploadTimer.clear()
      debugLog(options, `File Error: ${err.message}`)
      cleanup()
      failedResolvingFiles(err)
    })

    // Start upload process.
    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`)
    uploadTimer.set()
  })

  busboy.on('finish', async () => {
    debugLog(options, `Busboy finished parsing request.`)
    if (options.parseNested) {
      result.fields = processNested(result.fields)
      result.files = processNested(result.files)
    }

    if (request[waitFlushProperty]) {
      try {
        await Promise.all(request[waitFlushProperty]).then(() => {
          delete request[waitFlushProperty]
        })
      } catch (err) {
        debugLog(options, `Error waiting for file write promises: ${err}`)
      }
    }

    return result
  })

  busboy.on(
    'error',
    (err = new APIError('Busboy error parsing multipart request', httpStatus.BAD_REQUEST)) => {
      debugLog(options, `Busboy error`)
      throw err
    },
  )

  while (parsingRequest) {
    const { done, value } = await reader.read()

    if (done) {
      parsingRequest = false
    }

    if (value && !shouldAbortProccessing) {
      busboy.write(value)
    }
  }

  if (fileCount !== 0) {
    await allFilesComplete.catch((e) => {
      throw e
    })
  }

  return result
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/processNested.ts">
// @ts-strict-ignore
import { isSafeFromPollution } from './utilities.js'

export const processNested = function (data) {
  if (!data || data.length < 1) {
    return Object.create(null)
  }

  const d = Object.create(null),
    keys = Object.keys(data)

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i],
      keyParts = key.replace(new RegExp(/\[/g), '.').replace(new RegExp(/\]/g), '').split('.'),
      value = data[key]
    let current = d

    for (let index = 0; index < keyParts.length; index++) {
      const k = keyParts[index]

      // Ensure we don't allow prototype pollution
      if (!isSafeFromPollution(current, k)) {
        continue
      }

      if (index >= keyParts.length - 1) {
        current[k] = value
      } else {
        if (!current[k]) {
          current[k] = !keyParts[index + 1] ? [] : Object.create(null)
        }
        current = current[k]
      }
    }
  }
  return d
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/uploadTimer.ts">
// @ts-strict-ignore
type CreateUploadTimer = (
  timeout?: number,
  callback?: () => void,
) => {
  clear: () => void
  set: () => boolean
}

export const createUploadTimer: CreateUploadTimer = (timeout = 0, callback = () => {}) => {
  let timer = null

  const clear = () => {
    clearTimeout(timer)
  }

  const set = () => {
    // Do not start a timer if zero timeout or it hasn't been set.
    if (!timeout) {
      return false
    }
    clear()
    timer = setTimeout(callback, timeout)
    return true
  }

  return { clear, set }
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-multipart/utilities.ts">
// @ts-strict-ignore
import fs from 'fs'
import path from 'path'
import { Readable } from 'stream'

import type { FetchAPIFileUploadOptions } from '../../config/types.js'

// Parameters for safe file name parsing.
const SAFE_FILE_NAME_REGEX = /[^\w-]/g
const MAX_EXTENSION_LENGTH = 3

// Parameters to generate unique temporary file names:
const TEMP_COUNTER_MAX = 65536
const TEMP_PREFIX = 'tmp'
let tempCounter = 0

/**
 * Logs message to console if options.debug option set to true.
 */
export const debugLog = (options: FetchAPIFileUploadOptions, msg: string) => {
  const opts = options || {}
  if (!opts.debug) {
    return false
  }
  console.log(`Next-file-upload: ${msg}`) // eslint-disable-line
  return true
}

/**
 * Generates unique temporary file name. e.g. tmp-5000-156788789789.
 */
export const getTempFilename = (prefix: string = TEMP_PREFIX) => {
  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1
  return `${prefix}-${tempCounter}-${Date.now()}`
}

type FuncType = (...args: any[]) => any
export const isFunc = (value: any): value is FuncType => {
  return typeof value === 'function'
}

/**
 * Set errorFunc to the same value as successFunc for callback mode.
 */
type ErrorFunc = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void
const errorFunc: ErrorFunc = (resolve, reject) => (isFunc(reject) ? reject : resolve)

/**
 * Return a callback function for promise resole/reject args.
 * Ensures that callback is called only once.
 */
type PromiseCallback = (resolve: () => void, reject: (err: Error) => void) => (err: Error) => void
export const promiseCallback: PromiseCallback = (resolve, reject) => {
  let hasFired = false
  return (err: Error) => {
    if (hasFired) {
      return
    }

    hasFired = true
    return err ? errorFunc(resolve, reject)(err) : resolve()
  }
}

// The default prototypes for both objects and arrays.
// Used by isSafeFromPollution
const OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype)
const ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype)

/**
 * Determines whether a key insertion into an object could result in a prototype pollution
 */
type IsSafeFromPollution = (base: any, key: string) => boolean
export const isSafeFromPollution: IsSafeFromPollution = (base, key) => {
  // We perform an instanceof check instead of Array.isArray as the former is more
  // permissive for cases in which the object as an Array prototype but was not constructed
  // via an Array constructor or literal.
  const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key)
  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key)

  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE
}

/**
 * Build request field/file objects to return
 */
type BuildFields = (instance: any, field: string, value: any) => any
export const buildFields: BuildFields = (instance, field, value) => {
  // Do nothing if value is not set.
  if (value === null || value === undefined) {
    return instance
  }
  instance = instance || Object.create(null)

  if (!isSafeFromPollution(instance, field)) {
    return instance
  }
  // Non-array fields
  if (!instance[field]) {
    instance[field] = value
    return instance
  }
  // Array fields
  if (instance[field] instanceof Array) {
    instance[field].push(value)
  } else {
    instance[field] = [instance[field], value]
  }
  return instance
}

/**
 * Creates a folder if it does not exist
 * for file specified in the path variable
 */
type CheckAndMakeDir = (fileUploadOptions: FetchAPIFileUploadOptions, filePath: string) => boolean
export const checkAndMakeDir: CheckAndMakeDir = (fileUploadOptions, filePath) => {
  if (!fileUploadOptions.createParentPath) {
    return false
  }
  // Check whether folder for the file exists.
  const parentPath = path.dirname(filePath)
  // Create folder if it doesn't exist.
  if (!fs.existsSync(parentPath)) {
    fs.mkdirSync(parentPath, { recursive: true })
  }
  // Checks folder again and return a results.
  return fs.existsSync(parentPath)
}

/**
 * Delete a file.
 */
type DeleteFile = (filePath: string, callback: (args: any) => void) => void
export const deleteFile: DeleteFile = (filePath, callback: (args) => void) =>
  fs.unlink(filePath, callback)

/**
 * Copy file via streams
 */
type CopyFile = (src: string, dst: string, callback: (err: Error) => void) => void
const copyFile: CopyFile = (src, dst, callback) => {
  // cbCalled flag and runCb helps to run cb only once.
  let cbCalled = false
  const runCb = (err?: Error) => {
    if (cbCalled) {
      return
    }
    cbCalled = true
    callback(err)
  }
  // Create read stream
  const readable = fs.createReadStream(src)
  readable.on('error', runCb)
  // Create write stream
  const writable = fs.createWriteStream(dst)
  writable.on('error', (err: Error) => {
    readable.destroy()
    runCb(err)
  })
  writable.on('close', () => runCb())
  // Copy file via piping streams.
  readable.pipe(writable)
}

/**
 * moveFile: moves the file from src to dst.
 * Firstly trying to rename the file if no luck copying it to dst and then deleting src.
 */
type MoveFile = (
  src: string,
  dst: string,
  callback: (err: Error, renamed?: boolean) => void,
) => void
export const moveFile: MoveFile = (src, dst, callback) =>
  fs.rename(src, dst, (err) => {
    if (err) {
      // Try to copy file if rename didn't work.
      copyFile(src, dst, (cpErr) => (cpErr ? callback(cpErr) : deleteFile(src, callback)))
      return
    }
    // File was renamed successfully: Add true to the callback to indicate that.
    callback(null, true)
  })

/**
 * Save buffer data to a file.
 * @param {Buffer} buffer - buffer to save to a file.
 * @param {string} filePath - path to a file.
 */
export const saveBufferToFile = (buffer, filePath, callback) => {
  if (!Buffer.isBuffer(buffer)) {
    return callback(new Error('buffer variable should be type of Buffer!'))
  }
  // Setup readable stream from buffer.
  let streamData = buffer
  const readStream = new Readable()
  readStream._read = () => {
    readStream.push(streamData)
    streamData = null
  }
  // Setup file system writable stream.
  const fstream = fs.createWriteStream(filePath)
  // console.log("Calling saveBuffer");
  fstream.on('error', (err) => {
    // console.log("err cb")
    callback(err)
  })
  fstream.on('close', () => {
    // console.log("close cb");
    callback()
  })
  // Copy file via piping streams.
  readStream.pipe(fstream)
}

/**
 * Decodes uriEncoded file names.
 * @param {Object} opts - middleware options.
 * @param fileName {String} - file name to decode.
 * @returns {String}
 */
const uriDecodeFileName = (opts, fileName) => {
  if (!opts || !opts.uriDecodeFileNames) {
    return fileName
  }
  // Decode file name from URI with checking URI malformed errors.
  // See Issue https://github.com/richardgirges/express-fileupload/issues/342.
  try {
    return decodeURIComponent(fileName)
  } catch (err) {
    const matcher = /(%[a-f\d]{2})/gi
    return fileName
      .split(matcher)
      .map((str) => {
        try {
          return decodeURIComponent(str)
        } catch (err) {
          return ''
        }
      })
      .join('')
  }
}

/**
 * Parses filename and extension and returns object {name, extension}.
 */
type ParseFileNameExtension = (
  preserveExtension: boolean | number,
  fileName: string,
) => {
  extension: string
  name: string
}
export const parseFileNameExtension: ParseFileNameExtension = (preserveExtension, fileName) => {
  const defaultResult = {
    name: fileName,
    extension: '',
  }
  if (!preserveExtension) {
    return defaultResult
  }

  // Define maximum extension length
  const maxExtLength =
    typeof preserveExtension === 'boolean' ? MAX_EXTENSION_LENGTH : preserveExtension

  const nameParts = fileName.split('.')
  if (nameParts.length < 2) {
    return defaultResult
  }

  let extension = nameParts.pop()
  if (extension.length > maxExtLength && maxExtLength > 0) {
    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength)
    extension = extension.substr(-maxExtLength)
  }

  return {
    name: nameParts.join('.'),
    extension: maxExtLength ? extension : '',
  }
}

/**
 * Parse file name and extension.
 */
type ParseFileName = (opts: FetchAPIFileUploadOptions, fileName: string) => string
export const parseFileName: ParseFileName = (opts, fileName) => {
  // Check fileName argument
  if (!fileName || typeof fileName !== 'string') {
    return getTempFilename()
  }
  // Cut off file name if it's length more then 255.
  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255)
  // Decode file name if uriDecodeFileNames option set true.
  parsedName = uriDecodeFileName(opts, parsedName)
  // Stop parsing file name if safeFileNames options hasn't been set.
  if (!opts.safeFileNames) {
    return parsedName
  }
  // Set regular expression for the file name.
  const nameRegex =
    typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp
      ? opts.safeFileNames
      : SAFE_FILE_NAME_REGEX
  // Parse file name extension.
  const parsedFileName = parseFileNameExtension(opts.preserveExtension, parsedName)
  if (parsedFileName.extension.length) {
    parsedFileName.extension = '.' + parsedFileName.extension.replace(nameRegex, '')
  }

  return parsedFileName.name.replace(nameRegex, '').concat(parsedFileName.extension)
}
</file>

<file path="packages/payload/src/uploads/fetchAPI-stream-file/index.ts">
// @ts-strict-ignore
import fs from 'fs'

export function iteratorToStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await iterator.next()
      if (done) {
        controller.close()
      } else {
        controller.enqueue(value)
      }
    },
  })
}

export async function* nodeStreamToIterator(stream: fs.ReadStream) {
  for await (const chunk of stream) {
    yield new Uint8Array(chunk)
  }
}

export function streamFile(path: string): ReadableStream {
  const nodeStream = fs.createReadStream(path)
  const data: ReadableStream = iteratorToStream(nodeStreamToIterator(nodeStream))
  return data
}
</file>

<file path="packages/payload/src/uploads/canResizeImage.ts">
export function canResizeImage(mimeType: string): boolean {
  return (
    ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/tiff', 'image/avif'].indexOf(
      mimeType,
    ) > -1
  )
}
</file>

<file path="packages/payload/src/uploads/checkFileAccess.ts">
// @ts-strict-ignore
import type { Collection, TypeWithID } from '../collections/config/types.js'
import type { PayloadRequest, Where } from '../types/index.js'

import executeAccess from '../auth/executeAccess.js'
import { Forbidden } from '../errors/Forbidden.js'

export const checkFileAccess = async ({
  collection,
  filename,
  req,
}: {
  collection: Collection
  filename: string
  req: PayloadRequest
}): Promise<TypeWithID> => {
  if (filename.includes('../') || filename.includes('..\\')) {
    throw new Forbidden(req.t)
  }
  const { config } = collection

  const accessResult = await executeAccess(
    { data: { filename }, isReadingStaticFile: true, req },
    config.access.read,
  )

  if (typeof accessResult === 'object') {
    const queryToBuild: Where = {
      and: [
        {
          or: [
            {
              filename: {
                equals: filename,
              },
            },
          ],
        },
        accessResult,
      ],
    }

    if (config.upload.imageSizes) {
      config.upload.imageSizes.forEach(({ name }) => {
        queryToBuild.and[0].or.push({
          [`sizes.${name}.filename`]: {
            equals: filename,
          },
        })
      })
    }

    const doc = await req.payload.db.findOne({
      collection: config.slug,
      req,
      where: queryToBuild,
    })

    if (!doc) {
      throw new Forbidden(req.t)
    }

    return doc
  }
}
</file>

<file path="packages/payload/src/uploads/cropImage.ts">
// @ts-strict-ignore
import type { SharpOptions } from 'sharp'

import type { SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { WithMetadata } from './optionallyAppendMetadata.js'
import type { UploadEdits } from './types.js'

import { optionallyAppendMetadata } from './optionallyAppendMetadata.js'

export const percentToPixel = (value, dimension) => {
  return Math.floor((parseFloat(value) / 100) * dimension)
}

type CropImageArgs = {
  cropData: UploadEdits['crop']
  dimensions: { height: number; width: number }
  file: PayloadRequest['file']
  heightInPixels: number
  req?: PayloadRequest
  sharp: SanitizedConfig['sharp']
  widthInPixels: number
  withMetadata?: WithMetadata
}
export async function cropImage({
  cropData,
  dimensions,
  file,
  heightInPixels,
  req,
  sharp,
  widthInPixels,
  withMetadata,
}: CropImageArgs) {
  try {
    const { x, y } = cropData

    const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)

    const sharpOptions: SharpOptions = {}

    if (fileIsAnimatedType) {
      sharpOptions.animated = true
    }

    const formattedCropData = {
      height: Number(heightInPixels),
      left: percentToPixel(x, dimensions.width),
      top: percentToPixel(y, dimensions.height),
      width: Number(widthInPixels),
    }

    let cropped = sharp(file.tempFilePath || file.data, sharpOptions).extract(formattedCropData)

    cropped = await optionallyAppendMetadata({
      req,
      sharpFile: cropped,
      withMetadata,
    })

    return await cropped.toBuffer({
      resolveWithObject: true,
    })
  } catch (error) {
    console.error(`Error cropping image:`, error)
    throw error
  }
}
</file>

<file path="packages/payload/src/uploads/deleteAssociatedFiles.ts">
import fs from 'fs/promises'

import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { FileData, FileToSave } from './types.js'

import { ErrorDeletingFile } from '../errors/index.js'
import fileExists from './fileExists.js'

type Args = {
  collectionConfig: SanitizedCollectionConfig
  config: SanitizedConfig
  doc: Record<string, unknown>
  files?: FileToSave[]
  overrideDelete: boolean
  req: PayloadRequest
}

export const deleteAssociatedFiles: (args: Args) => Promise<void> = async ({
  collectionConfig,
  doc,
  files = [],
  overrideDelete,
  req,
}) => {
  if (!collectionConfig.upload) {
    return
  }
  if (overrideDelete || files.length > 0) {
    const { staticDir: staticPath } = collectionConfig.upload

    const fileToDelete = `${staticPath}/${doc.filename as string}`

    try {
      if (await fileExists(fileToDelete)) {
        await fs.unlink(fileToDelete)
      }
    } catch (err) {
      throw new ErrorDeletingFile(req.t)
    }

    if (doc.sizes) {
      const sizes: FileData[] = Object.values(doc.sizes)
      // Since forEach will not wait until unlink is finished it could
      // happen that two operations will try to delete the same file.
      // To avoid this it is recommended to use "sync" instead

      for (const size of sizes) {
        const sizeToDelete = `${staticPath}/${size.filename}`
        try {
          if (await fileExists(sizeToDelete)) {
            await fs.unlink(sizeToDelete)
          }
        } catch (err) {
          throw new ErrorDeletingFile(req.t)
        }
      }
    }
  }
}
</file>

<file path="packages/payload/src/uploads/docWithFilenameExists.ts">
import type { PayloadRequest } from '../types/index.js'

type Args = {
  collectionSlug: string
  filename: string
  path: string
  req: PayloadRequest
}

const docWithFilenameExists = async ({ collectionSlug, filename, req }: Args): Promise<boolean> => {
  const doc = await req.payload.db.findOne({
    collection: collectionSlug,
    req,
    where: {
      filename: {
        equals: filename,
      },
    },
  })
  if (doc) {
    return true
  }

  return false
}

export default docWithFilenameExists
</file>

<file path="packages/payload/src/uploads/fileExists.ts">
import fs from 'fs/promises'

const fileExists = async (filename: string): Promise<boolean> => {
  try {
    await fs.stat(filename)

    return true
  } catch (err) {
    return false
  }
}

export default fileExists
</file>

<file path="packages/payload/src/uploads/formatFilesize.ts">
export function formatFilesize(bytes: number, decimals = 0): string {
  if (bytes === 0) {
    return '0 bytes'
  }

  const k = 1024
  const dm = decimals < 0 ? 0 : decimals
  const sizes = [' bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return `${parseFloat((bytes / k ** i).toFixed(dm))}${sizes[i]}`
}
</file>

<file path="packages/payload/src/uploads/generateFileData.ts">
// @ts-strict-ignore
import type { OutputInfo, Sharp, SharpOptions } from 'sharp'

import { fileTypeFromBuffer } from 'file-type'
import fs from 'fs/promises'
import sanitize from 'sanitize-filename'

import type { Collection } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'

import { FileRetrievalError, FileUploadError, MissingFile } from '../errors/index.js'
import { canResizeImage } from './canResizeImage.js'
import { cropImage } from './cropImage.js'
import { getExternalFile } from './getExternalFile.js'
import { getFileByPath } from './getFileByPath.js'
import { getImageSize } from './getImageSize.js'
import { getSafeFileName } from './getSafeFilename.js'
import { resizeAndTransformImageSizes } from './imageResizer.js'
import { isImage } from './isImage.js'
import { optionallyAppendMetadata } from './optionallyAppendMetadata.js'

type Args<T> = {
  collection: Collection
  config: SanitizedConfig
  data: T
  isDuplicating?: boolean
  operation: 'create' | 'update'
  originalDoc?: T
  overwriteExistingFiles?: boolean
  req: PayloadRequest
  throwOnMissingFile?: boolean
}

type Result<T> = Promise<{
  data: T
  files: FileToSave[]
}>

export const generateFileData = async <T>({
  collection: { config: collectionConfig },
  data,
  isDuplicating,
  operation,
  originalDoc,
  overwriteExistingFiles,
  req,
  throwOnMissingFile,
}: Args<T>): Result<T> => {
  if (!collectionConfig.upload) {
    return {
      data,
      files: [],
    }
  }

  const { sharp } = req.payload.config

  let file = req.file

  const uploadEdits = parseUploadEditsFromReqOrIncomingData({
    data,
    isDuplicating,
    operation,
    originalDoc,
    req,
  })

  const {
    disableLocalStorage,
    focalPoint: focalPointEnabled = true,
    formatOptions,
    imageSizes,
    resizeOptions,
    staticDir,
    trimOptions,
    withMetadata,
  } = collectionConfig.upload

  const staticPath = staticDir

  const incomingFileData = isDuplicating ? originalDoc : data

  if (!file && uploadEdits && incomingFileData) {
    const { filename, url } = incomingFileData as FileData

    try {
      if (url && url.startsWith('/') && !disableLocalStorage) {
        const filePath = `${staticPath}/${filename}`
        const response = await getFileByPath(filePath)
        file = response
        overwriteExistingFiles = true
      } else if (filename && url) {
        file = await getExternalFile({
          data: incomingFileData as FileData,
          req,
          uploadConfig: collectionConfig.upload,
        })
        overwriteExistingFiles = true
      }
    } catch (err: unknown) {
      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)
    }
  }

  if (isDuplicating) {
    overwriteExistingFiles = false
  }

  if (!file) {
    if (throwOnMissingFile) {
      throw new MissingFile(req.t)
    }

    return {
      data,
      files: [],
    }
  }

  if (!disableLocalStorage) {
    await fs.mkdir(staticPath, { recursive: true })
  }

  let newData = data
  const filesToSave: FileToSave[] = []
  const fileData: Partial<FileData> = {}
  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)
  const cropData =
    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined

  try {
    const fileSupportsResize = canResizeImage(file.mimetype)
    let fsSafeName: string
    let sharpFile: Sharp | undefined
    let dimensions: ProbedImageSize | undefined
    let fileBuffer: { data: Buffer; info: OutputInfo }
    let ext
    let mime: string
    const fileHasAdjustments =
      fileSupportsResize &&
      Boolean(resizeOptions || formatOptions || trimOptions || file.tempFilePath)

    const sharpOptions: SharpOptions = {}

    if (fileIsAnimatedType) {
      sharpOptions.animated = true
    }

    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {
      if (file.tempFilePath) {
        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
      } else {
        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
      }

      if (fileHasAdjustments) {
        if (resizeOptions) {
          sharpFile = sharpFile.resize(resizeOptions)
        }
        if (formatOptions) {
          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)
        }
        if (trimOptions) {
          sharpFile = sharpFile.trim(trimOptions)
        }
      }
    }

    if (fileSupportsResize || isImage(file.mimetype)) {
      dimensions = await getImageSize(file)
      fileData.width = dimensions.width
      fileData.height = dimensions.height
    }

    if (sharpFile) {
      const metadata = await sharpFile.metadata()
      sharpFile = await optionallyAppendMetadata({
        req,
        sharpFile,
        withMetadata,
      })
      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })
      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.
      fileData.width = fileBuffer.info.width
      fileData.height = fileBuffer.info.height
      fileData.filesize = fileBuffer.info.size

      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages
      if (metadata.pages) {
        fileData.height = fileBuffer.info.height / metadata.pages
        fileData.filesize = fileBuffer.data.length
      }
    } else {
      mime = file.mimetype
      fileData.filesize = file.size

      if (file.name.includes('.')) {
        ext = file.name.split('.').pop().split('?')[0]
      } else {
        ext = ''
      }
    }

    // Adjust SVG mime type. fromBuffer modifies it.
    if (mime === 'application/xml' && ext === 'svg') {
      mime = 'image/svg+xml'
    }
    fileData.mimeType = mime

    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)
    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`

    if (!overwriteExistingFiles) {
      fsSafeName = await getSafeFileName({
        collectionSlug: collectionConfig.slug,
        desiredFilename: fsSafeName,
        req,
        staticPath,
      })
    }

    fileData.filename = fsSafeName
    let fileForResize = file

    if (cropData && sharp) {
      const { data: croppedImage, info } = await cropImage({
        cropData,
        dimensions,
        file,
        heightInPixels: uploadEdits.heightInPixels,
        req,
        sharp,
        widthInPixels: uploadEdits.widthInPixels,
        withMetadata,
      })

      // Apply resize after cropping to ensure it conforms to resizeOptions
      if (resizeOptions) {
        const resizedAfterCrop = await sharp(croppedImage)
          .resize({
            fit: resizeOptions?.fit || 'cover',
            height: resizeOptions?.height,
            position: resizeOptions?.position || 'center',
            width: resizeOptions?.width,
          })
          .toBuffer({ resolveWithObject: true })

        filesToSave.push({
          buffer: resizedAfterCrop.data,
          path: `${staticPath}/${fsSafeName}`,
        })

        fileForResize = {
          ...fileForResize,
          data: resizedAfterCrop.data,
          size: resizedAfterCrop.info.size,
        }

        fileData.width = resizedAfterCrop.info.width
        fileData.height = resizedAfterCrop.info.height
        if (fileIsAnimatedType) {
          const metadata = await sharpFile.metadata()
          fileData.height = metadata.pages
            ? resizedAfterCrop.info.height / metadata.pages
            : resizedAfterCrop.info.height
        }
        fileData.filesize = resizedAfterCrop.info.size
      } else {
        // If resizeOptions is not present, just save the cropped image
        filesToSave.push({
          buffer: croppedImage,
          path: `${staticPath}/${fsSafeName}`,
        })

        fileForResize = {
          ...file,
          data: croppedImage,
          size: info.size,
        }

        fileData.width = info.width
        fileData.height = info.height
        if (fileIsAnimatedType) {
          const metadata = await sharpFile.metadata()
          fileData.height = metadata.pages ? info.height / metadata.pages : info.height
        }
        fileData.filesize = info.size
      }

      if (file.tempFilePath) {
        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path
      } else {
        req.file = fileForResize
      }
    } else {
      filesToSave.push({
        buffer: fileBuffer?.data || file.data,
        path: `${staticPath}/${fsSafeName}`,
      })

      // If using temp files and the image is being resized, write the file to the temp path
      if (fileBuffer?.data || file.data.length > 0) {
        if (file.tempFilePath) {
          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path
        } else {
          // Assign the _possibly modified_ file to the request object
          req.file = {
            ...file,
            data: fileBuffer?.data || file.data,
            size: fileBuffer?.info.size,
          }
        }
      }
    }

    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {
      req.payloadUploadSizes = {}
      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({
        config: collectionConfig,
        dimensions: !cropData
          ? dimensions
          : {
              ...dimensions,
              height: fileData.height,
              width: fileData.width,
            },
        file: fileForResize,
        mimeType: fileData.mimeType,
        req,
        savedFilename: fsSafeName || file.name,
        sharp,
        staticPath,
        uploadEdits,
        withMetadata,
      })

      fileData.sizes = sizeData
      fileData.focalX = focalPoint?.x
      fileData.focalY = focalPoint?.y
      filesToSave.push(...sizesToSave)
    }
  } catch (err) {
    req.payload.logger.error(err)
    throw new FileUploadError(req.t)
  }

  newData = {
    ...newData,
    ...fileData,
  }

  return {
    data: newData,
    files: filesToSave,
  }
}

/**
 * Parse upload edits from req or incoming data
 */
function parseUploadEditsFromReqOrIncomingData(args: {
  data: unknown
  isDuplicating?: boolean
  operation: 'create' | 'update'
  originalDoc: unknown
  req: PayloadRequest
}): UploadEdits {
  const { data, isDuplicating, operation, originalDoc, req } = args

  // Get intended focal point change from query string or incoming data
  const uploadEdits =
    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'
      ? (req.query.uploadEdits as UploadEdits)
      : {}

  if (uploadEdits.focalPoint) {
    return uploadEdits
  }

  const incomingData = data as FileData
  const origDoc = originalDoc as FileData

  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {
    // If no change in focal point, return undefined.
    // This prevents a refocal operation triggered from admin, because it always sends the focal point.
    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {
      return undefined
    }

    if (isDuplicating) {
      uploadEdits.focalPoint = {
        x: incomingData?.focalX || origDoc.focalX,
        y: incomingData?.focalY || origDoc.focalX,
      }
    }
  }

  if (incomingData?.focalX && incomingData?.focalY) {
    uploadEdits.focalPoint = {
      x: incomingData.focalX,
      y: incomingData.focalY,
    }
    return uploadEdits
  }

  // If no focal point is set, default to center
  if (operation === 'create') {
    uploadEdits.focalPoint = {
      x: 50,
      y: 50,
    }
  }

  return uploadEdits
}
</file>

<file path="packages/payload/src/uploads/getBaseFields.ts">
// @ts-strict-ignore
import type { CollectionConfig } from '../collections/config/types.js'
import type { Config } from '../config/types.js'
import type { Field } from '../fields/config/types.js'
import type { UploadConfig } from './types.js'

import { mimeTypeValidator } from './mimeTypeValidator.js'

type GenerateURLArgs = {
  collectionSlug: string
  config: Config
  filename?: string
}
const generateURL = ({ collectionSlug, config, filename }: GenerateURLArgs) => {
  if (filename) {
    return `${config.serverURL || ''}${config.routes.api || ''}/${collectionSlug}/file/${encodeURIComponent(filename)}`
  }
  return undefined
}

type Options = {
  collection: CollectionConfig
  config: Config
}

export const getBaseUploadFields = ({ collection, config }: Options): Field[] => {
  const uploadOptions: UploadConfig = typeof collection.upload === 'object' ? collection.upload : {}

  const mimeType: Field = {
    name: 'mimeType',
    type: 'text',
    admin: {
      hidden: true,
      readOnly: true,
    },
    label: 'MIME Type',
  }

  const thumbnailURL: Field = {
    name: 'thumbnailURL',
    type: 'text',
    admin: {
      hidden: true,
      readOnly: true,
    },
    hooks: {
      afterRead: [
        ({ originalDoc }) => {
          const adminThumbnail =
            typeof collection.upload !== 'boolean' ? collection.upload?.adminThumbnail : undefined

          if (typeof adminThumbnail === 'function') {
            return adminThumbnail({ doc: originalDoc })
          }

          if (
            typeof adminThumbnail === 'string' &&
            'sizes' in originalDoc &&
            originalDoc.sizes?.[adminThumbnail]?.filename
          ) {
            return generateURL({
              collectionSlug: collection.slug,
              config,
              filename: originalDoc.sizes?.[adminThumbnail].filename as string,
            })
          }

          return null
        },
      ],
    },
    label: 'Thumbnail URL',
  }

  const width: Field = {
    name: 'width',
    type: 'number',
    admin: {
      hidden: true,
      readOnly: true,
    },
    label: ({ t }) => t('upload:width'),
  }

  const height: Field = {
    name: 'height',
    type: 'number',
    admin: {
      hidden: true,
      readOnly: true,
    },
    label: ({ t }) => t('upload:height'),
  }

  const filesize: Field = {
    name: 'filesize',
    type: 'number',
    admin: {
      hidden: true,
      readOnly: true,
    },
    label: ({ t }) => t('upload:fileSize'),
  }

  const filename: Field = {
    name: 'filename',
    type: 'text',
    admin: {
      disableBulkEdit: true,
      hidden: true,
      readOnly: true,
    },
    index: true,
    label: ({ t }) => t('upload:fileName'),
  }

  // Only set unique: true if the collection does not have a compound index
  if (
    collection.upload === true ||
    (typeof collection.upload === 'object' && !collection.upload.filenameCompoundIndex)
  ) {
    filename.unique = true
  }

  const url: Field = {
    name: 'url',
    type: 'text',
    admin: {
      hidden: true,
      readOnly: true,
    },
    label: 'URL',
  }

  let uploadFields: Field[] = [
    {
      ...url,
      hooks: {
        afterRead: [
          ({ data, value }) => {
            if (value && !data.filename) {
              return value
            }

            return generateURL({
              collectionSlug: collection.slug,
              config,
              filename: data?.filename,
            })
          },
        ],
      },
    },
    thumbnailURL,
    filename,
    mimeType,
    filesize,
    width,
    height,
  ]

  // Add focal point fields if not disabled
  if (
    uploadOptions.focalPoint !== false ||
    uploadOptions.imageSizes ||
    uploadOptions.resizeOptions
  ) {
    uploadFields = uploadFields.concat(
      ['focalX', 'focalY'].map((name) => {
        return {
          name,
          type: 'number',
          admin: {
            disableListColumn: true,
            disableListFilter: true,
            hidden: true,
          },
        }
      }),
    )
  }

  if (uploadOptions.mimeTypes) {
    mimeType.validate = mimeTypeValidator(uploadOptions.mimeTypes)
  }

  if (uploadOptions.imageSizes) {
    uploadFields = uploadFields.concat([
      {
        name: 'sizes',
        type: 'group',
        admin: {
          hidden: true,
        },
        fields: uploadOptions.imageSizes.map((size) => ({
          name: size.name,
          type: 'group',
          admin: {
            hidden: true,
          },
          fields: [
            {
              ...url,
              hooks: {
                afterRead: [
                  ({ data, value }) => {
                    if (value && size.height && size.width && !data.filename) {
                      return value
                    }

                    const sizeFilename = data?.sizes?.[size.name]?.filename

                    if (sizeFilename) {
                      return `${config.serverURL}${config.routes.api}/${collection.slug}/file/${sizeFilename}`
                    }

                    return null
                  },
                ],
              },
            },
            width,
            height,
            mimeType,
            filesize,
            {
              ...filename,
              unique: false,
            },
          ],
          label: size.name,
        })),
        label: ({ t }) => t('upload:sizes'),
      },
    ])
  }
  return uploadFields
}
</file>

<file path="packages/payload/src/uploads/getExternalFile.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../types/index.js'
import type { File, FileData, UploadConfig } from './types.js'

import { APIError } from '../errors/index.js'

type Args = {
  data: FileData
  req: PayloadRequest
  uploadConfig: UploadConfig
}
export const getExternalFile = async ({ data, req, uploadConfig }: Args): Promise<File> => {
  const { filename, url } = data

  if (typeof url === 'string') {
    let fileURL = url
    if (!url.startsWith('http')) {
      const baseUrl = req.headers.get('origin') || `${req.protocol}://${req.headers.get('host')}`
      fileURL = `${baseUrl}${url}`
    }

    const headers = uploadConfig.externalFileHeaderFilter
      ? uploadConfig.externalFileHeaderFilter(Object.fromEntries(new Headers(req.headers)))
      : { cookie: req.headers?.get('cookie') }

    const res = await fetch(fileURL, {
      credentials: 'include',
      headers,
      method: 'GET',
    })

    if (!res.ok) {
      throw new APIError(`Failed to fetch file from ${fileURL}`, res.status)
    }

    const data = await res.arrayBuffer()

    return {
      name: filename,
      data: Buffer.from(data),
      mimetype: res.headers.get('content-type') || undefined,
      size: Number(res.headers.get('content-length')) || 0,
    }
  }

  throw new APIError('Invalid file url', 400)
}
</file>

<file path="packages/payload/src/uploads/getFileByPath.ts">
// @ts-strict-ignore
import { fileTypeFromFile } from 'file-type'
import fs from 'fs/promises'
import path from 'path'

import type { PayloadRequest } from '../types/index.js'

const mimeTypeEstimate = {
  svg: 'image/svg+xml',
}

export const getFileByPath = async (filePath: string): Promise<PayloadRequest['file']> => {
  if (typeof filePath === 'string') {
    const data = await fs.readFile(filePath)
    const mimetype = fileTypeFromFile(filePath)
    const { size } = await fs.stat(filePath)

    const name = path.basename(filePath)
    const ext = path.extname(filePath).slice(1)

    const mime = (await mimetype)?.mime || mimeTypeEstimate[ext]

    return {
      name,
      data,
      mimetype: mime,
      size,
    }
  }

  return undefined
}
</file>

<file path="packages/payload/src/uploads/getFileTypeFallback.ts">
type ReturnType = {
  ext: string
  mime: string
}

const extensionMap: {
  [ext: string]: string
} = {
  css: 'text/css',
  csv: 'text/csv',
  htm: 'text/html',
  html: 'text/html',
  js: 'application/javascript',
  json: 'application/json',
  md: 'text/markdown',
  svg: 'image/svg+xml',
  xml: 'application/xml',
  yml: 'application/x-yaml',
}

export const getFileTypeFallback = (path: string): ReturnType => {
  const ext = path.split('.').pop() || 'txt'

  return {
    ext,
    mime: extensionMap[ext] || 'text/plain',
  }
}
</file>

<file path="packages/payload/src/uploads/getImageSize.ts">
// @ts-strict-ignore
import fs from 'fs/promises'
import { imageSize } from 'image-size'
import { imageSizeFromFile } from 'image-size/fromFile'

import type { PayloadRequest } from '../types/index.js'
import type { ProbedImageSize } from './types.js'

import { temporaryFileTask } from './tempFile.js'

export async function getImageSize(file: PayloadRequest['file']): Promise<ProbedImageSize> {
  if (file.tempFilePath) {
    return imageSizeFromFile(file.tempFilePath)
  }

  // Tiff file do not support buffers or streams, so we must write to file first
  // then retrieve dimensions. https://github.com/image-size/image-size/issues/103
  if (file.mimetype === 'image/tiff') {
    const dimensions = await temporaryFileTask(
      async (filepath: string) => {
        await fs.writeFile(filepath, file.data)
        return imageSizeFromFile(filepath)
      },
      { extension: 'tiff' },
    )
    return dimensions
  }

  return imageSize(file.data)
}
</file>

<file path="packages/payload/src/uploads/getSafeFilename.ts">
import sanitize from 'sanitize-filename'

import type { PayloadRequest } from '../types/index.js'

import docWithFilenameExists from './docWithFilenameExists.js'
import fileExists from './fileExists.js'

const incrementName = (name: string) => {
  const extension = name.split('.').pop()
  const baseFilename = sanitize(name.substring(0, name.lastIndexOf('.')) || name)
  let incrementedName = baseFilename
  const regex = /(.*)-(\d+)$/
  const found = baseFilename.match(regex)
  if (found === null) {
    incrementedName += '-1'
  } else {
    const matchedName = found[1]
    const matchedNumber = found[2]
    const incremented = Number(matchedNumber) + 1
    incrementedName = `${matchedName}-${incremented}`
  }
  return `${incrementedName}.${extension}`
}

type Args = {
  collectionSlug: string
  desiredFilename: string
  req: PayloadRequest
  staticPath: string
}

export async function getSafeFileName({
  collectionSlug,
  desiredFilename,
  req,
  staticPath,
}: Args): Promise<string> {
  let modifiedFilename = desiredFilename

  while (
    (await docWithFilenameExists({
      collectionSlug,
      filename: modifiedFilename,
      path: staticPath,
      req,
    })) ||
    (await fileExists(`${staticPath}/${modifiedFilename}`))
  ) {
    modifiedFilename = incrementName(modifiedFilename)
  }
  return modifiedFilename
}
</file>

<file path="packages/payload/src/uploads/imageResizer.ts">
// @ts-strict-ignore
import type { Sharp, Metadata as SharpMetadata, SharpOptions } from 'sharp'

import { fileTypeFromBuffer } from 'file-type'
import fs from 'fs/promises'
import sanitize from 'sanitize-filename'

import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SharpDependency } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { WithMetadata } from './optionallyAppendMetadata.js'
import type {
  FileSize,
  FileSizes,
  FileToSave,
  ImageSize,
  ProbedImageSize,
  UploadEdits,
} from './types.js'

import { isNumber } from '../utilities/isNumber.js'
import fileExists from './fileExists.js'
import { optionallyAppendMetadata } from './optionallyAppendMetadata.js'

type ResizeArgs = {
  config: SanitizedCollectionConfig
  dimensions: ProbedImageSize
  file: PayloadRequest['file']
  mimeType: string
  req: PayloadRequest
  savedFilename: string
  sharp?: SharpDependency
  staticPath: string
  uploadEdits?: UploadEdits
  withMetadata?: WithMetadata
}

/** Result from resizing and transforming the requested image sizes */
type ImageSizesResult = {
  focalPoint?: UploadEdits['focalPoint']
  sizeData: FileSizes
  sizesToSave: FileToSave[]
}

type SanitizedImageData = {
  ext: string
  name: string
}

/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */
const getSanitizedImageData = (sourceImage: string): SanitizedImageData => {
  const extension = sourceImage.split('.').pop()
  const name = sanitize(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage)
  return { name, ext: extension }
}

/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */
type CreateImageNameArgs = {
  extension: string
  height: number
  outputImageName: string
  width: number
}
const createImageName = ({
  extension,
  height,
  outputImageName,
  width,
}: CreateImageNameArgs): string => {
  return `${outputImageName}-${width}x${height}.${extension}`
}

type CreateResultArgs = {
  filename?: FileSize['filename']
  filesize?: FileSize['filesize']
  height?: FileSize['height']
  mimeType?: FileSize['mimeType']
  name: string
  sizesToSave?: FileToSave[]
  width?: FileSize['width']
}

/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */
const createResult = ({
  name,
  filename = null,
  filesize = null,
  height = null,
  mimeType = null,
  sizesToSave = [],
  width = null,
}: CreateResultArgs): ImageSizesResult => {
  return {
    sizeData: {
      [name]: {
        filename,
        filesize,
        height,
        mimeType,
        width,
      },
    },
    sizesToSave,
  }
}

/**
 * Determine whether or not to resize the image.
 * - resize using image config
 * - resize using image config with focal adjustments
 * - do not resize at all
 *
 * `imageResizeConfig.withoutEnlargement`:
 * - undefined [default]: uploading images with smaller width AND height than the image size will return null
 * - false: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * `imageResizeConfig.withoutReduction`:
 * - false [default]: always enlarge images to the image size
 * - true: if the image is smaller than the image size, return the original image
 *
 * @return 'omit' | 'resize' | 'resizeWithFocalPoint'
 */
const getImageResizeAction = ({
  dimensions: originalImage,
  hasFocalPoint,
  imageResizeConfig,
}: {
  dimensions: ProbedImageSize
  hasFocalPoint?: boolean
  imageResizeConfig: ImageSize
}): 'omit' | 'resize' | 'resizeWithFocalPoint' => {
  const {
    fit,
    height: targetHeight,
    width: targetWidth,
    withoutEnlargement,
    withoutReduction,
  } = imageResizeConfig

  // prevent upscaling by default when x and y are both smaller than target image size
  if (targetHeight && targetWidth) {
    const originalImageIsSmallerXAndY =
      originalImage.width < targetWidth && originalImage.height < targetHeight
    if (withoutEnlargement === undefined && originalImageIsSmallerXAndY) {
      return 'omit' // prevent image size from being enlarged
    }
  }

  if (withoutEnlargement === undefined && (!targetWidth || !targetHeight)) {
    if (
      (targetWidth && originalImage.width < targetWidth) ||
      (targetHeight && originalImage.height < targetHeight)
    ) {
      return 'omit'
    }
  }

  const originalImageIsSmallerXOrY =
    originalImage.width < targetWidth || originalImage.height < targetHeight
  if (fit === 'contain' || fit === 'inside') {
    return 'resize'
  }
  if (!isNumber(targetHeight) && !isNumber(targetWidth)) {
    return 'resize'
  }

  const targetAspectRatio = targetWidth / targetHeight
  const originalAspectRatio = originalImage.width / originalImage.height
  if (originalAspectRatio === targetAspectRatio) {
    return 'resize'
  }

  if (withoutEnlargement && originalImageIsSmallerXOrY) {
    return 'resize'
  }
  if (withoutReduction && !originalImageIsSmallerXOrY) {
    return 'resize'
  }

  return hasFocalPoint ? 'resizeWithFocalPoint' : 'resize'
}

/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */
const sanitizeResizeConfig = (resizeConfig: ImageSize): ImageSize => {
  if (resizeConfig.withoutReduction) {
    return {
      ...resizeConfig,
      // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
      fit: resizeConfig?.fit || 'contain',
      position: resizeConfig?.position || 'left top',
    }
  }
  return resizeConfig
}

/**
 * Used to extract height from images, animated or not.
 *
 * @param sharpMetadata - the sharp metadata
 * @returns the height of the image
 */
function extractHeightFromImage(sharpMetadata: SharpMetadata): number {
  if (sharpMetadata?.pages) {
    return sharpMetadata.height / sharpMetadata.pages
  }
  return sharpMetadata.height
}

/**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that does not need to be resized, a result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */
export async function resizeAndTransformImageSizes({
  config,
  dimensions,
  file,
  mimeType,
  req,
  savedFilename,
  sharp,
  staticPath,
  uploadEdits,
  withMetadata,
}: ResizeArgs): Promise<ImageSizesResult> {
  const { focalPoint: focalPointEnabled = true, imageSizes } = config.upload

  // Focal point adjustments
  const incomingFocalPoint = uploadEdits.focalPoint
    ? {
        x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,
        y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,
      }
    : undefined

  const defaultResult: ImageSizesResult = {
    ...(focalPointEnabled && incomingFocalPoint && { focalPoint: incomingFocalPoint }),
    sizeData: {},
    sizesToSave: [],
  }

  if (!imageSizes || !sharp) {
    return defaultResult
  }

  // Determine if the file is animated
  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)
  const sharpOptions: SharpOptions = {}

  if (fileIsAnimatedType) {
    sharpOptions.animated = true
  }

  const sharpBase: Sharp | undefined = sharp(file.tempFilePath || file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
  const originalImageMeta = await sharpBase.metadata()

  let adjustedDimensions = { ...dimensions }

  // Images with an exif orientation of 5, 6, 7, or 8 are auto-rotated by sharp
  // Need to adjust the dimensions to match the original image
  if ([5, 6, 7, 8].includes(originalImageMeta.orientation)) {
    adjustedDimensions = {
      ...dimensions,
      height: dimensions.width,
      width: dimensions.height,
    }
  }

  const resizeImageMeta = {
    height: extractHeightFromImage(originalImageMeta),
    width: originalImageMeta.width,
  }

  const results: ImageSizesResult[] = await Promise.all(
    imageSizes.map(async (imageResizeConfig): Promise<ImageSizesResult> => {
      imageResizeConfig = sanitizeResizeConfig(imageResizeConfig)

      const resizeAction = getImageResizeAction({
        dimensions,
        hasFocalPoint: Boolean(incomingFocalPoint),
        imageResizeConfig,
      })
      if (resizeAction === 'omit') {
        return createResult({ name: imageResizeConfig.name })
      }

      const imageToResize = sharpBase.clone()
      let resized = imageToResize

      if (resizeAction === 'resizeWithFocalPoint') {
        let { height: resizeHeight, width: resizeWidth } = imageResizeConfig

        const originalAspectRatio = adjustedDimensions.width / adjustedDimensions.height

        // Calculate resizeWidth based on original aspect ratio if it's undefined
        if (resizeHeight && !resizeWidth) {
          resizeWidth = Math.round(resizeHeight * originalAspectRatio)
        }

        // Calculate resizeHeight based on original aspect ratio if it's undefined
        if (resizeWidth && !resizeHeight) {
          resizeHeight = Math.round(resizeWidth / originalAspectRatio)
        }

        if (!resizeHeight) {
          resizeHeight = resizeImageMeta.height
        }
        if (!resizeWidth) {
          resizeWidth = resizeImageMeta.width
        }

        const resizeAspectRatio = resizeWidth / resizeHeight
        const prioritizeHeight = resizeAspectRatio < originalAspectRatio
        // Scales the image before extracting from it
        resized = imageToResize.resize({
          fastShrinkOnLoad: false,
          height: prioritizeHeight ? resizeHeight : undefined,
          width: prioritizeHeight ? undefined : resizeWidth,
        })

        const metadataAppendedFile = await optionallyAppendMetadata({
          req,
          sharpFile: resized,
          withMetadata,
        })

        // Must read from buffer, resized.metadata will return the original image metadata
        const { info } = await metadataAppendedFile.toBuffer({ resolveWithObject: true })

        resizeImageMeta.height = extractHeightFromImage({
          ...originalImageMeta,
          height: info.height,
        })
        resizeImageMeta.width = info.width

        const halfResizeX = resizeWidth / 2
        const xFocalCenter = resizeImageMeta.width * (incomingFocalPoint.x / 100)
        const calculatedRightPixelBound = xFocalCenter + halfResizeX
        let leftBound = xFocalCenter - halfResizeX

        // if the right bound is greater than the image width, adjust the left bound
        // keeping focus on the right
        if (calculatedRightPixelBound > resizeImageMeta.width) {
          leftBound = resizeImageMeta.width - resizeWidth
        }

        // if the left bound is less than 0, adjust the left bound to 0
        // keeping the focus on the left
        if (leftBound < 0) {
          leftBound = 0
        }

        const halfResizeY = resizeHeight / 2
        const yFocalCenter = resizeImageMeta.height * (incomingFocalPoint.y / 100)
        const calculatedBottomPixelBound = yFocalCenter + halfResizeY
        let topBound = yFocalCenter - halfResizeY

        // if the bottom bound is greater than the image height, adjust the top bound
        // keeping the image as far right as possible
        if (calculatedBottomPixelBound > resizeImageMeta.height) {
          topBound = resizeImageMeta.height - resizeHeight
        }

        // if the top bound is less than 0, adjust the top bound to 0
        // keeping the image focus near the top
        if (topBound < 0) {
          topBound = 0
        }

        resized = resized.extract({
          height: resizeHeight,
          left: Math.floor(leftBound),
          top: Math.floor(topBound),
          width: resizeWidth,
        })
      } else {
        resized = imageToResize.resize(imageResizeConfig)
      }

      if (imageResizeConfig.formatOptions) {
        resized = resized.toFormat(
          imageResizeConfig.formatOptions.format,
          imageResizeConfig.formatOptions.options,
        )
      }

      if (imageResizeConfig.trimOptions) {
        resized = resized.trim(imageResizeConfig.trimOptions)
      }

      const metadataAppendedFile = await optionallyAppendMetadata({
        req,
        sharpFile: resized,
        withMetadata,
      })

      const { data: bufferData, info: bufferInfo } = await metadataAppendedFile.toBuffer({
        resolveWithObject: true,
      })

      const sanitizedImage = getSanitizedImageData(savedFilename)

      if (req.payloadUploadSizes) {
        req.payloadUploadSizes[imageResizeConfig.name] = bufferData
      }

      const mimeInfo = await fileTypeFromBuffer(bufferData)

      const imageNameWithDimensions = imageResizeConfig.generateImageName
        ? imageResizeConfig.generateImageName({
            extension: mimeInfo?.ext || sanitizedImage.ext,
            height: extractHeightFromImage({
              ...originalImageMeta,
              height: bufferInfo.height,
            }),
            originalName: sanitizedImage.name,
            sizeName: imageResizeConfig.name,
            width: bufferInfo.width,
          })
        : createImageName({
            extension: mimeInfo?.ext || sanitizedImage.ext,
            height: extractHeightFromImage({
              ...originalImageMeta,
              height: bufferInfo.height,
            }),
            outputImageName: sanitizedImage.name,
            width: bufferInfo.width,
          })

      const imagePath = `${staticPath}/${imageNameWithDimensions}`

      if (await fileExists(imagePath)) {
        try {
          await fs.unlink(imagePath)
        } catch {
          // Ignore unlink errors
        }
      }

      const { height, size, width } = bufferInfo
      return createResult({
        name: imageResizeConfig.name,
        filename: imageNameWithDimensions,
        filesize: size,
        height:
          fileIsAnimatedType && originalImageMeta.pages ? height / originalImageMeta.pages : height,
        mimeType: mimeInfo?.mime || mimeType,
        sizesToSave: [{ buffer: bufferData, path: imagePath }],
        width,
      })
    }),
  )

  return results.reduce(
    (acc, result) => {
      Object.assign(acc.sizeData, result.sizeData)
      acc.sizesToSave.push(...result.sizesToSave)
      return acc
    },
    { ...defaultResult },
  )
}
</file>

<file path="packages/payload/src/uploads/isImage.ts">
export function isImage(mimeType: string): boolean {
  return (
    [
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/svg+xml',
      'image/webp',
      'image/avif',
      'image/jxl',
    ].indexOf(mimeType) > -1
  )
}
</file>

<file path="packages/payload/src/uploads/mimeTypeValidator.spec.ts">
import type { ValidateOptions } from '../fields/config/types'

import { mimeTypeValidator } from './mimeTypeValidator'

const options = { siblingData: { filename: 'file.xyz' } } as ValidateOptions<
  undefined,
  undefined,
  undefined
>

describe('mimeTypeValidator', () => {
  it('should validate single mimeType', () => {
    const mimeTypes = ['image/png']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('image/png', options)).toBe(true)
  })

  it('should validate multiple mimeTypes', () => {
    const mimeTypes = ['image/png', 'application/pdf']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('image/png', options)).toBe(true)
    expect(validate('application/pdf', options)).toBe(true)
  })

  it('should validate using wildcard', () => {
    const mimeTypes = ['image/*']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('image/png', options)).toBe(true)
    expect(validate('image/gif', options)).toBe(true)
  })

  it('should validate multiple wildcards', () => {
    const mimeTypes = ['image/*', 'audio/*']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('image/png', options)).toBe(true)
    expect(validate('audio/mpeg', options)).toBe(true)
  })

  it('should not validate when unmatched', () => {
    const mimeTypes = ['image/png']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('audio/mpeg', options)).toBe("Invalid file type: 'audio/mpeg'")
  })

  it('should not validate when unmatched - multiple mimeTypes', () => {
    const mimeTypes = ['image/png', 'application/pdf']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('audio/mpeg', options)).toBe("Invalid file type: 'audio/mpeg'")
  })

  it('should not validate using wildcard - unmatched', () => {
    const mimeTypes = ['image/*']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('audio/mpeg', options)).toBe("Invalid file type: 'audio/mpeg'")
  })

  it('should not validate multiple wildcards - unmatched', () => {
    const mimeTypes = ['image/*', 'audio/*']
    const validate = mimeTypeValidator(mimeTypes)
    expect(validate('video/mp4', options)).toBe("Invalid file type: 'video/mp4'")
    expect(validate('application/pdf', options)).toBe("Invalid file type: 'application/pdf'")
  })

  it('should not error when mimeType is missing', () => {
    const mimeTypes = ['image/*', 'application/pdf']
    const validate = mimeTypeValidator(mimeTypes)
    let value
    expect(validate(value, options)).toBe('Invalid file type')
  })
})
</file>

<file path="packages/payload/src/uploads/mimeTypeValidator.ts">
import type { Validate } from '../fields/config/types.js'

import { validateMimeType } from '../utilities/validateMimeType.js'

export const mimeTypeValidator =
  (mimeTypes: string[]): Validate =>
  (val: string, { siblingData }) => {
    if (!siblingData.filename) {
      return true
    }

    if (!val) {
      return 'Invalid file type'
    }

    const isValidMimeType = validateMimeType(val, mimeTypes)
    return isValidMimeType ? true : `Invalid file type: '${val}'`
  }
</file>

<file path="packages/payload/src/uploads/optionallyAppendMetadata.ts">
import type { Sharp, Metadata as SharpMetadata } from 'sharp'

import type { PayloadRequest } from '../types/index.js'

export type WithMetadata =
  | ((options: { metadata: SharpMetadata; req: PayloadRequest }) => Promise<boolean>)
  | boolean

export async function optionallyAppendMetadata({
  req,
  sharpFile,
  withMetadata,
}: {
  req: PayloadRequest
  sharpFile: Sharp
  withMetadata: WithMetadata
}): Promise<Sharp> {
  const metadata = await sharpFile.metadata()

  if (withMetadata === true) {
    return sharpFile.withMetadata()
  } else if (typeof withMetadata === 'function') {
    const useMetadata = await withMetadata({ metadata, req })

    if (useMetadata) {
      return sharpFile.withMetadata()
    }
  }

  return sharpFile
}
</file>

<file path="packages/payload/src/uploads/saveBufferToFile.ts">
// @ts-strict-ignore
import fs from 'fs/promises'
import { Readable } from 'stream'

/**
 * Save buffer data to a file.
 * @param {Buffer} buffer - buffer to save to a file.
 * @param {string} filePath - path to a file.
 */
const saveBufferToFile = async (buffer: Buffer, filePath: string): Promise<void> => {
  // Setup readable stream from buffer.
  let streamData = buffer
  const readStream = new Readable()
  readStream._read = () => {
    readStream.push(streamData)
    streamData = null
  }
  // Setup file system writable stream.
  return await fs.writeFile(filePath, buffer)
}

export default saveBufferToFile
</file>

<file path="packages/payload/src/uploads/tempFile.ts">
// @ts-strict-ignore
import fs from 'fs/promises'
import os from 'node:os'
import path from 'node:path'
import { v4 as uuid } from 'uuid'

async function runTask(temporaryPath: string, callback) {
  try {
    return await callback(temporaryPath)
  } finally {
    await fs.rm(temporaryPath, { force: true, maxRetries: 2, recursive: true })
  }
}

type Options = {
  extension?: string
  name?: string
}

export const temporaryFileTask = async (callback, options: Options = {}) => {
  const filePath = await temporaryFile(options)
  return runTask(filePath, callback)
}

async function temporaryFile(options: Options) {
  if (options.name) {
    if (options.extension !== undefined && options.extension !== null) {
      throw new Error('The `name` and `extension` options are mutually exclusive')
    }

    return path.join(await temporaryDirectory(), options.name)
  }

  return (
    (await getPath()) +
    (options.extension === undefined || options.extension === null
      ? ''
      : '.' + options.extension.replace(/^\./, ''))
  )
}

async function temporaryDirectory({ prefix = '' } = {}) {
  const directory = await getPath(prefix)
  await fs.mkdir(directory)
  return directory
}

async function getPath(prefix = ''): Promise<string> {
  const temporaryDirectory = await fs.realpath(os.tmpdir())
  return path.join(temporaryDirectory, prefix + uuid())
}
</file>

<file path="packages/payload/src/uploads/types.ts">
import type { ResizeOptions, Sharp } from 'sharp'

import type { TypeWithID } from '../collections/config/types.js'
import type { PayloadRequest } from '../types/index.js'
import type { WithMetadata } from './optionallyAppendMetadata.js'

export type FileSize = {
  filename: null | string
  filesize: null | number
  height: null | number
  mimeType: null | string
  width: null | number
}

// TODO: deprecate in Payload v4.
/**
 * FileSizeImproved is a more precise type, and will replace FileSize in Payload v4.
 * This type is for internal use only as it will be deprecated in the future.
 * @internal
 */
export type FileSizeImproved = {
  url: null | string
} & FileSize

export type FileSizes = {
  [size: string]: FileSize
}

export type FileData = {
  filename: string
  filesize: number
  focalX?: number
  focalY?: number
  height: number
  mimeType: string
  sizes: FileSizes
  tempFilePath?: string
  url?: string
  width: number
}

export type ProbedImageSize = {
  height: number
  width: number
}

/**
 * Params sent to the sharp `toFormat()` function
 * @link https://sharp.pixelplumbing.com/api-output#toformat
 */
export type ImageUploadFormatOptions = {
  format: Parameters<Sharp['toFormat']>[0]
  options?: Parameters<Sharp['toFormat']>[1]
}

/**
 * Params sent to the sharp trim() function
 * @link https://sharp.pixelplumbing.com/api-resize#trim
 */
export type ImageUploadTrimOptions = Parameters<Sharp['trim']>[0]

export type GenerateImageName = (args: {
  extension: string
  height: number
  originalName: string
  sizeName: string
  width: number
}) => string

export type ImageSize = {
  /**
   * @deprecated prefer position
   */
  crop?: string // comes from sharp package
  formatOptions?: ImageUploadFormatOptions
  /**
   * Generate a custom name for the file of this image size.
   */
  generateImageName?: GenerateImageName
  name: string
  trimOptions?: ImageUploadTrimOptions
  /**
   * When an uploaded image is smaller than the defined image size, we have 3 options:
   *
   * `undefined | false | true`
   *
   * 1. `undefined` [default]: uploading images with smaller width AND height than the image size will return null
   * 2. `false`: always enlarge images to the image size
   * 3. `true`: if the image is smaller than the image size, return the original image
   */
  withoutEnlargement?: ResizeOptions['withoutEnlargement']
} & Omit<ResizeOptions, 'withoutEnlargement'>

export type GetAdminThumbnail = (args: { doc: Record<string, unknown> }) => false | null | string

export type AllowList = Array<{
  hostname: string
  pathname?: string
  port?: string
  protocol?: 'http' | 'https'
  search?: string
}>

export type UploadConfig = {
  /**
   * The adapter name to use for uploads. Used for storage adapter telemetry.
   * @default undefined
   */
  adapter?: string
  /**
   * Represents an admin thumbnail, which can be either a React component or a string.
   * - If a string, it should be one of the image size names.
   * - A function that generates a fully qualified URL for the thumbnail, receives the doc as the only argument.
   **/
  adminThumbnail?: GetAdminThumbnail | string
  /**
   * Enables bulk upload of files from the list view.
   * @default true
   */
  bulkUpload?: boolean
  /**
   * Appends a cache tag to the image URL when fetching the thumbnail in the admin panel. It may be desirable to disable this when hosting via CDNs with strict parameters.
   *
   * @default true
   */
  cacheTags?: boolean
  /**
   * Enables cropping of images.
   * @default true
   */
  crop?: boolean
  /**
   * Disable the ability to save files to disk.
   * @default false
   */
  disableLocalStorage?: boolean
  /**
   * Enable displaying preview of the uploaded file in Upload fields related to this Collection.
   * Can be locally overridden by `displayPreview` option in Upload field.
   * @default false
   */
  displayPreview?: boolean
  /**
   * Ability to filter/modify Request Headers when fetching a file.
   *
   * Useful for adding custom headers to fetch from external providers.
   * @default undefined
   */
  externalFileHeaderFilter?: (headers: Record<string, string>) => Record<string, string>
  /**
   * Field slugs to use for a compount index instead of the default filename index.
   */
  filenameCompoundIndex?: string[]
  /**
   * Require files to be uploaded when creating a document.
   * @default true
   */
  filesRequiredOnCreate?: boolean
  /**
   * Enables focal point positioning for image manipulation.
   * @default false
   */
  focalPoint?: boolean
  /**
   * Format options for the uploaded file. Formatting image sizes needs to be done within each formatOptions individually.
   */
  formatOptions?: ImageUploadFormatOptions
  /**
   * Custom handlers to run when a file is fetched.
   *
   * - If a handler returns a Response, the response will be sent to the client and no further handlers will be run.
   * - If a handler returns null, the next handler will be run.
   * - If no handlers return a response the file will be returned by default.
   *
   * @default undefined
   */
  handlers?: ((
    req: PayloadRequest,
    args: {
      doc: TypeWithID
      params: { clientUploadContext?: unknown; collection: string; filename: string }
    },
  ) => Promise<Response> | Promise<void> | Response | void)[]
  /**
   * Set to `true` to prevent the admin UI from showing file inputs during document creation, useful for programmatic file generation.
   */
  hideFileInputOnCreate?: boolean
  /**
   * Set to `true` to prevent the admin UI having a way to remove an existing file while editing.
   */
  hideRemoveFile?: boolean
  imageSizes?: ImageSize[]
  /**
   * Restrict mimeTypes in the file picker. Array of valid mime types or mimetype wildcards
   * @example ['image/*', 'application/pdf']
   * @default undefined
   */
  mimeTypes?: string[]
  /**
   * Ability to modify the response headers fetching a file.
   * @default undefined
   */
  modifyResponseHeaders?: ({ headers }: { headers: Headers }) => Headers
  /**
   * Controls the behavior of pasting/uploading files from URLs.
   * If set to `false`, fetching from remote URLs is disabled.
   * If an allowList is provided, server-side fetching will be enabled for specified URLs.
   * @default true (client-side fetching enabled)
   */
  pasteURL?:
    | {
        allowList: AllowList
      }
    | false
  /**
   * Sharp resize options for the original image.
   * @link https://sharp.pixelplumbing.com/api-resize#resize
   * @default undefined
   */
  resizeOptions?: ResizeOptions
  /**
   * The directory to serve static files from. Defaults to collection slug.
   * @default undefined
   */
  staticDir?: string
  trimOptions?: ImageUploadTrimOptions
  /**
   * Optionally append metadata to the image during processing.
   *
   * Can be a boolean or a function.
   *
   * If true, metadata will be appended to the image.
   * If false, no metadata will be appended.
   * If a function, it will receive an object containing the metadata and should return a boolean indicating whether to append the metadata.
   * @default false
   */
  withMetadata?: WithMetadata
}

export type SanitizedUploadConfig = {
  staticDir: UploadConfig['staticDir']
} & UploadConfig

export type File = {
  /**
   * The buffer of the file.
   */
  data: Buffer
  /**
   * The mimetype of the file.
   */
  mimetype: string
  /**
   * The name of the file.
   */
  name: string
  /**
   * The size of the file in bytes.
   */
  size: number
}

export type FileToSave = {
  /**
   * The buffer of the file.
   */
  buffer: Buffer
  /**
   * The path to save the file.
   */
  path: string
}

type Crop = {
  height: number
  unit: '%' | 'px'
  width: number
  x: number
  y: number
}

type FocalPoint = {
  x: number
  y: number
}

export type UploadEdits = {
  crop?: Crop
  focalPoint?: FocalPoint
  heightInPixels?: number
  widthInPixels?: number
}
</file>

<file path="packages/payload/src/uploads/unlinkTempFiles.ts">
import fs from 'fs/promises'

import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { mapAsync } from '../utilities/mapAsync.js'

type Args = {
  collectionConfig: SanitizedCollectionConfig
  config: SanitizedConfig
  req: PayloadRequest
}
/**
 * Cleanup temp files after operation lifecycle
 */
export const unlinkTempFiles: (args: Args) => Promise<void> = async ({
  collectionConfig,
  config,
  req,
}) => {
  if (config.upload?.useTempFiles && collectionConfig.upload) {
    const { file } = req
    const fileArray = [{ file }]
    await mapAsync(fileArray, async ({ file }) => {
      // Still need this check because this will not be populated if using local API
      if (file?.tempFilePath) {
        await fs.unlink(file.tempFilePath)
      }
    })
  }
}
</file>

<file path="packages/payload/src/uploads/uploadFiles.ts">
import type { Payload } from '../index.js'
import type { PayloadRequest } from '../types/index.js'
import type { FileToSave } from './types.js'

import { FileUploadError } from '../errors/index.js'
import saveBufferToFile from './saveBufferToFile.js'

export const uploadFiles = async (
  payload: Payload,
  files: FileToSave[],
  req: PayloadRequest,
): Promise<void> => {
  try {
    await Promise.all(
      files.map(async ({ buffer, path }) => {
        await saveBufferToFile(buffer, path)
      }),
    )
  } catch (err) {
    payload.logger.error(err)
    throw new FileUploadError(req.t)
  }
}
</file>

<file path="packages/payload/src/utilities/dependencies/dependencyChecker.ts">
// @ts-strict-ignore
import path from 'path'
import { fileURLToPath } from 'url'

import { getDependencies } from '../../index.js'
import { compareVersions } from './versionUtils.js'

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

export type CustomVersionParser = (version: string) => { parts: number[]; preReleases: string[] }

export type DependencyCheckerArgs = {
  /**
   * Define dependency groups to ensure that all dependencies within that group are on the same version, and that no dependencies in that group with different versions are found
   */
  dependencyGroups?: {
    dependencies: string[]
    /**
     * Name of the dependency group to be displayed in the error message
     */
    name: string
    targetVersion?: string
    targetVersionDependency?: string
  }[]
  /**
   * Dependency package names keyed to their required versions. Supports >= (greater or equal than version) as a prefix, or no prefix for the exact version
   */
  dependencyVersions?: {
    [dependency: string]: {
      customVersionParser?: CustomVersionParser
      required?: boolean
      version?: string
    }
  }
}

export async function checkDependencies({
  dependencyGroups,
  dependencyVersions,
}: DependencyCheckerArgs): Promise<void> {
  if (dependencyGroups?.length) {
    for (const dependencyGroup of dependencyGroups) {
      const resolvedDependencies = await getDependencies(dirname, dependencyGroup.dependencies)

      // Go through each resolved dependency. If any dependency has a mismatching version, throw an error
      const foundVersions: {
        [version: string]: string
      } = {}
      for (const [_pkg, { version }] of resolvedDependencies.resolved) {
        if (!Object.keys(foundVersions).includes(version)) {
          foundVersions[version] = _pkg
        }
      }
      if (Object.keys(foundVersions).length > 1) {
        const targetVersion =
          dependencyGroup.targetVersion ??
          resolvedDependencies.resolved.get(dependencyGroup.targetVersionDependency)?.version
        if (targetVersion) {
          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)
            .filter(([version]) => version !== targetVersion)
            .map(([version, pkg]) => `${pkg}@${version} (Please change this to ${targetVersion})`)
            .join(', ')
          throw new Error(
            `Mismatching "${dependencyGroup.name}" dependency versions found: ${formattedVersionsWithPackageNameString}. All "${dependencyGroup.name}" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all "${dependencyGroup.name}" packages have the same version.`,
          )
        } else {
          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)
            .map(([version, pkg]) => `${pkg}@${version}`)
            .join(', ')
          throw new Error(
            `Mismatching "${dependencyGroup.name}" dependency versions found: ${formattedVersionsWithPackageNameString}. All "${dependencyGroup.name}" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all "${dependencyGroup.name}" packages have the same version.`,
          )
        }
      }
    }
  }

  if (dependencyVersions && Object.keys(dependencyVersions).length) {
    const resolvedDependencies = await getDependencies(dirname, Object.keys(dependencyVersions))
    for (const [dependency, settings] of Object.entries(dependencyVersions)) {
      const resolvedDependency = resolvedDependencies.resolved.get(dependency)
      if (!resolvedDependency) {
        if (!settings.required) {
          continue
        }
        throw new Error(`Dependency ${dependency} not found. Please ensure it is installed.`)
      }

      if (settings.version) {
        const settingsVersionToCheck = settings.version.startsWith('>=')
          ? settings.version.slice(2)
          : settings.version

        const versionCompareResult = compareVersions(
          resolvedDependency.version,
          settingsVersionToCheck,
          settings.customVersionParser,
        )

        if (settings.version.startsWith('>=')) {
          if (versionCompareResult === 'lower') {
            throw new Error(
              `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} or greater is required. Please update this dependency.`,
            )
          }
        } else if (versionCompareResult === 'lower' || versionCompareResult === 'greater') {
          throw new Error(
            `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} is required. Please update this dependency.`,
          )
        }
      }
    }
  }
}
</file>

<file path="packages/payload/src/utilities/dependencies/getDependencies.ts">
/*
  This source code has been taken and modified from https://github.com/vercel/next.js/blob/41a80533f900467e1b788bd2673abe2dca20be6a/packages/next/src/lib/has-necessary-dependencies.ts

  License:

  The MIT License (MIT)

  Copyright (c) 2024 Vercel, Inc.

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

import { promises as fs } from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

import { findUp } from '../findUp.js'
import { resolveFrom } from './resolveFrom.js'

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

const payloadPkgDirname = path.resolve(dirname, '../../../') // pkg dir (outside src)
// if node_modules is in payloadPkgDirname, go to parent dir which contains node_modules
if (payloadPkgDirname.includes('node_modules')) {
  payloadPkgDirname.split('node_modules').slice(0, -1)
}
const resolvedCwd = path.resolve(process.cwd())

export type NecessaryDependencies = {
  missing: string[]
  resolved: Map<
    string,
    {
      path: string
      version: string
    }
  >
}

export async function getDependencies(
  baseDir: string,
  requiredPackages: string[],
): Promise<NecessaryDependencies> {
  const resolutions = new Map<
    string,
    {
      path: string
      version: string
    }
  >()
  const missingPackages: string[] = []

  await Promise.all(
    requiredPackages.map(async (pkg) => {
      try {
        const pkgPath = await fs.realpath(resolveFrom(baseDir, pkg))
        const pkgDir = path.dirname(pkgPath)

        let packageJsonFilePath = null

        const foundPackageJsonDir = await findUp({
          dir: pkgDir,
          fileNames: ['package.json'],
        })

        if (foundPackageJsonDir) {
          const resolvedFoundPath = path.resolve(foundPackageJsonDir)

          if (
            resolvedFoundPath.startsWith(resolvedCwd) ||
            resolvedFoundPath.startsWith(payloadPkgDirname)
          ) {
            // We don't want to match node modules outside the user's project. Checking for both process.cwd and dirname is a reliable way to do this.
            packageJsonFilePath = resolvedFoundPath
          }
        }

        // No need to check if packageJsonFilePath exists - findUp checks that for us
        if (packageJsonFilePath) {
          // parse version
          const packageJson = JSON.parse(await fs.readFile(packageJsonFilePath, 'utf8'))
          const version = packageJson.version

          resolutions.set(pkg, {
            path: packageJsonFilePath,
            version,
          })
        } else {
          return missingPackages.push(pkg)
        }
      } catch (_) {
        return missingPackages.push(pkg)
      }
    }),
  )

  return {
    missing: missingPackages,
    resolved: resolutions,
  }
}
</file>

<file path="packages/payload/src/utilities/dependencies/isError.ts">
/*
  This source code has been taken and modified from https://github.com/vercel/next.js/blob/be87132327ea28acd4bf7af09a401bac2374cb64/packages/next/src/lib/is-error.ts

  License:

  The MIT License (MIT)

  Copyright (c) 2024 Vercel, Inc.

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

export interface ErrorWithCode extends Error {
  code?: number | string
}

export function isError(err: unknown): err is ErrorWithCode {
  return typeof err === 'object' && err !== null && 'name' in err && 'message' in err
}
</file>

<file path="packages/payload/src/utilities/dependencies/realPath.ts">
/*
  This source code has been taken from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/realpath.ts

  License:

  The MIT License (MIT)

  Copyright (c) 2024 Vercel, Inc.

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
import fs from 'fs'

const isWindows = process.platform === 'win32'

// Interesting learning from this, that fs.realpathSync is 70x slower than fs.realpathSync.native:
// https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html#fs-realpathsync-issue
// https://github.com/nodejs/node/issues/2680
// However, we can't use fs.realpathSync.native on Windows due to behavior differences.
export const realpathSync = isWindows ? fs.realpathSync : fs.realpathSync.native
</file>

<file path="packages/payload/src/utilities/dependencies/resolveFrom.ts">
/*
  This source code has been taken and modified from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/resolve-from.ts

  License:

  The MIT License (MIT)

  Copyright (c) 2024 Vercel, Inc.

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// source: https://github.com/sindresorhus/resolve-from
import { createRequire } from 'module'
import path from 'path'

import { isError } from './isError.js'
import { realpathSync } from './realPath.js'

export const resolveFrom = (fromDirectory: string, moduleId: string, silent?: boolean) => {
  if (typeof fromDirectory !== 'string') {
    throw new TypeError(
      `Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``,
    )
  }

  if (typeof moduleId !== 'string') {
    throw new TypeError(
      `Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``,
    )
  }

  try {
    fromDirectory = realpathSync(fromDirectory)
  } catch (error: unknown) {
    if (isError(error) && error.code === 'ENOENT') {
      fromDirectory = path.resolve(fromDirectory)
    } else if (silent) {
      return
    } else {
      throw error
    }
  }

  const fromFile = path.join(fromDirectory, 'noop.js')

  const require = createRequire(import.meta.url)

  const Module = require('module')

  const resolveFileName = () => {
    return Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDirectory),
    })
  }

  if (silent) {
    try {
      return resolveFileName()
    } catch (error) {
      return
    }
  }

  return resolveFileName()
}
</file>

<file path="packages/payload/src/utilities/dependencies/versionUtils.ts">
// @ts-strict-ignore
import type { CustomVersionParser } from './dependencyChecker.js'

export function parseVersion(version: string): { parts: number[]; preReleases: string[] } {
  const [mainVersion, ...preReleases] = version.split('-')
  const parts = mainVersion.split('.').map(Number)
  return { parts, preReleases }
}

function extractNumbers(str: string): number[] {
  const matches = str.match(/\d+/g) || []
  return matches.map(Number)
}

function comparePreRelease(v1: string, v2: string): number {
  const num1 = extractNumbers(v1)
  const num2 = extractNumbers(v2)

  for (let i = 0; i < Math.max(num1.length, num2.length); i++) {
    if ((num1[i] || 0) < (num2[i] || 0)) {
      return -1
    }
    if ((num1[i] || 0) > (num2[i] || 0)) {
      return 1
    }
  }

  // If numeric parts are equal, compare the whole string
  if (v1 < v2) {
    return -1
  }
  if (v1 > v2) {
    return 1
  }
  return 0
}

/**
 * Compares two semantic version strings, including handling pre-release identifiers.
 *
 * This function first compares the major, minor, and patch components as integers.
 * If these components are equal, it then moves on to compare pre-release versions.
 * Pre-release versions are compared first by extracting and comparing any numerical values.
 * If numerical values are equal, it compares the whole pre-release string lexicographically.
 *
 * @param {string} compare - The first version string to compare.
 * @param {string} to - The second version string to compare.
 * @param {function} [customVersionParser] - An optional function to parse version strings into parts and pre-releases.
 * @returns {string} - Returns greater if compare is greater than to, lower if compare is less than to, and equal if they are equal.
 */
export function compareVersions(
  compare: string,
  to: string,
  customVersionParser?: CustomVersionParser,
): 'equal' | 'greater' | 'lower' {
  const { parts: parts1, preReleases: preReleases1 } = customVersionParser
    ? customVersionParser(compare)
    : parseVersion(compare)
  const { parts: parts2, preReleases: preReleases2 } = customVersionParser
    ? customVersionParser(to)
    : parseVersion(to)

  // Compare main version parts
  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    if ((parts1[i] || 0) > (parts2[i] || 0)) {
      return 'greater'
    }
    if ((parts1[i] || 0) < (parts2[i] || 0)) {
      return 'lower'
    }
  }

  // Compare pre-release parts if main versions are equal
  if (preReleases1?.length || preReleases2?.length) {
    for (let i = 0; i < Math.max(preReleases1.length, preReleases2.length); i++) {
      if (!preReleases1[i]) {
        return 'greater'
      }
      if (!preReleases2[i]) {
        return 'lower'
      }

      const result = comparePreRelease(preReleases1[i], preReleases2[i])
      if (result !== 0) {
        return result === 1 ? 'greater' : 'lower'
      }
      // Equal => continue for loop to check for next pre-release part
    }
  }

  return 'equal'
}
</file>

<file path="packages/payload/src/utilities/telemetry/conf/envPaths.ts">
// @ts-strict-ignore
/**
 * Taken from https://github.com/sindresorhus/env-paths/blob/main/index.js
 *
 * MIT License
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import os from 'node:os'
import path from 'node:path'
import process from 'node:process'

const homedir = os.homedir()
const tmpdir = os.tmpdir()
const { env } = process

const macos = (name) => {
  const library = path.join(homedir, 'Library')

  return {
    cache: path.join(library, 'Caches', name),
    config: path.join(library, 'Preferences', name),
    data: path.join(library, 'Application Support', name),
    log: path.join(library, 'Logs', name),
    temp: path.join(tmpdir, name),
  }
}

const windows = (name) => {
  const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming')
  const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local')

  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    cache: path.join(localAppData, name, 'Cache'),
    config: path.join(appData, name, 'Config'),
    data: path.join(localAppData, name, 'Data'),
    log: path.join(localAppData, name, 'Log'),
    temp: path.join(tmpdir, name),
  }
}

// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
const linux = (name) => {
  const username = path.basename(homedir)

  return {
    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),
    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),
    data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),
    temp: path.join(tmpdir, username, name),
  }
}

export function envPaths(name, { suffix = 'nodejs' } = {}) {
  if (typeof name !== 'string') {
    throw new TypeError(`Expected a string, got ${typeof name}`)
  }

  if (suffix) {
    // Add suffix to prevent possible conflict with native apps
    name += `-${suffix}`
  }

  if (process.platform === 'darwin') {
    return macos(name)
  }

  if (process.platform === 'win32') {
    return windows(name)
  }

  return linux(name)
}
</file>

<file path="packages/payload/src/utilities/telemetry/conf/index.ts">
/**
 * Taken & simplified from https://github.com/sindresorhus/conf/blob/main/source/index.ts
 *
 * MIT License
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import assert from 'node:assert'
import fs from 'node:fs'
import path from 'node:path'

import { envPaths } from './envPaths.js'

const createPlainObject = <T = Record<string, unknown>>(): T => Object.create(null)

const checkValueType = (key: string, value: unknown): void => {
  const nonJsonTypes = new Set(['function', 'symbol', 'undefined'])

  const type = typeof value

  if (nonJsonTypes.has(type)) {
    throw new TypeError(
      `Setting a value of type \`${type}\` for key \`${key}\` is not allowed as it's not supported by JSON`,
    )
  }
}

export class Conf<T extends Record<string, any> = Record<string, unknown>>
  implements Iterable<[keyof T, T[keyof T]]>
{
  readonly #options: Readonly<Partial<Options>>
  private readonly _deserialize: Deserialize<T> = (value) => JSON.parse(value)
  private readonly _serialize: Serialize<T> = (value) => JSON.stringify(value, undefined, '\t')

  readonly events: EventTarget

  readonly path: string

  constructor() {
    const options: Partial<Options> = {
      configFileMode: 0o666,
      configName: 'config',
      fileExtension: 'json',
      projectSuffix: 'nodejs',
    }

    const cwd = envPaths('payload', { suffix: options.projectSuffix }).config

    this.#options = options

    this.events = new EventTarget()

    const fileExtension = options.fileExtension ? `.${options.fileExtension}` : ''
    this.path = path.resolve(cwd, `${options.configName ?? 'config'}${fileExtension}`)

    const fileStore = this.store
    const store = Object.assign(createPlainObject(), fileStore)

    try {
      assert.deepEqual(fileStore, store)
    } catch {
      this.store = store
    }
  }

  private _ensureDirectory(): void {
    // Ensure the directory exists as it could have been deleted in the meantime.
    fs.mkdirSync(path.dirname(this.path), { recursive: true })
  }

  private _write(value: T): void {
    const data: string | Uint8Array = this._serialize(value)

    fs.writeFileSync(this.path, data, { mode: this.#options.configFileMode })
  }

  /**
   Delete an item.

   @param key - The key of the item to delete.
   */
  delete(key: string): void {
    const { store } = this
    delete store[key]

    this.store = store
  }

  /**
   Get an item.

   @param key - The key of the item to get.
   */
  get<Key extends keyof T>(key: Key): T[Key] {
    const { store } = this
    return store[key]
  }

  /**
   Set an item or multiple items at once.

   @param key - You can use [dot-notation](https://github.com/sindresorhus/dot-prop) in a key to access nested properties. Or a hashmap of items to set at once.
   @param value - Must be JSON serializable. Trying to set the type `undefined`, `function`, or `symbol` will result in a `TypeError`.
   */
  set<Key extends keyof T>(key: string, value?: T[Key] | unknown): void {
    if (typeof key !== 'string' && typeof key !== 'object') {
      throw new TypeError(
        `Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`,
      )
    }

    if (typeof key !== 'object' && value === undefined) {
      throw new TypeError('Use `delete()` to clear values')
    }

    const { store } = this

    const set = (key: string, value?: T | T[Key] | unknown): void => {
      checkValueType(key, value)
      store[key as Key] = value as T[Key]
    }

    if (typeof key === 'object') {
      const object = key
      for (const [key, value] of Object.entries(object)) {
        set(key, value)
      }
    } else {
      set(key, value)
    }

    this.store = store
  }

  *[Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]> {
    for (const [key, value] of Object.entries(this.store)) {
      yield [key, value]
    }
  }
  get size(): number {
    return Object.keys(this.store).length
  }
  get store(): T {
    try {
      const dataString = fs.readFileSync(this.path, 'utf8')
      const deserializedData = this._deserialize(dataString)
      return Object.assign(createPlainObject(), deserializedData)
    } catch (error: unknown) {
      if ((error as any)?.code === 'ENOENT') {
        this._ensureDirectory()
        return createPlainObject()
      }

      throw error
    }
  }

  set store(value: T) {
    this._ensureDirectory()

    this._write(value)

    this.events.dispatchEvent(new Event('change'))
  }
}

export type Options = {
  /**
   The config is cleared if reading the config file causes a `SyntaxError`. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there's nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing.

   @default false
   */
  clearInvalidConfig?: boolean

  /**
   The [mode](https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation) that will be used for the config file.

   You would usually not need this, but it could be useful if you want to restrict the permissions of the config file. Setting a permission such as `0o600` would result in a config file that can only be accessed by the user running the program.

   Note that setting restrictive permissions can cause problems if different users need to read the file. A common problem is a user running your tool with and without `sudo` and then not being able to access the config the second time.

   @default 0o666
   */
  readonly configFileMode?: number

  /**
   Name of the config file (without extension).

   Useful if you need multiple config files for your app or module. For example, different config files between two major versions.

   @default 'config'
   */
  configName?: string

  /**
   Extension of the config file.

   You would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app.

   @default 'json'
   */
  fileExtension?: string

  readonly projectSuffix?: string
}

export type Serialize<T> = (value: T) => string
export type Deserialize<T> = (text: string) => T
</file>

<file path="packages/payload/src/utilities/telemetry/events/adminInit.ts">
// @ts-strict-ignore
import type { Payload } from '../../../index.js'
import type { PayloadRequest } from '../../../types/index.js'

import { sendEvent } from '../index.js'
import { oneWayHash } from '../oneWayHash.js'

export type AdminInitEvent = {
  domainID?: string
  type: 'admin-init'
  userID?: string
}

type Args = {
  headers: Request['headers']
  payload: Payload
  user: PayloadRequest['user']
}
export const adminInit = ({ headers, payload, user }: Args): void => {
  const host = headers.get('host')

  let domainID: string
  let userID: string

  if (host) {
    domainID = oneWayHash(host, payload.secret)
  }

  if (user?.id) {
    userID = oneWayHash(String(user.id), payload.secret)
  }

  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  sendEvent({
    event: {
      type: 'admin-init',
      domainID,
      userID,
    },
    payload,
  })
}
</file>

<file path="packages/payload/src/utilities/telemetry/events/serverInit.ts">
import type { Payload } from '../../../index.js'

import { sendEvent } from '../index.js'

export type ServerInitEvent = {
  type: 'server-init'
}

export const serverInit = (payload: Payload): void => {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  sendEvent({
    event: {
      type: 'server-init',
    },
    payload,
  })
}
</file>

<file path="packages/payload/src/utilities/telemetry/index.ts">
// @ts-strict-ignore
import { execSync } from 'child_process'
import ciInfo from 'ci-info'
import { randomBytes } from 'crypto'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

import type { Payload } from '../../types/index.js'
import type { AdminInitEvent } from './events/adminInit.js'
import type { ServerInitEvent } from './events/serverInit.js'

import { findUp } from '../findUp.js'
import { Conf } from './conf/index.js'
import { oneWayHash } from './oneWayHash.js'

export type BaseEvent = {
  ciName: null | string
  dbAdapter: string
  emailAdapter: null | string
  envID: string
  isCI: boolean
  locales: string[]
  localizationDefaultLocale: null | string
  localizationEnabled: boolean
  nodeEnv: string
  nodeVersion: string
  payloadVersion: string
  projectID: string
  projectIDSource: 'cwd' | 'git' | 'packageJSON' | 'serverURL'
  uploadAdapters: string[]
}

type PackageJSON = {
  dependencies: Record<string, string | undefined>
  name: string
}

type TelemetryEvent = AdminInitEvent | ServerInitEvent

type Args = {
  event: TelemetryEvent
  payload: Payload
}

let baseEvent: BaseEvent | null = null

export const sendEvent = async ({ event, payload }: Args): Promise<void> => {
  try {
    const { packageJSON, packageJSONPath } = await getPackageJSON()

    // Only generate the base event once
    if (!baseEvent) {
      const { projectID, source: projectIDSource } = getProjectID(payload, packageJSON)
      baseEvent = {
        ciName: ciInfo.isCI ? ciInfo.name : null,
        envID: getEnvID(),
        isCI: ciInfo.isCI,
        nodeEnv: process.env.NODE_ENV || 'development',
        nodeVersion: process.version,
        payloadVersion: getPayloadVersion(packageJSON),
        projectID,
        projectIDSource,
        ...getLocalizationInfo(payload),
        dbAdapter: payload.db.name,
        emailAdapter: payload.email?.name || null,
        uploadAdapters: payload.config.upload.adapters,
      }
    }

    if (process.env.PAYLOAD_TELEMETRY_DEBUG) {
      payload.logger.info({
        event: { ...baseEvent, ...event, packageJSONPath },
        msg: 'Telemetry Event',
      })
      return
    }

    if (payload.config.telemetry !== false) {
      await fetch('https://telemetry.payloadcms.com/events', {
        body: JSON.stringify({ ...baseEvent, ...event }),
        headers: {
          'Content-Type': 'application/json',
        },
        method: 'post',
      })
    }
  } catch (_) {
    // Eat any errors in sending telemetry event
  }
}

/**
 * This is a quasi-persistent identifier used to dedupe recurring events. It's
 * generated from random data and completely anonymous.
 */
const getEnvID = (): string => {
  const conf = new Conf()
  const ENV_ID = 'envID'

  const val = conf.get(ENV_ID)
  if (val) {
    return val as string
  }

  const generated = randomBytes(32).toString('hex')
  conf.set(ENV_ID, generated)
  return generated
}

const getProjectID = (
  payload: Payload,
  packageJSON: PackageJSON,
): { projectID: string; source: BaseEvent['projectIDSource'] } => {
  const gitID = getGitID(payload)
  if (gitID) {
    return { projectID: oneWayHash(gitID, payload.secret), source: 'git' }
  }

  const packageJSONID = getPackageJSONID(payload, packageJSON)
  if (packageJSONID) {
    return { projectID: oneWayHash(packageJSONID, payload.secret), source: 'packageJSON' }
  }

  const serverURL = payload.config.serverURL
  if (serverURL) {
    return { projectID: oneWayHash(serverURL, payload.secret), source: 'serverURL' }
  }

  const cwd = process.cwd()
  return { projectID: oneWayHash(cwd, payload.secret), source: 'cwd' }
}

const getGitID = (payload: Payload) => {
  try {
    const originBuffer = execSync('git config --local --get remote.origin.url', {
      stdio: 'pipe',
      timeout: 1000,
    })

    return oneWayHash(String(originBuffer).trim(), payload.secret)
  } catch (_) {
    return null
  }
}

const getPackageJSON = async (): Promise<{
  packageJSON?: PackageJSON
  packageJSONPath: string
}> => {
  let packageJSONPath = path.resolve(process.cwd(), 'package.json')

  if (!fs.existsSync(packageJSONPath)) {
    // Old logic
    const filename = fileURLToPath(import.meta.url)
    const dirname = path.dirname(filename)
    packageJSONPath = await findUp({
      dir: dirname,
      fileNames: ['package.json'],
    })
  }

  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')
  const jsonContent: PackageJSON = JSON.parse(jsonContentString)
  return { packageJSON: jsonContent, packageJSONPath }
}

const getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {
  return oneWayHash(packageJSON.name, payload.secret)
}

export const getPayloadVersion = (packageJSON: PackageJSON): string => {
  return packageJSON?.dependencies?.payload ?? ''
}

export const getLocalizationInfo = (
  payload: Payload,
): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {
  if (!payload.config.localization) {
    return {
      locales: [],
      localizationDefaultLocale: null,
      localizationEnabled: false,
    }
  }

  return {
    locales: payload.config.localization.localeCodes,
    localizationDefaultLocale: payload.config.localization.defaultLocale,
    localizationEnabled: true,
  }
}
</file>

<file path="packages/payload/src/utilities/telemetry/oneWayHash.ts">
import type { BinaryLike } from 'crypto'

import { createHash } from 'crypto'

export const oneWayHash = (data: BinaryLike, secret: string): string => {
  const hash = createHash('sha256')

  // prepend value with payload secret. This ensure one-way.
  hash.update(secret)

  // Update is an append operation, not a replacement. The secret from the prior
  // update is still present!
  hash.update(data)
  return hash.digest('hex')
}
</file>

<file path="packages/payload/src/utilities/addDataAndFileToRequest.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../types/index.js'

import { APIError } from '../errors/APIError.js'
import { fetchAPIFileUpload } from '../uploads/fetchAPI-multipart/index.js'

type AddDataAndFileToRequest = (req: PayloadRequest) => Promise<void>

/**
 * Mutates the Request, appending 'data' and 'file' if found
 */
export const addDataAndFileToRequest: AddDataAndFileToRequest = async (req) => {
  const { body, headers, method, payload } = req

  if (method && ['PATCH', 'POST', 'PUT'].includes(method.toUpperCase()) && body) {
    const [contentType] = (headers.get('Content-Type') || '').split(';')
    const bodyByteSize = parseInt(req.headers.get('Content-Length') || '0', 10)

    if (contentType === 'application/json') {
      let data = {}
      try {
        const text = await req.text()
        data = text ? JSON.parse(text) : {}
      } catch (error) {
        req.payload.logger.error(error)
      } finally {
        req.data = data
        req.json = () => Promise.resolve(data)
      }
    } else if (bodyByteSize && contentType.includes('multipart/')) {
      const { error, fields, files } = await fetchAPIFileUpload({
        options: payload.config.upload,
        request: req as Request,
      })

      if (error) {
        throw new APIError(error.message)
      }

      if (files?.file) {
        req.file = files.file
      }

      if (fields?._payload && typeof fields._payload === 'string') {
        req.data = JSON.parse(fields._payload)
      }

      if (!req.file && fields?.file && typeof fields?.file === 'string') {
        const { clientUploadContext, collectionSlug, filename, mimeType, size } = JSON.parse(
          fields.file,
        )
        const uploadConfig = req.payload.collections[collectionSlug].config.upload

        if (!uploadConfig.handlers) {
          throw new APIError('uploadConfig.handlers is not present for ' + collectionSlug)
        }

        let response: null | Response = null
        let error: unknown

        for (const handler of uploadConfig.handlers) {
          try {
            const result = await handler(req, {
              doc: null,
              params: {
                clientUploadContext, // Pass additional specific to adapters context returned from UploadHandler, then staticHandler can use them.
                collection: collectionSlug,
                filename,
              },
            })
            if (result) {
              response = result
            }
            // If we couldn't get the file from that handler, save the error and try other.
          } catch (err) {
            error = err
          }
        }

        if (!response) {
          if (error) {
            payload.logger.error(error)
          }

          throw new APIError('Expected response from the upload handler.')
        }

        req.file = {
          name: filename,
          clientUploadContext,
          data: Buffer.from(await response.arrayBuffer()),
          mimetype: response.headers.get('Content-Type') || mimeType,
          size,
        }
      }
    }
  }
}
</file>

<file path="packages/payload/src/utilities/addLocalesToRequest.ts">
// @ts-strict-ignore
import type { SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { sanitizeFallbackLocale } from './sanitizeFallbackLocale.js'

/**
 * Mutates the Request to contain 'locale' and 'fallbackLocale' based on data or searchParams
 */
export function addLocalesToRequestFromData(req: PayloadRequest): void {
  const {
    data,
    payload: { config },
  } = req

  if (data) {
    const localeOnReq = req.locale
    const fallbackLocaleOnReq = req.fallbackLocale
    let localeFromData
    let fallbackLocaleFromData

    if (!localeOnReq && data?.locale && typeof data.locale === 'string') {
      localeFromData = data.locale
    }

    if (!fallbackLocaleOnReq) {
      if (data?.['fallback-locale'] && typeof data?.['fallback-locale'] === 'string') {
        fallbackLocaleFromData = data['fallback-locale']
      }

      if (data?.['fallbackLocale'] && typeof data?.['fallbackLocale'] === 'string') {
        fallbackLocaleFromData = data['fallbackLocale']
      }
    }

    if (!localeOnReq || !fallbackLocaleOnReq) {
      const { fallbackLocale, locale } = sanitizeLocales({
        fallbackLocale: fallbackLocaleFromData,
        locale: localeFromData,
        localization: config.localization,
      })

      if (localeFromData) {
        req.locale = locale
      }

      if (fallbackLocaleFromData) {
        req.fallbackLocale = fallbackLocale
      }
    }
  }
}

type SanitizeLocalesArgs = {
  fallbackLocale: string
  locale: string
  localization: SanitizedConfig['localization']
}
type SanitizeLocalesReturn = {
  fallbackLocale?: string
  locale?: string
}
export const sanitizeLocales = ({
  fallbackLocale,
  locale,
  localization,
}: SanitizeLocalesArgs): SanitizeLocalesReturn => {
  // Check if localization has fallback enabled or if a fallback locale is provided

  if (localization) {
    fallbackLocale = sanitizeFallbackLocale({
      fallbackLocale,
      locale,
      localization,
    })
  }

  if (['*', 'all'].includes(locale)) {
    locale = 'all'
  } else if (localization && !localization.localeCodes.includes(locale) && localization.fallback) {
    locale = localization.defaultLocale
  }

  return {
    fallbackLocale,
    locale,
  }
}
</file>

<file path="packages/payload/src/utilities/addSelectGenericsToGeneratedTypes.spec.ts">
import { addSelectGenericsToGeneratedTypes } from './addSelectGenericsToGeneretedTypes.js'

const INPUT_AND_OUTPUT = [
  {
    input: `
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run \`payload generate:types\` to regenerate this file.
 */

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  collections: {
    posts: Post;
    users: User;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsSelect: {
    posts: PostsSelect;
    users: UsersSelect;
    'payload-locked-documents': PayloadLockedDocumentsSelect;
    'payload-preferences': PayloadPreferencesSelect;
    'payload-migrations': PayloadMigrationsSelect;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: null;
  user: User & {
    collection: 'users';
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "posts".
 */
export interface Post {
  id: string;
  text?: string | null;
  number?: number | null;
  group?: {
    text?: string | null;
    number?: number | null;
  };
  array?:
    | {
        text?: string | null;
        number?: number | null;
        id?: string | null;
      }[]
    | null;
  blocks?:
    | (
        | {
            text?: string | null;
            introText?: string | null;
            id?: string | null;
            blockName?: string | null;
            blockType: 'intro';
          }
        | {
            text?: string | null;
            ctaText?: string | null;
            id?: string | null;
            blockName?: string | null;
            blockType: 'cta';
          }
      )[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  password?: string | null;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'posts';
        value: string | Post;
      } | null)
    | ({
        relationTo: 'users';
        value: string | User;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "posts_select".
 */
export interface PostsSelect {
  text?: boolean;
  number?: boolean;
  sharedGroup?: boolean | SharedGroup;
  group?:
    | boolean
    | {
        text?: boolean;
        number?: boolean;
      };
  array?:
    | boolean
    | {
        text?: boolean;
        number?: boolean;
        id?: boolean;
      };
  blocks?:
    | boolean
    | {
        intro?:
          | boolean
          | {
              text?: boolean;
              introText?: boolean;
              id?: boolean;
              blockName?: boolean;
            };
        cta?:
          | boolean
          | {
              text?: boolean;
              ctaText?: boolean;
              id?: boolean;
              blockName?: boolean;
            };
      };
  updatedAt?: boolean;
  createdAt?: boolean;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "users_select".
 */
export interface UsersSelect {
  updatedAt?: boolean;
  createdAt?: boolean;
  email?: boolean;
  resetPasswordToken?: boolean;
  resetPasswordExpiration?: boolean;
  salt?: boolean;
  hash?: boolean;
  loginAttempts?: boolean;
  lockUntil?: boolean;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect {
  document?: boolean;
  globalSlug?: boolean;
  user?: boolean;
  updatedAt?: boolean;
  createdAt?: boolean;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect {
  user?: boolean;
  key?: boolean;
  value?: boolean;
  updatedAt?: boolean;
  createdAt?: boolean;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect {
  name?: boolean;
  batch?: boolean;
  updatedAt?: boolean;
  createdAt?: boolean;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
`,
    output: `
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run \`payload generate:types\` to regenerate this file.
 */

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  collections: {
    posts: Post;
    users: User;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsSelect: {
    posts: PostsSelect<false> | PostsSelect<true>;
    users: UsersSelect<false> | UsersSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: null;
  user: User & {
    collection: 'users';
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "posts".
 */
export interface Post {
  id: string;
  text?: string | null;
  number?: number | null;
  group?: {
    text?: string | null;
    number?: number | null;
  };
  array?:
    | {
        text?: string | null;
        number?: number | null;
        id?: string | null;
      }[]
    | null;
  blocks?:
    | (
        | {
            text?: string | null;
            introText?: string | null;
            id?: string | null;
            blockName?: string | null;
            blockType: 'intro';
          }
        | {
            text?: string | null;
            ctaText?: string | null;
            id?: string | null;
            blockName?: string | null;
            blockType: 'cta';
          }
      )[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  password?: string | null;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'posts';
        value: string | Post;
      } | null)
    | ({
        relationTo: 'users';
        value: string | User;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "posts_select".
 */
export interface PostsSelect<T extends boolean = true> {
  text?: T;
  number?: T;
  sharedGroup?: T | SharedGroup<T>;
  group?:
    | T
    | {
        text?: T;
        number?: T;
      };
  array?:
    | T
    | {
        text?: T;
        number?: T;
        id?: T;
      };
  blocks?:
    | T
    | {
        intro?:
          | T
          | {
              text?: T;
              introText?: T;
              id?: T;
              blockName?: T;
            };
        cta?:
          | T
          | {
              text?: T;
              ctaText?: T;
              id?: T;
              blockName?: T;
            };
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by \`Config\`'s JSON-Schema
 * via the \`definition\` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
`,
  },
]

describe('addSelectGenericsToGeneratedTypes', () => {
  it('should match return of given input with output', () => {
    for (const { input, output } of INPUT_AND_OUTPUT) {
      expect(
        addSelectGenericsToGeneratedTypes({
          compiledGeneratedTypes: input,
        }),
      ).toStrictEqual(output)
    }
  })
})
</file>

<file path="packages/payload/src/utilities/addSelectGenericsToGeneretedTypes.ts">
export const addSelectGenericsToGeneratedTypes = ({
  compiledGeneratedTypes,
}: {
  compiledGeneratedTypes: string
}) => {
  const modifiedLines = []

  let isCollectionsSelectToken = false
  let isSelectTypeToken = false

  for (const line of compiledGeneratedTypes.split('\n')) {
    let newLine = line
    if (line === `  collectionsSelect: {` || line === `  globalsSelect: {`) {
      isCollectionsSelectToken = true
    }

    if (isCollectionsSelectToken) {
      if (line === '  };') {
        isCollectionsSelectToken = false
      } else {
        // replace <posts: PostsSelect;> with <posts: PostsSelect<true> | PostsSelect<false;>
        newLine = line.replace(/(['"]?\w+['"]?):\s*(\w+);/g, (_, variable, type) => {
          return `${variable}: ${type}<false> | ${type}<true>;`
        })
      }
    }

    // eslint-disable-next-line regexp/no-unused-capturing-group
    if (line.match(/via the `definition` "([\w-]+_select)"/g)) {
      isSelectTypeToken = true
    }

    if (isSelectTypeToken) {
      if (line.startsWith('export interface')) {
        // add generic to the interface
        newLine = line.replace(/(export interface\s+\w+)(\s*\{)/g, '$1<T extends boolean = true>$2')
      } else {
        newLine = line
          // replace booleans with T on the line
          .replace(/(?<!\?)\bboolean\b/g, 'T')
          // replace interface names like CtaBlock to CtaBlock<T>
          .replace(
            /\b(\w+)\s*\|\s*(\w+)\b/g,
            (_match, left, right) => `${left} | ${right}<${left}>`,
          )

        if (line === '}') {
          isSelectTypeToken = false
        }
      }
    }

    modifiedLines.push(newLine)
  }

  return modifiedLines.join('\n')
}
</file>

<file path="packages/payload/src/utilities/checkDocumentLockStatus.ts">
import type { TypeWithID } from '../collections/config/types.js'
import type { PaginatedDocs } from '../database/types.js'
import type { JsonObject, PayloadRequest } from '../types/index.js'

import { Locked } from '../errors/index.js'
import { lockedDocumentsCollectionSlug } from '../locked-documents/config.js'

type CheckDocumentLockStatusArgs = {
  collectionSlug?: string
  globalSlug?: string
  id?: number | string
  lockDurationDefault?: number
  lockErrorMessage?: string
  overrideLock?: boolean
  req: PayloadRequest
}

export const checkDocumentLockStatus = async ({
  id,
  collectionSlug,
  globalSlug,
  lockDurationDefault = 300, // Default 5 minutes in seconds
  lockErrorMessage,
  overrideLock = true,
  req,
}: CheckDocumentLockStatusArgs): Promise<void> => {
  const { payload } = req

  // Retrieve the lockDocuments property for either collection or global
  const lockDocumentsProp = collectionSlug
    ? payload.collections?.[collectionSlug]?.config?.lockDocuments
    : payload.config?.globals?.find((g) => g.slug === globalSlug)?.lockDocuments

  const isLockingEnabled = lockDocumentsProp !== false

  let lockedDocumentQuery = {}

  if (collectionSlug) {
    lockedDocumentQuery = {
      and: [
        { 'document.relationTo': { equals: collectionSlug } },
        { 'document.value': { equals: id } },
      ],
    }
  } else if (globalSlug) {
    lockedDocumentQuery = { globalSlug: { equals: globalSlug } }
  } else {
    throw new Error('Either collectionSlug or globalSlug must be provided.')
  }

  if (!isLockingEnabled) {
    return
  }

  // Only perform lock checks if overrideLock is false and locking is enabled
  if (!overrideLock) {
    const defaultLockErrorMessage = collectionSlug
      ? `Document with ID ${id} is currently locked by another user and cannot be modified.`
      : `Global document with slug "${globalSlug}" is currently locked by another user and cannot be modified.`

    const finalLockErrorMessage = lockErrorMessage || defaultLockErrorMessage

    const lockedDocumentResult: PaginatedDocs<JsonObject & TypeWithID> = await payload.db.find({
      collection: lockedDocumentsCollectionSlug,
      limit: 1,
      pagination: false,
      sort: '-updatedAt',
      where: lockedDocumentQuery,
    })

    // If there's a locked document, check lock conditions
    const lockedDoc = lockedDocumentResult?.docs[0]
    if (lockedDoc) {
      const lastEditedAt = new Date(lockedDoc?.updatedAt).getTime()
      const now = new Date().getTime()

      const lockDuration =
        typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault

      const lockDurationInMilliseconds = lockDuration * 1000
      const currentUserId = req.user?.id

      // document is locked by another user and the lock hasn't expired
      if (
        lockedDoc.user?.value !== currentUserId &&
        now - lastEditedAt <= lockDurationInMilliseconds
      ) {
        throw new Locked(finalLockErrorMessage)
      }
    }
  }

  // Perform the delete operation regardless of overrideLock status
  await payload.db.deleteMany({
    collection: lockedDocumentsCollectionSlug,
    // Not passing req fails on postgres
    req: payload.db.name === 'mongoose' ? undefined : req,
    where: lockedDocumentQuery,
  })
}
</file>

<file path="packages/payload/src/utilities/commitTransaction.ts">
// @ts-strict-ignore
import type { MarkRequired } from 'ts-essentials'

import type { PayloadRequest } from '../types/index.js'

/**
 * complete a transaction calling adapter db.commitTransaction and delete the transactionID from req
 */
export async function commitTransaction(
  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,
): Promise<void> {
  const { payload, transactionID } = req

  await payload.db.commitTransaction(transactionID)
  delete req.transactionID
}
</file>

<file path="packages/payload/src/utilities/configToJSONSchema.spec.ts">
import type { JSONSchema4 } from 'json-schema'

import type { Config } from '../config/types.js'

import { sanitizeConfig } from '../config/sanitize.js'
import { configToJSONSchema } from './configToJSONSchema.js'
import type { Block, BlocksField, RichTextField } from '../fields/config/types.js'

describe('configToJSONSchema', () => {
  it('should handle optional arrays with required fields', async () => {
    // @ts-expect-error
    const config: Config = {
      collections: [
        {
          slug: 'test',
          fields: [
            {
              name: 'someRequiredField',
              type: 'array',
              fields: [
                {
                  name: 'someRequiredField',
                  type: 'text',
                  required: true,
                },
              ],
            },
          ],
          timestamps: false,
        },
      ],
    }

    const sanitizedConfig = await sanitizeConfig(config)
    const schema = configToJSONSchema(sanitizedConfig, 'text')

    expect(schema?.definitions?.test).toStrictEqual({
      type: 'object',
      additionalProperties: false,
      properties: {
        id: {
          type: 'string',
        },
        someRequiredField: {
          type: ['array', 'null'],
          items: {
            type: 'object',
            additionalProperties: false,
            properties: {
              id: {
                type: ['string', 'null'],
              },
              someRequiredField: {
                type: 'string',
              },
            },
            required: ['someRequiredField'],
          },
        },
      },
      required: ['id'],
      title: 'Test',
    })
  })

  it('should handle block fields with no blocks', async () => {
    // @ts-expect-error
    const config: Config = {
      collections: [
        {
          slug: 'test',
          fields: [
            {
              name: 'blockField',
              type: 'blocks',
              blocks: [],
            },
            {
              name: 'blockFieldRequired',
              type: 'blocks',
              blocks: [],
              required: true,
            },
            {
              name: 'blockFieldWithFields',
              type: 'blocks',
              blocks: [
                {
                  slug: 'test',
                  fields: [
                    {
                      name: 'field',
                      type: 'text',
                    },
                  ],
                },
              ],
            },
            {
              name: 'blockFieldWithFieldsRequired',
              type: 'blocks',
              blocks: [
                {
                  slug: 'test',
                  fields: [
                    {
                      name: 'field',
                      type: 'text',
                      required: true,
                    },
                  ],
                },
              ],
            },
          ],
          timestamps: false,
        },
      ],
    }

    const sanitizedConfig = await sanitizeConfig(config)
    const schema = configToJSONSchema(sanitizedConfig, 'text')

    expect(schema?.definitions?.test).toStrictEqual({
      type: 'object',
      additionalProperties: false,
      properties: {
        id: {
          type: 'string',
        },
        blockField: {
          type: ['array', 'null'],
          items: {},
        },
        blockFieldRequired: {
          type: 'array',
          items: {},
        },
        blockFieldWithFields: {
          type: ['array', 'null'],
          items: {
            oneOf: [
              {
                type: 'object',
                additionalProperties: false,
                properties: {
                  id: {
                    type: ['string', 'null'],
                  },
                  blockName: {
                    type: ['string', 'null'],
                  },
                  blockType: {
                    const: 'test',
                  },
                  field: {
                    type: ['string', 'null'],
                  },
                },
                required: ['blockType'],
              },
            ],
          },
        },
        blockFieldWithFieldsRequired: {
          type: ['array', 'null'],
          items: {
            oneOf: [
              {
                type: 'object',
                additionalProperties: false,
                properties: {
                  id: {
                    type: ['string', 'null'],
                  },
                  blockName: {
                    type: ['string', 'null'],
                  },
                  blockType: {
                    const: 'test',
                  },
                  field: {
                    type: 'string',
                  },
                },
                required: ['blockType', 'field'],
              },
            ],
          },
        },
      },
      required: ['id', 'blockFieldRequired'],
      title: 'Test',
    })
  })

  it('should handle tabs and named tabs with required fields', async () => {
    // @ts-expect-error
    const config: Config = {
      collections: [
        {
          slug: 'test',
          fields: [
            {
              type: 'tabs',
              tabs: [
                {
                  fields: [
                    {
                      name: 'fieldInUnnamedTab',
                      type: 'text',
                    },
                  ],
                  label: 'unnamedTab',
                },
                {
                  name: 'namedTab',
                  fields: [
                    {
                      name: 'fieldInNamedTab',
                      type: 'text',
                    },
                  ],
                  label: 'namedTab',
                },
                {
                  name: 'namedTabWithRequired',
                  fields: [
                    {
                      name: 'fieldInNamedTab',
                      type: 'text',
                      required: true,
                    },
                  ],
                  label: 'namedTabWithRequired',
                },
              ],
            },
          ],
          timestamps: false,
        },
      ],
    }

    const sanitizedConfig = await sanitizeConfig(config)
    const schema = configToJSONSchema(sanitizedConfig, 'text')

    expect(schema?.definitions?.test).toStrictEqual({
      type: 'object',
      additionalProperties: false,
      properties: {
        id: {
          type: 'string',
        },
        fieldInUnnamedTab: {
          type: ['string', 'null'],
        },
        namedTab: {
          type: 'object',
          additionalProperties: false,
          properties: {
            fieldInNamedTab: {
              type: ['string', 'null'],
            },
          },
          required: [],
        },
        namedTabWithRequired: {
          type: 'object',
          additionalProperties: false,
          properties: {
            fieldInNamedTab: {
              type: 'string',
            },
          },
          required: ['fieldInNamedTab'],
        },
      },
      required: ['id', 'namedTabWithRequired'],
      title: 'Test',
    })
  })

  it('should handle custom typescript schema and JSON field schema', async () => {
    const customSchema: JSONSchema4 = {
      type: 'object',
      properties: {
        id: {
          type: 'number',
        },
        required: ['id'],
      },
    }

    const config: Partial<Config> = {
      collections: [
        {
          slug: 'test',
          fields: [
            {
              name: 'withCustom',
              type: 'text',
              typescriptSchema: [() => customSchema],
            },
            {
              name: 'jsonWithSchema',
              type: 'json',
              jsonSchema: {
                fileMatch: ['a://b/foo.json'],
                schema: customSchema,
                uri: 'a://b/foo.json',
              },
            },
          ],
          timestamps: false,
        },
      ],
    }

    const sanitizedConfig = await sanitizeConfig(config as Config)
    const schema = configToJSONSchema(sanitizedConfig, 'text')

    expect(schema?.definitions?.test).toStrictEqual({
      type: 'object',
      additionalProperties: false,
      properties: {
        id: {
          type: 'string',
        },
        jsonWithSchema: customSchema,
        withCustom: customSchema,
      },
      required: ['id'],
      title: 'Test',
    })
  })

  it('should handle same block object being referenced in both collection and config.blocks', async () => {
    const sharedBlock: Block = {
      slug: 'sharedBlock',
      interfaceName: 'SharedBlock',
      fields: [
        {
          name: 'richText',
          type: 'richText',
          editor: () => {
            // stub rich text editor
            return {
              CellComponent: '',
              FieldComponent: '',
              validate: () => true,
            }
          },
        },
      ],
    }

    // @ts-expect-error
    const config: Config = {
      blocks: [sharedBlock],
      collections: [
        {
          slug: 'test',
          fields: [
            {
              name: 'someBlockField',
              type: 'blocks',
              blocks: [sharedBlock],
            },
          ],
          timestamps: false,
        },
      ],
    }

    // Ensure both rich text editor are sanitized
    const sanitizedConfig = await sanitizeConfig(config)
    expect(typeof (sanitizedConfig?.blocks?.[0]?.fields?.[0] as RichTextField)?.editor).toBe(
      'object',
    )
    expect(
      typeof (
        (sanitizedConfig.collections[0].fields[0] as BlocksField)?.blocks?.[0]
          ?.fields?.[0] as RichTextField
      )?.editor,
    ).toBe('object')

    const schema = configToJSONSchema(sanitizedConfig, 'text')

    expect(schema?.definitions?.test).toStrictEqual({
      type: 'object',
      additionalProperties: false,
      title: 'Test',
      properties: {
        id: {
          type: 'string',
        },
        someBlockField: {
          type: ['array', 'null'],
          items: {
            oneOf: [
              {
                $ref: '#/definitions/SharedBlock',
              },
            ],
          },
        },
      },
      required: ['id'],
    })

    expect(schema?.definitions?.SharedBlock).toBeDefined()
  })

  it('should allow overriding required to false', async () => {
    // @ts-expect-error
    const config: Config = {
      collections: [
        {
          slug: 'test',
          fields: [
            {
              name: 'title',
              type: 'text',
              required: true,
              defaultValue: 'test',
              typescriptSchema: [
                () => ({
                  type: 'string',
                  required: false,
                }),
              ],
            },
          ],
          timestamps: false,
        },
      ],
    }

    const sanitizedConfig = await sanitizeConfig(config)
    const schema = configToJSONSchema(sanitizedConfig, 'text')

    // @ts-expect-error
    expect(schema.definitions.test.properties.title.required).toStrictEqual(false)
  })
})
</file>

<file path="packages/payload/src/utilities/configToJSONSchema.ts">
// @ts-strict-ignore
import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'

import pluralize from 'pluralize'
const { singular } = pluralize

import type { I18n } from '@convexcms/translations'

import type { Auth } from '../auth/types.js'
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { FieldAffectingData, FlattenedField, Option } from '../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'

import { MissingEditorProp } from '../errors/MissingEditorProp.js'
import { fieldAffectsData } from '../fields/config/types.js'
import { generateJobsJSONSchemas } from '../queues/config/generateJobsJSONSchemas.js'
import { toWords } from './formatLabels.js'
import { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'

const fieldIsRequired = (field: FlattenedField) => {
  const isConditional = Boolean(field?.admin && field?.admin?.condition)
  if (isConditional) {
    return false
  }

  const isMarkedRequired = 'required' in field && field.required === true
  if (fieldAffectsData(field) && isMarkedRequired) {
    return true
  }

  // if any subfields are required, this field is required
  if ('fields' in field && field.type !== 'array') {
    return field.flattenedFields.some((subField) => fieldIsRequired(subField))
  }

  return false
}

function buildOptionEnums(options: Option[]): string[] {
  return options.map((option) => {
    if (typeof option === 'object' && 'value' in option) {
      return option.value
    }

    return option
  })
}

function generateEntitySchemas(
  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],
): JSONSchema4 {
  const properties = [...entities].reduce((acc, { slug }) => {
    acc[slug] = {
      $ref: `#/definitions/${slug}`,
    }

    return acc
  }, {})

  return {
    type: 'object',
    additionalProperties: false,
    properties,
    required: Object.keys(properties),
  }
}

function generateEntitySelectSchemas(
  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],
): JSONSchema4 {
  const properties = [...entities].reduce((acc, { slug }) => {
    acc[slug] = {
      $ref: `#/definitions/${slug}_select`,
    }

    return acc
  }, {})

  return {
    type: 'object',
    additionalProperties: false,
    properties,
    required: Object.keys(properties),
  }
}

function generateCollectionJoinsSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {
  const properties = [...collections].reduce<Record<string, JSONSchema4>>(
    (acc, { slug, joins, polymorphicJoins }) => {
      const schema = {
        type: 'object',
        additionalProperties: false,
        properties: {},
        required: [],
      } satisfies JSONSchema4

      for (const collectionSlug in joins) {
        for (const join of joins[collectionSlug]) {
          schema.properties[join.joinPath] = {
            type: 'string',
            enum: [collectionSlug],
          }
          schema.required.push(join.joinPath)
        }
      }

      for (const join of polymorphicJoins) {
        schema.properties[join.joinPath] = {
          type: 'string',
          enum: join.field.collection,
        }
        schema.required.push(join.joinPath)
      }

      if (Object.keys(schema.properties).length > 0) {
        acc[slug] = schema
      }

      return acc
    },
    {},
  )

  return {
    type: 'object',
    additionalProperties: false,
    properties,
    required: Object.keys(properties),
  }
}

function generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {
  if (localization && 'locales' in localization && localization?.locales) {
    const localesFromConfig = localization?.locales

    const locales = [...localesFromConfig].map((locale) => {
      return locale.code
    }, [])

    return {
      type: 'string',
      enum: locales,
    }
  }

  return {
    type: 'null',
  }
}

function generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {
  const properties: JSONSchema4[] = [...entities]
    .filter(({ auth }) => Boolean(auth))
    .map(({ slug }) => {
      return {
        allOf: [
          { $ref: `#/definitions/${slug}` },
          {
            type: 'object',
            additionalProperties: false,
            properties: {
              collection: { type: 'string', enum: [slug] },
            },
            required: ['collection'],
          },
        ],
      }
    }, {})

  return {
    oneOf: properties,
  }
}

/**
 * Generates the JSON Schema for database configuration
 *
 * @example { db: idType: string }
 */
function generateDbEntitySchema(config: SanitizedConfig): JSONSchema4 {
  const defaultIDType: JSONSchema4 =
    config.db?.defaultIDType === 'number' ? { type: 'number' } : { type: 'string' }

  return {
    type: 'object',
    additionalProperties: false,
    properties: {
      defaultIDType,
    },
    required: ['defaultIDType'],
  }
}

/**
 * Returns a JSON Schema Type with 'null' added if the field is not required.
 */
export function withNullableJSONSchemaType(
  fieldType: JSONSchema4TypeName,
  isRequired: boolean,
): JSONSchema4TypeName | JSONSchema4TypeName[] {
  const fieldTypes = [fieldType]
  if (isRequired) {
    return fieldType
  }
  fieldTypes.push('null')
  return fieldTypes
}

function entityOrFieldToJsDocs({
  entity,
  i18n,
}: {
  entity: FlattenedField | SanitizedCollectionConfig | SanitizedGlobalConfig
  i18n?: I18n
}): string | undefined {
  let description: string | undefined = undefined
  if (entity?.admin?.description) {
    if (typeof entity?.admin?.description === 'string') {
      description = entity?.admin?.description
    } else if (typeof entity?.admin?.description === 'object') {
      if (entity?.admin?.description?.en) {
        description = entity?.admin?.description?.en
      } else if (entity?.admin?.description?.[i18n.language]) {
        description = entity?.admin?.description?.[i18n.language]
      }
    } else if (typeof entity?.admin?.description === 'function' && i18n) {
      // do not evaluate description functions for generating JSDocs. The output of
      // those can differ depending on where and when they are called, creating
      // inconsistencies in the generated JSDocs.
    }
  }
  return description
}
export function fieldsToJSONSchema(
  /**
   * Used for relationship fields, to determine whether to use a string or number type for the ID.
   * While there is a default ID field type set by the db adapter, they can differ on a collection-level
   * if they have custom ID fields.
   */
  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },
  fields: FlattenedField[],
  /**
   * Allows you to define new top-level interfaces that can be re-used in the output schema.
   */
  interfaceNameDefinitions: Map<string, JSONSchema4>,
  config?: SanitizedConfig,
  i18n?: I18n,
): {
  properties: {
    [k: string]: JSONSchema4
  }
  required: string[]
} {
  const requiredFieldNames = new Set<string>()

  return {
    properties: Object.fromEntries(
      fields.reduce((fieldSchemas, field, index) => {
        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)

        const fieldDescription = entityOrFieldToJsDocs({ entity: field, i18n })
        const baseFieldSchema: JSONSchema4 = {}
        if (fieldDescription) {
          baseFieldSchema.description = fieldDescription
        }

        let fieldSchema: JSONSchema4

        switch (field.type) {
          case 'array': {
            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('array', isRequired),
              items: {
                type: 'object',
                additionalProperties: false,
                ...fieldsToJSONSchema(
                  collectionIDFieldTypes,
                  field.flattenedFields,
                  interfaceNameDefinitions,
                  config,
                  i18n,
                ),
              },
            }

            if (field.interfaceName) {
              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)

              fieldSchema = {
                $ref: `#/definitions/${field.interfaceName}`,
              }
            }
            break
          }
          case 'blocks': {
            // Check for a case where no blocks are provided.
            // We need to generate an empty array for this case, note that JSON schema 4 doesn't support empty arrays
            // so the best we can get is `unknown[]`
            const hasBlocks = Boolean(
              field.blockReferences ? field.blockReferences.length : field.blocks.length,
            )

            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('array', isRequired),
              items: hasBlocks
                ? {
                    oneOf: (field.blockReferences ?? field.blocks).map((block) => {
                      if (typeof block === 'string') {
                        const resolvedBlock = config?.blocks?.find((b) => b.slug === block)
                        return {
                          $ref: `#/definitions/${resolvedBlock.interfaceName ?? resolvedBlock.slug}`,
                        }
                      }
                      const blockFieldSchemas = fieldsToJSONSchema(
                        collectionIDFieldTypes,
                        block.flattenedFields,
                        interfaceNameDefinitions,
                        config,
                        i18n,
                      )

                      const blockSchema: JSONSchema4 = {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                          ...blockFieldSchemas.properties,
                          blockType: {
                            const: block.slug,
                          },
                        },
                        required: ['blockType', ...blockFieldSchemas.required],
                      }

                      if (block.interfaceName) {
                        interfaceNameDefinitions.set(block.interfaceName, blockSchema)

                        return {
                          $ref: `#/definitions/${block.interfaceName}`,
                        }
                      }

                      return blockSchema
                    }),
                  }
                : {},
            }
            break
          }
          case 'checkbox': {
            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('boolean', isRequired),
            }
            break
          }
          case 'code':
          case 'date':
          case 'email':
          case 'textarea': {
            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('string', isRequired),
            }
            break
          }

          case 'group':
          case 'tab': {
            fieldSchema = {
              ...baseFieldSchema,
              type: 'object',
              additionalProperties: false,
              ...fieldsToJSONSchema(
                collectionIDFieldTypes,
                field.flattenedFields,
                interfaceNameDefinitions,
                config,
                i18n,
              ),
            }

            if (field.interfaceName) {
              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)

              fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }
            }
            break
          }

          case 'join': {
            let items: JSONSchema4

            if (Array.isArray(field.collection)) {
              items = {
                oneOf: field.collection.map((collection) => ({
                  type: 'object',
                  additionalProperties: false,
                  properties: {
                    relationTo: {
                      const: collection,
                    },
                    value: {
                      oneOf: [
                        {
                          type: collectionIDFieldTypes[collection],
                        },
                        {
                          $ref: `#/definitions/${collection}`,
                        },
                      ],
                    },
                  },
                  required: ['collectionSlug', 'value'],
                })),
              }
            } else {
              items = {
                oneOf: [
                  {
                    type: collectionIDFieldTypes[field.collection],
                  },
                  {
                    $ref: `#/definitions/${field.collection}`,
                  },
                ],
              }
            }

            fieldSchema = {
              ...baseFieldSchema,
              type: 'object',
              additionalProperties: false,
              properties: {
                docs: {
                  type: 'array',
                  items,
                },
                hasNextPage: { type: 'boolean' },
                totalDocs: { type: 'number' },
              },
            }
            break
          }

          case 'json': {
            fieldSchema = field.jsonSchema?.schema || {
              ...baseFieldSchema,
              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],
            }
            break
          }

          case 'number': {
            if (field.hasMany === true) {
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('array', isRequired),
                items: { type: 'number' },
              }
            } else {
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('number', isRequired),
              }
            }
            break
          }

          case 'point': {
            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('array', isRequired),
              items: [
                {
                  type: 'number',
                },
                {
                  type: 'number',
                },
              ],
              maxItems: 2,
              minItems: 2,
            }
            break
          }
          case 'radio': {
            fieldSchema = {
              ...baseFieldSchema,
              type: withNullableJSONSchemaType('string', isRequired),
              enum: buildOptionEnums(field.options),
            }

            if (field.interfaceName) {
              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)

              fieldSchema = {
                $ref: `#/definitions/${field.interfaceName}`,
              }
            }

            break
          }

          case 'relationship':
          case 'upload': {
            if (Array.isArray(field.relationTo)) {
              if (field.hasMany) {
                fieldSchema = {
                  ...baseFieldSchema,
                  type: withNullableJSONSchemaType('array', isRequired),
                  items: {
                    oneOf: field.relationTo.map((relation) => {
                      return {
                        type: 'object',
                        additionalProperties: false,
                        properties: {
                          relationTo: {
                            const: relation,
                          },
                          value: {
                            oneOf: [
                              {
                                type: collectionIDFieldTypes[relation],
                              },
                              {
                                $ref: `#/definitions/${relation}`,
                              },
                            ],
                          },
                        },
                        required: ['value', 'relationTo'],
                      }
                    }),
                  },
                }
              } else {
                fieldSchema = {
                  ...baseFieldSchema,
                  oneOf: field.relationTo.map((relation) => {
                    return {
                      type: withNullableJSONSchemaType('object', isRequired),
                      additionalProperties: false,
                      properties: {
                        relationTo: {
                          const: relation,
                        },
                        value: {
                          oneOf: [
                            {
                              type: collectionIDFieldTypes[relation],
                            },
                            {
                              $ref: `#/definitions/${relation}`,
                            },
                          ],
                        },
                      },
                      required: ['value', 'relationTo'],
                    }
                  }),
                }
              }
            } else if (field.hasMany) {
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('array', isRequired),
                items: {
                  oneOf: [
                    {
                      type: collectionIDFieldTypes[field.relationTo],
                    },
                    {
                      $ref: `#/definitions/${field.relationTo}`,
                    },
                  ],
                },
              }
            } else {
              fieldSchema = {
                ...baseFieldSchema,
                oneOf: [
                  {
                    type: withNullableJSONSchemaType(
                      collectionIDFieldTypes[field.relationTo],
                      isRequired,
                    ),
                  },
                  { $ref: `#/definitions/${field.relationTo}` },
                ],
              }
            }

            break
          }

          case 'richText': {
            if (!field?.editor) {
              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
            }
            if (typeof field.editor === 'function') {
              throw new Error('Attempted to access unsanitized rich text editor.')
            }
            if (field.editor.outputSchema) {
              fieldSchema = {
                ...baseFieldSchema,
                ...field.editor.outputSchema({
                  collectionIDFieldTypes,
                  config,
                  field,
                  i18n,
                  interfaceNameDefinitions,
                  isRequired,
                }),
              }
            } else {
              // Maintain backwards compatibility with existing rich text editors
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('array', isRequired),
                items: {
                  type: 'object',
                },
              }
            }

            break
          }
          case 'select': {
            const optionEnums = buildOptionEnums(field.options)
            // We get the previous field to check for a date in the case of a timezone select
            // This works because timezone selects are always inserted right after a date with 'timezone: true'
            const previousField = fields?.[index - 1]
            const isTimezoneField =
              previousField?.type === 'date' && previousField.timezone && field.name.includes('_tz')

            // Timezone selects should reference the supportedTimezones definition
            if (isTimezoneField) {
              fieldSchema = {
                $ref: `#/definitions/supportedTimezones`,
              }
            } else {
              if (field.hasMany) {
                fieldSchema = {
                  ...baseFieldSchema,
                  type: withNullableJSONSchemaType('array', isRequired),
                  items: {
                    type: 'string',
                  },
                }
                if (optionEnums?.length) {
                  ;(fieldSchema.items as JSONSchema4).enum = optionEnums
                }
              } else {
                fieldSchema = {
                  ...baseFieldSchema,
                  type: withNullableJSONSchemaType('string', isRequired),
                }
                if (optionEnums?.length) {
                  fieldSchema.enum = optionEnums
                }
              }

              if (field.interfaceName) {
                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)

                fieldSchema = {
                  $ref: `#/definitions/${field.interfaceName}`,
                }
              }
              break
            }

            break
          }

          case 'text':
            if (field.hasMany === true) {
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('array', isRequired),
                items: { type: 'string' },
              }
            } else {
              fieldSchema = {
                ...baseFieldSchema,
                type: withNullableJSONSchemaType('string', isRequired),
              }
            }
            break

          default: {
            break
          }
        }

        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {
          for (const schema of field.typescriptSchema) {
            fieldSchema = schema({ jsonSchema: fieldSchema })
          }
        }

        if (fieldSchema && fieldAffectsData(field)) {
          if (isRequired && fieldSchema.required !== false) {
            requiredFieldNames.add(field.name)
          }
          fieldSchemas.set(field.name, fieldSchema)
        }

        return fieldSchemas
      }, new Map<string, JSONSchema4>()),
    ),
    required: Array.from(requiredFieldNames),
  }
}

// This function is part of the public API and is exported through payload/utilities
export function entityToJSONSchema(
  config: SanitizedConfig,
  entity: SanitizedCollectionConfig | SanitizedGlobalConfig,
  interfaceNameDefinitions: Map<string, JSONSchema4>,
  defaultIDType: 'number' | 'text',
  collectionIDFieldTypes?: { [key: string]: 'number' | 'string' },
  i18n?: I18n,
): JSONSchema4 {
  if (!collectionIDFieldTypes) {
    collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })
  }

  const title = entity.typescript?.interface
    ? entity.typescript.interface
    : singular(toWords(entity.slug, true))

  let mutableFields = [...entity.flattenedFields]

  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }
  const customIdField = mutableFields.find((field) => field.name === 'id') as FieldAffectingData

  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {
    mutableFields = mutableFields.map((field) => {
      if (field === customIdField) {
        return { ...field, required: true }
      }

      return field
    })
  } else {
    mutableFields.unshift(idField)
  }

  // mark timestamp fields required
  if ('timestamps' in entity && entity.timestamps !== false) {
    mutableFields = mutableFields.map((field) => {
      if (field.name === 'createdAt' || field.name === 'updatedAt') {
        return {
          ...field,
          required: true,
        }
      }
      return field
    })
  }

  if (
    'auth' in entity &&
    entity.auth &&
    (!entity.auth?.disableLocalStrategy ||
      (typeof entity.auth?.disableLocalStrategy === 'object' &&
        entity.auth.disableLocalStrategy.enableFields))
  ) {
    mutableFields.push({
      name: 'password',
      type: 'text',
    })
  }

  const jsonSchema: JSONSchema4 = {
    type: 'object',
    additionalProperties: false,
    title,
    ...fieldsToJSONSchema(
      collectionIDFieldTypes,
      mutableFields,
      interfaceNameDefinitions,
      config,
      i18n,
    ),
  }

  const entityDescription = entityOrFieldToJsDocs({ entity, i18n })

  if (entityDescription) {
    jsonSchema.description = entityDescription
  }

  return jsonSchema
}

export function fieldsToSelectJSONSchema({
  config,
  fields,
  interfaceNameDefinitions,
}: {
  config: SanitizedConfig
  fields: FlattenedField[]
  interfaceNameDefinitions: Map<string, JSONSchema4>
}): JSONSchema4 {
  const schema: JSONSchema4 = {
    type: 'object',
    additionalProperties: false,
    properties: {},
  }

  for (const field of fields) {
    switch (field.type) {
      case 'array':
      case 'group':
      case 'tab': {
        let fieldSchema: JSONSchema4 = fieldsToSelectJSONSchema({
          config,
          fields: field.flattenedFields,
          interfaceNameDefinitions,
        })

        if (field.interfaceName) {
          const definition = `${field.interfaceName}_select`
          interfaceNameDefinitions.set(definition, fieldSchema)

          fieldSchema = {
            $ref: `#/definitions/${definition}`,
          }
        }

        schema.properties[field.name] = {
          oneOf: [
            {
              type: 'boolean',
            },
            fieldSchema,
          ],
        }

        break
      }

      case 'blocks': {
        const blocksSchema: JSONSchema4 = {
          type: 'object',
          additionalProperties: false,
          properties: {},
        }

        for (const block of field.blockReferences ?? field.blocks) {
          if (typeof block === 'string') {
            continue // TODO
          }

          let blockSchema = fieldsToSelectJSONSchema({
            config,
            fields: block.flattenedFields,
            interfaceNameDefinitions,
          })

          if (block.interfaceName) {
            const definition = `${block.interfaceName}_select`
            interfaceNameDefinitions.set(definition, blockSchema)
            blockSchema = {
              $ref: `#/definitions/${definition}`,
            }
          }

          blocksSchema.properties[block.slug] = {
            oneOf: [
              {
                type: 'boolean',
              },
              blockSchema,
            ],
          }
        }

        schema.properties[field.name] = {
          oneOf: [
            {
              type: 'boolean',
            },
            blocksSchema,
          ],
        }

        break
      }

      default:
        schema.properties[field.name] = {
          type: 'boolean',
        }
        break
    }
  }

  return schema
}

const fieldType: JSONSchema4 = {
  type: 'string',
  required: false,
}
const generateAuthFieldTypes = ({
  type,
  loginWithUsername,
}: {
  loginWithUsername: Auth['loginWithUsername']
  type: 'forgotOrUnlock' | 'login' | 'register'
}): JSONSchema4 => {
  if (loginWithUsername) {
    switch (type) {
      case 'forgotOrUnlock': {
        if (loginWithUsername.allowEmailLogin) {
          // allow email or username for unlock/forgot-password
          return {
            additionalProperties: false,
            oneOf: [
              {
                additionalProperties: false,
                properties: { email: fieldType },
                required: ['email'],
              },
              {
                additionalProperties: false,
                properties: { username: fieldType },
                required: ['username'],
              },
            ],
          }
        } else {
          // allow only username for unlock/forgot-password
          return {
            additionalProperties: false,
            properties: { username: fieldType },
            required: ['username'],
          }
        }
      }

      case 'login': {
        if (loginWithUsername.allowEmailLogin) {
          // allow username or email and require password for login
          return {
            additionalProperties: false,
            oneOf: [
              {
                additionalProperties: false,
                properties: { email: fieldType, password: fieldType },
                required: ['email', 'password'],
              },
              {
                additionalProperties: false,
                properties: { password: fieldType, username: fieldType },
                required: ['username', 'password'],
              },
            ],
          }
        } else {
          // allow only username and password for login
          return {
            additionalProperties: false,
            properties: {
              password: fieldType,
              username: fieldType,
            },
            required: ['username', 'password'],
          }
        }
      }

      case 'register': {
        const requiredFields: ('email' | 'password' | 'username')[] = ['password']
        const properties: {
          email?: JSONSchema4['properties']
          password?: JSONSchema4['properties']
          username?: JSONSchema4['properties']
        } = {
          password: fieldType,
          username: fieldType,
        }

        if (loginWithUsername.requireEmail) {
          requiredFields.push('email')
        }
        if (loginWithUsername.requireUsername) {
          requiredFields.push('username')
        }
        if (loginWithUsername.requireEmail || loginWithUsername.allowEmailLogin) {
          properties.email = fieldType
        }

        return {
          additionalProperties: false,
          properties,
          required: requiredFields,
        }
      }
    }
  }

  // default email (and password for login/register)
  return {
    additionalProperties: false,
    properties: { email: fieldType, password: fieldType },
    required: ['email', 'password'],
  }
}

export function authCollectionToOperationsJSONSchema(
  config: SanitizedCollectionConfig,
): JSONSchema4 {
  const loginWithUsername = config.auth?.loginWithUsername
  const loginUserFields: JSONSchema4 = generateAuthFieldTypes({ type: 'login', loginWithUsername })
  const forgotOrUnlockUserFields: JSONSchema4 = generateAuthFieldTypes({
    type: 'forgotOrUnlock',
    loginWithUsername,
  })
  const registerUserFields: JSONSchema4 = generateAuthFieldTypes({
    type: 'register',
    loginWithUsername,
  })

  const properties: JSONSchema4['properties'] = {
    forgotPassword: forgotOrUnlockUserFields,
    login: loginUserFields,
    registerFirstUser: registerUserFields,
    unlock: forgotOrUnlockUserFields,
  }

  return {
    type: 'object',
    additionalProperties: false,
    properties,
    required: Object.keys(properties),
    title: `${singular(toWords(`${config.slug}`, true))}AuthOperations`,
  }
}

// Generates the JSON Schema for supported timezones
export function timezonesToJSONSchema(
  supportedTimezones: SanitizedConfig['admin']['timezones']['supportedTimezones'],
): JSONSchema4 {
  return {
    description: 'Supported timezones in IANA format.',
    enum: supportedTimezones.map((timezone) =>
      typeof timezone === 'string' ? timezone : timezone.value,
    ),
  }
}

function generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {
  const properties = collections.reduce((acc, collection) => {
    if (collection.auth) {
      acc[collection.slug] = {
        $ref: `#/definitions/auth/${collection.slug}`,
      }
    }
    return acc
  }, {})

  return {
    type: 'object',
    additionalProperties: false,
    properties,
    required: Object.keys(properties),
  }
}

/**
 * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.
 */
export function configToJSONSchema(
  config: SanitizedConfig,
  defaultIDType?: 'number' | 'text',
  i18n?: I18n,
): JSONSchema4 {
  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here
  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()

  //  Used for relationship fields, to determine whether to use a string or number type for the ID.
  const collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })

  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global
  // types to be inlined inside the `Config` type

  const entities: {
    entity: SanitizedCollectionConfig | SanitizedGlobalConfig
    type: 'collection' | 'global'
  }[] = [
    ...config.globals.map((global) => ({ type: 'global' as const, entity: global })),
    ...config.collections.map((collection) => ({
      type: 'collection' as const,
      entity: collection,
    })),
  ]

  const entityDefinitions: { [k: string]: JSONSchema4 } = entities.reduce(
    (acc, { type, entity }) => {
      acc[entity.slug] = entityToJSONSchema(
        config,
        entity,
        interfaceNameDefinitions,
        defaultIDType,
        collectionIDFieldTypes,
        i18n,
      )
      const select = fieldsToSelectJSONSchema({
        config,
        fields: entity.flattenedFields,
        interfaceNameDefinitions,
      })

      if (type === 'global') {
        select.properties.globalType = {
          type: 'boolean',
        }
      }

      acc[`${entity.slug}_select`] = {
        type: 'object',
        additionalProperties: false,
        ...select,
      }

      return acc
    },
    {},
  )

  const timezoneDefinitions = timezonesToJSONSchema(config.admin.timezones.supportedTimezones)

  const authOperationDefinitions = [...config.collections]
    .filter(({ auth }) => Boolean(auth))
    .reduce(
      (acc, authCollection) => {
        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)
        return acc
      },
      { auth: {} },
    )

  const jobsSchemas = config.jobs
    ? generateJobsJSONSchemas(
        config,
        config.jobs,
        interfaceNameDefinitions,
        collectionIDFieldTypes,
        i18n,
      )
    : {}

  const blocksDefinition: JSONSchema4 | undefined = {
    type: 'object',
    additionalProperties: false,
    properties: {},
    required: [],
  }
  if (config?.blocks?.length) {
    for (const block of config.blocks) {
      const blockFieldSchemas = fieldsToJSONSchema(
        collectionIDFieldTypes,
        block.flattenedFields,
        interfaceNameDefinitions,
        config,
        i18n,
      )

      const blockSchema: JSONSchema4 = {
        type: 'object',
        additionalProperties: false,
        properties: {
          ...blockFieldSchemas.properties,
          blockType: {
            const: block.slug,
          },
        },
        required: ['blockType', ...blockFieldSchemas.required],
      }

      const interfaceName = block.interfaceName ?? block.slug
      interfaceNameDefinitions.set(interfaceName, blockSchema)

      blocksDefinition.properties[block.slug] = {
        $ref: `#/definitions/${interfaceName}`,
      }
      ;(blocksDefinition.required as string[]).push(block.slug)
    }
  }

  let jsonSchema: JSONSchema4 = {
    additionalProperties: false,
    definitions: {
      supportedTimezones: timezoneDefinitions,
      ...entityDefinitions,
      ...Object.fromEntries(interfaceNameDefinitions),
      ...authOperationDefinitions,
    },
    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type
    type: 'object',
    properties: {
      auth: generateAuthOperationSchemas(config.collections),
      blocks: blocksDefinition,
      collections: generateEntitySchemas(config.collections || []),
      collectionsJoins: generateCollectionJoinsSchemas(config.collections || []),
      collectionsSelect: generateEntitySelectSchemas(config.collections || []),
      db: generateDbEntitySchema(config),
      globals: generateEntitySchemas(config.globals || []),
      globalsSelect: generateEntitySelectSchemas(config.globals || []),
      locale: generateLocaleEntitySchemas(config.localization),
      user: generateAuthEntitySchemas(config.collections),
    },
    required: [
      'user',
      'locale',
      'collections',
      'collectionsSelect',
      'collectionsJoins',
      'globalsSelect',
      'globals',
      'auth',
      'db',
      'jobs',
      'blocks',
    ],
    title: 'Config',
  }

  if (jobsSchemas.definitions?.size) {
    for (const [key, value] of jobsSchemas.definitions) {
      jsonSchema.definitions[key] = value
    }
  }
  if (jobsSchemas.properties) {
    jsonSchema.properties.jobs = {
      type: 'object',
      additionalProperties: false,
      properties: jobsSchemas.properties,
      required: ['tasks', 'workflows'],
    }
  }

  if (config?.typescript?.schema?.length) {
    for (const schema of config.typescript.schema) {
      jsonSchema = schema({ collectionIDFieldTypes, config, i18n, jsonSchema })
    }
  }

  return jsonSchema
}
</file>

<file path="packages/payload/src/utilities/createArrayFromCommaDelineated.ts">
export function createArrayFromCommaDelineated(input: string): string[] {
  if (Array.isArray(input)) {
    return input
  }
  if (input.indexOf(',') > -1) {
    return input.split(',')
  }
  return [input]
}
</file>

<file path="packages/payload/src/utilities/createLocalReq.ts">
// @ts-strict-ignore
import type { User } from '../auth/types.js'
import type { Payload, RequestContext, TypedLocale } from '../index.js'
import type { PayloadRequest } from '../types/index.js'

import { getDataLoader } from '../collections/dataloader.js'
import { getLocalI18n } from '../translations/getLocalI18n.js'
import { sanitizeFallbackLocale } from '../utilities/sanitizeFallbackLocale.js'

function getRequestContext(
  req: Partial<PayloadRequest> = { context: null } as PayloadRequest,
  context: RequestContext = {},
): RequestContext {
  if (req.context) {
    if (Object.keys(req.context).length === 0 && req.context.constructor === Object) {
      // if req.context is `{}` avoid unnecessary spread
      return context
    } else {
      return { ...req.context, ...context }
    }
  } else {
    return context
  }
}

const attachFakeURLProperties = (req: Partial<PayloadRequest>, urlSuffix?: string) => {
  /**
   * *NOTE*
   * If no URL is provided, the local API was called outside
   * the context of a request. Therefore we create a fake URL object.
   * `ts-expect-error` is used below for properties that are 'read-only'.
   * Since they do not exist yet we can safely ignore the error.
   */
  let urlObject: undefined | URL

  function getURLObject() {
    if (urlObject) {
      return urlObject
    }

    const fallbackURL = `http://${req.host || 'localhost'}${urlSuffix || ''}`

    const urlToUse =
      req?.url || req.payload.config?.serverURL
        ? `${req.payload.config.serverURL}${urlSuffix || ''}`
        : fallbackURL

    try {
      urlObject = new URL(urlToUse)
    } catch (_err) {
      req.payload.logger.error(
        `Failed to create URL object from URL: ${urlToUse}, falling back to ${fallbackURL}`,
      )

      urlObject = new URL(fallbackURL)
    }

    return urlObject
  }

  if (!req.host) {
    req.host = getURLObject().host
  }

  if (!req.protocol) {
    req.protocol = getURLObject().protocol
  }

  if (!req.pathname) {
    req.pathname = getURLObject().pathname
  }

  if (!req.searchParams) {
    // @ts-expect-error eslint-disable-next-line no-param-reassign
    req.searchParams = getURLObject().searchParams
  }

  if (!req.origin) {
    // @ts-expect-error eslint-disable-next-line no-param-reassign
    req.origin = getURLObject().origin
  }

  if (!req?.url) {
    // @ts-expect-error eslint-disable-next-line no-param-reassign
    req.url = getURLObject().href
  }
}

type CreateLocalReq = (
  options: {
    context?: RequestContext
    fallbackLocale?: false | TypedLocale
    locale?: string
    req?: Partial<PayloadRequest>
    urlSuffix?: string
    user?: User
  },
  payload: Payload,
) => Promise<PayloadRequest>

export const createLocalReq: CreateLocalReq = async (
  { context, fallbackLocale, locale: localeArg, req = {} as PayloadRequest, urlSuffix, user },
  payload,
): Promise<PayloadRequest> => {
  const localization = payload.config?.localization

  if (localization) {
    const locale = localeArg === '*' ? 'all' : localeArg
    const defaultLocale = localization.defaultLocale
    const localeCandidate = locale || req?.locale || req?.query?.locale

    req.locale =
      localeCandidate && typeof localeCandidate === 'string' ? localeCandidate : defaultLocale

    const sanitizedFallback = sanitizeFallbackLocale({
      fallbackLocale,
      locale: req.locale,
      localization,
    })

    req.fallbackLocale = sanitizedFallback
  }

  const i18n =
    req?.i18n ||
    (await getLocalI18n({ config: payload.config, language: payload.config.i18n.fallbackLanguage }))

  if (!req.headers) {
    // @ts-expect-error eslint-disable-next-line no-param-reassign
    req.headers = new Headers()
  }

  req.context = getRequestContext(req, context)
  req.payloadAPI = req?.payloadAPI || 'local'
  req.payload = payload
  req.i18n = i18n
  req.t = i18n.t
  req.user = user || req?.user || null
  req.payloadDataLoader = req?.payloadDataLoader || getDataLoader(req as PayloadRequest)
  req.routeParams = req?.routeParams || {}
  req.query = req?.query || {}

  attachFakeURLProperties(req, urlSuffix)

  return req as PayloadRequest
}
</file>

<file path="packages/payload/src/utilities/createPayloadRequest.ts">
// @ts-strict-ignore
import { initI18n } from '@convexcms/translations'
import * as qs from 'qs-esm'

import type { SanitizedConfig } from '../config/types.js'
import type { CustomPayloadRequestProperties, PayloadRequest } from '../types/index.js'

import { executeAuthStrategies } from '../auth/executeAuthStrategies.js'
import { getDataLoader } from '../collections/dataloader.js'
import { getPayload } from '../index.js'
import { sanitizeLocales } from './addLocalesToRequest.js'
import { getRequestLanguage } from './getRequestLanguage.js'
import { parseCookies } from './parseCookies.js'

type Args = {
  config: Promise<SanitizedConfig> | SanitizedConfig
  params?: {
    collection: string
  }
  request: Request
}

export const createPayloadRequest = async ({
  config: configPromise,
  params,
  request,
}: Args): Promise<PayloadRequest> => {
  const cookies = parseCookies(request.headers)
  const payload = await getPayload({ config: configPromise })

  const { config } = payload
  const localization = config.localization

  const urlProperties = new URL(request.url)
  const { pathname, searchParams } = urlProperties

  const isGraphQL =
    !config.graphQL.disable && pathname === `${config.routes.api}${config.routes.graphQL}`

  const language = getRequestLanguage({
    config,
    cookies,
    headers: request.headers,
  })

  const i18n = await initI18n({
    config: config.i18n,
    context: 'api',
    language,
  })

  const fallbackFromRequest =
    searchParams.get('fallback-locale') || searchParams.get('fallbackLocale')
  let locale = searchParams.get('locale')
  let fallbackLocale = fallbackFromRequest

  const { search: queryToParse } = urlProperties

  const query = queryToParse
    ? qs.parse(queryToParse, {
        arrayLimit: 1000,
        depth: 10,
        ignoreQueryPrefix: true,
      })
    : {}

  if (localization) {
    const locales = sanitizeLocales({
      fallbackLocale,
      locale,
      localization,
    })

    fallbackLocale = locales.fallbackLocale
    locale = locales.locale
  }

  const customRequest: CustomPayloadRequestProperties = {
    context: {},
    fallbackLocale,
    hash: urlProperties.hash,
    host: urlProperties.host,
    href: urlProperties.href,
    i18n,
    locale,
    origin: urlProperties.origin,
    pathname: urlProperties.pathname,
    payload,
    payloadAPI: isGraphQL ? 'GraphQL' : 'REST',
    payloadDataLoader: undefined,
    payloadUploadSizes: {},
    port: urlProperties.port,
    protocol: urlProperties.protocol,
    query,
    routeParams: params || {},
    search: urlProperties.search,
    searchParams: urlProperties.searchParams,
    t: i18n.t,
    transactionID: undefined,
    user: null,
  }

  const req: PayloadRequest = Object.assign(request, customRequest)

  req.payloadDataLoader = getDataLoader(req)

  const { responseHeaders, user } = await executeAuthStrategies({
    headers: req.headers,
    isGraphQL,
    payload,
  })

  req.user = user

  if (responseHeaders) {
    req.responseHeaders = responseHeaders
  }

  return req
}
</file>

<file path="packages/payload/src/utilities/deepCopyObject.ts">
// @ts-strict-ignore
import type { JsonValue } from '../types/index.js'

/*
Main deepCopyObject handling - from rfdc: https://github.com/davidmarkclements/rfdc/blob/master/index.js

Copyright 2019 "David Mark Clements <david.mark.clements@gmail.com>"

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
*/

function copyBuffer(cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur)
  }

  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
}

const constructorHandlers = new Map()
constructorHandlers.set(Date, (o) => new Date(o))
constructorHandlers.set(Map, (o, fn) => new Map(cloneArray<any>(Array.from(o), fn)))
constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)))
constructorHandlers.set(RegExp, (regex: RegExp) => new RegExp(regex.source, regex.flags))

let handler = null

function cloneArray<T>(a: T, fn): T {
  const keys = Object.keys(a)
  const a2 = new Array(keys.length)
  for (let i = 0; i < keys.length; i++) {
    const k = keys[i]
    const cur = a[k]
    if (typeof cur !== 'object' || cur === null) {
      a2[k] = cur
    } else if (cur instanceof RegExp) {
      a2[k] = new RegExp(cur.source, cur.flags)
    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
      a2[k] = handler(cur, fn)
    } else if (ArrayBuffer.isView(cur)) {
      a2[k] = copyBuffer(cur)
    } else {
      a2[k] = fn(cur)
    }
  }
  return a2 as T
}

export const deepCopyObject = <T>(o: T): T => {
  if (typeof o !== 'object' || o === null) {
    return o
  }
  if (Array.isArray(o)) {
    return cloneArray(o, deepCopyObject)
  }
  if (o instanceof RegExp) {
    return new RegExp(o.source, o.flags) as T
  }

  if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
    return handler(o, deepCopyObject)
  }
  const o2 = {}
  for (const k in o) {
    if (Object.hasOwnProperty.call(o, k) === false) {
      continue
    }
    const cur = o[k]
    if (typeof cur !== 'object' || cur === null) {
      o2[k as string] = cur
    } else if (cur instanceof RegExp) {
      o2[k as string] = new RegExp(cur.source, cur.flags)
    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
      o2[k as string] = handler(cur, deepCopyObject)
    } else if (ArrayBuffer.isView(cur)) {
      o2[k as string] = copyBuffer(cur)
    } else {
      o2[k as string] = deepCopyObject(cur)
    }
  }
  return o2 as T
}

/*
Fast deepCopyObjectSimple handling - from fast-json-clone: https://github.com/rhysd/fast-json-clone

Benchmark: https://github.com/AlessioGr/fastest-deep-clone-json/blob/main/test/benchmark.js
*/

/**
 * A deepCopyObject implementation which only works for JSON objects and arrays, and is faster than
 * JSON.parse(JSON.stringify(obj))
 *
 * @param value The JSON value to be cloned. There are two invariants. 1) It must not contain circles
 *              as JSON does not allow it. This function will cause infinite loop for such values by
 *              design. 2) It must contain JSON values only. Other values like `Date`, `Regexp`, `Map`,
 *              `Set`, `Buffer`, ... are not allowed.
 * @returns The cloned JSON value.
 */
export function deepCopyObjectSimple<T extends JsonValue>(value: T, filterUndefined = false): T {
  if (typeof value !== 'object' || value === null) {
    return value
  } else if (Array.isArray(value)) {
    return value.map((e) =>
      typeof e !== 'object' || e === null ? e : deepCopyObjectSimple(e, filterUndefined),
    ) as T
  } else {
    if (value instanceof Date) {
      return new Date(value) as unknown as T
    }
    const ret: { [key: string]: T } = {}
    for (const k in value) {
      const v = value[k]
      if (filterUndefined && v === undefined) {
        continue
      }
      ret[k] =
        typeof v !== 'object' || v === null
          ? v
          : (deepCopyObjectSimple(v as T, filterUndefined) as any)
    }
    return ret as unknown as T
  }
}

export function deepCopyObjectSimpleWithoutReactComponents<T extends JsonValue>(value: T): T {
  if (
    typeof value === 'object' &&
    value !== null &&
    '$$typeof' in value &&
    typeof value.$$typeof === 'symbol'
  ) {
    return undefined
  } else if (typeof value !== 'object' || value === null) {
    return value
  } else if (Array.isArray(value)) {
    return value.map((e) =>
      typeof e !== 'object' || e === null ? e : deepCopyObjectSimpleWithoutReactComponents(e),
    ) as T
  } else {
    if (value instanceof Date) {
      return new Date(value) as unknown as T
    }
    const ret: { [key: string]: T } = {}
    for (const k in value) {
      const v = value[k]
      ret[k] =
        typeof v !== 'object' || v === null
          ? v
          : (deepCopyObjectSimpleWithoutReactComponents(v as T) as any)
    }
    return ret as unknown as T
  }
}

/**
 * A deepCopyObject implementation which is slower than deepCopyObject, but more correct.
 * Can be used if correctness is more important than speed. Supports circular dependencies
 */
export function deepCopyObjectComplex<T>(object: T, cache: WeakMap<any, any> = new WeakMap()): T {
  if (object === null) {
    return null
  }

  if (cache.has(object)) {
    return cache.get(object)
  }

  // Handle File
  if (object instanceof File) {
    return object as unknown as T
  }

  // Handle Date
  if (object instanceof Date) {
    return new Date(object.getTime()) as unknown as T
  }

  // Handle RegExp
  if (object instanceof RegExp) {
    return new RegExp(object.source, object.flags) as unknown as T
  }

  // Handle Map
  if (object instanceof Map) {
    const clonedMap = new Map()
    cache.set(object, clonedMap)
    for (const [key, value] of object.entries()) {
      clonedMap.set(key, deepCopyObjectComplex(value, cache))
    }
    return clonedMap as unknown as T
  }

  // Handle Set
  if (object instanceof Set) {
    const clonedSet = new Set()
    cache.set(object, clonedSet)
    for (const value of object.values()) {
      clonedSet.add(deepCopyObjectComplex(value, cache))
    }
    return clonedSet as unknown as T
  }

  // Handle Array and Object
  if (typeof object === 'object' && object !== null) {
    if ('$$typeof' in object && typeof object.$$typeof === 'symbol') {
      return object
    }

    const clonedObject: any = Array.isArray(object)
      ? []
      : Object.create(Object.getPrototypeOf(object))
    cache.set(object, clonedObject)

    for (const key in object) {
      if (
        Object.prototype.hasOwnProperty.call(object, key) ||
        Object.getOwnPropertySymbols(object).includes(key as any)
      ) {
        clonedObject[key] = deepCopyObjectComplex(object[key], cache)
      }
    }

    return clonedObject as T
  }

  // Handle all other cases
  return object
}
</file>

<file path="packages/payload/src/utilities/deepMerge.ts">
// @ts-strict-ignore
import deepMerge from 'deepmerge'

import { isPlainObject } from './isPlainObject.js'

export { deepMerge }
/**
 * Fully-featured deepMerge.
 *
 * Array handling: Arrays in the target object are combined with the source object's arrays.
 */
export function deepMergeWithCombinedArrays<T extends object>(
  obj1: object,
  obj2: object,
  options: deepMerge.Options = {},
): T {
  return deepMerge<T>(obj1, obj2, {
    arrayMerge: (target, source, options) => {
      const destination = target.slice()

      source.forEach((item, index) => {
        if (typeof destination[index] === 'undefined') {
          destination[index] = options.cloneUnlessOtherwiseSpecified(item, options)
        } else if (options.isMergeableObject(item)) {
          destination[index] = deepMerge(target[index], item, options)
        } else if (target.indexOf(item) === -1) {
          destination.push(item)
        }
      })
      return destination
    },
    ...options,
  })
}

/**
 * Fully-featured deepMerge.
 *
 * Array handling: Arrays in the target object are replaced by the source object's arrays.
 */
export function deepMergeWithSourceArrays<T extends object>(obj1: object, obj2: object): T {
  return deepMerge<T>(obj1, obj2, { arrayMerge: (_, source) => source })
}

/**
 * Fully-featured deepMerge. Does not clone React components by default.
 */
export function deepMergeWithReactComponents<T extends object>(obj1: object, obj2: object): T {
  return deepMerge<T>(obj1, obj2, {
    isMergeableObject: isPlainObject,
  })
}
</file>

<file path="packages/payload/src/utilities/fieldSchemaToJSON.ts">
import type { ClientConfig } from '../config/client.js'
// @ts-strict-ignore
import type { ClientField } from '../fields/config/client.js'
import type { FieldTypes } from '../fields/config/types.js'

export type FieldSchemaJSON = {
  blocks?: FieldSchemaJSON // TODO: conditionally add based on `type`
  fields?: FieldSchemaJSON // TODO: conditionally add based on `type`
  hasMany?: boolean // TODO: conditionally add based on `type`
  name: string
  relationTo?: string // TODO: conditionally add based on `type`
  slug?: string // TODO: conditionally add based on `type`
  type: FieldTypes
}[]

export const fieldSchemaToJSON = (fields: ClientField[], config: ClientConfig): FieldSchemaJSON => {
  return fields.reduce((acc, field) => {
    let result = acc

    switch (field.type) {
      case 'array':
        acc.push({
          name: field.name,
          type: field.type,
          fields: fieldSchemaToJSON(
            [
              ...field.fields,
              {
                name: 'id',
                type: 'text',
              },
            ],
            config,
          ),
        })

        break

      case 'blocks':
        acc.push({
          name: field.name,
          type: field.type,
          blocks: (field.blockReferences ?? field.blocks).reduce((acc, _block) => {
            const block = typeof _block === 'string' ? config.blocksMap[_block] : _block
            acc[block.slug] = {
              fields: fieldSchemaToJSON(
                [
                  ...block.fields,
                  {
                    name: 'id',
                    type: 'text',
                  },
                ],
                config,
              ),
            }

            return acc
          }, {}),
        })

        break

      case 'collapsible': // eslint-disable no-fallthrough
      case 'row':
        result = result.concat(fieldSchemaToJSON(field.fields, config))
        break

      case 'group':
        acc.push({
          name: field.name,
          type: field.type,
          fields: fieldSchemaToJSON(field.fields, config),
        })

        break

      case 'relationship': // eslint-disable no-fallthrough
      case 'upload':
        acc.push({
          name: field.name,
          type: field.type,
          hasMany: 'hasMany' in field ? Boolean(field.hasMany) : false, // TODO: type this
          relationTo: field.relationTo,
        })

        break

      case 'tabs': {
        let tabFields = []

        field.tabs.forEach((tab) => {
          if ('name' in tab) {
            tabFields.push({
              name: tab.name,
              type: field.type,
              fields: fieldSchemaToJSON(tab.fields, config),
            })
            return
          }

          tabFields = tabFields.concat(fieldSchemaToJSON(tab.fields, config))
        })

        result = result.concat(tabFields)

        break
      }

      default:
        if ('name' in field) {
          acc.push({
            name: field.name,
            type: field.type,
          })
        }
    }

    return result
  }, [])
}
</file>

<file path="packages/payload/src/utilities/findUp.ts">
// @ts-strict-ignore
import fs from 'fs'
import path from 'path'

/**
 * Synchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.
 */
export function findUpSync({
  condition,
  dir,
  fileNames,
}: {
  condition?: (dir: string) => boolean | Promise<boolean | string> | string
  dir: string
  fileNames?: string[]
}): null | string {
  const { root } = path.parse(dir)

  while (true) {
    if (fileNames?.length) {
      let found = false
      for (const fileName of fileNames) {
        const filePath = path.join(dir, fileName)
        const exists = pathExistsAndIsAccessibleSync(filePath)
        if (exists) {
          if (!condition) {
            return filePath
          }
          found = true
          break
        }
      }
      if (!found) {
        dir = path.dirname(dir) // Move up one directory level.
        continue
      }
    }
    const result = condition(dir)
    if (result === true) {
      return dir
    }
    if (typeof result === 'string' && result?.length) {
      return result
    }
    if (dir === root) {
      return null // Reached the root directory without a match.
    }
    dir = path.dirname(dir) // Move up one directory level.
  }
}

/**
 * Asynchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.
 */
export async function findUp({
  condition,
  dir,
  fileNames,
}: {
  condition?: (dir: string) => boolean | Promise<boolean | string> | string
  dir: string
  fileNames?: string[]
}): Promise<null | string> {
  const { root } = path.parse(dir)

  while (true) {
    if (fileNames?.length) {
      let found = false
      for (const fileName of fileNames) {
        const filePath = path.resolve(dir, fileName)
        const exists = await pathExistsAndIsAccessible(filePath)
        if (exists) {
          if (!condition) {
            return filePath
          }
          found = true
          break
        }
      }
      if (!found) {
        dir = path.dirname(dir) // Move up one directory level.
        continue
      }
    }
    const result = await condition(dir)
    if (result === true) {
      return dir
    }
    if (typeof result === 'string' && result?.length) {
      return result
    }
    if (dir === root) {
      return null // Reached the root directory without a match.
    }
    dir = path.dirname(dir) // Move up one directory level.
  }
}

// From https://github.com/sindresorhus/path-exists/blob/main/index.js
// fs.accessSync is preferred over fs.existsSync as it's usually a good idea
// to check if the process has permission to read/write to a file before doing so.
// Also see https://github.com/nodejs/node/issues/39960
export function pathExistsAndIsAccessibleSync(path: string) {
  try {
    fs.accessSync(path)
    return true
  } catch {
    return false
  }
}

export async function pathExistsAndIsAccessible(path: string) {
  try {
    await fs.promises.access(path)
    return true
  } catch {
    return false
  }
}
</file>

<file path="packages/payload/src/utilities/flattenAllFields.ts">
import type {
  Block,
  Field,
  FlattenedBlock,
  FlattenedBlocksField,
  FlattenedField,
  FlattenedJoinField,
} from '../fields/config/types.js'

import { tabHasName } from '../fields/config/types.js'

export const flattenBlock = ({ block }: { block: Block }): FlattenedBlock => {
  return {
    ...block,
    flattenedFields: flattenAllFields({ fields: block.fields }),
  }
}

const flattenedFieldsCache = new Map<Field[], FlattenedField[]>()

/**
 * Flattens all fields in a collection, preserving the nested field structure.
 * @param cache
 * @param fields
 */
export const flattenAllFields = ({
  cache,
  fields,
}: {
  /** Allows you to get FlattenedField[] from Field[] anywhere without performance overhead by caching. */
  cache?: boolean
  fields: Field[]
}): FlattenedField[] => {
  if (cache) {
    const maybeFields = flattenedFieldsCache.get(fields)
    if (maybeFields) {
      return maybeFields
    }
  }

  const result: FlattenedField[] = []

  for (const field of fields) {
    switch (field.type) {
      case 'array':
      case 'group': {
        result.push({ ...field, flattenedFields: flattenAllFields({ fields: field.fields }) })
        break
      }

      case 'blocks': {
        const blocks: FlattenedBlock[] = []
        let blockReferences: (FlattenedBlock | string)[] | undefined = undefined
        if (field.blockReferences) {
          blockReferences = []
          for (const block of field.blockReferences) {
            if (typeof block === 'string') {
              blockReferences.push(block)
              continue
            }
            blockReferences.push(flattenBlock({ block }))
          }
        } else {
          for (const block of field.blocks) {
            if (typeof block === 'string') {
              blocks.push(block)
              continue
            }
            blocks.push(flattenBlock({ block }))
          }
        }

        const resultField: FlattenedBlocksField = {
          ...field,
          blockReferences,
          blocks,
        }

        result.push(resultField)
        break
      }

      case 'collapsible':
      case 'row': {
        for (const nestedField of flattenAllFields({ fields: field.fields })) {
          result.push(nestedField)
        }
        break
      }

      case 'join': {
        result.push(field as FlattenedJoinField)
        break
      }

      case 'tabs': {
        for (const tab of field.tabs) {
          if (!tabHasName(tab)) {
            for (const nestedField of flattenAllFields({ fields: tab.fields })) {
              result.push(nestedField)
            }
          } else {
            result.push({
              ...tab,
              type: 'tab',
              flattenedFields: flattenAllFields({ fields: tab.fields }),
            })
          }
        }
        break
      }

      default: {
        if (field.type !== 'ui') {
          result.push(field)
        }
      }
    }
  }

  flattenedFieldsCache.set(fields, result)

  return result
}
</file>

<file path="packages/payload/src/utilities/flattenTopLevelFields.ts">
// @ts-strict-ignore
import type { ClientTab } from '../admin/fields/Tabs.js'
import type { ClientField } from '../fields/config/client.js'
import type {
  Field,
  FieldAffectingData,
  FieldAffectingDataClient,
  FieldPresentationalOnly,
  FieldPresentationalOnlyClient,
  Tab,
} from '../fields/config/types.js'

import {
  fieldAffectsData,
  fieldHasSubFields,
  fieldIsPresentationalOnly,
  tabHasName,
} from '../fields/config/types.js'

type FlattenedField<TField> = TField extends ClientField
  ? FieldAffectingDataClient | FieldPresentationalOnlyClient
  : FieldAffectingData | FieldPresentationalOnly

type TabType<TField> = TField extends ClientField ? ClientTab : Tab

/**
 * Flattens a collection's fields into a single array of fields, as long
 * as the fields do not affect data.
 *
 * @param fields
 * @param keepPresentationalFields if true, will skip flattening fields that are presentational only
 */
function flattenFields<TField extends ClientField | Field>(
  fields: TField[],
  keepPresentationalFields?: boolean,
): FlattenedField<TField>[] {
  return fields.reduce<FlattenedField<TField>[]>((acc, field) => {
    if (fieldAffectsData(field) || (keepPresentationalFields && fieldIsPresentationalOnly(field))) {
      acc.push(field as FlattenedField<TField>)
    } else if (fieldHasSubFields(field)) {
      acc.push(...flattenFields(field.fields as TField[], keepPresentationalFields))
    } else if (field.type === 'tabs' && 'tabs' in field) {
      return [
        ...acc,
        ...field.tabs.reduce<FlattenedField<TField>[]>((tabFields, tab: TabType<TField>) => {
          if (tabHasName(tab)) {
            return [...tabFields, { ...tab, type: 'tab' } as unknown as FlattenedField<TField>]
          } else {
            return [
              ...tabFields,
              ...flattenFields(tab.fields as TField[], keepPresentationalFields),
            ]
          }
        }, []),
      ]
    }

    return acc
  }, [])
}

export default flattenFields
</file>

<file path="packages/payload/src/utilities/formatAdminURL.ts">
import type { Config } from '../config/types.js'

/** Will read the `routes.admin` config and appropriately handle `"/"` admin paths */
export const formatAdminURL = (args: {
  adminRoute: NonNullable<Config['routes']>['admin']
  basePath?: string
  path: '' | `/${string}` | null | undefined
  serverURL?: Config['serverURL']
}): string => {
  const { adminRoute, basePath = '', path: pathFromArgs, serverURL } = args
  const path = pathFromArgs || ''

  if (adminRoute) {
    if (adminRoute === '/') {
      if (!path) {
        return `${serverURL || ''}${basePath}${adminRoute}`
      }
    } else {
      return `${serverURL || ''}${basePath}${adminRoute}${path}`
    }
  }

  return `${serverURL || ''}${basePath}${path}`
}
</file>

<file path="packages/payload/src/utilities/formatErrors.ts">
// @ts-strict-ignore
import type { ErrorResult } from '../config/types.js'
import type { APIError } from '../errors/APIError.js'

import { APIErrorName } from '../errors/APIError.js'
import { ValidationErrorName } from '../errors/ValidationError.js'

export const formatErrors = (incoming: { [key: string]: unknown } | APIError): ErrorResult => {
  if (incoming) {
    // Cannot use `instanceof` to check error type: https://github.com/microsoft/TypeScript/issues/13965
    // Instead, get the prototype of the incoming error and check its constructor name
    const proto = Object.getPrototypeOf(incoming)

    // Payload 'ValidationError' and 'APIError'
    if (
      (proto.constructor.name === ValidationErrorName || proto.constructor.name === APIErrorName) &&
      incoming.data
    ) {
      return {
        errors: [
          {
            name: incoming.name,
            data: incoming.data,
            message: incoming.message,
          },
        ],
      }
    }

    // Mongoose 'ValidationError': https://mongoosejs.com/docs/api/error.html#Error.ValidationError
    if (proto.constructor.name === ValidationErrorName && 'errors' in incoming && incoming.errors) {
      return {
        errors: Object.keys(incoming.errors).reduce((acc, key) => {
          acc.push({
            field: incoming.errors[key].path,
            message: incoming.errors[key].message,
          })
          return acc
        }, []),
      }
    }

    if (Array.isArray(incoming.message)) {
      return {
        errors: incoming.message,
      }
    }

    if (incoming.name) {
      return {
        errors: [
          {
            message: incoming.message,
          },
        ],
      }
    }
  }

  return {
    errors: [
      {
        message: 'An unknown error occurred.',
      },
    ],
  }
}
</file>

<file path="packages/payload/src/utilities/formatLabels.spec.ts">
import { formatLabels, toWords } from './formatLabels'

describe('formatLabels', () => {
  it('should format singular slug', () => {
    expect(formatLabels('word')).toMatchObject({
      plural: 'Words',
      singular: 'Word',
    })
  })

  it('should format plural slug', () => {
    expect(formatLabels('words')).toMatchObject({
      plural: 'Words',
      singular: 'Word',
    })
  })

  it('should format kebab case', () => {
    expect(formatLabels('my-slugs')).toMatchObject({
      plural: 'My Slugs',
      singular: 'My Slug',
    })
  })

  it('should format camelCase', () => {
    expect(formatLabels('camelCaseItems')).toMatchObject({
      plural: 'Camel Case Items',
      singular: 'Camel Case Item',
    })
  })

  describe('toWords', () => {
    it('should convert camel to capitalized words', () => {
      expect(toWords('camelCaseItems')).toBe('Camel Case Items')
    })

    it('should allow no separator (used for building GraphQL label from name)', () => {
      expect(toWords('myGraphField', true)).toBe('MyGraphField')
    })
  })
})
</file>

<file path="packages/payload/src/utilities/formatLabels.ts">
// @ts-strict-ignore
import pluralize from 'pluralize'
const { isPlural, singular } = pluralize

const capitalizeFirstLetter = (string: string): string =>
  string.charAt(0).toUpperCase() + string.slice(1)

const toWords = (inputString: string, joinWords = false): string => {
  const notNullString = inputString || ''
  const trimmedString = notNullString.trim()
  const arrayOfStrings = trimmedString.split(/[\s-]/)

  const splitStringsArray = []
  arrayOfStrings.forEach((tempString) => {
    if (tempString !== '') {
      const splitWords = tempString.split(/(?=[A-Z])/).join(' ')
      splitStringsArray.push(capitalizeFirstLetter(splitWords))
    }
  })

  return joinWords ? splitStringsArray.join('').replace(/\s/g, '') : splitStringsArray.join(' ')
}

const formatLabels = (slug: string): { plural: string; singular: string } => {
  const words = toWords(slug)
  return isPlural(slug)
    ? {
        plural: words,
        singular: singular(words),
      }
    : {
        plural: pluralize(words),
        singular: words,
      }
}

const formatNames = (slug: string): { plural: string; singular: string } => {
  const words = toWords(slug, true)
  return isPlural(slug)
    ? {
        plural: words,
        singular: singular(words),
      }
    : {
        plural: pluralize(words),
        singular: words,
      }
}

export { formatLabels, formatNames, toWords }
</file>

<file path="packages/payload/src/utilities/getBlockSelect.ts">
import type { Block } from '../fields/config/types.js'
import type { SelectMode, SelectType } from '../types/index.js'

/**
 * This is used for the Select API to determine the select level of a block.
 * It will ensure that `id` and `blockType` are always included in the select object.
 * @returns { blockSelect: boolean | SelectType, blockSelectMode: SelectMode }
 */
export const getBlockSelect = ({
  block,
  select,
  selectMode,
}: {
  block: Block
  select: SelectType[string]
  selectMode: SelectMode
}): { blockSelect: boolean | SelectType; blockSelectMode: SelectMode } => {
  if (typeof select === 'object') {
    let blockSelectMode = selectMode

    const blocksSelect = {
      ...select,
    }

    let blockSelect = blocksSelect[block.slug]

    // sanitize `{ blocks: { cta: false }}` to `{ blocks: { cta: { id: true, blockType: true }}}`
    if (selectMode === 'exclude' && blockSelect === false) {
      blockSelectMode = 'include'

      blockSelect = {
        id: true,
        blockType: true,
      }
    } else if (selectMode === 'include') {
      if (!blockSelect) {
        blockSelect = {}
      }

      if (typeof blockSelect === 'object') {
        blockSelect = {
          ...blockSelect,
        }

        blockSelect['id'] = true
        blockSelect['blockType'] = true
      }
    }

    return { blockSelect, blockSelectMode }
  }

  return { blockSelect: select, blockSelectMode: selectMode }
}
</file>

<file path="packages/payload/src/utilities/getCollectionIDFieldTypes.ts">
// @ts-strict-ignore
import type { SanitizedConfig } from '../config/types.js'

/**
 *  While the default ID is determined by the db adapter, it can still differ for a collection if they
 *  define a custom ID field. This builds a map of collection slugs to their ID field type.
 * @param defaultIDType as defined by the database adapter
 */
export function getCollectionIDFieldTypes({
  config,
  defaultIDType,
}: {
  config: SanitizedConfig
  defaultIDType: 'number' | 'text'
}): { [key: string]: 'number' | 'string' } {
  return config.collections.reduce((acc, collection) => {
    const customCollectionIdField = collection.fields.find(
      (field) => 'name' in field && field.name === 'id',
    )

    acc[collection.slug] = defaultIDType === 'text' ? 'string' : 'number'

    if (customCollectionIdField) {
      acc[collection.slug] = customCollectionIdField.type === 'number' ? 'number' : 'string'
    }

    return acc
  }, {})
}
</file>

<file path="packages/payload/src/utilities/getDataByPath.ts">
// @ts-strict-ignore
import type { FormState } from '../admin/types.js'

import { unflatten } from './unflatten.js'

export const getDataByPath = <T = unknown>(fields: FormState, path: string): T => {
  const pathPrefixToRemove = path.substring(0, path.lastIndexOf('.') + 1)
  const name = path.split('.').pop()

  const data = {}
  Object.keys(fields).forEach((key) => {
    if (!fields[key].disableFormData && (key.indexOf(`${path}.`) === 0 || key === path)) {
      data[key.replace(pathPrefixToRemove, '')] = fields[key].value

      if (fields[key]?.rows && fields[key].rows.length === 0) {
        data[key.replace(pathPrefixToRemove, '')] = []
      }
    }
  })

  const unflattenedData = unflatten(data)

  return unflattenedData?.[name]
}
</file>

<file path="packages/payload/src/utilities/getEntityPolicies.ts">
// @ts-strict-ignore
import type { CollectionPermission, FieldsPermissions, GlobalPermission } from '../auth/types.js'
import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'
import type { Access } from '../config/types.js'
import type { Field, FieldAccess } from '../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { BlockSlug } from '../index.js'
import type { AllOperations, JsonObject, Payload, PayloadRequest, Where } from '../types/index.js'

import { combineQueries } from '../database/combineQueries.js'
import { tabHasName } from '../fields/config/types.js'

export type BlockPolicies = Record<BlockSlug, FieldsPermissions | Promise<FieldsPermissions>>
type Args = {
  blockPolicies: BlockPolicies
  entity: SanitizedCollectionConfig | SanitizedGlobalConfig
  id?: number | string
  operations: AllOperations[]
  req: PayloadRequest
  type: 'collection' | 'global'
}

type ReturnType<T extends Args> = T['type'] extends 'global'
  ? GlobalPermission
  : CollectionPermission

type CreateAccessPromise = (args: {
  access: Access | FieldAccess
  accessLevel: 'entity' | 'field'
  disableWhere?: boolean
  operation: AllOperations
  policiesObj: CollectionPermission | GlobalPermission
}) => Promise<void>

type EntityDoc = JsonObject | TypeWithID

/**
 * Build up permissions object for an entity (collection or global)
 */
export async function getEntityPolicies<T extends Args>(args: T): Promise<ReturnType<T>> {
  const { id, type, blockPolicies, entity, operations, req } = args
  const { data, locale, payload, user } = req
  const isLoggedIn = !!user

  const policies = {
    fields: {},
  } as ReturnType<T>

  let docBeingAccessed: EntityDoc | Promise<EntityDoc | undefined> | undefined

  async function getEntityDoc({
    operation,
    where,
  }: { operation?: AllOperations; where?: Where } = {}): Promise<EntityDoc | undefined> {
    if (!entity.slug) {
      return undefined
    }

    if (type === 'global') {
      return payload.findGlobal({
        slug: entity.slug,
        depth: 0,
        fallbackLocale: null,
        locale,
        overrideAccess: true,
        req,
      })
    }

    if (type === 'collection' && id) {
      if (typeof where === 'object') {
        const options = {
          collection: entity.slug,
          depth: 0,
          fallbackLocale: null,
          limit: 1,
          locale,
          overrideAccess: true,
          req,
        }
        if (operation === 'readVersions') {
          const paginatedRes = await payload.findVersions({
            ...options,
            where: combineQueries(where, { parent: { equals: id } }),
          })
          return paginatedRes?.docs?.[0] || undefined
        }

        const paginatedRes = await payload.find({
          ...options,
          pagination: false,
          where: combineQueries(where, { id: { equals: id } }),
        })
        return paginatedRes?.docs?.[0] || undefined
      }

      return payload.findByID({
        id,
        collection: entity.slug,
        depth: 0,
        fallbackLocale: null,
        locale,
        overrideAccess: true,
        req,
      })
    }
  }

  const createAccessPromise: CreateAccessPromise = async ({
    access,
    accessLevel,
    disableWhere = false,
    operation,
    policiesObj: mutablePolicies,
  }) => {
    if (accessLevel === 'field' && docBeingAccessed === undefined) {
      // assign docBeingAccessed first as the promise to avoid multiple calls to getEntityDoc
      docBeingAccessed = getEntityDoc().then((doc) => {
        docBeingAccessed = doc
      })
    }
    // awaiting the promise to ensure docBeingAccessed is assigned before it is used
    await docBeingAccessed

    // https://payloadcms.slack.com/archives/C048Z9C2BEX/p1702054928343769
    const accessResult = await access({ id, data, doc: docBeingAccessed, req })

    // Where query was returned from access function => check if document is returned when querying with where
    if (typeof accessResult === 'object' && !disableWhere) {
      mutablePolicies[operation] = {
        permission:
          id || type === 'global'
            ? !!(await getEntityDoc({ operation, where: accessResult }))
            : true,
        where: accessResult,
      }
    } else if (mutablePolicies[operation]?.permission !== false) {
      mutablePolicies[operation] = {
        permission: !!accessResult,
      }
    }
  }

  for (const operation of operations) {
    if (typeof entity.access[operation] === 'function') {
      await createAccessPromise({
        access: entity.access[operation],
        accessLevel: 'entity',
        operation,
        policiesObj: policies,
      })
    } else {
      policies[operation] = {
        permission: isLoggedIn,
      }
    }

    await executeFieldPolicies({
      blockPolicies,
      createAccessPromise,
      entityPermission: policies[operation].permission as boolean,
      fields: entity.fields,
      operation,
      payload,
      policiesObj: policies,
    })
  }

  return policies
}

/**
 * Build up permissions object and run access functions for each field of an entity
 */
const executeFieldPolicies = async ({
  blockPolicies,
  createAccessPromise,
  entityPermission,
  fields,
  operation,
  payload,
  policiesObj,
}: {
  blockPolicies: BlockPolicies
  createAccessPromise: CreateAccessPromise
  entityPermission: boolean
  fields: Field[]
  operation: AllOperations
  payload: Payload
  policiesObj: CollectionPermission | FieldsPermissions | GlobalPermission
}) => {
  const mutablePolicies = policiesObj.fields

  // Fields don't have all operations of a collection
  if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {
    return
  }

  await Promise.all(
    fields.map(async (field) => {
      if ('name' in field && field.name) {
        if (!mutablePolicies[field.name]) {
          mutablePolicies[field.name] = {}
        }

        if ('access' in field && field.access && typeof field.access[operation] === 'function') {
          await createAccessPromise({
            access: field.access[operation],
            accessLevel: 'field',
            disableWhere: true,
            operation,
            policiesObj: mutablePolicies[field.name],
          })
        } else {
          mutablePolicies[field.name][operation] = {
            permission: policiesObj[operation]?.permission,
          }
        }

        if ('fields' in field && field.fields) {
          if (!mutablePolicies[field.name].fields) {
            mutablePolicies[field.name].fields = {}
          }

          await executeFieldPolicies({
            blockPolicies,
            createAccessPromise,
            entityPermission,
            fields: field.fields,
            operation,
            payload,
            policiesObj: mutablePolicies[field.name],
          })
        }

        if (
          ('blocks' in field && field.blocks?.length) ||
          ('blockReferences' in field && field.blockReferences?.length)
        ) {
          if (!mutablePolicies[field.name]?.blocks) {
            mutablePolicies[field.name].blocks = {}
          }

          await Promise.all(
            (field.blockReferences ?? field.blocks).map(async (_block) => {
              const block = typeof _block === 'string' ? payload.blocks[_block] : _block

              if (typeof _block === 'string') {
                if (blockPolicies[_block]) {
                  if (typeof blockPolicies[_block].then === 'function') {
                    // Earlier access to this block is still pending, so await it instead of re-running executeFieldPolicies
                    mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]
                  } else {
                    // It's already a resolved policy object
                    mutablePolicies[field.name].blocks[block.slug] = blockPolicies[_block]
                  }
                  return
                } else {
                  // We have not seen this block slug yet. Immediately create a promise
                  // so that any parallel calls will just await this same promise
                  // instead of re-running executeFieldPolicies.
                  blockPolicies[_block] = (async () => {
                    // If the block doesn’t exist yet in our mutablePolicies, initialize it
                    if (!mutablePolicies[field.name].blocks?.[block.slug]) {
                      mutablePolicies[field.name].blocks[block.slug] = {
                        fields: {},
                        [operation]: { permission: entityPermission },
                      }
                    } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {
                      mutablePolicies[field.name].blocks[block.slug][operation] = {
                        permission: entityPermission,
                      }
                    }

                    await executeFieldPolicies({
                      blockPolicies,
                      createAccessPromise,
                      entityPermission,
                      fields: block.fields,
                      operation,
                      payload,
                      policiesObj: mutablePolicies[field.name].blocks[block.slug],
                    })

                    return mutablePolicies[field.name].blocks[block.slug]
                  })()

                  mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]
                  blockPolicies[_block] = mutablePolicies[field.name].blocks[block.slug]
                  return
                }
              }

              if (!mutablePolicies[field.name].blocks?.[block.slug]) {
                mutablePolicies[field.name].blocks[block.slug] = {
                  fields: {},
                  [operation]: { permission: entityPermission },
                }
              } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {
                mutablePolicies[field.name].blocks[block.slug][operation] = {
                  permission: entityPermission,
                }
              }

              await executeFieldPolicies({
                blockPolicies,
                createAccessPromise,
                entityPermission,
                fields: block.fields,
                operation,
                payload,
                policiesObj: mutablePolicies[field.name].blocks[block.slug],
              })
            }),
          )
        }
      } else if ('fields' in field && field.fields) {
        await executeFieldPolicies({
          blockPolicies,
          createAccessPromise,
          entityPermission,
          fields: field.fields,
          operation,
          payload,
          policiesObj,
        })
      } else if (field.type === 'tabs') {
        await Promise.all(
          field.tabs.map(async (tab) => {
            if (tabHasName(tab)) {
              if (!mutablePolicies[tab.name]) {
                mutablePolicies[tab.name] = {
                  fields: {},
                  [operation]: { permission: entityPermission },
                }
              } else if (!mutablePolicies[tab.name][operation]) {
                mutablePolicies[tab.name][operation] = { permission: entityPermission }
              }
              await executeFieldPolicies({
                blockPolicies,
                createAccessPromise,
                entityPermission,
                fields: tab.fields,
                operation,
                payload,
                policiesObj: mutablePolicies[tab.name],
              })
            } else {
              await executeFieldPolicies({
                blockPolicies,
                createAccessPromise,
                entityPermission,
                fields: tab.fields,
                operation,
                payload,
                policiesObj,
              })
            }
          }),
        )
      }
    }),
  )
}
</file>

<file path="packages/payload/src/utilities/getFieldByPath.spec.ts">
import { assert } from 'ts-essentials'
import { flattenAllFields } from './flattenAllFields.js'
import { getFieldByPath } from './getFieldByPath.js'
import type { FlattenedArrayField, FlattenedGroupField } from '../fields/config/types.js'

const fields = flattenAllFields({
  fields: [
    {
      type: 'text',
      name: 'text',
    },
    {
      type: 'text',
      name: 'textLocalized',
      localized: true,
    },
    {
      type: 'array',
      name: 'array',
      fields: [
        {
          name: 'text',
          type: 'text',
        },
        {
          name: 'textLocalized',
          localized: true,
          type: 'text',
        },
        {
          name: 'group',
          type: 'group',
          fields: [
            {
              name: 'text',
              type: 'text',
            },
          ],
        },
      ],
    },
    {
      type: 'tabs',
      tabs: [
        {
          name: 'tab',
          fields: [
            {
              type: 'array',
              name: 'localizedArray',
              localized: true,
              fields: [
                {
                  name: 'text',
                  type: 'text',
                },
              ],
            },
          ],
        },
      ],
    },
  ],
})

describe('getFieldByPath', () => {
  it('asserts getFieldByPath', () => {
    const assert_1 = getFieldByPath({ fields, path: 'text' })
    assert(assert_1)
    expect(assert_1.field).toBe(fields[0])
    expect(assert_1.pathHasLocalized).toBe(false)

    const assert_2 = getFieldByPath({ fields, path: 'textLocalized' })
    assert(assert_2)
    expect(assert_2.field).toBe(fields[1])
    expect(assert_2.pathHasLocalized).toBe(true)
    expect(assert_2.localizedPath).toBe('textLocalized.<locale>')

    const arrayField = fields[2] as FlattenedArrayField
    const assert_3 = getFieldByPath({ fields, path: 'array' })
    assert(assert_3)
    expect(assert_3.field).toBe(arrayField)
    expect(assert_3.pathHasLocalized).toBe(false)

    const assert_4 = getFieldByPath({ fields, path: 'array.text' })
    assert(assert_4)
    expect(assert_4.field).toBe(arrayField.flattenedFields[0])
    expect(assert_4.pathHasLocalized).toBe(false)

    const assert_5 = getFieldByPath({ fields, path: 'array.textLocalized' })
    assert(assert_5)
    expect(assert_5.field).toBe(arrayField.flattenedFields[1])
    expect(assert_5.pathHasLocalized).toBe(true)
    expect(assert_5.localizedPath).toBe('array.textLocalized.<locale>')

    const groupWithinArray = arrayField.flattenedFields[2] as FlattenedGroupField
    const assert_6 = getFieldByPath({ fields, path: 'array.group.text' })
    assert(assert_6)
    expect(assert_6.field).toBe(groupWithinArray.flattenedFields[0])
    expect(assert_6.pathHasLocalized).toBe(false)

    const assert_7 = getFieldByPath({ fields, path: 'tab.localizedArray.text' })
    assert(assert_7)
    expect(assert_7.field).toBe((fields[3] as any).flattenedFields[0].flattenedFields[0])
    expect(assert_7.pathHasLocalized).toBe(true)
    expect(assert_7.localizedPath).toBe('tab.localizedArray.<locale>.text')
  })
})
</file>

<file path="packages/payload/src/utilities/getFieldByPath.ts">
import type { FlattenedField } from '../fields/config/types.js'

/**
 * Get the field from by its path.
 * Can accept nested paths, e.g: group.title, array.group.title
 * If there were any localized on the path, pathHasLocalized will be true and localizedPath will look like:
 * group.<locale>.title // group is localized here
 */
export const getFieldByPath = ({
  fields,
  localizedPath = '',
  path,
}: {
  fields: FlattenedField[]
  localizedPath?: string
  path: string
}): {
  field: FlattenedField
  localizedPath: string
  pathHasLocalized: boolean
} | null => {
  let currentFields: FlattenedField[] = fields

  let currentField: FlattenedField | null = null

  const segments = path.split('.')

  let pathHasLocalized = false

  while (segments.length > 0) {
    const segment = segments.shift()
    localizedPath = `${localizedPath ? `${localizedPath}.` : ''}${segment}`
    const field = currentFields.find((each) => each.name === segment)

    if (!field) {
      return null
    }

    if (field.localized) {
      pathHasLocalized = true
      localizedPath = `${localizedPath}.<locale>`
    }

    if ('flattenedFields' in field) {
      currentFields = field.flattenedFields
    }

    if ('blocks' in field) {
      for (const block of field.blocks) {
        const maybeField = getFieldByPath({
          fields: block.flattenedFields,
          localizedPath,
          path: [...segments].join('.'),
        })

        if (maybeField) {
          return maybeField
        }
      }
    }

    currentField = field
  }

  if (!currentField) {
    return null
  }

  return { field: currentField, localizedPath, pathHasLocalized }
}
</file>

<file path="packages/payload/src/utilities/getFieldPermissions.ts">
// @ts-strict-ignore
import type { SanitizedFieldPermissions } from '../auth/types.js'
import type { ClientField, Field } from '../fields/config/types.js'
import type { Operation } from '../types/index.js'

/**
 * Gets read and operation-level permissions for a given field based on cascading field permissions.
 * @returns An object with the following properties:
 * - `operation`: Whether the user has permission to perform the operation on the field (`create` or `update`).
 * - `permissions`: The field-level permissions.
 * - `read`: Whether the user has permission to read the field.
 */
export const getFieldPermissions = ({
  field,
  operation,
  parentName,
  permissions,
}: {
  readonly field: ClientField | Field
  readonly operation: Operation
  readonly parentName: string
  readonly permissions:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | SanitizedFieldPermissions
}): {
  operation: boolean
  permissions: SanitizedFieldPermissions
  read: boolean
} => ({
  operation:
    permissions === true ||
    permissions?.[operation] === true ||
    permissions?.[parentName] === true ||
    ('name' in field &&
      typeof permissions === 'object' &&
      permissions?.[field.name] &&
      (permissions[field.name] === true ||
        (operation in permissions[field.name] && permissions[field.name][operation]))),
  permissions:
    permissions === undefined || permissions === null || permissions === true
      ? true
      : 'name' in field
        ? permissions?.[field.name]
        : permissions,
  read:
    permissions === true ||
    permissions?.read === true ||
    permissions?.[parentName] === true ||
    ('name' in field &&
      typeof permissions === 'object' &&
      permissions?.[field.name] &&
      (permissions[field.name] === true ||
        ('read' in permissions[field.name] && permissions[field.name].read))),
})
</file>

<file path="packages/payload/src/utilities/getObjectDotNotation.ts">
// @ts-strict-ignore
export const getObjectDotNotation = <T>(
  obj: Record<string, unknown>,
  path: string,
  defaultValue?: T,
): T => {
  if (!path || !obj) {
    return defaultValue
  }
  const result = path.split('.').reduce((o, i) => o?.[i], obj)
  return result === undefined ? defaultValue : (result as T)
}
</file>

<file path="packages/payload/src/utilities/getRequestEntity.ts">
// @ts-strict-ignore
import type { Collection } from '../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { APIError } from '../errors/APIError.js'

export const getRequestCollection = (req: PayloadRequest): Collection => {
  const collectionSlug = req.routeParams.collection

  if (typeof collectionSlug !== 'string') {
    throw new APIError(`No collection was specified`, 400)
  }

  const collection = req.payload.collections[collectionSlug]

  if (!collection) {
    throw new APIError(`Collection with the slug ${collectionSlug} was not found`, 404)
  }

  return collection
}

export const getRequestCollectionWithID = <T extends boolean>(
  req: PayloadRequest,
  {
    disableSanitize,
    optionalID,
  }: {
    disableSanitize?: T
    optionalID?: boolean
  } = {},
): {
  collection: Collection
  id: T extends true ? string : number | string
} => {
  const collection = getRequestCollection(req)
  const id = req.routeParams.id

  if (typeof id !== 'string') {
    if (optionalID) {
      return {
        id: undefined,
        collection,
      }
    }

    throw new APIError(`ID was not specified`, 400)
  }

  if (disableSanitize === true) {
    return {
      id,
      collection,
    }
  }

  let sanitizedID: number | string = id

  // If default db ID type is a number, we should sanitize
  let shouldSanitize = Boolean(req.payload.db.defaultIDType === 'number')

  // UNLESS the customIDType for this collection is text.... then we leave it
  if (shouldSanitize && collection.customIDType === 'text') {
    shouldSanitize = false
  }

  // If we still should sanitize, parse float
  if (shouldSanitize) {
    sanitizedID = parseFloat(sanitizedID)
  }

  return {
    // @ts-expect-error generic return
    id: sanitizedID,
    collection,
  }
}

export const getRequestGlobal = (req: PayloadRequest): SanitizedGlobalConfig => {
  const globalSlug = req.routeParams.global

  if (typeof globalSlug !== 'string') {
    throw new APIError(`No global was specified`, 400)
  }

  const globalConfig = req.payload.globals.config.find((each) => each.slug === globalSlug)

  if (!globalConfig) {
    throw new APIError(`Global with the slug ${globalSlug} was not found`, 404)
  }

  return globalConfig
}
</file>

<file path="packages/payload/src/utilities/getRequestLanguage.ts">
// @ts-strict-ignore
import type { AcceptedLanguages } from '@convexcms/translations'
import type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies.js'

import { extractHeaderLanguage } from '@convexcms/translations'

import type { SanitizedConfig } from '../config/types.js'

type GetRequestLanguageArgs = {
  config: SanitizedConfig
  cookies: Map<string, string> | ReadonlyRequestCookies
  defaultLanguage?: AcceptedLanguages
  headers: Request['headers']
}

export const getRequestLanguage = ({
  config,
  cookies,
  headers,
}: GetRequestLanguageArgs): AcceptedLanguages => {
  const supportedLanguageKeys = <AcceptedLanguages[]>Object.keys(config.i18n.supportedLanguages)
  const langCookie = cookies.get(`${config.cookiePrefix || 'payload'}-lng`)

  const languageFromCookie: AcceptedLanguages = (
    typeof langCookie === 'string' ? langCookie : langCookie?.value
  ) as AcceptedLanguages

  if (languageFromCookie && supportedLanguageKeys.includes(languageFromCookie)) {
    return languageFromCookie
  }

  const languageFromHeader = headers.get('Accept-Language')
    ? extractHeaderLanguage(headers.get('Accept-Language'))
    : undefined

  if (languageFromHeader && supportedLanguageKeys.includes(languageFromHeader)) {
    return languageFromHeader
  }

  return config.i18n.fallbackLanguage
}
</file>

<file path="packages/payload/src/utilities/getSelectMode.ts">
import type { SelectMode, SelectType } from '../types/index.js'

export const getSelectMode = (select: SelectType): SelectMode => {
  for (const key in select) {
    const selectValue = select[key]
    if (selectValue === false) {
      return 'exclude'
    }

    if (typeof selectValue === 'object') {
      return getSelectMode(selectValue)
    }
  }

  return 'include'
}
</file>

<file path="packages/payload/src/utilities/getSiblingData.ts">
// @ts-strict-ignore
import type { Data, FormState } from '../admin/types.js'

import { reduceFieldsToValues } from './reduceFieldsToValues.js'
import { unflatten } from './unflatten.js'

export const getSiblingData = (fields: FormState, path: string): Data => {
  if (!fields) {
    return null
  }

  if (path.indexOf('.') === -1) {
    return reduceFieldsToValues(fields, true)
  }

  const siblingFields = {}

  // Determine if the last segment of the path is an array-based row
  const pathSegments = path.split('.')
  const lastSegment = pathSegments[pathSegments.length - 1]
  const lastSegmentIsRowIndex = !Number.isNaN(Number(lastSegment))

  let parentFieldPath: string

  if (lastSegmentIsRowIndex) {
    // If the last segment is a row index,
    // the sibling data is that row's contents
    // so create a parent field path that will
    // retrieve all contents of that row index only
    parentFieldPath = `${path}.`
  } else {
    // Otherwise, the last path segment is a field name
    // and it should be removed
    parentFieldPath = path.substring(0, path.lastIndexOf('.') + 1)
  }

  Object.keys(fields).forEach((fieldKey) => {
    if (!fields[fieldKey].disableFormData && fieldKey.indexOf(parentFieldPath) === 0) {
      siblingFields[fieldKey.replace(parentFieldPath, '')] = fields[fieldKey].value
    }
  })

  return unflatten(siblingFields)
}
</file>

<file path="packages/payload/src/utilities/getTranslatedLabel.ts">
// @ts-strict-ignore
import { getTranslation, type I18n } from '@convexcms/translations'

import type { LabelFunction, StaticLabel } from '../config/types.js'

export const getTranslatedLabel = (label: LabelFunction | StaticLabel, i18n?: I18n): string => {
  if (typeof label === 'function') {
    return label({ i18n, t: i18n.t })
  }

  if (typeof label === 'object') {
    return getTranslation(label, i18n)
  }

  return label
}
</file>

<file path="packages/payload/src/utilities/getUniqueListBy.ts">
// @ts-strict-ignore
export function getUniqueListBy<T>(arr: T[], key: string): T[] {
  return [...new Map(arr.map((item) => [item[key], item])).values()]
}
</file>

<file path="packages/payload/src/utilities/handleEndpoints.ts">
// @ts-strict-ignore
import { status as httpStatus } from 'http-status'
import { match } from 'path-to-regexp'

import type { Collection } from '../collections/config/types.js'
import type { Endpoint, PayloadHandler, SanitizedConfig } from '../config/types.js'
import type { GlobalConfig } from '../globals/config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { createPayloadRequest } from './createPayloadRequest.js'
import { headersWithCors } from './headersWithCors.js'
import { mergeHeaders } from './mergeHeaders.js'
import { routeError } from './routeError.js'

const notFoundResponse = (req: PayloadRequest, pathname?: string) => {
  return Response.json(
    {
      message: `Route not found "${pathname ?? new URL(req.url).pathname}"`,
    },
    {
      headers: headersWithCors({
        headers: new Headers(),
        req,
      }),
      status: httpStatus.NOT_FOUND,
    },
  )
}

/**
 * Attaches the Payload REST API to any backend framework that uses Fetch Request/Response
 * like Next.js (app router), Remix, Bun, Hono.
 *
 * ### Example: Using Hono
 * ```ts
 * import { handleEndpoints } from '@convexcms/core';
 * import { serve } from '@hono/node-server';
 * import { loadEnv } from 'payload/node';
 *
 * const port = 3001;
 * loadEnv();
 *
 * const { default: config } = await import('@payload-config');
 *
 * const server = serve({
 *   fetch: async (request) => {
 *     const response = await handleEndpoints({
 *       config,
 *       request: request.clone(),
 *     });
 *
 *     return response;
 *   },
 *   port,
 * });
 *
 * server.on('listening', () => {
 *   console.log(`API server is listening on http://localhost:${port}/api`);
 * });
 * ```
 */
export const handleEndpoints = async ({
  basePath = '',
  config: incomingConfig,
  path,
  request,
}: {
  basePath?: string
  config: Promise<SanitizedConfig> | SanitizedConfig
  /** Override path from the request */
  path?: string
  request: Request
}): Promise<Response> => {
  let handler: PayloadHandler
  let req: PayloadRequest
  let collection: Collection

  // This can be used against GET request search params size limit.
  // Instead you can do POST request with a text body as search params.
  // We use this interally for relationships querying on the frontend
  // packages/ui/src/fields/Relationship/index.tsx
  if (
    request.method.toLowerCase() === 'post' &&
    request.headers.get('X-HTTP-Method-Override') === 'GET'
  ) {
    const search = await request.text()

    const url = `${request.url}?${new URLSearchParams(search).toString()}`
    const response = await handleEndpoints({
      basePath,
      config: incomingConfig,
      path,
      request: new Request(url, {
        cache: request.cache,
        credentials: request.credentials,
        headers: request.headers,
        method: 'GET',
        signal: request.signal,
      }),
    })

    return response
  }

  try {
    req = await createPayloadRequest({ config: incomingConfig, request })

    if (req.method.toLowerCase() === 'options') {
      return Response.json(
        {},
        {
          headers: headersWithCors({
            headers: new Headers(),
            req,
          }),
          status: 200,
        },
      )
    }

    const { payload } = req
    const { config } = payload

    const pathname = `${basePath}${path ?? new URL(req.url).pathname}`

    if (!pathname.startsWith(config.routes.api)) {
      return notFoundResponse(req, pathname)
    }

    // /api/posts/route -> /posts/route
    let adjustedPathname = pathname.replace(config.routes.api, '')

    let isGlobals = false

    // /globals/header/route -> /header/route
    if (adjustedPathname.startsWith('/globals')) {
      isGlobals = true
      adjustedPathname = adjustedPathname.replace('/globals', '')
    }

    const segments = adjustedPathname.split('/')
    // remove empty string first element
    segments.shift()

    const firstParam = segments[0]

    let globalConfig: GlobalConfig

    // first param can be a global slug or collection slug, find the relevant config
    if (firstParam) {
      if (isGlobals) {
        globalConfig = payload.globals.config.find((each) => each.slug === firstParam)
      } else if (payload.collections[firstParam]) {
        collection = payload.collections[firstParam]
      }
    }

    let endpoints: Endpoint[] | false = config.endpoints

    if (collection) {
      endpoints = collection.config.endpoints
      // /posts/route -> /route
      adjustedPathname = adjustedPathname.replace(`/${collection.config.slug}`, '')
    } else if (globalConfig) {
      // /header/route -> /route
      adjustedPathname = adjustedPathname.replace(`/${globalConfig.slug}`, '')
      endpoints = globalConfig.endpoints
    }

    // sanitize when endpoint.path is '/'
    if (adjustedPathname === '') {
      adjustedPathname = '/'
    }

    if (endpoints === false) {
      return Response.json(
        {
          message: `Cannot ${req.method.toUpperCase()} ${req.url}`,
        },
        {
          headers: headersWithCors({
            headers: new Headers(),
            req,
          }),
          status: httpStatus.NOT_IMPLEMENTED,
        },
      )
    }

    // Find the relevant endpoint configuration
    const endpoint = endpoints?.find((endpoint) => {
      if (endpoint.method !== req.method.toLowerCase()) {
        return false
      }

      const pathMatchFn = match(endpoint.path, { decode: decodeURIComponent })

      const matchResult = pathMatchFn(adjustedPathname)

      if (!matchResult) {
        return false
      }

      req.routeParams = matchResult.params as Record<string, unknown>

      // Inject to routeParams the slug as well so it can be used later
      if (collection) {
        req.routeParams.collection = collection.config.slug
      } else if (globalConfig) {
        req.routeParams.global = globalConfig.slug
      }

      return true
    })

    if (endpoint) {
      handler = endpoint.handler
    }

    if (!handler) {
      return notFoundResponse(req, pathname)
    }

    const response = await handler(req)
    return new Response(response.body, {
      headers: mergeHeaders(req.responseHeaders ?? new Headers(), response.headers),
      status: response.status,
      statusText: response.statusText,
    })
  } catch (err) {
    return routeError({
      collection,
      config: incomingConfig,
      err,
      req,
    })
  }
}
</file>

<file path="packages/payload/src/utilities/headersWithCors.ts">
// @ts-strict-ignore
import type { PayloadRequest } from '../types/index.js'

type CorsArgs = {
  headers: Headers
  req: Partial<PayloadRequest>
}
export const headersWithCors = ({ headers, req }: CorsArgs): Headers => {
  const cors = req?.payload.config.cors
  const requestOrigin = req?.headers.get('Origin')

  if (cors) {
    const defaultAllowedHeaders = [
      'Origin',
      'X-Requested-With',
      'Content-Type',
      'Accept',
      'Authorization',
      'Content-Encoding',
      'x-apollo-tracing',
    ]

    headers.set('Access-Control-Allow-Methods', 'PUT, PATCH, POST, GET, DELETE, OPTIONS')

    if (typeof cors === 'object' && 'headers' in cors) {
      headers.set(
        'Access-Control-Allow-Headers',
        [...defaultAllowedHeaders, ...cors.headers].filter(Boolean).join(', '),
      )
    } else {
      headers.set('Access-Control-Allow-Headers', defaultAllowedHeaders.join(', '))
    }

    if (cors === '*' || (typeof cors === 'object' && 'origins' in cors && cors.origins === '*')) {
      headers.set('Access-Control-Allow-Origin', '*')
    } else if (
      (Array.isArray(cors) && cors.indexOf(requestOrigin) > -1) ||
      (!Array.isArray(cors) &&
        typeof cors === 'object' &&
        'origins' in cors &&
        cors.origins.indexOf(requestOrigin) > -1)
    ) {
      headers.set('Access-Control-Allow-Credentials', 'true')
      headers.set('Access-Control-Allow-Origin', requestOrigin)
    }
  }

  return headers
}
</file>

<file path="packages/payload/src/utilities/initTransaction.ts">
// @ts-strict-ignore
import type { MarkRequired } from 'ts-essentials'

import type { PayloadRequest } from '../types/index.js'

/**
 * Starts a new transaction using the db adapter with a random id and then assigns it to the req.transaction
 * @returns true if beginning a transaction and false when req already has a transaction to use
 */
export async function initTransaction(
  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,
): Promise<boolean> {
  const { payload, transactionID } = req
  if (transactionID instanceof Promise) {
    // wait for whoever else is already creating the transaction
    await transactionID
    return false
  }

  if (transactionID) {
    // we already have a transaction, we're not in charge of committing it
    return false
  }
  if (typeof payload.db.beginTransaction === 'function') {
    // create a new transaction
    req.transactionID = payload.db.beginTransaction().then((transactionID) => {
      if (transactionID) {
        req.transactionID = transactionID
      }

      return transactionID
    })
    return !!(await req.transactionID)
  }
  return false
}
</file>

<file path="packages/payload/src/utilities/isEntityHidden.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { PayloadRequest } from '../types/index.js'

export const isEntityHidden = ({
  hidden,
  user,
}: {
  hidden: SanitizedCollectionConfig['admin']['hidden'] | SanitizedGlobalConfig['admin']['hidden']
  user: PayloadRequest['user']
}) => {
  return typeof hidden === 'function' ? hidden({ user }) : hidden === true
}
</file>

<file path="packages/payload/src/utilities/isNextBuild.ts">
/**
 * Utility function to determine if the code is being executed during the Next.js build process.
 */
export function isNextBuild() {
  return (
    process.env.NEXT_PHASE === 'phase-production-build' ||
    process.env.npm_lifecycle_event === 'build'
  )
}
</file>

<file path="packages/payload/src/utilities/isNumber.ts">
export function isNumber(value: unknown): value is number {
  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
    return false
  }

  return !Number.isNaN(Number(value))
}
</file>

<file path="packages/payload/src/utilities/isolateObjectProperty.ts">
/* eslint-disable no-restricted-exports */
/**
 * Creates a proxy for the given object that has its own property
 */
export default function isolateObjectProperty<T extends object>(
  object: T,
  key: (keyof T)[] | keyof T,
): T {
  const keys = Array.isArray(key) ? key : [key]
  const delegate = {} as T

  // Initialize delegate with the keys, if they exist in the original object
  for (const k of keys) {
    if (k in object) {
      delegate[k] = object[k]
    }
  }

  const handler: ProxyHandler<T> = {
    deleteProperty(target, p): boolean {
      return Reflect.deleteProperty(keys.includes(p as keyof T) ? delegate : target, p)
    },
    get(target, p, receiver) {
      return Reflect.get(keys.includes(p as keyof T) ? delegate : target, p, receiver)
    },
    has(target, p) {
      return Reflect.has(keys.includes(p as keyof T) ? delegate : target, p)
    },
    set(target, p, newValue, receiver) {
      if (keys.includes(p as keyof T)) {
        // in case of transactionID we must ignore any receiver, because
        // "If provided and target does not have a setter for propertyKey, the property will be set on receiver instead."
        return Reflect.set(delegate, p, newValue)
      } else {
        return Reflect.set(target, p, newValue, receiver)
      }
    },
  }
  return new Proxy(object, handler)
}
</file>

<file path="packages/payload/src/utilities/isPlainObject.ts">
import { isReactComponentOrFunction } from './isReactComponent.js'

export function isPlainObject(o: any): boolean {
  // Is this a React component?
  if (isReactComponentOrFunction(o)) {
    return false
  }

  // from https://github.com/fastify/deepmerge/blob/master/index.js#L77
  return typeof o === 'object' && o !== null && !(o instanceof RegExp) && !(o instanceof Date)
}
</file>

<file path="packages/payload/src/utilities/isReactComponent.ts">
import type React from 'react'

const clientRefSymbol = Symbol.for('react.client.reference')

export function isReactServerComponentOrFunction<T extends any>(
  component: any | React.ComponentType,
): component is T {
  if (component === null || component === undefined) {
    return false
  }
  const hasClientComponentSymbol = component.$$typeof == clientRefSymbol

  const isFunctionalComponent = typeof component === 'function'
  // Anonymous functions are Client Components in Turbopack. RSCs should have a name
  const isAnonymousFunction = typeof component === 'function' && component.name === ''

  const isRSC = isFunctionalComponent && !isAnonymousFunction && !hasClientComponentSymbol

  return isRSC
}

export function isReactClientComponent<T extends any>(
  component: any | React.ComponentType,
): component is T {
  if (component === null || component === undefined) {
    return false
  }
  return !isReactServerComponentOrFunction(component) && component.$$typeof == clientRefSymbol
}

export function isReactComponentOrFunction<T extends any>(
  component: any | React.ComponentType,
): component is T {
  return isReactServerComponentOrFunction(component) || isReactClientComponent(component)
}
</file>

<file path="packages/payload/src/utilities/isURLAllowed.ts">
import type { AllowList } from '../uploads/types.js'

export const isURLAllowed = (url: string, allowList: AllowList): boolean => {
  try {
    const parsedUrl = new URL(url)

    return allowList.some((allowItem) => {
      return Object.entries(allowItem).every(([key, value]) => {
        // Skip undefined or null values
        if (!value) {
          return true
        }
        // Compare protocol with colon
        if (key === 'protocol') {
          return typeof value === 'string' && parsedUrl.protocol === `${value}:`
        }

        if (key === 'pathname') {
          // Convert wildcards to a regex
          const regexPattern = value
            .replace(/\*\*/g, '.*') // Match any path
            .replace(/\*/g, '[^/]*') // Match any part of a path segment
            .replace(/\/$/, '(/)?') // Allow optional trailing slash
          const regex = new RegExp(`^${regexPattern}$`)
          return regex.test(parsedUrl.pathname)
        }

        // Default comparison for all other properties (hostname, port, search)
        return parsedUrl[key as keyof URL] === value
      })
    })
  } catch {
    return false // If the URL is invalid, deny by default
  }
}
</file>

<file path="packages/payload/src/utilities/isValidID.ts">
// @ts-strict-ignore
import ObjectIdImport from 'bson-objectid'

const ObjectId = (ObjectIdImport.default ||
  ObjectIdImport) as unknown as typeof ObjectIdImport.default

export const isValidID = (
  value: number | string,
  type: 'number' | 'ObjectID' | 'text',
): boolean => {
  if (type === 'text' && value) {
    if (['object', 'string'].includes(typeof value)) {
      const isObjectID = ObjectId.isValid(value as string)
      return typeof value === 'string' || isObjectID
    }
    return false
  }

  if (typeof value === 'number' && !Number.isNaN(value)) {
    return true
  }

  if (type === 'ObjectID') {
    return ObjectId.isValid(String(value))
  }
}
</file>

<file path="packages/payload/src/utilities/killTransaction.ts">
// @ts-strict-ignore
import type { MarkRequired } from 'ts-essentials'

import type { PayloadRequest } from '../types/index.js'

/**
 * Rollback the transaction from the req using the db adapter and removes it from the req
 */
export async function killTransaction(
  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,
): Promise<void> {
  const { payload, transactionID } = req
  if (transactionID && !(transactionID instanceof Promise)) {
    try {
      await payload.db.rollbackTransaction(req.transactionID)
    } catch (error) {
      // swallow any errors while attempting to rollback
    }
    delete req.transactionID
  }
}
</file>

<file path="packages/payload/src/utilities/logError.ts">
// @ts-strict-ignore
import type pino from 'pino'

import type { Payload } from '../types/index.js'

export const logError = ({ err, payload }: { err: unknown; payload: Payload }): void => {
  let level: false | pino.Level = 'error'

  if (
    err &&
    typeof err === 'object' &&
    'name' in err &&
    typeof err.name === 'string' &&
    typeof payload.config.loggingLevels[err.name] !== 'undefined'
  ) {
    level = payload.config.loggingLevels[err.name]
  }

  if (level) {
    const logObject: { err?: unknown; msg?: unknown } = {}

    if (level === 'info') {
      logObject.msg = typeof err === 'object' && 'message' in err ? err.message : 'Error'
    } else {
      logObject.err = err
    }

    payload.logger[level](logObject)
  }
}
</file>

<file path="packages/payload/src/utilities/logger.ts">
import { type Logger, pino } from 'pino'
import { build, type PinoPretty, type PrettyOptions } from 'pino-pretty'

import type { Config } from '../config/types.js'

/**
 * Payload internal logger. Uses Pino.
 * This allows you to bring your own logger instance and let payload use it
 */
export type PayloadLogger = Logger

const prettyOptions: PrettyOptions = {
  colorize: true,
  ignore: 'pid,hostname',
  translateTime: 'SYS:HH:MM:ss',
}

export const prettySyncLoggerDestination: PinoPretty.PrettyStream = build({
  ...prettyOptions,
  destination: 1, // stdout
  sync: true,
})

export const defaultLoggerOptions: PinoPretty.PrettyStream = build(prettyOptions)

export const getLogger = (name = 'payload', logger?: Config['logger']): PayloadLogger => {
  if (!logger) {
    return pino(defaultLoggerOptions)
  }

  // Synchronous logger used by bin scripts
  if (logger === 'sync') {
    return pino(prettySyncLoggerDestination)
  }

  // Check if logger is an object
  if ('options' in logger) {
    const { destination, options } = logger

    if (!options.name) {
      options.name = name
    }

    if (!options.enabled) {
      options.enabled = process.env.DISABLE_LOGGING !== 'true'
    }

    return pino(options, destination)
  } else {
    // Instantiated logger
    return logger
  }
}
</file>

<file path="packages/payload/src/utilities/mapAsync.ts">
export async function mapAsync<T, U>(
  arr: T[],
  callbackfn: (item: T, index: number, array: T[]) => Promise<U>,
): Promise<U[]> {
  return Promise.all(arr.map(callbackfn))
}
</file>

<file path="packages/payload/src/utilities/mergeHeaders.ts">
export const mergeHeaders = (sourceHeaders: Headers, destinationHeaders: Headers): Headers => {
  // Create a new Headers object
  const combinedHeaders = new Headers(destinationHeaders)

  // Append sourceHeaders to combinedHeaders
  sourceHeaders.forEach((value, key) => {
    combinedHeaders.append(key, value)
  })

  return combinedHeaders
}
</file>

<file path="packages/payload/src/utilities/mergeListSearchAndWhere.ts">
import type { ClientCollectionConfig } from '../collections/config/client.js'
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { Where } from '../types/index.js'

const isEmptyObject = (obj: object) => Object.keys(obj).length === 0

export const hoistQueryParamsToAnd = (currentWhere: Where, incomingWhere: Where) => {
  if (isEmptyObject(incomingWhere)) {
    return currentWhere
  }

  if (isEmptyObject(currentWhere)) {
    return incomingWhere
  }

  if ('and' in currentWhere && currentWhere.and) {
    currentWhere.and.push(incomingWhere)
  } else if ('or' in currentWhere) {
    currentWhere = {
      and: [currentWhere, incomingWhere],
    }
  } else {
    currentWhere = {
      and: [currentWhere, incomingWhere],
    }
  }

  return currentWhere
}

type Args = {
  collectionConfig: ClientCollectionConfig | SanitizedCollectionConfig
  search: string
  where?: Where
}

export const mergeListSearchAndWhere = ({ collectionConfig, search, where = {} }: Args): Where => {
  if (search) {
    let copyOfWhere = { ...(where || {}) }

    const searchAsConditions = (
      collectionConfig.admin.listSearchableFields || [collectionConfig.admin?.useAsTitle || 'id']
    ).map((fieldName) => ({
      [fieldName]: {
        like: search,
      },
    }))

    if (searchAsConditions.length > 0) {
      copyOfWhere = hoistQueryParamsToAnd(copyOfWhere, {
        or: searchAsConditions,
      })
    }

    if (!isEmptyObject(copyOfWhere)) {
      where = copyOfWhere
    }
  }

  return where
}
</file>

<file path="packages/payload/src/utilities/parseCookies.ts">
// @ts-strict-ignore
import { APIError } from '../errors/APIError.js'

export const parseCookies = (headers: Request['headers']): Map<string, string> => {
  const list = new Map<string, string>()
  const rc = headers.get('Cookie')

  if (rc) {
    rc.split(';').forEach((cookie) => {
      const parts = cookie.split('=')
      const key = parts.shift().trim()
      const encodedValue = parts.join('=')

      try {
        const decodedValue = decodeURI(encodedValue)
        list.set(key, decodedValue)
      } catch (e) {
        throw new APIError(`Error decoding cookie value for key ${key}: ${e.message}`)
      }
    })
  }

  return list
}
</file>

<file path="packages/payload/src/utilities/reduceFieldsToValues.ts">
// @ts-strict-ignore
import type { Data, FormState } from '../admin/types.js'

import { unflatten as flatleyUnflatten } from './unflatten.js'
/**
 * Reduce flattened form fields (Fields) to just map to the respective values instead of the full FormField object
 *
 * @param unflatten This also unflattens the data if `unflatten` is true. The unflattened data should match the original data structure
 * @param ignoreDisableFormData - if true, will include fields that have `disableFormData` set to true, for example, blocks or arrays fields.
 *
 */
export const reduceFieldsToValues = (
  fields: FormState,
  unflatten?: boolean,
  ignoreDisableFormData?: boolean,
): Data => {
  let data = {}

  if (!fields) {
    return data
  }

  Object.keys(fields).forEach((key) => {
    if (ignoreDisableFormData === true || !fields[key]?.disableFormData) {
      data[key] = fields[key]?.value
    }
  })

  if (unflatten) {
    data = flatleyUnflatten(data)
  }

  return data
}
</file>

<file path="packages/payload/src/utilities/removeUndefined.ts">
export function removeUndefined<T extends object>(obj: T): T {
  return Object.fromEntries(Object.entries(obj).filter(([, value]) => value !== undefined)) as T
}
</file>

<file path="packages/payload/src/utilities/routeError.ts">
import { status as httpStatus } from 'http-status'

import type { Collection } from '../collections/config/types.js'
import type { ErrorResult, SanitizedConfig } from '../config/types.js'
import type { PayloadRequest } from '../types/index.js'

import { APIError } from '../errors/APIError.js'
import { getPayload } from '../index.js'
import { formatErrors } from './formatErrors.js'
import { headersWithCors } from './headersWithCors.js'
import { logError } from './logError.js'
import { mergeHeaders } from './mergeHeaders.js'

export const routeError = async ({
  collection,
  config: configArg,
  err,
  req: incomingReq,
}: {
  collection?: Collection
  config: Promise<SanitizedConfig> | SanitizedConfig
  err: APIError
  req: PayloadRequest | Request
}) => {
  if ('payloadInitError' in err && err.payloadInitError === true) {
    // do not attempt initializing Payload if the error is due to a failed initialization. Otherwise,
    // it will cause an infinite loop of initialization attempts and endless error responses, without
    // actually logging the error, as the error logging code will never be reached.
    console.error(err)
    return Response.json(
      {
        message: 'There was an error initializing Payload',
      },
      { status: httpStatus.INTERNAL_SERVER_ERROR },
    )
  }

  let payload = incomingReq && 'payload' in incomingReq && incomingReq?.payload

  if (!payload) {
    try {
      payload = await getPayload({ config: configArg })
    } catch (e) {
      return Response.json(
        {
          message: 'There was an error initializing Payload',
        },
        { status: httpStatus.INTERNAL_SERVER_ERROR },
      )
    }
  }

  let response = formatErrors(err)

  let status = err.status || httpStatus.INTERNAL_SERVER_ERROR

  logError({ err, payload })

  const req = incomingReq as PayloadRequest

  req.payload = payload
  const headers = headersWithCors({
    headers: new Headers(),
    req,
  })

  const { config } = payload

  // Internal server errors can contain anything, including potentially sensitive data.
  // Therefore, error details will be hidden from the response unless `config.debug` is `true`
  if (!config.debug && !err.isPublic && status === httpStatus.INTERNAL_SERVER_ERROR) {
    response = formatErrors(new APIError('Something went wrong.'))
  }

  if (config.debug && config.debug === true) {
    response.stack = err.stack
  }

  if (collection) {
    await collection.config.hooks.afterError?.reduce(async (promise, hook) => {
      await promise

      const result = await hook({
        collection: collection.config,
        context: req.context,
        error: err,
        req,
        result: response,
      })

      if (result) {
        response = (result.response as ErrorResult) || response
        status = result.status || status
      }
    }, Promise.resolve())
  }

  await config.hooks.afterError?.reduce(async (promise, hook) => {
    await promise

    const result = await hook({
      collection: collection?.config,
      context: req.context,
      error: err,
      req,
      result: response,
    })

    if (result) {
      response = (result.response as ErrorResult) || response
      status = result.status || status
    }
  }, Promise.resolve())

  return Response.json(response, {
    headers: req.responseHeaders ? mergeHeaders(req.responseHeaders, headers) : headers,
    status,
  })
}
</file>

<file path="packages/payload/src/utilities/sanitizeFallbackLocale.ts">
import type { SanitizedLocalizationConfig } from '../config/types.js'
import type { TypedLocale } from '../index.js'

interface Args {
  fallbackLocale: false | TypedLocale
  locale: string
  localization: SanitizedLocalizationConfig
}

/**
 * Sanitizes fallbackLocale based on a provided fallbackLocale, locale and localization config
 *
 * Handles the following scenarios:
 * - determines if a fallback locale should be used
 * - determines if a locale specific fallback should be used in place of the default locale
 * - sets the fallbackLocale to 'null' if no fallback locale should be used
 */
export const sanitizeFallbackLocale = ({
  fallbackLocale,
  locale,
  localization,
}: Args): null | string => {
  let hasFallbackLocale = false

  if (fallbackLocale === undefined || fallbackLocale === null) {
    hasFallbackLocale = Boolean(localization && localization.fallback)
  }

  if (fallbackLocale && !['false', 'none', 'null'].includes(fallbackLocale)) {
    hasFallbackLocale = true
  }

  if (hasFallbackLocale) {
    if (!fallbackLocale) {
      // Check for locale specific fallback
      const localeSpecificFallback =
        localization && localization?.locales?.length
          ? localization.locales.find((localeConfig) => localeConfig.code === locale)
              ?.fallbackLocale
          : undefined

      if (localeSpecificFallback) {
        fallbackLocale = localeSpecificFallback
      } else {
        // Use defaultLocale as fallback otherwise
        if (localization && 'fallback' in localization && localization.fallback) {
          fallbackLocale = localization.defaultLocale
        }
      }
    }
  } else {
    fallbackLocale = null
  }

  return fallbackLocale as null | string
}
</file>

<file path="packages/payload/src/utilities/sanitizeInternalFields.ts">
const sanitizeInternalFields = <T extends Record<string, unknown>>(incomingDoc: T): T => {
  // Create a new object to hold the sanitized fields
  const newDoc: Record<string, unknown> = {}

  for (const key in incomingDoc) {
    const val = incomingDoc[key]
    if (key === '_id') {
      newDoc['id'] = val
    } else if (key !== '__v') {
      newDoc[key] = val
    }
  }

  return newDoc as T
}

export default sanitizeInternalFields
</file>

<file path="packages/payload/src/utilities/sanitizeJoinParams.ts">
// @ts-strict-ignore
import type { JoinQuery } from '../types/index.js'

import { isNumber } from './isNumber.js'

/**
 * Convert request JoinQuery object from strings to numbers
 * @param joins
 */
export const sanitizeJoinParams = (
  joins:
    | {
        [schemaPath: string]:
          | {
              limit?: unknown
              sort?: string
              where?: unknown
            }
          | false
      }
    | false = {},
): JoinQuery => {
  const joinQuery = {}

  Object.keys(joins).forEach((schemaPath) => {
    if (joins[schemaPath] === 'false' || joins[schemaPath] === false) {
      joinQuery[schemaPath] = false
    } else {
      joinQuery[schemaPath] = {
        count: joins[schemaPath].count === 'true',
        limit: isNumber(joins[schemaPath]?.limit) ? Number(joins[schemaPath].limit) : undefined,
        page: isNumber(joins[schemaPath]?.page) ? Number(joins[schemaPath].page) : undefined,
        sort: joins[schemaPath]?.sort ? joins[schemaPath].sort : undefined,
        where: joins[schemaPath]?.where ? joins[schemaPath].where : undefined,
      }
    }
  })

  return joinQuery
}
</file>

<file path="packages/payload/src/utilities/sanitizePermissions.spec.ts">
import type { CollectionPermission, Permissions } from '../auth/types.js'
import { preferencesCollectionSlug } from '../preferences/config.js'

import { sanitizePermissions } from './sanitizePermissions.js'

/* eslint-disable perfectionist/sort-objects */
describe('recursivelySanitizePermissions', () => {
  it('should sanitize a basic collection', () => {
    const permissions: CollectionPermission = {
      fields: {
        text: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
      create: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: false,
      },
      readVersions: {
        permission: true,
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions,
      },
    })

    expect(permissions).toStrictEqual({
      fields: true,
      create: true,
      read: true,
      update: true,
      readVersions: true,
    })
  })

  it('should sanitize a collection with where queries', () => {
    const permissions: CollectionPermission = {
      fields: {},
      create: {
        permission: true,
        where: {
          user: {
            equals: 2,
          },
        },
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: false,
      },
      readVersions: {
        permission: true,
        where: {
          user: {
            equals: 1,
          },
        },
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions,
      },
    })
    expect(permissions).toStrictEqual({
      create: {
        permission: true,
        where: {
          user: {
            equals: 2,
          },
        },
      },
      fields: true,
      read: true,
      update: true,
      readVersions: {
        permission: true,
        where: {
          user: {
            equals: 1,
          },
        },
      },
    })
  })

  it('should sanitize a collection with nested fields in blocks', () => {
    const permissions: CollectionPermission = {
      create: {
        permission: true,
      },
      delete: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      fields: {
        layout: {
          create: {
            permission: true,
          },
          blocks: {
            blockWithTitle: {
              fields: {
                blockTitle: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions,
      },
    })
    expect(permissions).toStrictEqual({
      create: true,
      delete: true,
      fields: true,
      read: true,
      update: true,
    })
  })

  it('should sanitize a collection with nested fields in blocks without truncating', () => {
    const permissions: CollectionPermission = {
      create: {
        permission: true,
      },
      delete: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      fields: {
        layout: {
          create: {
            permission: true,
          },
          blocks: {
            blockWithTitle: {
              fields: {
                blockTitle: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: false,
                  },
                },
              },
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions,
      },
    })
    expect(permissions).toStrictEqual({
      create: true,
      delete: true,
      read: true,
      update: true,
      fields: {
        layout: {
          create: true,
          blocks: {
            blockWithTitle: {
              fields: {
                blockTitle: true,
                id: true,
                blockName: {
                  read: true,
                },
              },
              create: true,
              update: true,
              read: true,
            },
          },
          read: true,
          update: true,
        },
      },
    })
  })

  it('should sanitize a collection with nested fields in arrays', () => {
    const permissions: Partial<CollectionPermission> = {
      fields: {
        arrayOfText: {
          create: {
            permission: true,
          },
          fields: {
            text: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            hiddenText: {
              create: {
                permission: true,
              },
              read: {
                permission: false,
              },
              update: {
                permission: true,
              },
            },
            id: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions as CollectionPermission,
      },
    })
    expect(permissions).toStrictEqual({
      fields: {
        arrayOfText: {
          create: true,
          fields: {
            text: true,
            hiddenText: {
              create: true,
              update: true,
            },
            id: true,
          },
          read: true,
          update: true,
        },
      },
    })
  })

  it('should sanitize blocks with subfield named blocks', () => {
    const permissions: CollectionPermission = {
      fields: {
        content: {
          create: { permission: true },
          blocks: {
            test: {
              fields: {
                blocks: {
                  create: { permission: true },
                  fields: {
                    arrayText: {
                      create: { permission: true },
                      read: { permission: true },
                      update: { permission: true },
                    },
                    id: {
                      create: { permission: true },
                      read: { permission: true },
                      update: { permission: true },
                    },
                  },
                  read: { permission: true },
                  update: { permission: true },
                },
                id: {
                  create: { permission: true },
                  read: { permission: true },
                  update: { permission: true },
                },
                blockName: {
                  create: { permission: true },
                  read: { permission: true },
                  update: { permission: true },
                },
              },
              create: { permission: true },
              read: { permission: true },
              update: { permission: true },
            },
          },
          read: { permission: true },
          update: { permission: true },
        },
      },
      create: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: false,
      },
      readVersions: {
        permission: true,
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions,
      },
    })
    expect(permissions).toStrictEqual({
      fields: true,
      create: true,
      read: true,
      update: true,
      readVersions: true,
    })
  })

  it('should sanitize a collection with nested fields in richText', () => {
    const permissions: Partial<CollectionPermission> = {
      fields: {
        text: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        richText: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions as CollectionPermission,
      },
    })
    expect(permissions).toStrictEqual({
      fields: true,
    })
  })

  it('ensure complex permissions are sanitized correctly', () => {
    // This tests a bug where the sanitizePermissions function would previously not correctly sanitize
    const permissions: Partial<CollectionPermission> = {
      fields: {
        GR: {
          create: {
            permission: false,
          },
          fields: {
            rt: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            aaa: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        tab1: {
          fields: {
            rt2: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            blocks2: {
              create: {
                permission: false,
              },
              blocks: {
                myBlock: {
                  fields: {
                    art: {
                      create: {
                        permission: false,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    id: {
                      create: {
                        permission: false,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    blockName: {
                      create: {
                        permission: false,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                  },
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          create: {
            permission: false,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        rt3: {
          create: {
            permission: false,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        blocks3: {
          create: {
            permission: false,
          },
          blocks: {
            myBlock: {
              fields: {
                art: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        array: {
          create: {
            permission: false,
          },
          fields: {
            art: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            id: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        arrayWithAccessFalse: {
          create: {
            permission: false,
          },
          fields: {
            art: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: false,
              },
            },
            id: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: false,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: false,
          },
        },
        blocks: {
          create: {
            permission: false,
          },
          blocks: {
            myBlock: {
              fields: {
                art: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: false,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        updatedAt: {
          create: {
            permission: false,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        createdAt: {
          create: {
            permission: false,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
      create: {
        permission: false,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: true,
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions as CollectionPermission,
      },
    })
    expect(permissions).toStrictEqual({
      fields: {
        GR: {
          fields: {
            rt: {
              read: true,
              update: true,
            },
            aaa: {
              read: true,
              update: true,
            },
          },
          read: true,
          update: true,
        },
        tab1: {
          fields: {
            rt2: {
              read: true,
              update: true,
            },
            blocks2: {
              blocks: {
                myBlock: {
                  fields: {
                    art: {
                      read: true,
                      update: true,
                    },
                    id: {
                      read: true,
                      update: true,
                    },
                    blockName: {
                      read: true,
                      update: true,
                    },
                  },
                  read: true,
                  update: true,
                },
              },
              read: true,
              update: true,
            },
          },
          read: true,
          update: true,
        },
        rt3: {
          read: true,
          update: true,
        },
        blocks3: {
          blocks: {
            myBlock: {
              fields: {
                art: {
                  read: true,
                  update: true,
                },
                id: {
                  read: true,
                  update: true,
                },
                blockName: {
                  read: true,
                  update: true,
                },
              },
              read: true,
              update: true,
            },
          },
          read: true,
          update: true,
        },
        array: {
          fields: {
            art: {
              read: true,
              update: true,
            },
            id: {
              read: true,
              update: true,
            },
          },
          read: true,
          update: true,
        },
        arrayWithAccessFalse: {
          fields: {
            art: {
              read: true,
            },
            id: {
              read: true,
            },
          },
          read: true,
        },
        blocks: {
          blocks: {
            myBlock: {
              fields: {
                art: {
                  read: true,
                  update: true,
                },
                id: {
                  read: true,
                  update: true,
                },
                blockName: {
                  read: true,
                  update: true,
                },
              },
              read: true,
              update: true,
            },
          },
          read: true,
          update: true,
        },
        updatedAt: {
          read: true,
          update: true,
        },
        createdAt: {
          read: true,
          update: true,
        },
      },
      read: true,
      update: true,
      delete: true,
    })
  })

  it('ensure complex permissions are sanitized correctly 2', () => {
    // This tests a bug where the sanitizePermissions function would previously not correctly sanitize
    const permissions: Partial<CollectionPermission> = {
      fields: {
        GR: {
          create: {
            permission: true,
          },
          fields: {
            rt: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            aaa: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        tab1: {
          fields: {
            rt2: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            blocks2: {
              create: {
                permission: true,
              },
              blocks: {
                myBlock: {
                  fields: {
                    art: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    id: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    blockName: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                  },
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        rt3: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        arrayWithAccessFalse: {
          create: {
            permission: false,
          },
          fields: {
            art: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: false,
              },
            },
            id: {
              create: {
                permission: false,
              },
              read: {
                permission: true,
              },
              update: {
                permission: false,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: false,
          },
        },
        blocks: {
          create: {
            permission: true,
          },
          blocks: {
            myBlock: {
              fields: {
                art: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        updatedAt: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        createdAt: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
      create: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: true,
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions as CollectionPermission,
      },
    })
    expect(permissions).toStrictEqual({
      fields: {
        GR: true,
        tab1: true,
        rt3: true,
        arrayWithAccessFalse: {
          fields: {
            art: {
              read: true,
            },
            id: {
              read: true,
            },
          },
          read: true,
        },
        blocks: true,
        updatedAt: true,
        createdAt: true,
      },
      create: true,
      read: true,
      update: true,
      delete: true,
    })
  })

  it('ensure complex permissions are sanitized correctly 3', () => {
    // This tests a bug where the sanitizePermissions function would previously not correctly sanitize
    const permissions: Partial<CollectionPermission> = {
      fields: {
        GR: {
          create: {
            permission: true,
          },
          fields: {
            rt: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            aaa: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        tab1: {
          fields: {
            rt2: {
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
            blocks2: {
              create: {
                permission: true,
              },
              blocks: {
                myBlock: {
                  fields: {
                    art: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    id: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                    blockName: {
                      create: {
                        permission: true,
                      },
                      read: {
                        permission: true,
                      },
                      update: {
                        permission: true,
                      },
                    },
                  },
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        rt3: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        blocks: {
          create: {
            permission: true,
          },
          blocks: {
            myBlock: {
              fields: {
                art: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                id: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
                blockName: {
                  create: {
                    permission: true,
                  },
                  read: {
                    permission: true,
                  },
                  update: {
                    permission: true,
                  },
                },
              },
              create: {
                permission: true,
              },
              read: {
                permission: true,
              },
              update: {
                permission: true,
              },
            },
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        updatedAt: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
        createdAt: {
          create: {
            permission: true,
          },
          read: {
            permission: true,
          },
          update: {
            permission: true,
          },
        },
      },
      create: {
        permission: true,
      },
      read: {
        permission: true,
      },
      update: {
        permission: true,
      },
      delete: {
        permission: true,
      },
    }

    sanitizePermissions({
      canAccessAdmin: true,
      collections: {
        test: permissions as CollectionPermission,
      },
    })
    expect(permissions).toStrictEqual({
      fields: true,
      create: true,
      read: true,
      update: true,
      delete: true,
    })
  })
})

describe('sanitizePermissions', () => {
  it('should return nothing for unauthenticated user', () => {
    const permissions: Permissions = {
      canAccessAdmin: false,
      collections: {
        preferencesCollectionSlug: {
          fields: {
            user: {
              create: {
                permission: false,
              },
              read: {
                permission: false,
              },
              update: {
                permission: false,
              },
            },
          },
          create: {
            permission: false,
          },
          read: {
            permission: false,
          },
          update: {
            permission: false,
          },
          delete: {
            permission: false,
          },
        },
      },
      globals: {
        menu: {
          fields: {
            globalText: {
              create: {
                permission: false,
              },
              read: {
                permission: false,
              },
              update: {
                permission: false,
              },
            },
          },
          read: {
            permission: false,
          },
          update: {
            permission: false,
          },
        },
      },
    }

    const sanitizedPermissions = sanitizePermissions(permissions)

    expect(sanitizedPermissions).toStrictEqual({})
  })
})
</file>

<file path="packages/payload/src/utilities/sanitizePermissions.ts">
// @ts-strict-ignore
import type { MarkOptional } from 'ts-essentials'

import type {
  CollectionPermission,
  FieldPermissions,
  FieldsPermissions,
  GlobalPermission,
  Permissions,
  SanitizedBlocksPermissions,
  SanitizedFieldPermissions,
  SanitizedFieldsPermissions,
  SanitizedPermissions,
} from '../auth/types.js'

function checkAndSanitizeFieldsPermssions(data: FieldsPermissions): boolean {
  let allFieldPermissionsTrue = true
  for (const key in data) {
    if (typeof data[key] === 'object') {
      if (!checkAndSanitizePermissions(data[key])) {
        allFieldPermissionsTrue = false
      } else {
        ;(data[key] as unknown as SanitizedFieldPermissions) = true
      }
    } else if (data[key] !== true) {
      allFieldPermissionsTrue = false
    }
  }

  // If all values are true or it's an empty object, return true
  return allFieldPermissionsTrue
}

/**
 * Check if all permissions in a FieldPermissions, CollectionPermission or GlobalPermission object are true.
 * If nested fields or blocks are present, the function will recursively check those as well.
 */
function checkAndSanitizePermissions(
  data: CollectionPermission | FieldPermissions | GlobalPermission,
): boolean {
  /**
   * Check blocks permissions
   */
  let blocksPermissions = true
  if ('blocks' in data && data.blocks) {
    for (const blockSlug in data.blocks) {
      if (typeof data.blocks[blockSlug] === 'object') {
        for (const key in data.blocks[blockSlug]) {
          /**
           * Check fields in nested blocks
           */
          if (key === 'fields') {
            if (data.blocks[blockSlug].fields) {
              if (!checkAndSanitizeFieldsPermssions(data.blocks[blockSlug].fields)) {
                blocksPermissions = false
              } else {
                ;(data.blocks[blockSlug].fields as unknown as SanitizedFieldsPermissions) = true
              }
            }
          } else {
            if (typeof data.blocks[blockSlug][key] === 'object') {
              /**
               * Check Permissions in nested blocks
               */
              if (isPermissionObject(data.blocks[blockSlug][key])) {
                if (
                  data.blocks[blockSlug][key]['permission'] === true &&
                  !('where' in data.blocks[blockSlug][key])
                ) {
                  // If the permission is true and there is no where clause, set the key to true
                  data.blocks[blockSlug][key] = true
                  continue
                } else if (
                  data.blocks[blockSlug][key]['permission'] === true &&
                  'where' in data.blocks[blockSlug][key]
                ) {
                  // otherwise do nothing so we can keep the where clause
                  blocksPermissions = false
                } else {
                  blocksPermissions = false
                  data.blocks[blockSlug][key] = false
                  delete data.blocks[blockSlug][key]
                  continue
                }
              } else {
                throw new Error('Unexpected object in block permissions')
              }
            }
          }
        }
      } else if (data.blocks[blockSlug] !== true) {
        // If any value is not true, return false
        blocksPermissions = false
        delete data.blocks[blockSlug]
      }
    }
    if (blocksPermissions) {
      ;(data.blocks as unknown as SanitizedBlocksPermissions) = true
    }
  }

  /**
   * Check nested Fields permissions
   */
  let fieldsPermissions = true
  if (data.fields) {
    if (!checkAndSanitizeFieldsPermssions(data.fields)) {
      fieldsPermissions = false
    } else {
      ;(data.fields as unknown as SanitizedFieldsPermissions) = true
    }
  }

  /**
   * Check other Permissions objects (e.g. read, write)
   */
  let otherPermissions = true
  for (const key in data) {
    if (key === 'fields' || key === 'blocks') {
      continue
    }
    if (typeof data[key] === 'object') {
      if (isPermissionObject(data[key])) {
        if (data[key]['permission'] === true && !('where' in data[key])) {
          // If the permission is true and there is no where clause, set the key to true
          data[key] = true
          continue
        } else if (data[key]['permission'] === true && 'where' in data[key]) {
          // otherwise do nothing so we can keep the where clause
          otherPermissions = false
        } else {
          otherPermissions = false
          data[key] = false
          delete data[key]
          continue
        }
      } else {
        throw new Error('Unexpected object in fields permissions')
      }
    } else if (data[key] !== true) {
      // If any value is not true, return false
      otherPermissions = false
    }
  }

  // If all values are true or it's an empty object, return true
  return fieldsPermissions && blocksPermissions && otherPermissions
}

/**
 * Check if an object is a permission object.
 */
function isPermissionObject(data: unknown): boolean {
  return typeof data === 'object' && 'permission' in data && typeof data['permission'] === 'boolean'
}

/**
 * Recursively remove empty objects from an object.
 */
function cleanEmptyObjects(obj: any): void {
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      // Recursive call
      cleanEmptyObjects(obj[key])
      if (Object.keys(obj[key]).length === 0) {
        // Delete the key if the object is empty
        delete obj[key]
      }
    } else if (obj[key] === null || obj[key] === undefined) {
      delete obj[key]
    }
  })
}

export function recursivelySanitizeCollections(obj: Permissions['collections']): void {
  if (typeof obj !== 'object') {
    return
  }

  const collectionPermissions = Object.values(obj)

  for (const collectionPermission of collectionPermissions) {
    checkAndSanitizePermissions(collectionPermission)
  }
}

export function recursivelySanitizeGlobals(obj: Permissions['globals']): void {
  if (typeof obj !== 'object') {
    return
  }

  const globalPermissions = Object.values(obj)

  for (const globalPermission of globalPermissions) {
    checkAndSanitizePermissions(globalPermission)
  }
}

/**
 * Recursively remove empty objects and false values from an object.
 */
export function sanitizePermissions(
  data: MarkOptional<Permissions, 'canAccessAdmin'>,
): SanitizedPermissions {
  if (data.canAccessAdmin === false) {
    delete data.canAccessAdmin
  }

  if (data.collections) {
    recursivelySanitizeCollections(data.collections)
  }

  if (data.globals) {
    recursivelySanitizeGlobals(data.globals)
  }

  // Run clean up of empty objects at the end
  cleanEmptyObjects(data)

  return data as unknown as SanitizedPermissions
}
</file>

<file path="packages/payload/src/utilities/sanitizePopulateParam.ts">
// @ts-strict-ignore
import type { PopulateType } from '../types/index.js'

import { sanitizeSelectParam } from './sanitizeSelectParam.js'

/**
 * Sanitizes REST populate query to PopulateType
 */
export const sanitizePopulateParam = (unsanitizedPopulate: unknown): PopulateType | undefined => {
  if (!unsanitizedPopulate || typeof unsanitizedPopulate !== 'object') {
    return
  }

  for (const k in unsanitizedPopulate) {
    unsanitizedPopulate[k] = sanitizeSelectParam(unsanitizedPopulate[k])
  }

  return unsanitizedPopulate as PopulateType
}
</file>

<file path="packages/payload/src/utilities/sanitizeSelect.ts">
import { deepMergeSimple } from '@convexcms/translations/utilities'

import type { SelectType } from '../types/index.js'

import { getSelectMode } from './getSelectMode.js'

export const sanitizeSelect = ({
  forceSelect,
  select,
}: {
  forceSelect?: SelectType
  select?: SelectType
}): SelectType | undefined => {
  if (!forceSelect || !select) {
    return select
  }

  const selectMode = getSelectMode(select)

  if (selectMode === 'exclude') {
    return select
  }

  return deepMergeSimple(select, forceSelect)
}
</file>

<file path="packages/payload/src/utilities/sanitizeSelectParam.ts">
// @ts-strict-ignore
import type { SelectType } from '../types/index.js'

/**
 * Sanitizes REST select query to SelectType
 */
export const sanitizeSelectParam = (unsanitizedSelect: unknown): SelectType | undefined => {
  if (unsanitizedSelect && typeof unsanitizedSelect === 'object') {
    for (const k in unsanitizedSelect) {
      if (unsanitizedSelect[k] === 'true') {
        unsanitizedSelect[k] = true
      } else if (unsanitizedSelect[k] === 'false') {
        unsanitizedSelect[k] = false
      } else if (typeof unsanitizedSelect[k] === 'object') {
        sanitizeSelectParam(unsanitizedSelect[k])
      }
    }
  }

  return unsanitizedSelect as SelectType
}
</file>

<file path="packages/payload/src/utilities/setsAreEqual.ts">
export const setsAreEqual = (xs: Set<unknown>, ys: Set<unknown>) =>
  xs.size === ys.size && [...xs].every((x) => ys.has(x))
</file>

<file path="packages/payload/src/utilities/stripUnselectedFields.ts">
import type { Data } from '../admin/types.js'
import type { Field, TabAsField } from '../fields/config/types.js'
import type { SelectMode, SelectType } from '../types/index.js'

import { fieldAffectsData } from '../fields/config/types.js'

/**
 * This is used for the Select API to strip out fields that are not selected.
 * It will mutate the given data object and determine if your recursive function should continue to run.
 * It is used within the `afterRead` hook as well as `getFormState`.
 * @returns boolean - whether or not the recursive function should continue
 */
export const stripUnselectedFields = ({
  field,
  select,
  selectMode,
  siblingDoc,
}: {
  field: Field | TabAsField
  select: SelectType
  selectMode: SelectMode
  siblingDoc: Data
}): boolean => {
  let shouldContinue = true

  if (fieldAffectsData(field) && select && selectMode && field.name) {
    if (selectMode === 'include') {
      if (!select[field.name]) {
        delete siblingDoc[field.name]
        shouldContinue = false
      }
    }

    if (selectMode === 'exclude') {
      if (select[field.name] === false) {
        delete siblingDoc[field.name]
        shouldContinue = false
      }
    }
  }

  return shouldContinue
}
</file>

<file path="packages/payload/src/utilities/timestamp.ts">
// @ts-strict-ignore
export const timestamp = (label) => {
  if (!process.env.PAYLOAD_TIME) {
    process.env.PAYLOAD_TIME = String(new Date().getTime())
  }
  const now = new Date()
  console.log(`[${now.getTime() - Number(process.env.PAYLOAD_TIME)}ms] ${label}`)
}
</file>

<file path="packages/payload/src/utilities/toKebabCase.ts">
// @ts-strict-ignore
const toKebabCase = (string) =>
  string
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/\s+/g, '-')
    .toLowerCase()

export default toKebabCase
</file>

<file path="packages/payload/src/utilities/transformColumnPreferences.ts">
import type { Column } from '../admin/types.js'
import type { ColumnPreference } from '../preferences/types.js'

export type ColumnsFromURL = string[]

/**
 * Transforms various forms of columns into `ColumnPreference[]` which is what is stored in the user's preferences table
 * In React state, for example, columns are stored in in their entirety, including React components: `[{ accessor: 'title', active: true, Label: React.ReactNode, ... }]`
 * In the URL, they are stored as an array of strings: `['title', '-slug']`, where the `-` prefix is used to indicate that the column is inactive
 * However in the database, columns must be in this exact shape: `[{ accessor: 'title', active: true }, { accessor: 'slug', active: false }]`
 * This means that when handling columns, they need to be consistently transformed back and forth
 */
export const transformColumnsToPreferences = (
  columns: Column[] | ColumnPreference[] | ColumnsFromURL | string,
): ColumnPreference[] | undefined => {
  let columnsToTransform = columns

  // Columns that originate from the URL are a stringified JSON array and need to be parsed first
  if (typeof columns === 'string') {
    try {
      columnsToTransform = JSON.parse(columns)
    } catch (e) {
      console.error('Error parsing columns', columns, e) // eslint-disable-line no-console
    }
  }

  if (columnsToTransform && Array.isArray(columnsToTransform)) {
    return columnsToTransform.map((col) => {
      if (typeof col === 'string') {
        const active = col[0] !== '-'
        return { accessor: active ? col : col.slice(1), active }
      }

      return { accessor: col.accessor, active: col.active }
    })
  }
}

/**
 * Does the opposite of `transformColumnsToPreferences`, where `ColumnPreference[]` and `Column[]` are transformed into `ColumnsFromURL`
 * This is useful for storing the columns in the URL, where it appears as a simple comma delimited array of strings
 * The `-` prefix is used to indicate that the column is inactive
 */
export const transformColumnsToSearchParams = (
  columns: Column[] | ColumnPreference[],
): ColumnsFromURL => {
  return columns.map((col) => (col.active ? col.accessor : `-${col.accessor}`))
}
</file>

<file path="packages/payload/src/utilities/transformWhereQuery.ts">
import type { Where } from '../types/index.js'

/**
 * Transforms a basic "where" query into a format in which the "where builder" can understand.
 * Even though basic queries are valid, we need to hoist them into the "and" / "or" format.
 * Use this function alongside `validateWhereQuery` to check that for valid queries before transforming.
 * @example
 * Inaccurate: [text][equals]=example%20post
 * Accurate: [or][0][and][0][text][equals]=example%20post
 */
export const transformWhereQuery = (whereQuery: Where): Where => {
  if (!whereQuery) {
    return {}
  }

  // Check if 'whereQuery' has 'or' field but no 'and'. This is the case for "correct" queries
  if (whereQuery.or && !whereQuery.and) {
    return {
      or: whereQuery.or.map((query) => {
        // ...but if the or query does not have an and, we need to add it
        if (!query.and) {
          return {
            and: [query],
          }
        }
        return query
      }),
    }
  }

  // Check if 'whereQuery' has 'and' field but no 'or'.
  if (whereQuery.and && !whereQuery.or) {
    return {
      or: [
        {
          and: whereQuery.and,
        },
      ],
    }
  }

  // Check if 'whereQuery' has neither 'or' nor 'and'.
  if (!whereQuery.or && !whereQuery.and) {
    return {
      or: [
        {
          and: [whereQuery], // top-level siblings are considered 'and'
        },
      ],
    }
  }

  // If 'whereQuery' has 'or' and 'and', just return it as it is.
  return whereQuery
}
</file>

<file path="packages/payload/src/utilities/traverseFields.ts">
// @ts-strict-ignore
import type { Config, SanitizedConfig } from '../config/types.js'
import type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'

import { fieldHasSubFields, fieldShouldBeLocalized } from '../fields/config/types.js'

const traverseArrayOrBlocksField = ({
  callback,
  callbackStack,
  config,
  data,
  field,
  fillEmpty,
  leavesFirst,
  parentIsLocalized,
  parentRef,
}: {
  callback: TraverseFieldsCallback
  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]
  config?: Config | SanitizedConfig
  data: Record<string, unknown>[]
  field: ArrayField | BlocksField
  fillEmpty: boolean
  leavesFirst: boolean
  parentIsLocalized: boolean
  parentRef?: unknown
}) => {
  if (fillEmpty) {
    if (field.type === 'array') {
      traverseFields({
        callback,
        callbackStack,
        config,
        fields: field.fields,
        isTopLevel: false,
        leavesFirst,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentRef,
      })
    }
    if (field.type === 'blocks') {
      for (const _block of field.blockReferences ?? field.blocks) {
        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks
        const block =
          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block
        if (block) {
          traverseFields({
            callback,
            callbackStack,
            config,
            fields: block.fields,
            isTopLevel: false,
            leavesFirst,
            parentIsLocalized: parentIsLocalized || field.localized,
            parentRef,
          })
        }
      }
    }
    return
  }
  for (const ref of data) {
    let fields: Field[]
    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {
      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks
      const block = field.blockReferences
        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??
            field.blockReferences.find(
              (b) => typeof b !== 'string' && b.slug === ref.blockType,
            )) as Block)
        : field.blocks.find((b) => b.slug === ref.blockType)

      fields = block?.fields
    } else if (field.type === 'array') {
      fields = field.fields
    }

    if (fields) {
      traverseFields({
        callback,
        callbackStack,
        config,
        fields,
        fillEmpty,
        isTopLevel: false,
        leavesFirst,
        parentIsLocalized: parentIsLocalized || field.localized,
        parentRef,
        ref,
      })
    }
  }
}

export type TraverseFieldsCallback = (args: {
  /**
   * The current field
   */
  field: Field | TabAsField
  /**
   * Function that when called will skip the current field and continue to the next
   */
  next?: () => void
  parentIsLocalized: boolean
  /**
   * The parent reference object
   */
  parentRef?: Record<string, unknown> | unknown
  /**
   * The current reference object
   */
  ref?: Record<string, unknown> | unknown
}) => boolean | void

type TraverseFieldsArgs = {
  callback: TraverseFieldsCallback
  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]
  config?: Config | SanitizedConfig
  fields: (Field | TabAsField)[]
  fillEmpty?: boolean
  isTopLevel?: boolean
  /**
   * @default false
   *
   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.
   * The return value of the callback function will be ignored.
   */
  leavesFirst?: boolean
  parentIsLocalized?: boolean
  parentRef?: Record<string, unknown> | unknown
  ref?: Record<string, unknown> | unknown
}

/**
 * Iterate a recurse an array of fields, calling a callback for each field
 *
 * @param fields
 * @param callback callback called for each field, discontinue looping if callback returns truthy
 * @param fillEmpty fill empty properties to use this without data
 * @param ref the data or any artifacts assigned in the callback during field recursion
 * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up
 */
export const traverseFields = ({
  callback,
  callbackStack: _callbackStack = [],
  config,
  fields,
  fillEmpty = true,
  isTopLevel = true,
  leavesFirst = false,
  parentIsLocalized,
  parentRef = {},
  ref = {},
}: TraverseFieldsArgs): void => {
  fields.some((field) => {
    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []
    if (!isTopLevel) {
      callbackStack = _callbackStack
    }
    let skip = false
    const next = () => {
      skip = true
    }

    if (!ref || typeof ref !== 'object') {
      return
    }

    if (!leavesFirst && callback && callback({ field, next, parentIsLocalized, parentRef, ref })) {
      return true
    } else if (leavesFirst) {
      callbackStack.push(() => callback({ field, next, parentIsLocalized, parentRef, ref }))
    }

    if (skip) {
      return false
    }

    // avoid mutation of ref for all fields
    let currentRef = ref
    let currentParentRef = parentRef

    if (field.type === 'tabs' && 'tabs' in field) {
      for (const tab of field.tabs) {
        let tabRef = ref

        if (skip) {
          return false
        }

        if ('name' in tab && tab.name) {
          if (!ref[tab.name] || typeof ref[tab.name] !== 'object') {
            if (fillEmpty) {
              if (tab.localized) {
                ref[tab.name] = { en: {} }
              } else {
                ref[tab.name] = {}
              }
            } else {
              continue
            }
          }

          if (
            callback &&
            !leavesFirst &&
            callback({
              field: { ...tab, type: 'tab' },
              next,
              parentIsLocalized,
              parentRef: currentParentRef,
              ref: tabRef,
            })
          ) {
            return true
          } else if (leavesFirst) {
            callbackStack.push(() =>
              callback({
                field: { ...tab, type: 'tab' },
                next,
                parentIsLocalized,
                parentRef: currentParentRef,
                ref: tabRef,
              }),
            )
          }

          tabRef = tabRef[tab.name]

          if (tab.localized) {
            for (const key in tabRef as Record<string, unknown>) {
              if (tabRef[key] && typeof tabRef[key] === 'object') {
                traverseFields({
                  callback,
                  callbackStack,
                  config,
                  fields: tab.fields,
                  fillEmpty,
                  isTopLevel: false,
                  leavesFirst,
                  parentIsLocalized: true,
                  parentRef: currentParentRef,
                  ref: tabRef[key],
                })
              }
            }
          }
        } else {
          if (
            callback &&
            !leavesFirst &&
            callback({
              field: { ...tab, type: 'tab' },
              next,
              parentIsLocalized,
              parentRef: currentParentRef,
              ref: tabRef,
            })
          ) {
            return true
          } else if (leavesFirst) {
            callbackStack.push(() =>
              callback({
                field: { ...tab, type: 'tab' },
                next,
                parentIsLocalized,
                parentRef: currentParentRef,
                ref: tabRef,
              }),
            )
          }
        }

        if (!tab.localized) {
          traverseFields({
            callback,
            callbackStack,
            config,
            fields: tab.fields,
            fillEmpty,
            isTopLevel: false,
            leavesFirst,
            parentIsLocalized: false,
            parentRef: currentParentRef,
            ref: tabRef,
          })
        }

        if (skip) {
          return false
        }
      }

      return
    }

    if (field.type !== 'tab' && (fieldHasSubFields(field) || field.type === 'blocks')) {
      if ('name' in field && field.name) {
        currentParentRef = currentRef
        if (!ref[field.name]) {
          if (fillEmpty) {
            if (field.type === 'group') {
              if (fieldShouldBeLocalized({ field, parentIsLocalized })) {
                ref[field.name] = {
                  en: {},
                }
              } else {
                ref[field.name] = {}
              }
            } else if (field.type === 'array' || field.type === 'blocks') {
              if (fieldShouldBeLocalized({ field, parentIsLocalized })) {
                ref[field.name] = {
                  en: [],
                }
              } else {
                ref[field.name] = []
              }
            }
          } else {
            return
          }
        }
        currentRef = ref[field.name]
      }

      if (
        field.type === 'group' &&
        fieldShouldBeLocalized({ field, parentIsLocalized }) &&
        currentRef &&
        typeof currentRef === 'object'
      ) {
        for (const key in currentRef as Record<string, unknown>) {
          if (currentRef[key]) {
            traverseFields({
              callback,
              callbackStack,
              config,
              fields: field.fields,
              fillEmpty,
              isTopLevel: false,
              leavesFirst,
              parentIsLocalized: true,
              parentRef: currentParentRef,
              ref: currentRef[key],
            })
          }
        }
        return
      }

      if (
        (field.type === 'blocks' || field.type === 'array') &&
        currentRef &&
        typeof currentRef === 'object'
      ) {
        if (fieldShouldBeLocalized({ field, parentIsLocalized })) {
          if (Array.isArray(currentRef)) {
            return
          }

          for (const key in currentRef as Record<string, unknown>) {
            const localeData = currentRef[key]
            if (!Array.isArray(localeData)) {
              continue
            }

            traverseArrayOrBlocksField({
              callback,
              callbackStack,
              config,
              data: localeData,
              field,
              fillEmpty,
              leavesFirst,
              parentIsLocalized: true,
              parentRef: currentParentRef,
            })
          }
        } else if (Array.isArray(currentRef)) {
          traverseArrayOrBlocksField({
            callback,
            callbackStack,
            config,
            data: currentRef as Record<string, unknown>[],
            field,
            fillEmpty,
            leavesFirst,
            parentIsLocalized,
            parentRef: currentParentRef,
          })
        }
      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {
        traverseFields({
          callback,
          callbackStack,
          config,
          fields: field.fields,
          fillEmpty,
          isTopLevel: false,
          leavesFirst,
          parentIsLocalized,
          parentRef: currentParentRef,
          ref: currentRef,
        })
      }
    }

    if (isTopLevel) {
      callbackStack.reverse().forEach((cb) => {
        cb()
      })
    }
  })
}
</file>

<file path="packages/payload/src/utilities/unflatten.ts">
// @ts-strict-ignore
/*
 * Copyright (c) 2014, Hugh Kennedy
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2020, Feross Aboukhadijeh <https://feross.org>
 * Reference: https://www.npmjs.com/package/is-buffer
 * All rights reserved.
 */
function isBuffer(obj) {
  return (
    obj != null &&
    obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' &&
    obj.constructor.isBuffer(obj)
  )
}

interface Opts {
  delimiter?: string
  object?: any
  overwrite?: boolean
  recursive?: boolean
}

export const unflatten = (target, opts?: Opts) => {
  opts = opts || {}

  const delimiter = opts.delimiter || '.'
  const overwrite = opts.overwrite || false
  const recursive = opts.recursive || false
  const result = {}

  const isbuffer = isBuffer(target)

  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {
    return target
  }

  // safely ensure that the key is an integer.
  const getkey = (key) => {
    const parsedKey = Number(key)
    return isNaN(parsedKey) || key.indexOf('.') !== -1 || opts.object ? key : parsedKey
  }

  const sortedKeys = Object.keys(target).sort((keyA, keyB) => keyA.length - keyB.length)

  sortedKeys.forEach((key) => {
    const split = key.split(delimiter)
    let key1 = getkey(split.shift())
    let key2 = getkey(split[0])
    let recipient = result

    while (key2 !== undefined) {
      if (key1 === '__proto__') {
        return
      }

      const type = Object.prototype.toString.call(recipient[key1])
      const isobject = type === '[object Object]' || type === '[object Array]'

      // do not write over falsey, non-undefined values if overwrite is false
      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {
        return
      }

      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {
        recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {}
      }

      recipient = recipient[key1]

      if (split.length > 0) {
        key1 = getkey(split.shift())
        key2 = getkey(split[0])
      }
    }

    // unflatten again for 'messy objects'
    recipient[key1] = recursive ? unflatten(target[key], opts) : target[key]
  })

  return result
}
</file>

<file path="packages/payload/src/utilities/validateMimeType.ts">
export const validateMimeType = (mimeType: string, allowedMimeTypes: string[]): boolean => {
  const cleanedMimeTypes = allowedMimeTypes.map((v) => v.replace('*', ''))
  return cleanedMimeTypes.some((cleanedMimeType) => mimeType.startsWith(cleanedMimeType))
}
</file>

<file path="packages/payload/src/utilities/validateWhereQuery.ts">
import type { Operator, Where } from '../types/index.js'

import { validOperatorSet } from '../types/constants.js'

/**
 * Validates that a "where" query is in a format in which the "where builder" can understand.
 * Even though basic queries are valid, we need to hoist them into the "and" / "or" format.
 * Use this function alongside `transformWhereQuery` to perform a transformation if the query is not valid.
 * @example
 * Inaccurate: [text][equals]=example%20post
 * Accurate: [or][0][and][0][text][equals]=example%20post
 */
export const validateWhereQuery = (whereQuery: Where): whereQuery is Where => {
  if (
    whereQuery?.or &&
    whereQuery?.or?.length > 0 &&
    whereQuery?.or?.[0]?.and &&
    whereQuery?.or?.[0]?.and?.length > 0
  ) {
    // At this point we know that the whereQuery has 'or' and 'and' fields,
    // now let's check the structure and content of these fields.

    const isValid = whereQuery.or.every((orQuery) => {
      if (orQuery.and && Array.isArray(orQuery.and)) {
        return orQuery.and.every((andQuery) => {
          if (typeof andQuery !== 'object') {
            return false
          }

          const andKeys = Object.keys(andQuery)

          // If there are no keys, it's not a valid WhereField.
          if (andKeys.length === 0) {
            return false
          }

          for (const key of andKeys) {
            const operator = Object.keys(andQuery[key])[0]
            // Check if the key is a valid Operator.
            if (!operator || !validOperatorSet.has(operator as Operator)) {
              return false
            }
          }
          return true
        })
      }
      return false
    })

    return isValid
  }

  return false
}
</file>

<file path="packages/payload/src/utilities/wait.ts">
// @ts-strict-ignore
export async function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms)
  })
}
</file>

<file path="packages/payload/src/utilities/wordBoundariesRegex.ts">
export default (input: string): RegExp => {
  const words = input.split(' ')

  // Regex word boundaries that work for cyrillic characters - https://stackoverflow.com/a/47062016/1717697
  const wordBoundaryBefore = '(?:(?:[^\\p{L}\\p{N}])|^)' // Converted to a non-matching group instead of positive lookbehind for Safari
  const wordBoundaryAfter = '(?=[^\\p{L}\\p{N}]|$)'
  const regex = words.reduce((pattern, word, i) => {
    const escapedWord = word.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
    return `${pattern}(?=.*${wordBoundaryBefore}.*${escapedWord}.*${wordBoundaryAfter})${
      i + 1 === words.length ? '.+' : ''
    }`
  }, '')
  return new RegExp(regex, 'i')
}
</file>

<file path="packages/payload/src/utilities/wrapInternalEndpoints.ts">
import type { Endpoint } from '../config/types.js'

import { addDataAndFileToRequest } from './addDataAndFileToRequest.js'
import { addLocalesToRequestFromData } from './addLocalesToRequest.js'

export const wrapInternalEndpoints = (endpoints: Endpoint[]): Endpoint[] => {
  return endpoints.map((endpoint) => {
    const handler = endpoint.handler

    if (['patch', 'post'].includes(endpoint.method)) {
      endpoint.handler = async (req) => {
        await addDataAndFileToRequest(req)
        addLocalesToRequestFromData(req)
        return handler(req)
      }
    }

    return endpoint
  })
}
</file>

<file path="packages/payload/src/versions/drafts/appendVersionToQueryKey.ts">
import type { Where } from '../../types/index.js'

export const appendVersionToQueryKey = (query: Where = {}): Where => {
  return Object.entries(query).reduce((res, [key, val]) => {
    if (['AND', 'and', 'OR', 'or'].includes(key) && Array.isArray(val)) {
      return {
        ...res,
        [key.toLowerCase()]: val.map((subQuery) => appendVersionToQueryKey(subQuery)),
      }
    }

    if (key !== 'id') {
      return {
        ...res,
        [`version.${key}`]: val,
      }
    }

    return {
      ...res,
      parent: val,
    }
  }, {})
}
</file>

<file path="packages/payload/src/versions/drafts/getQueryDraftsSelect.ts">
import type { SelectType } from '../../types/index.js'

import { getSelectMode } from '../../utilities/getSelectMode.js'

export const getQueryDraftsSelect = ({
  select,
}: {
  select?: SelectType
}): SelectType | undefined => {
  if (!select) {
    return
  }

  const mode = getSelectMode(select)

  if (mode === 'include') {
    return {
      parent: true,
      version: select,
    } as SelectType
  }

  return {
    version: select,
  } as SelectType
}
</file>

<file path="packages/payload/src/versions/drafts/getQueryDraftsSort.ts">
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { Sort } from '../../types/index.js'

/**
 * Takes the incoming sort argument and prefixes it with `versions.` and preserves any `-` prefixes for descending order
 * @param sort
 */
export const getQueryDraftsSort = ({
  collectionConfig,
  sort,
}: {
  collectionConfig: SanitizedCollectionConfig
  sort?: Sort
}): Sort => {
  if (!sort) {
    if (collectionConfig.defaultSort) {
      sort = collectionConfig.defaultSort
    } else {
      sort = '-createdAt'
    }
  }

  if (typeof sort === 'string') {
    sort = [sort]
  }

  return sort.map((field: string) => {
    let orderBy: string
    let direction = ''
    if (field[0] === '-') {
      orderBy = field.substring(1)
      direction = '-'
    } else {
      orderBy = field
    }

    if (orderBy === 'id') {
      return `${direction}parent`
    }

    return `${direction}version.${orderBy}`
  })
}
</file>

<file path="packages/payload/src/versions/drafts/replaceWithDraftIfAvailable.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'
import type { AccessResult } from '../../config/types.js'
import type { FindGlobalVersionsArgs, FindVersionsArgs } from '../../database/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { PayloadRequest, SelectType, Where } from '../../types/index.js'

import { hasWhereAccessResult } from '../../auth/index.js'
import { combineQueries } from '../../database/combineQueries.js'
import { docHasTimestamps } from '../../types/index.js'
import sanitizeInternalFields from '../../utilities/sanitizeInternalFields.js'
import { appendVersionToQueryKey } from './appendVersionToQueryKey.js'
import { getQueryDraftsSelect } from './getQueryDraftsSelect.js'

type Arguments<T> = {
  accessResult: AccessResult
  doc: T
  entity: SanitizedCollectionConfig | SanitizedGlobalConfig
  entityType: 'collection' | 'global'
  overrideAccess: boolean
  req: PayloadRequest
  select?: SelectType
}

const replaceWithDraftIfAvailable = async <T extends TypeWithID>({
  accessResult,
  doc,
  entity,
  entityType,
  req,
  select,
}: Arguments<T>): Promise<T> => {
  const { locale } = req

  const queryToBuild: Where = {
    and: [
      {
        'version._status': {
          equals: 'draft',
        },
      },
    ],
  }

  if (entityType === 'collection') {
    queryToBuild.and.push({
      parent: {
        equals: doc.id,
      },
    })
  }

  if (docHasTimestamps(doc)) {
    queryToBuild.and.push({
      or: [
        {
          updatedAt: {
            greater_than: doc.updatedAt,
          },
        },
        {
          latest: {
            equals: true,
          },
        },
      ],
    })
  }

  let versionAccessResult

  if (hasWhereAccessResult(accessResult)) {
    versionAccessResult = appendVersionToQueryKey(accessResult)
  }

  const findVersionsArgs: FindGlobalVersionsArgs & FindVersionsArgs = {
    collection: entity.slug,
    global: entity.slug,
    limit: 1,
    locale,
    pagination: false,
    req,
    select: getQueryDraftsSelect({ select }),
    sort: '-updatedAt',
    where: combineQueries(queryToBuild, versionAccessResult),
  }

  let versionDocs
  if (entityType === 'global') {
    versionDocs = (await req.payload.db.findGlobalVersions<T>(findVersionsArgs)).docs
  } else {
    versionDocs = (await req.payload.db.findVersions<T>(findVersionsArgs)).docs
  }

  let draft = versionDocs[0]

  if (!draft) {
    return doc
  }

  draft = sanitizeInternalFields(draft)

  // Patch globalType onto version doc
  if (entityType === 'global' && 'globalType' in doc) {
    draft.version.globalType = doc.globalType
  }

  // handle when .version wasn't selected due to projection
  if (!draft.version) {
    draft.version = {}
  }

  // Disregard all other draft content at this point,
  // Only interested in the version itself.
  // Operations will handle firing hooks, etc.

  draft.version.id = doc.id

  return draft.version
}

export default replaceWithDraftIfAvailable
</file>

<file path="packages/payload/src/versions/schedule/job.ts">
// @ts-strict-ignore
import type { User } from '../../auth/types.js'
import type { Field } from '../../fields/config/types.js'
import type { TaskConfig } from '../../queues/config/types/taskTypes.js'
import type { SchedulePublishTaskInput } from './types.js'

type Args = {
  adminUserSlug: string
  collections: string[]
  globals: string[]
}

export const getSchedulePublishTask = ({
  adminUserSlug,
  collections,
  globals,
}: Args): TaskConfig<{ input: SchedulePublishTaskInput; output: object }> => {
  return {
    slug: 'schedulePublish',
    handler: async ({ input, req }) => {
      const _status = input?.type === 'publish' || !input?.type ? 'published' : 'draft'

      const userID = input.user

      let user: null | User = null

      if (userID) {
        user = (await req.payload.findByID({
          id: userID,
          collection: adminUserSlug,
          depth: 0,
        })) as User

        user.collection = adminUserSlug
      }

      let publishSpecificLocale: string

      if (input?.type === 'publish' && input.locale && req.payload.config.localization) {
        const matchedLocale = req.payload.config.localization.locales.find(
          ({ code }) => code === input.locale,
        )

        if (matchedLocale) {
          publishSpecificLocale = input.locale
        }
      }

      if (input.doc) {
        await req.payload.update({
          id: input.doc.value,
          collection: input.doc.relationTo,
          data: {
            _status,
          },
          depth: 0,
          overrideAccess: user === null,
          publishSpecificLocale,
          user,
        })
      }

      if (input.global) {
        await req.payload.updateGlobal({
          slug: input.global,
          data: {
            _status,
          },
          depth: 0,
          overrideAccess: user === null,
          publishSpecificLocale,
          user,
        })
      }

      return {
        output: {},
      }
    },
    inputSchema: [
      {
        name: 'type',
        type: 'radio',
        defaultValue: 'publish',
        options: ['publish', 'unpublish'],
      },
      {
        name: 'locale',
        type: 'text',
      },
      ...(collections.length > 0
        ? [
            {
              name: 'doc',
              type: 'relationship',
              relationTo: collections,
            } satisfies Field,
          ]
        : []),
      {
        name: 'global',
        type: 'select',
        options: globals,
      },
      {
        name: 'user',
        type: 'relationship',
        relationTo: adminUserSlug,
      },
    ],
  }
}
</file>

<file path="packages/payload/src/versions/schedule/types.ts">
import type { CollectionSlug, GlobalSlug } from '../../index.js'

export type SchedulePublishTaskInput = {
  doc?: {
    relationTo: CollectionSlug
    value: string
  }
  global?: GlobalSlug
  locale?: string
  type?: string
  user?: number | string
}
</file>

<file path="packages/payload/src/versions/baseFields.ts">
// @ts-strict-ignore
import type { CheckboxField, Field } from '../fields/config/types.js'

export const statuses = [
  {
    label: ({ t }) => t('version:draft'),
    value: 'draft',
  },
  {
    label: ({ t }) => t('version:published'),
    value: 'published',
  },
]

const baseVersionFields: Field[] = [
  {
    name: '_status',
    type: 'select',
    admin: {
      components: {
        Field: false,
      },
      disableBulkEdit: true,
    },
    defaultValue: 'draft',
    index: true,
    label: ({ t }) => t('version:status'),
    options: statuses,
  },
]

// When publishing a specific locale,
// we need to create a new draft which acts as a
// "snapshot" to retain all existing draft data.
// This field will be used to exclude any snapshot versions
// from the admin Versions list
export const versionSnapshotField: CheckboxField = {
  name: 'snapshot',
  type: 'checkbox',
  admin: {
    disableBulkEdit: true,
    disabled: true,
  },
  index: true,
}

export default baseVersionFields
</file>

<file path="packages/payload/src/versions/buildCollectionFields.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedConfig } from '../config/types.js'
import type { Field, FlattenedField } from '../fields/config/types.js'

import { versionSnapshotField } from './baseFields.js'

export const buildVersionCollectionFields = <T extends boolean = false>(
  config: SanitizedConfig,
  collection: SanitizedCollectionConfig,
  flatten?: T,
): true extends T ? FlattenedField[] : Field[] => {
  const fields: FlattenedField[] = [
    {
      name: 'parent',
      type: 'relationship',
      index: true,
      relationTo: collection.slug,
    },
    {
      name: 'version',
      type: 'group',
      fields: collection.fields.filter((field) => !('name' in field) || field.name !== 'id'),
      ...(flatten && {
        flattenedFields: collection.flattenedFields.filter((each) => each.name !== 'id'),
      }),
    },
    {
      name: 'createdAt',
      type: 'date',
      admin: {
        disabled: true,
      },
      index: true,
    },
    {
      name: 'updatedAt',
      type: 'date',
      admin: {
        disabled: true,
      },
      index: true,
    },
  ]

  if (collection?.versions?.drafts) {
    if (config.localization) {
      fields.push(versionSnapshotField)

      fields.push({
        name: 'publishedLocale',
        type: 'select',
        admin: {
          disableBulkEdit: true,
          disabled: true,
        },
        index: true,
        options: config.localization.locales.map((locale) => {
          if (typeof locale === 'string') {
            return locale
          }

          return locale.code
        }),
      })
    }

    fields.push({
      name: 'latest',
      type: 'checkbox',
      admin: {
        disabled: true,
      },
      index: true,
    })

    if (collection?.versions?.drafts?.autosave) {
      fields.push({
        name: 'autosave',
        type: 'checkbox',
        index: true,
      })
    }
  }

  return fields as true extends T ? FlattenedField[] : Field[]
}
</file>

<file path="packages/payload/src/versions/buildGlobalFields.ts">
// @ts-strict-ignore
import type { SanitizedConfig } from '../config/types.js'
import type { Field, FlattenedField } from '../fields/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'

import { versionSnapshotField } from './baseFields.js'

export const buildVersionGlobalFields = <T extends boolean = false>(
  config: SanitizedConfig,
  global: SanitizedGlobalConfig,
  flatten?: T,
): true extends T ? FlattenedField[] : Field[] => {
  const fields: FlattenedField[] = [
    {
      name: 'version',
      type: 'group',
      fields: global.fields,
      ...(flatten && {
        flattenedFields: global.flattenedFields,
      }),
    },
    {
      name: 'createdAt',
      type: 'date',
      admin: {
        disabled: true,
      },
      index: true,
    },
    {
      name: 'updatedAt',
      type: 'date',
      admin: {
        disabled: true,
      },
      index: true,
    },
  ]

  if (global?.versions?.drafts) {
    if (config.localization) {
      fields.push(versionSnapshotField)

      fields.push({
        name: 'publishedLocale',
        type: 'select',
        admin: {
          disableBulkEdit: true,
          disabled: true,
        },
        index: true,
        options: config.localization.locales.map((locale) => {
          if (typeof locale === 'string') {
            return locale
          }

          return locale.code
        }),
      })
    }

    fields.push({
      name: 'latest',
      type: 'checkbox',
      admin: {
        disabled: true,
      },
      index: true,
    })

    if (global?.versions?.drafts?.autosave) {
      fields.push({
        name: 'autosave',
        type: 'checkbox',
        index: true,
      })
    }
  }

  return fields as true extends T ? FlattenedField[] : Field[]
}
</file>

<file path="packages/payload/src/versions/buildVersionCompoundIndexes.ts">
import type { SanitizedCompoundIndex } from '../collections/config/types.js'

export const buildVersionCompoundIndexes = ({
  indexes,
}: {
  indexes: SanitizedCompoundIndex[]
}): SanitizedCompoundIndex[] => {
  return indexes.map((each) => ({
    fields: each.fields.map(({ field, localizedPath, path, pathHasLocalized }) => ({
      field,
      localizedPath: `version.${localizedPath}`,
      path: `version.${path}`,
      pathHasLocalized,
    })),
    unique: false,
  }))
}
</file>

<file path="packages/payload/src/versions/defaults.ts">
export const versionDefaults = {
  autosaveInterval: 2000,
}
</file>

<file path="packages/payload/src/versions/deleteCollectionVersions.ts">
import type { PayloadRequest } from '../types/index.js'

import { type Payload } from '../index.js'

type Args = {
  id?: number | string
  payload: Payload
  req?: PayloadRequest
  slug: string
}

export const deleteCollectionVersions = async ({ id, slug, payload, req }: Args): Promise<void> => {
  try {
    await payload.db.deleteVersions({
      collection: slug,
      req,
      where: {
        parent: {
          equals: id,
        },
      },
    })
  } catch (err) {
    payload.logger.error({
      err,
      msg: `There was an error removing versions for the deleted ${slug} document with ID ${id}.`,
    })
  }
}
</file>

<file path="packages/payload/src/versions/deleteScheduledPublishJobs.ts">
import type { PayloadRequest } from '../types/index.js'

import { type Payload } from '../index.js'
import { jobsCollectionSlug } from '../queues/config/index.js'

type Args = {
  id?: number | string
  payload: Payload
  req?: PayloadRequest
  slug: string
}

export const deleteScheduledPublishJobs = async ({
  id,
  slug,
  payload,
  req,
}: Args): Promise<void> => {
  try {
    await payload.db.deleteMany({
      collection: jobsCollectionSlug,
      req,
      where: {
        and: [
          // only want to delete jobs have not run yet
          {
            completedAt: {
              exists: false,
            },
          },
          {
            processing: {
              equals: false,
            },
          },
          {
            'input.doc.value': {
              equals: id,
            },
          },
          {
            'input.doc.relationTo': {
              equals: slug,
            },
          },
          // data.type narrows scheduled publish jobs in case of another job having input.doc.value
          {
            taskSlug: {
              equals: 'schedulePublish',
            },
          },
        ],
      },
    })
  } catch (err) {
    payload.logger.error({
      err,
      msg: `There was an error deleting scheduled publish jobs from the queue for ${slug} document with ID ${id}.`,
    })
  }
}
</file>

<file path="packages/payload/src/versions/enforceMaxVersions.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig } from '../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { Payload, PayloadRequest, Where } from '../types/index.js'

type Args = {
  collection?: SanitizedCollectionConfig
  global?: SanitizedGlobalConfig
  id?: number | string
  max: number
  payload: Payload
  req?: PayloadRequest
}

export const enforceMaxVersions = async ({
  id,
  collection,
  global,
  max,
  payload,
  req,
}: Args): Promise<void> => {
  const entityType = collection ? 'collection' : 'global'
  const slug = collection ? collection.slug : global?.slug

  try {
    const where: Where = {}
    let oldestAllowedDoc

    if (collection) {
      where.parent = {
        equals: id,
      }

      const query = await payload.db.findVersions({
        collection: collection.slug,
        limit: 1,
        pagination: false,
        req,
        skip: max,
        sort: '-updatedAt',
        where,
      })

      ;[oldestAllowedDoc] = query.docs
    } else if (global) {
      const query = await payload.db.findGlobalVersions({
        global: global.slug,
        limit: 1,
        pagination: false,
        req,
        skip: max,
        sort: '-updatedAt',
        where,
      })

      ;[oldestAllowedDoc] = query.docs
    }

    if (oldestAllowedDoc?.updatedAt) {
      const deleteQuery: Where = {
        updatedAt: {
          less_than_equal: oldestAllowedDoc.updatedAt,
        },
      }

      if (collection) {
        deleteQuery.parent = {
          equals: id,
        }
      }

      await payload.db.deleteVersions({
        collection: slug,
        req,
        where: deleteQuery,
      })
    }
  } catch (err) {
    payload.logger.error(
      `There was an error cleaning up old versions for the ${entityType} ${slug}`,
    )
  }
}
</file>

<file path="packages/payload/src/versions/getLatestCollectionVersion.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'
import type { FindOneArgs } from '../database/types.js'
import type { Payload, PayloadRequest } from '../types/index.js'
import type { TypeWithVersion } from './types.js'

import { combineQueries } from '../database/combineQueries.js'
import { appendVersionToQueryKey } from './drafts/appendVersionToQueryKey.js'

type Args = {
  config: SanitizedCollectionConfig
  id: number | string
  payload: Payload
  published?: boolean
  query: FindOneArgs
  req?: PayloadRequest
}

export const getLatestCollectionVersion = async <T extends TypeWithID = any>({
  id,
  config,
  payload,
  published,
  query,
  req,
}: Args): Promise<T> => {
  let latestVersion: TypeWithVersion<T>

  const whereQuery = published
    ? { and: [{ parent: { equals: id } }, { 'version._status': { equals: 'published' } }] }
    : { and: [{ parent: { equals: id } }, { latest: { equals: true } }] }

  if (config.versions?.drafts) {
    const { docs } = await payload.db.findVersions<T>({
      collection: config.slug,
      limit: 1,
      pagination: false,
      req,
      sort: '-updatedAt',
      where: combineQueries(appendVersionToQueryKey(query.where), whereQuery),
    })
    ;[latestVersion] = docs
  }

  if (!latestVersion) {
    if (!published) {
      const doc = await payload.db.findOne<T>({ ...query, req })

      return doc
    }

    return undefined
  }

  latestVersion.version.id = id

  return latestVersion.version
}
</file>

<file path="packages/payload/src/versions/getLatestGlobalVersion.ts">
// @ts-strict-ignore
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { Document, Payload, PayloadRequest, Where } from '../types/index.js'

type Args = {
  config: SanitizedGlobalConfig
  locale?: string
  payload: Payload
  published?: boolean
  req?: PayloadRequest
  slug: string
  where: Where
}

export const getLatestGlobalVersion = async ({
  slug,
  config,
  locale,
  payload,
  published,
  req,
  where,
}: Args): Promise<{ global: Document; globalExists: boolean }> => {
  let latestVersion

  const whereQuery = published
    ? { 'version._status': { equals: 'published' } }
    : { latest: { equals: true } }

  if (config.versions?.drafts) {
    latestVersion = (
      await payload.db.findGlobalVersions({
        global: slug,
        limit: 1,
        locale,
        pagination: false,
        req,
        where: whereQuery,
      })
    ).docs[0]
  }

  const global = await payload.db.findGlobal({
    slug,
    locale,
    req,
    where,
  })
  const globalExists = Boolean(global)

  if (!latestVersion) {
    return {
      global,
      globalExists,
    }
  }

  if (!latestVersion.version.createdAt) {
    latestVersion.version.createdAt = latestVersion.createdAt
  }

  if (!latestVersion.version.updatedAt) {
    latestVersion.version.updatedAt = latestVersion.updatedAt
  }

  return {
    global: latestVersion.version,
    globalExists,
  }
}
</file>

<file path="packages/payload/src/versions/payloadPackageList.ts">
export const PAYLOAD_PACKAGE_LIST = [
  'payload',
  '@payloadcms/bundler-vite',
  '@payloadcms/bundler-webpack',
  '@payloadcms/db-mongodb',
  '@payloadcms/db-postgres',
  '@payloadcms/email-nodemailer',
  '@payloadcms/email-resend',
  '@payloadcms/graphql',
  '@payloadcms/live-preview-react',
  '@payloadcms/live-preview',
  '@payloadcms/next/utilities',
  '@payloadcms/plugin-cloud-storage',
  '@payloadcms/payload-cloud',
  '@payloadcms/plugin-form-builder',
  '@payloadcms/plugin-import-export',
  // '@payloadcms/plugin-multi-tenant',
  '@payloadcms/plugin-nested-docs',
  '@payloadcms/plugin-redirects',
  '@payloadcms/plugin-search',
  '@payloadcms/plugin-seo',
  '@payloadcms/plugin-stripe',
  '@payloadcms/plugin-zapier',
  '@payloadcms/richtext-lexical',
  '@payloadcms/richtext-slate',
  '@payloadcms/storage-azure',
  '@payloadcms/storage-gcs',
  '@payloadcms/storage-s3',
  '@payloadcms/storage-uploadthing',
  '@payloadcms/storage-vercel-blob',
  from '@convexcms/translations',
  '@convexcms/ui/shared',
]
</file>

<file path="packages/payload/src/versions/saveVersion.ts">
// @ts-strict-ignore
import type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'
import type { SanitizedGlobalConfig } from '../globals/config/types.js'
import type { CreateGlobalVersionArgs, CreateVersionArgs, Payload } from '../index.js'
import type { PayloadRequest, SelectType } from '../types/index.js'

import { deepCopyObjectSimple } from '../index.js'
import sanitizeInternalFields from '../utilities/sanitizeInternalFields.js'
import { getQueryDraftsSelect } from './drafts/getQueryDraftsSelect.js'
import { enforceMaxVersions } from './enforceMaxVersions.js'

type Args = {
  autosave?: boolean
  collection?: SanitizedCollectionConfig
  docWithLocales: any
  draft?: boolean
  global?: SanitizedGlobalConfig
  id?: number | string
  payload: Payload
  publishSpecificLocale?: string
  req?: PayloadRequest
  select?: SelectType
  snapshot?: any
}

export const saveVersion = async ({
  id,
  autosave,
  collection,
  docWithLocales: doc,
  draft,
  global,
  payload,
  publishSpecificLocale,
  req,
  select,
  snapshot,
}: Args): Promise<TypeWithID> => {
  let result
  let createNewVersion = true
  const now = new Date().toISOString()
  const versionData = deepCopyObjectSimple(doc)
  if (draft) {
    versionData._status = 'draft'
  }

  if (collection?.timestamps && draft) {
    versionData.updatedAt = now
  }

  if (versionData._id) {
    delete versionData._id
  }

  try {
    if (autosave) {
      let docs
      const findVersionArgs = {
        limit: 1,
        pagination: false,
        req,
        sort: '-updatedAt',
      }

      if (collection) {
        ;({ docs } = await payload.db.findVersions({
          ...findVersionArgs,
          collection: collection.slug,
          limit: 1,
          pagination: false,
          req,
          where: {
            parent: {
              equals: id,
            },
          },
        }))
      } else {
        ;({ docs } = await payload.db.findGlobalVersions({
          ...findVersionArgs,
          global: global.slug,
          limit: 1,
          pagination: false,
          req,
        }))
      }
      const [latestVersion] = docs

      // overwrite the latest version if it's set to autosave
      if (latestVersion?.autosave === true) {
        createNewVersion = false

        const data: Record<string, unknown> = {
          createdAt: new Date(latestVersion.createdAt).toISOString(),
          latest: true,
          parent: id,
          updatedAt: now,
          version: {
            ...versionData,
          },
        }

        const updateVersionArgs = {
          id: latestVersion.id,
          req,
          versionData: data as TypeWithID,
        }

        if (collection) {
          result = await payload.db.updateVersion({
            ...updateVersionArgs,
            collection: collection.slug,
            req,
          })
        } else {
          result = await payload.db.updateGlobalVersion({
            ...updateVersionArgs,
            global: global.slug,
            req,
          })
        }
      }
    }

    if (createNewVersion) {
      const createVersionArgs = {
        autosave: Boolean(autosave),
        collectionSlug: undefined,
        createdAt: now,
        globalSlug: undefined,
        parent: collection ? id : undefined,
        publishedLocale: publishSpecificLocale || undefined,
        req,
        select: getQueryDraftsSelect({ select }),
        updatedAt: now,
        versionData,
      }

      if (collection) {
        createVersionArgs.collectionSlug = collection.slug
        result = await payload.db.createVersion(createVersionArgs)
      }

      if (global) {
        createVersionArgs.globalSlug = global.slug
        result = await payload.db.createGlobalVersion(createVersionArgs)
      }

      if (publishSpecificLocale && snapshot) {
        const snapshotData = deepCopyObjectSimple(snapshot)
        if (snapshotData._id) {
          delete snapshotData._id
        }

        snapshotData._status = 'draft'

        const snapshotDate = new Date().toISOString()

        const updatedArgs = {
          ...createVersionArgs,
          createdAt: snapshotDate,
          returning: false,
          snapshot: true,
          updatedAt: snapshotDate,
          versionData: snapshotData,
        } as CreateGlobalVersionArgs & CreateVersionArgs

        if (collection) {
          await payload.db.createVersion(updatedArgs)
        }
        if (global) {
          await payload.db.createGlobalVersion(updatedArgs)
        }
      }
    }
  } catch (err) {
    let errorMessage: string | undefined

    if (collection) {
      errorMessage = `There was an error while saving a version for the ${typeof collection.labels.singular === 'string' ? collection.labels.singular : collection.slug} with ID ${id}.`
    }
    if (global) {
      errorMessage = `There was an error while saving a version for the global ${typeof global.label === 'string' ? global.label : global.slug}.`
    }
    payload.logger.error({ err, msg: errorMessage })
    return
  }

  const max = collection ? collection.versions.maxPerDoc : global.versions.max

  if (createNewVersion && max > 0) {
    await enforceMaxVersions({
      id,
      collection,
      global,
      max,
      payload,
      req,
    })
  }

  let createdVersion = result.version

  createdVersion = sanitizeInternalFields(createdVersion)
  createdVersion.id = result.parent

  return createdVersion
}
</file>

<file path="packages/payload/src/versions/types.ts">
export type Autosave = {
  /**
   * Define an `interval` in milliseconds to automatically save progress while documents are edited.
   * Document updates are "debounced" at this interval.
   *
   * @default 800
   */
  interval?: number
}

export type SchedulePublish = {
  /**
   * Define a date format to use for the time picker.
   *
   * @example 'hh:mm' will give a 24 hour clock
   *
   * @default 'h:mm aa' which is a 12 hour clock
   */
  timeFormat?: string
  /**
   * Intervals for the time picker.
   *
   * @default 5
   */
  timeIntervals?: number
}

export type IncomingDrafts = {
  /**
   * Enable autosave to automatically save progress while documents are edited.
   * To enable, set to true or pass an object with options.
   */
  autosave?: Autosave | boolean
  /**
   * Allow for editors to schedule publish / unpublish events in the future.
   */
  schedulePublish?: boolean | SchedulePublish
  /**
   * Set validate to true to validate draft documents when saved.
   *
   * @default false
   */
  validate?: boolean
}

export type SanitizedDrafts = {
  /**
   * Enable autosave to automatically save progress while documents are edited.
   * To enable, set to true or pass an object with options.
   */
  autosave: Autosave | false
  /**
   * Allow for editors to schedule publish / unpublish events in the future.
   */
  schedulePublish: boolean | SchedulePublish
  /**
   * Set validate to true to validate draft documents when saved.
   *
   * @default false
   */
  validate: boolean
}

export type IncomingCollectionVersions = {
  /**
   * Enable Drafts mode for this collection.
   * To enable, set to true or pass an object with draft options.
   */
  drafts?: boolean | IncomingDrafts
  /**
   * Use this setting to control how many versions to keep on a document by document basis.
   * Must be an integer. Use 0 to save all versions.
   *
   * @default 100
   */
  maxPerDoc?: number
}

export interface SanitizedCollectionVersions extends Omit<IncomingCollectionVersions, 'drafts'> {
  /**
   * Enable Drafts mode for this collection.
   * To enable, set to true or pass an object with draft options.
   */
  drafts: false | SanitizedDrafts
  /**
   * Use this setting to control how many versions to keep on a document by document basis.
   * Must be an integer. Use 0 to save all versions.
   *
   * @default 100
   */
  maxPerDoc: number
}

export type IncomingGlobalVersions = {
  drafts?: boolean | IncomingDrafts
  /**
   * Use this setting to control how many versions to keep on a global by global basis.
   * Must be an integer.
   */
  max?: number
}

export type SanitizedGlobalVersions = {
  /**
   * Enable Drafts mode for this global. To enable, set to true or pass an object with draft options
   */
  drafts: false | SanitizedDrafts
  /**
   * Use this setting to control how many versions to keep on a global by global basis.
   * Must be an integer.
   */
  max: number
}

export type TypeWithVersion<T> = {
  createdAt: string
  id: string
  parent: number | string
  publishedLocale?: string
  snapshot?: boolean
  updatedAt: string
  version: T
}
</file>

<file path="packages/payload/src/checkPayloadDependencies.ts">
import { checkDependencies } from './utilities/dependencies/dependencyChecker.js'
import { PAYLOAD_PACKAGE_LIST } from './versions/payloadPackageList.js'

export function checkPayloadDependencies() {
  const dependencies = [...PAYLOAD_PACKAGE_LIST]

  if (process.env.PAYLOAD_CI_DEPENDENCY_CHECKER !== 'true') {
    dependencies.push('@payloadcms/plugin-sentry')
  }

  // First load. First check if there are mismatching dependency versions of payload packages
  void checkDependencies({
    dependencyGroups: [
      {
        name: 'payload',
        dependencies,
        targetVersionDependency: 'payload',
      },
    ],
  })
}
</file>

<file path="packages/payload/src/index.ts">
// @ts-strict-ignore
import type { ExecutionResult, GraphQLSchema, ValidationRule } from 'graphql'
import type { Request as graphQLRequest, OperationArgs } from 'graphql-http'
import type { Logger } from 'pino'
import type { NonNever } from 'ts-essentials'

import { spawn } from 'child_process'
import crypto from 'crypto'
import { fileURLToPath } from 'node:url'
import path from 'path'
import WebSocket from 'ws'

import type { AuthArgs } from './auth/operations/auth.js'
import type { Result as ForgotPasswordResult } from './auth/operations/forgotPassword.js'
import type { Options as ForgotPasswordOptions } from './auth/operations/local/forgotPassword.js'
import type { Options as LoginOptions } from './auth/operations/local/login.js'
import type { Options as ResetPasswordOptions } from './auth/operations/local/resetPassword.js'
import type { Options as UnlockOptions } from './auth/operations/local/unlock.js'
import type { Options as VerifyEmailOptions } from './auth/operations/local/verifyEmail.js'
import type { Result as LoginResult } from './auth/operations/login.js'
import type { Result as ResetPasswordResult } from './auth/operations/resetPassword.js'
import type { AuthStrategy, User } from './auth/types.js'
import type {
  BulkOperationResult,
  Collection,
  DataFromCollectionSlug,
  SelectFromCollectionSlug,
  TypeWithID,
} from './collections/config/types.js'
export type { FieldState } from './admin/forms/Form.js'
import type { Options as CountOptions } from './collections/operations/local/count.js'
import type { Options as CreateOptions } from './collections/operations/local/create.js'
import type {
  ByIDOptions as DeleteByIDOptions,
  ManyOptions as DeleteManyOptions,
  Options as DeleteOptions,
} from './collections/operations/local/delete.js'
import type { Options as DuplicateOptions } from './collections/operations/local/duplicate.js'
import type { Options as FindOptions } from './collections/operations/local/find.js'
import type { Options as FindByIDOptions } from './collections/operations/local/findByID.js'
import type { Options as FindVersionByIDOptions } from './collections/operations/local/findVersionByID.js'
import type { Options as FindVersionsOptions } from './collections/operations/local/findVersions.js'
import type { Options as RestoreVersionOptions } from './collections/operations/local/restoreVersion.js'
import type {
  ByIDOptions as UpdateByIDOptions,
  ManyOptions as UpdateManyOptions,
  Options as UpdateOptions,
} from './collections/operations/local/update.js'
import type { InitOptions, SanitizedConfig } from './config/types.js'
import type { BaseDatabaseAdapter, PaginatedDocs } from './database/types.js'
import type { InitializedEmailAdapter } from './email/types.js'
import type { DataFromGlobalSlug, Globals, SelectFromGlobalSlug } from './globals/config/types.js'
import type { CountGlobalVersionsOptions } from './globals/operations/local/countGlobalVersions.js'
import type { Options as FindGlobalOptions } from './globals/operations/local/findOne.js'
import type { Options as FindGlobalVersionByIDOptions } from './globals/operations/local/findVersionByID.js'
import type { Options as FindGlobalVersionsOptions } from './globals/operations/local/findVersions.js'
import type { Options as RestoreGlobalVersionOptions } from './globals/operations/local/restoreVersion.js'
import type { Options as UpdateGlobalOptions } from './globals/operations/local/update.js'
import type {
  ApplyDisableErrors,
  JsonObject,
  SelectType,
  TransformCollectionWithSelect,
  TransformGlobalWithSelect,
} from './types/index.js'
import type { TraverseFieldsCallback } from './utilities/traverseFields.js'
export type * from './admin/types.js'
import type { SupportedLanguages } from '@convexcms/translations'

import { Cron } from 'croner'

import type { ClientConfig } from './config/client.js'
import type { TypeWithVersion } from './versions/types.js'

import { decrypt, encrypt } from './auth/crypto.js'
import { APIKeyAuthentication } from './auth/strategies/apiKey.js'
import { JWTAuthentication } from './auth/strategies/jwt.js'
import { generateImportMap, type ImportMap } from './bin/generateImportMap/index.js'
import { checkPayloadDependencies } from './checkPayloadDependencies.js'
import localOperations from './collections/operations/local/index.js'
import { consoleEmailAdapter } from './email/consoleEmailAdapter.js'
import { fieldAffectsData, type FlattenedBlock } from './fields/config/types.js'
import localGlobalOperations from './globals/operations/local/index.js'
import { getJobsLocalAPI } from './queues/localAPI.js'
import { isNextBuild } from './utilities/isNextBuild.js'
import { getLogger } from './utilities/logger.js'
import { serverInit as serverInitTelemetry } from './utilities/telemetry/events/serverInit.js'
import { traverseFields } from './utilities/traverseFields.js'

export { default as executeAccess } from './auth/executeAccess.js'
export { executeAuthStrategies } from './auth/executeAuthStrategies.js'

export interface GeneratedTypes {
  authUntyped: {
    [slug: string]: {
      forgotPassword: {
        email: string
      }
      login: {
        email: string
        password: string
      }
      registerFirstUser: {
        email: string
        password: string
      }
      unlock: {
        email: string
      }
    }
  }

  blocksUntyped: {
    [slug: string]: JsonObject
  }
  collectionsJoinsUntyped: {
    [slug: string]: {
      [schemaPath: string]: CollectionSlug
    }
  }
  collectionsSelectUntyped: {
    [slug: string]: SelectType
  }

  collectionsUntyped: {
    [slug: string]: JsonObject & TypeWithID
  }
  dbUntyped: {
    defaultIDType: number | string
  }
  globalsSelectUntyped: {
    [slug: string]: SelectType
  }

  globalsUntyped: {
    [slug: string]: JsonObject
  }
  jobsUntyped: {
    tasks: {
      [slug: string]: {
        input?: JsonObject
        output?: JsonObject
      }
    }
    workflows: {
      [slug: string]: {
        input: JsonObject
      }
    }
  }
  localeUntyped: null | string
  userUntyped: User
}

// Helper type to resolve the correct type using conditional types
type ResolveCollectionType<T> = 'collections' extends keyof T
  ? T['collections']
  : // @ts-expect-error
    T['collectionsUntyped']

type ResolveBlockType<T> = 'blocks' extends keyof T
  ? T['blocks']
  : // @ts-expect-error
    T['blocksUntyped']

type ResolveCollectionSelectType<T> = 'collectionsSelect' extends keyof T
  ? T['collectionsSelect']
  : // @ts-expect-error
    T['collectionsSelectUntyped']

type ResolveCollectionJoinsType<T> = 'collectionsJoins' extends keyof T
  ? T['collectionsJoins']
  : // @ts-expect-error
    T['collectionsJoinsUntyped']

type ResolveGlobalType<T> = 'globals' extends keyof T
  ? T['globals']
  : // @ts-expect-error
    T['globalsUntyped']

type ResolveGlobalSelectType<T> = 'globalsSelect' extends keyof T
  ? T['globalsSelect']
  : // @ts-expect-error
    T['globalsSelectUntyped']

// Applying helper types to GeneratedTypes
export type TypedCollection = ResolveCollectionType<GeneratedTypes>

export type TypedBlock = ResolveBlockType<GeneratedTypes>

export type TypedUploadCollection = NonNever<{
  [K in keyof TypedCollection]:
    | 'filename'
    | 'filesize'
    | 'mimeType'
    | 'url' extends keyof TypedCollection[K]
    ? TypedCollection[K]
    : never
}>

export type TypedCollectionSelect = ResolveCollectionSelectType<GeneratedTypes>

export type TypedCollectionJoins = ResolveCollectionJoinsType<GeneratedTypes>

export type TypedGlobal = ResolveGlobalType<GeneratedTypes>

export type TypedGlobalSelect = ResolveGlobalSelectType<GeneratedTypes>

// Extract string keys from the type
export type StringKeyOf<T> = Extract<keyof T, string>

// Define the types for slugs using the appropriate collections and globals
export type CollectionSlug = StringKeyOf<TypedCollection>

export type BlockSlug = StringKeyOf<TypedBlock>

export type UploadCollectionSlug = StringKeyOf<TypedUploadCollection>

type ResolveDbType<T> = 'db' extends keyof T
  ? T['db']
  : // @ts-expect-error
    T['dbUntyped']

export type DefaultDocumentIDType = ResolveDbType<GeneratedTypes>['defaultIDType']
export type GlobalSlug = StringKeyOf<TypedGlobal>

// now for locale and user

// @ts-expect-error
type ResolveLocaleType<T> = 'locale' extends keyof T ? T['locale'] : T['localeUntyped']
// @ts-expect-error
type ResolveUserType<T> = 'user' extends keyof T ? T['user'] : T['userUntyped']

export type TypedLocale = ResolveLocaleType<GeneratedTypes>
export type TypedUser = ResolveUserType<GeneratedTypes>

// @ts-expect-error
type ResolveAuthOperationsType<T> = 'auth' extends keyof T ? T['auth'] : T['authUntyped']
export type TypedAuthOperations = ResolveAuthOperationsType<GeneratedTypes>

// @ts-expect-error
type ResolveJobOperationsType<T> = 'jobs' extends keyof T ? T['jobs'] : T['jobsUntyped']
export type TypedJobs = ResolveJobOperationsType<GeneratedTypes>

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

let checkedDependencies = false

/**
 * @description Payload
 */
export class BasePayload {
  /**
   * @description Authorization and Authentication using headers and cookies to run auth user strategies
   * @returns permissions: Permissions
   * @returns user: User
   */
  auth = async (options: AuthArgs) => {
    const { auth } = localOperations.auth
    return auth(this, options)
  }

  authStrategies: AuthStrategy[]

  blocks: Record<BlockSlug, FlattenedBlock> = {}

  collections: Record<CollectionSlug, Collection> = {}

  config: SanitizedConfig
  /**
   * @description Performs count operation
   * @param options
   * @returns count of documents satisfying query
   */
  count = async <T extends CollectionSlug>(
    options: CountOptions<T>,
  ): Promise<{ totalDocs: number }> => {
    const { count } = localOperations
    return count(this, options)
  }

  /**
   * @description Performs countGlobalVersions operation
   * @param options
   * @returns count of global document versions satisfying query
   */
  countGlobalVersions = async <T extends GlobalSlug>(
    options: CountGlobalVersionsOptions<T>,
  ): Promise<{ totalDocs: number }> => {
    const { countGlobalVersions } = localGlobalOperations
    return countGlobalVersions(this, options)
  }

  /**
   * @description Performs countVersions operation
   * @param options
   * @returns count of document versions satisfying query
   */
  countVersions = async <T extends CollectionSlug>(
    options: CountOptions<T>,
  ): Promise<{ totalDocs: number }> => {
    const { countVersions } = localOperations
    return countVersions(this, options)
  }

  /**
   * @description Performs create operation
   * @param options
   * @returns created document
   */
  create = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: CreateOptions<TSlug, TSelect>,
  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
    const { create } = localOperations
    return create<TSlug, TSelect>(this, options)
  }

  db: DatabaseAdapter
  decrypt = decrypt

  duplicate = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: DuplicateOptions<TSlug, TSelect>,
  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>> => {
    const { duplicate } = localOperations
    return duplicate<TSlug, TSelect>(this, options)
  }

  email: InitializedEmailAdapter

  encrypt = encrypt

  // TODO: re-implement or remove?
  // errorHandler: ErrorHandler

  extensions: (args: {
    args: OperationArgs<any>
    req: graphQLRequest<unknown, unknown>
    result: ExecutionResult
  }) => Promise<any>

  /**
   * @description Find documents with criteria
   * @param options
   * @returns documents satisfying query
   */
  find = async <TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: FindOptions<TSlug, TSelect>,
  ): Promise<PaginatedDocs<TransformCollectionWithSelect<TSlug, TSelect>>> => {
    const { find } = localOperations
    return find<TSlug, TSelect>(this, options)
  }

  /**
   * @description Find document by ID
   * @param options
   * @returns document with specified ID
   */
  findByID = async <
    TSlug extends CollectionSlug,
    TDisableErrors extends boolean,
    TSelect extends SelectFromCollectionSlug<TSlug>,
  >(
    options: FindByIDOptions<TSlug, TDisableErrors, TSelect>,
  ): Promise<ApplyDisableErrors<TransformCollectionWithSelect<TSlug, TSelect>, TDisableErrors>> => {
    const { findByID } = localOperations
    return findByID<TSlug, TDisableErrors, TSelect>(this, options)
  }

  findGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(
    options: FindGlobalOptions<TSlug, TSelect>,
  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {
    const { findOne } = localGlobalOperations
    return findOne<TSlug, TSelect>(this, options)
  }

  /**
   * @description Find global version by ID
   * @param options
   * @returns global version with specified ID
   */
  findGlobalVersionByID = async <TSlug extends GlobalSlug>(
    options: FindGlobalVersionByIDOptions<TSlug>,
  ): Promise<TypeWithVersion<DataFromGlobalSlug<TSlug>>> => {
    const { findVersionByID } = localGlobalOperations
    return findVersionByID<TSlug>(this, options)
  }

  /**
   * @description Find global versions with criteria
   * @param options
   * @returns versions satisfying query
   */
  findGlobalVersions = async <TSlug extends GlobalSlug>(
    options: FindGlobalVersionsOptions<TSlug>,
  ): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<TSlug>>>> => {
    const { findVersions } = localGlobalOperations
    return findVersions<TSlug>(this, options)
  }

  /**
   * @description Find version by ID
   * @param options
   * @returns version with specified ID
   */
  findVersionByID = async <TSlug extends CollectionSlug>(
    options: FindVersionByIDOptions<TSlug>,
  ): Promise<TypeWithVersion<DataFromCollectionSlug<TSlug>>> => {
    const { findVersionByID } = localOperations
    return findVersionByID<TSlug>(this, options)
  }

  /**
   * @description Find versions with criteria
   * @param options
   * @returns versions satisfying query
   */
  findVersions = async <TSlug extends CollectionSlug>(
    options: FindVersionsOptions<TSlug>,
  ): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<TSlug>>>> => {
    const { findVersions } = localOperations
    return findVersions<TSlug>(this, options)
  }

  forgotPassword = async <TSlug extends CollectionSlug>(
    options: ForgotPasswordOptions<TSlug>,
  ): Promise<ForgotPasswordResult> => {
    const { forgotPassword } = localOperations.auth
    return forgotPassword<TSlug>(this, options)
  }

  getAdminURL = (): string => `${this.config.serverURL}${this.config.routes.admin}`

  getAPIURL = (): string => `${this.config.serverURL}${this.config.routes.api}`

  globals: Globals

  importMap: ImportMap

  jobs = getJobsLocalAPI(this)

  logger: Logger

  login = async <TSlug extends CollectionSlug>(
    options: LoginOptions<TSlug>,
  ): Promise<{ user: DataFromCollectionSlug<TSlug> } & LoginResult> => {
    const { login } = localOperations.auth
    return login<TSlug>(this, options)
  }

  resetPassword = async <TSlug extends CollectionSlug>(
    options: ResetPasswordOptions<TSlug>,
  ): Promise<ResetPasswordResult> => {
    const { resetPassword } = localOperations.auth
    return resetPassword<TSlug>(this, options)
  }

  /**
   * @description Restore global version by ID
   * @param options
   * @returns version with specified ID
   */
  restoreGlobalVersion = async <TSlug extends GlobalSlug>(
    options: RestoreGlobalVersionOptions<TSlug>,
  ): Promise<DataFromGlobalSlug<TSlug>> => {
    const { restoreVersion } = localGlobalOperations
    return restoreVersion<TSlug>(this, options)
  }

  /**
   * @description Restore version by ID
   * @param options
   * @returns version with specified ID
   */
  restoreVersion = async <TSlug extends CollectionSlug>(
    options: RestoreVersionOptions<TSlug>,
  ): Promise<DataFromCollectionSlug<TSlug>> => {
    const { restoreVersion } = localOperations
    return restoreVersion<TSlug>(this, options)
  }

  schema: GraphQLSchema

  secret: string

  sendEmail: InitializedEmailAdapter['sendEmail']

  types: {
    arrayTypes: any
    blockInputTypes: any
    blockTypes: any
    fallbackLocaleInputType?: any
    groupTypes: any
    localeInputType?: any
    tabTypes: any
  }

  unlock = async <TSlug extends CollectionSlug>(
    options: UnlockOptions<TSlug>,
  ): Promise<boolean> => {
    const { unlock } = localOperations.auth
    return unlock<TSlug>(this, options)
  }

  updateGlobal = async <TSlug extends GlobalSlug, TSelect extends SelectFromGlobalSlug<TSlug>>(
    options: UpdateGlobalOptions<TSlug, TSelect>,
  ): Promise<TransformGlobalWithSelect<TSlug, TSelect>> => {
    const { update } = localGlobalOperations
    return update<TSlug, TSelect>(this, options)
  }

  validationRules: (args: OperationArgs<any>) => ValidationRule[]

  verifyEmail = async <TSlug extends CollectionSlug>(
    options: VerifyEmailOptions<TSlug>,
  ): Promise<boolean> => {
    const { verifyEmail } = localOperations.auth
    return verifyEmail(this, options)
  }

  versions: {
    [slug: string]: any // TODO: Type this
  } = {}

  async bin({
    args,
    cwd,
    log,
  }: {
    args: string[]
    cwd?: string
    log?: boolean
  }): Promise<{ code: number }> {
    return new Promise((resolve, reject) => {
      const spawned = spawn('node', [path.resolve(dirname, '../bin.js'), ...args], {
        cwd,
        stdio: log || log === undefined ? 'inherit' : 'ignore',
      })

      spawned.on('exit', (code) => {
        resolve({ code })
      })

      spawned.on('error', (error) => {
        reject(error)
      })
    })
  }

  /**
   * @description delete one or more documents
   * @param options
   * @returns Updated document(s)
   */
  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: DeleteByIDOptions<TSlug, TSelect>,
  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>

  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: DeleteManyOptions<TSlug, TSelect>,
  ): Promise<BulkOperationResult<TSlug, TSelect>>

  delete<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: DeleteOptions<TSlug, TSelect>,
  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
    const { deleteLocal } = localOperations
    return deleteLocal<TSlug, TSelect>(this, options)
  }

  /**
   * @description Initializes Payload
   * @param options
   */
  async init(options: InitOptions): Promise<Payload> {
    if (
      process.env.NODE_ENV !== 'production' &&
      process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&
      !checkedDependencies
    ) {
      checkedDependencies = true
      void checkPayloadDependencies()
    }

    this.importMap = options.importMap

    if (!options?.config) {
      throw new Error('Error: the payload config is required to initialize payload.')
    }

    this.config = await options.config
    this.logger = getLogger('payload', this.config.logger)

    if (!this.config.secret) {
      throw new Error('Error: missing secret key. A secret key is needed to secure Payload.')
    }

    this.secret = crypto.createHash('sha256').update(this.config.secret).digest('hex').slice(0, 32)

    this.globals = {
      config: this.config.globals,
    }

    for (const collection of this.config.collections) {
      let customIDType = undefined
      const findCustomID: TraverseFieldsCallback = ({ field }) => {
        if (
          ['array', 'blocks', 'group'].includes(field.type) ||
          (field.type === 'tab' && 'name' in field)
        ) {
          return true
        }

        if (!fieldAffectsData(field)) {
          return
        }

        if (field.name === 'id') {
          customIDType = field.type
          return true
        }
      }

      traverseFields({
        callback: findCustomID,
        config: this.config,
        fields: collection.fields,
        parentIsLocalized: false,
      })

      this.collections[collection.slug] = {
        config: collection,
        customIDType,
      }
    }

    this.blocks = this.config.blocks.reduce((blocks, block) => {
      blocks[block.slug] = block
      return blocks
    }, {})

    // Generate types on startup
    if (process.env.NODE_ENV !== 'production' && this.config.typescript.autoGenerate !== false) {
      // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.
      // see: https://github.com/vercel/next.js/issues/66723
      void this.bin({
        args: ['generate:types'],
        log: false,
      })
    }

    this.db = this.config.db.init({ payload: this })
    this.db.payload = this

    if (this.db?.init) {
      await this.db.init()
    }

    if (!options.disableDBConnect && this.db.connect) {
      await this.db.connect()
    }

    // Load email adapter
    if (this.config.email instanceof Promise) {
      const awaitedAdapter = await this.config.email
      this.email = awaitedAdapter({ payload: this })
    } else if (this.config.email) {
      this.email = this.config.email({ payload: this })
    } else {
      if (process.env.NEXT_PHASE !== 'phase-production-build') {
        this.logger.warn(
          `No email adapter provided. Email will be written to console. More info at https://payloadcms.com/docs/email/overview.`,
        )
      }

      this.email = consoleEmailAdapter({ payload: this })
    }

    // Warn if image resizing is enabled but sharp is not installed
    if (
      !this.config.sharp &&
      this.config.collections.some((c) => c.upload.imageSizes || c.upload.formatOptions)
    ) {
      this.logger.warn(
        `Image resizing is enabled for one or more collections, but sharp not installed. Please install 'sharp' and pass into the config.`,
      )
    }

    // Warn if user is deploying to Vercel, and any upload collection is missing a storage adapter
    if (process.env.VERCEL) {
      const uploadCollWithoutAdapter = this.config.collections.filter(
        (c) => c.upload && c.upload.adapter === undefined, // Uploads enabled, but no storage adapter provided
      )

      if (uploadCollWithoutAdapter.length) {
        const slugs = uploadCollWithoutAdapter.map((c) => c.slug).join(', ')
        this.logger.warn(
          `Collections with uploads enabled require a storage adapter when deploying to Vercel. Collection(s) without storage adapters: ${slugs}. See https://payloadcms.com/docs/upload/storage-adapters for more info.`,
        )
      }
    }

    this.sendEmail = this.email['sendEmail']

    serverInitTelemetry(this)

    // 1. loop over collections, if collection has auth strategy, initialize and push to array
    let jwtStrategyEnabled = false
    this.authStrategies = this.config.collections.reduce((authStrategies, collection) => {
      if (collection?.auth) {
        if (collection.auth.strategies.length > 0) {
          authStrategies.push(...collection.auth.strategies)
        }

        // 2. if api key enabled, push api key strategy into the array
        if (collection.auth?.useAPIKey) {
          authStrategies.push({
            name: `${collection.slug}-api-key`,
            authenticate: APIKeyAuthentication(collection),
          })
        }

        // 3. if localStrategy flag is true
        if (!collection.auth.disableLocalStrategy && !jwtStrategyEnabled) {
          jwtStrategyEnabled = true
        }
      }

      return authStrategies
    }, [] as AuthStrategy[])

    // 4. if enabled, push jwt strategy into authStrategies last
    if (jwtStrategyEnabled) {
      this.authStrategies.push({
        name: 'local-jwt',
        authenticate: JWTAuthentication,
      })
    }

    try {
      if (!options.disableOnInit) {
        if (typeof options.onInit === 'function') {
          await options.onInit(this)
        }
        if (typeof this.config.onInit === 'function') {
          await this.config.onInit(this)
        }
      }
    } catch (error) {
      this.logger.error({ err: error }, 'Error running onInit function')
      throw error
    }

    if (this.config.jobs.autoRun && !isNextBuild()) {
      const DEFAULT_CRON = '* * * * *'
      const DEFAULT_LIMIT = 10

      const cronJobs =
        typeof this.config.jobs.autoRun === 'function'
          ? await this.config.jobs.autoRun(this)
          : this.config.jobs.autoRun

      await Promise.all(
        cronJobs.map((cronConfig) => {
          const job = new Cron(cronConfig.cron ?? DEFAULT_CRON, async () => {
            if (typeof this.config.jobs.shouldAutoRun === 'function') {
              const shouldAutoRun = await this.config.jobs.shouldAutoRun(this)

              if (!shouldAutoRun) {
                job.stop()

                return false
              }
            }

            await this.jobs.run({
              limit: cronConfig.limit ?? DEFAULT_LIMIT,
              queue: cronConfig.queue,
            })
          })
        }),
      )
    }

    return this
  }

  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: UpdateManyOptions<TSlug, TSelect>,
  ): Promise<BulkOperationResult<TSlug, TSelect>>

  /**
   * @description Update one or more documents
   * @param options
   * @returns Updated document(s)
   */
  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: UpdateByIDOptions<TSlug, TSelect>,
  ): Promise<TransformCollectionWithSelect<TSlug, TSelect>>

  update<TSlug extends CollectionSlug, TSelect extends SelectFromCollectionSlug<TSlug>>(
    options: UpdateOptions<TSlug, TSelect>,
  ): Promise<BulkOperationResult<TSlug, TSelect> | TransformCollectionWithSelect<TSlug, TSelect>> {
    const { update } = localOperations
    return update<TSlug, TSelect>(this, options)
  }
}

const initialized = new BasePayload()

export default initialized

let cached: {
  payload: null | Payload
  promise: null | Promise<Payload>
  reload: boolean | Promise<void>
  ws: null | WebSocket
} = global._payload

if (!cached) {
  cached = global._payload = { payload: null, promise: null, reload: false, ws: null }
}

export const reload = async (
  config: SanitizedConfig,
  payload: Payload,
  skipImportMapGeneration?: boolean,
): Promise<void> => {
  if (typeof payload.db.destroy === 'function') {
    await payload.db.destroy()
  }

  payload.config = config

  payload.collections = config.collections.reduce((collections, collection) => {
    collections[collection.slug] = {
      config: collection,
      customIDType: payload.collections[collection.slug]?.customIDType,
    }
    return collections
  }, {})

  payload.blocks = config.blocks.reduce((blocks, block) => {
    blocks[block.slug] = block
    return blocks
  }, {})

  payload.globals = {
    config: config.globals,
  }

  // TODO: support HMR for other props in the future (see payload/src/index init()) that may change on Payload singleton

  // Generate types
  if (config.typescript.autoGenerate !== false) {
    // We cannot run it directly here, as generate-types imports json-schema-to-typescript, which breaks on turbopack.
    // see: https://github.com/vercel/next.js/issues/66723
    void payload.bin({
      args: ['generate:types'],
      log: false,
    })
  }

  // Generate component map
  if (skipImportMapGeneration !== true && config.admin?.importMap?.autoGenerate !== false) {
    await generateImportMap(config, {
      log: true,
    })
  }

  await payload.db.init()

  if (payload.db.connect) {
    await payload.db.connect({ hotReload: true })
  }

  global._payload_clientConfigs = {} as Record<keyof SupportedLanguages, ClientConfig>
  global._payload_schemaMap = null
  global._payload_clientSchemaMap = null
  global._payload_doNotCacheClientConfig = true // This will help refreshing the client config cache more reliably. If you remove this, please test HMR + client config refreshing (do new fields appear in the document?)
  global._payload_doNotCacheSchemaMap = true
  global._payload_doNotCacheClientSchemaMap = true
}

export const getPayload = async (
  options: Pick<InitOptions, 'config' | 'importMap'>,
): Promise<Payload> => {
  if (!options?.config) {
    throw new Error('Error: the payload config is required for getPayload to work.')
  }

  if (cached.payload) {
    if (cached.reload === true) {
      let resolve: () => void

      // getPayload is called multiple times, in parallel. However, we only want to run `await reload` once. By immediately setting cached.reload to a promise,
      // we can ensure that all subsequent calls will wait for the first reload to finish. So if we set it here, the 2nd call of getPayload
      // will reach `if (cached.reload instanceof Promise) {` which then waits for the first reload to finish.
      cached.reload = new Promise((res) => (resolve = res))
      const config = await options.config
      await reload(config, cached.payload, !options.importMap)

      resolve()
    }

    if (cached.reload instanceof Promise) {
      await cached.reload
    }
    if (options?.importMap) {
      cached.payload.importMap = options.importMap
    }
    return cached.payload
  }

  // eslint-disable-next-line @typescript-eslint/no-misused-promises
  if (!cached.promise) {
    // no need to await options.config here, as it's already awaited in the BasePayload.init
    cached.promise = new BasePayload().init(options)
  }

  try {
    cached.payload = await cached.promise

    if (
      !cached.ws &&
      process.env.NODE_ENV !== 'production' &&
      process.env.NODE_ENV !== 'test' &&
      process.env.DISABLE_PAYLOAD_HMR !== 'true'
    ) {
      try {
        const port = process.env.PORT || '3000'

        const path = '/_next/webpack-hmr'
        // The __NEXT_ASSET_PREFIX env variable is set for both assetPrefix and basePath (tested in Next.js 15.1.6)
        const prefix = process.env.__NEXT_ASSET_PREFIX ?? ''

        cached.ws = new WebSocket(
          process.env.PAYLOAD_HMR_URL_OVERRIDE ?? `ws://localhost:${port}${prefix}${path}`,
        )

        cached.ws.onmessage = (event) => {
          if (typeof event.data === 'string') {
            const data = JSON.parse(event.data)

            if ('action' in data && data.action === 'serverComponentChanges') {
              cached.reload = true
            }
          }
        }

        cached.ws.onerror = (_) => {
          // swallow any websocket connection error
        }
      } catch (_) {
        // swallow e
      }
    }
  } catch (e) {
    cached.promise = null
    // add identifier to error object, so that our error logger in routeError.ts does not attempt to re-initialize getPayload
    e.payloadInitError = true
    throw e
  }

  if (options?.importMap) {
    cached.payload.importMap = options.importMap
  }

  return cached.payload
}

type Payload = BasePayload

interface RequestContext {
  [key: string]: unknown
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface DatabaseAdapter extends BaseDatabaseAdapter {}
export type { Payload, RequestContext }
export { extractAccessFromPermission } from './auth/extractAccessFromPermission.js'
export { getAccessResults } from './auth/getAccessResults.js'
export { getFieldsToSign } from './auth/getFieldsToSign.js'
export * from './auth/index.js'
export { accessOperation } from './auth/operations/access.js'
export { forgotPasswordOperation } from './auth/operations/forgotPassword.js'
export { initOperation } from './auth/operations/init.js'
export { loginOperation } from './auth/operations/login.js'
export { logoutOperation } from './auth/operations/logout.js'
export type { MeOperationResult } from './auth/operations/me.js'
export { meOperation } from './auth/operations/me.js'
export { refreshOperation } from './auth/operations/refresh.js'
export { registerFirstUserOperation } from './auth/operations/registerFirstUser.js'
export { resetPasswordOperation } from './auth/operations/resetPassword.js'
export { unlockOperation } from './auth/operations/unlock.js'
export { verifyEmailOperation } from './auth/operations/verifyEmail.js'
export { JWTAuthentication } from './auth/strategies/jwt.js'
export type {
  AuthStrategyFunction,
  AuthStrategyFunctionArgs,
  AuthStrategyResult,
  CollectionPermission,
  DocumentPermissions,
  FieldPermissions,
  GlobalPermission,
  IncomingAuthType,
  Permission,
  Permissions,
  SanitizedCollectionPermission,
  SanitizedDocumentPermissions,
  SanitizedFieldPermissions,
  SanitizedGlobalPermission,
  SanitizedPermissions,
  User,
  VerifyConfig,
} from './auth/types.js'
export { generateImportMap } from './bin/generateImportMap/index.js'

export type { ImportMap } from './bin/generateImportMap/index.js'
export { genImportMapIterateFields } from './bin/generateImportMap/iterateFields.js'
export {
  type ClientCollectionConfig,
  createClientCollectionConfig,
  createClientCollectionConfigs,
  type ServerOnlyCollectionAdminProperties,
  type ServerOnlyCollectionProperties,
  type ServerOnlyUploadProperties,
} from './collections/config/client.js'

export type {
  AfterChangeHook as CollectionAfterChangeHook,
  AfterDeleteHook as CollectionAfterDeleteHook,
  AfterErrorHook as CollectionAfterErrorHook,
  AfterForgotPasswordHook as CollectionAfterForgotPasswordHook,
  AfterLoginHook as CollectionAfterLoginHook,
  AfterLogoutHook as CollectionAfterLogoutHook,
  AfterMeHook as CollectionAfterMeHook,
  AfterOperationHook as CollectionAfterOperationHook,
  AfterReadHook as CollectionAfterReadHook,
  AfterRefreshHook as CollectionAfterRefreshHook,
  AuthCollection,
  AuthOperationsFromCollectionSlug,
  BaseListFilter,
  BeforeChangeHook as CollectionBeforeChangeHook,
  BeforeDeleteHook as CollectionBeforeDeleteHook,
  BeforeLoginHook as CollectionBeforeLoginHook,
  BeforeOperationHook as CollectionBeforeOperationHook,
  BeforeReadHook as CollectionBeforeReadHook,
  BeforeValidateHook as CollectionBeforeValidateHook,
  BulkOperationResult,
  Collection,
  CollectionAdminOptions,
  CollectionConfig,
  DataFromCollectionSlug,
  HookOperationType,
  MeHook as CollectionMeHook,
  RefreshHook as CollectionRefreshHook,
  RequiredDataFromCollection,
  RequiredDataFromCollectionSlug,
  SanitizedCollectionConfig,
  SanitizedJoins,
  TypeWithID,
  TypeWithTimestamps,
} from './collections/config/types.js'

export type { CompoundIndex } from './collections/config/types.js'

export type { SanitizedCompoundIndex } from './collections/config/types.js'
export { createDataloaderCacheKey, getDataLoader } from './collections/dataloader.js'
export { countOperation } from './collections/operations/count.js'
export { createOperation } from './collections/operations/create.js'
export { deleteOperation } from './collections/operations/delete.js'
export { deleteByIDOperation } from './collections/operations/deleteByID.js'
export { docAccessOperation } from './collections/operations/docAccess.js'
export { duplicateOperation } from './collections/operations/duplicate.js'
export { findOperation } from './collections/operations/find.js'
export { findByIDOperation } from './collections/operations/findByID.js'
export { findVersionByIDOperation } from './collections/operations/findVersionByID.js'
export { findVersionsOperation } from './collections/operations/findVersions.js'
export { restoreVersionOperation } from './collections/operations/restoreVersion.js'
export { updateOperation } from './collections/operations/update.js'
export { updateByIDOperation } from './collections/operations/updateByID.js'
export { buildConfig } from './config/build.js'

export {
  type ClientConfig,
  createClientConfig,
  serverOnlyAdminConfigProperties,
  serverOnlyConfigProperties,
  type UnsanitizedClientConfig,
} from './config/client.js'

export { defaults } from './config/defaults.js'
export { type OrderableEndpointBody } from './config/orderable/index.js'
export { sanitizeConfig } from './config/sanitize.js'
export type * from './config/types.js'
export { combineQueries } from './database/combineQueries.js'
export { createDatabaseAdapter } from './database/createDatabaseAdapter.js'
export { defaultBeginTransaction } from './database/defaultBeginTransaction.js'
export { flattenWhereToOperators } from './database/flattenWhereToOperators.js'
export { getLocalizedPaths } from './database/getLocalizedPaths.js'
export { createMigration } from './database/migrations/createMigration.js'
export { getMigrations } from './database/migrations/getMigrations.js'
export { getPredefinedMigration } from './database/migrations/getPredefinedMigration.js'
export { migrate } from './database/migrations/migrate.js'
export { migrateDown } from './database/migrations/migrateDown.js'
export { migrateRefresh } from './database/migrations/migrateRefresh.js'
export { migrateReset } from './database/migrations/migrateReset.js'
export { migrateStatus } from './database/migrations/migrateStatus.js'
export { migrationsCollection } from './database/migrations/migrationsCollection.js'
export { migrationTemplate } from './database/migrations/migrationTemplate.js'
export { readMigrationFiles } from './database/migrations/readMigrationFiles.js'
export { writeMigrationIndex } from './database/migrations/writeMigrationIndex.js'
export type * from './database/queryValidation/types.js'
export type { EntityPolicies, PathToQuery } from './database/queryValidation/types.js'
export { validateQueryPaths } from './database/queryValidation/validateQueryPaths.js'
export { validateSearchParam } from './database/queryValidation/validateSearchParams.js'
export type {
  BaseDatabaseAdapter,
  BeginTransaction,
  CommitTransaction,
  Connect,
  Count,
  CountArgs,
  CountGlobalVersionArgs,
  CountGlobalVersions,
  CountVersions,
  Create,
  CreateArgs,
  CreateGlobal,
  CreateGlobalArgs,
  CreateGlobalVersion,
  CreateGlobalVersionArgs,
  CreateMigration,
  CreateVersion,
  CreateVersionArgs,
  DatabaseAdapterResult as DatabaseAdapterObj,
  DBIdentifierName,
  DeleteMany,
  DeleteManyArgs,
  DeleteOne,
  DeleteOneArgs,
  DeleteVersions,
  DeleteVersionsArgs,
  Destroy,
  Find,
  FindArgs,
  FindGlobal,
  FindGlobalArgs,
  FindGlobalVersions,
  FindGlobalVersionsArgs,
  FindOne,
  FindOneArgs,
  FindVersions,
  FindVersionsArgs,
  GenerateSchema,
  Init,
  Migration,
  MigrationData,
  MigrationTemplateArgs,
  PaginatedDocs,
  QueryDrafts,
  QueryDraftsArgs,
  RollbackTransaction,
  Transaction,
  UpdateGlobal,
  UpdateGlobalArgs,
  UpdateGlobalVersion,
  UpdateGlobalVersionArgs,
  UpdateJobs,
  UpdateJobsArgs,
  UpdateMany,
  UpdateManyArgs,
  UpdateOne,
  UpdateOneArgs,
  UpdateVersion,
  UpdateVersionArgs,
  Upsert,
  UpsertArgs,
} from './database/types.js'
export type { EmailAdapter as PayloadEmailAdapter, SendEmailOptions } from './email/types.js'
export {
  APIError,
  APIErrorName,
  AuthenticationError,
  DuplicateCollection,
  DuplicateFieldName,
  DuplicateGlobal,
  ErrorDeletingFile,
  FileRetrievalError,
  FileUploadError,
  Forbidden,
  InvalidConfiguration,
  InvalidFieldName,
  InvalidFieldRelationship,
  Locked,
  LockedAuth,
  MissingCollectionLabel,
  MissingEditorProp,
  MissingFieldInputOptions,
  MissingFieldType,
  MissingFile,
  NotFound,
  QueryError,
  ValidationError,
  ValidationErrorName,
} from './errors/index.js'
export type { ValidationFieldError } from './errors/index.js'

export { baseBlockFields } from './fields/baseFields/baseBlockFields.js'
export { baseIDField } from './fields/baseFields/baseIDField.js'
export {
  createClientField,
  createClientFields,
  type ServerOnlyFieldAdminProperties,
  type ServerOnlyFieldProperties,
} from './fields/config/client.js'

export { sanitizeFields } from './fields/config/sanitize.js'
export type {
  AdminClient,
  ArrayField,
  ArrayFieldClient,
  BaseValidateOptions,
  Block,
  BlockJSX,
  BlocksField,
  BlocksFieldClient,
  CheckboxField,
  CheckboxFieldClient,
  ClientBlock,
  ClientField,
  ClientFieldProps,
  CodeField,
  CodeFieldClient,
  CollapsibleField,
  CollapsibleFieldClient,
  Condition,
  DateField,
  DateFieldClient,
  EmailField,
  EmailFieldClient,
  Field,
  FieldAccess,
  FieldAffectingData,
  FieldAffectingDataClient,
  FieldBase,
  FieldBaseClient,
  FieldHook,
  FieldHookArgs,
  FieldPresentationalOnly,
  FieldPresentationalOnlyClient,
  FieldTypes,
  FieldWithMany,
  FieldWithManyClient,
  FieldWithMaxDepth,
  FieldWithMaxDepthClient,
  FieldWithPath,
  FieldWithPathClient,
  FieldWithSubFields,
  FieldWithSubFieldsClient,
  FilterOptions,
  FilterOptionsProps,
  FlattenedArrayField,
  FlattenedBlock,
  FlattenedBlocksField,
  FlattenedField,
  FlattenedGroupField,
  FlattenedJoinField,
  FlattenedTabAsField,
  GroupField,
  GroupFieldClient,
  HookName,
  JoinField,
  JoinFieldClient,
  JSONField,
  JSONFieldClient,
  Labels,
  LabelsClient,
  NamedTab,
  NonPresentationalField,
  NonPresentationalFieldClient,
  NumberField,
  NumberFieldClient,
  Option,
  OptionLabel,
  OptionObject,
  PointField,
  PointFieldClient,
  PolymorphicRelationshipField,
  PolymorphicRelationshipFieldClient,
  RadioField,
  RadioFieldClient,
  RelationshipField,
  RelationshipFieldClient,
  RelationshipValue,
  RichTextField,
  RichTextFieldClient,
  RowField,
  RowFieldClient,
  SelectField,
  SelectFieldClient,
  SingleRelationshipField,
  SingleRelationshipFieldClient,
  Tab,
  TabAsField,
  TabAsFieldClient,
  TabsField,
  TabsFieldClient,
  TextareaField,
  TextareaFieldClient,
  TextField,
  TextFieldClient,
  UIField,
  UIFieldClient,
  UnnamedTab,
  UploadField,
  UploadFieldClient,
  Validate,
  ValidateOptions,
  ValueWithRelation,
} from './fields/config/types.js'

export { getDefaultValue } from './fields/getDefaultValue.js'

export { traverseFields as afterChangeTraverseFields } from './fields/hooks/afterChange/traverseFields.js'
export { promise as afterReadPromise } from './fields/hooks/afterRead/promise.js'
export { traverseFields as afterReadTraverseFields } from './fields/hooks/afterRead/traverseFields.js'
export { traverseFields as beforeChangeTraverseFields } from './fields/hooks/beforeChange/traverseFields.js'
export { traverseFields as beforeValidateTraverseFields } from './fields/hooks/beforeValidate/traverseFields.js'
export { default as sortableFieldTypes } from './fields/sortableFieldTypes.js'

export { validations } from './fields/validations.js'
export type {
  ArrayFieldValidation,
  BlocksFieldValidation,
  CheckboxFieldValidation,
  CodeFieldValidation,
  ConfirmPasswordFieldValidation,
  DateFieldValidation,
  EmailFieldValidation,
  JSONFieldValidation,
  NumberFieldManyValidation,
  NumberFieldSingleValidation,
  NumberFieldValidation,
  PasswordFieldValidation,
  PointFieldValidation,
  RadioFieldValidation,
  RelationshipFieldManyValidation,
  RelationshipFieldSingleValidation,
  RelationshipFieldValidation,
  RichTextFieldValidation,
  SelectFieldManyValidation,
  SelectFieldSingleValidation,
  SelectFieldValidation,
  TextareaFieldValidation,
  TextFieldManyValidation,
  TextFieldSingleValidation,
  TextFieldValidation,
  UploadFieldManyValidation,
  UploadFieldSingleValidation,
  UploadFieldValidation,
  UsernameFieldValidation,
} from './fields/validations.js'
export {
  type ClientGlobalConfig,
  createClientGlobalConfig,
  createClientGlobalConfigs,
  type ServerOnlyGlobalAdminProperties,
  type ServerOnlyGlobalProperties,
} from './globals/config/client.js'

export type {
  AfterChangeHook as GlobalAfterChangeHook,
  AfterReadHook as GlobalAfterReadHook,
  BeforeChangeHook as GlobalBeforeChangeHook,
  BeforeReadHook as GlobalBeforeReadHook,
  BeforeValidateHook as GlobalBeforeValidateHook,
  DataFromGlobalSlug,
  GlobalAdminOptions,
  GlobalConfig,
  SanitizedGlobalConfig,
} from './globals/config/types.js'

export { docAccessOperation as docAccessOperationGlobal } from './globals/operations/docAccess.js'

export { findOneOperation } from './globals/operations/findOne.js'
export { findVersionByIDOperation as findVersionByIDOperationGlobal } from './globals/operations/findVersionByID.js'
export { findVersionsOperation as findVersionsOperationGlobal } from './globals/operations/findVersions.js'
export { restoreVersionOperation as restoreVersionOperationGlobal } from './globals/operations/restoreVersion.js'
export { updateOperation as updateOperationGlobal } from './globals/operations/update.js'
export type {
  CollapsedPreferences,
  ColumnPreference,
  DocumentPreferences,
  FieldsPreferences,
  InsideFieldsPreferences,
  ListPreferences,
  PreferenceRequest,
  PreferenceUpdateRequest,
  TabsPreferences,
} from './preferences/types.js'
export type { QueryPreset } from './query-presets/types.js'
export { jobAfterRead } from './queues/config/index.js'
export type { JobsConfig, RunJobAccess, RunJobAccessArgs } from './queues/config/types/index.js'

export type {
  RunInlineTaskFunction,
  RunTaskFunction,
  RunTaskFunctions,
  TaskConfig,
  TaskHandler,
  TaskHandlerArgs,
  TaskHandlerResult,
  TaskHandlerResults,
  TaskInput,
  TaskOutput,
  TaskType,
} from './queues/config/types/taskTypes.js'
export type {
  BaseJob,
  JobLog,
  JobTaskStatus,
  RunningJob,
  SingleTaskStatus,
  WorkflowConfig,
  WorkflowHandler,
  WorkflowTypes,
} from './queues/config/types/workflowTypes.js'
export { importHandlerPath } from './queues/operations/runJobs/runJob/importHandlerPath.js'
export { getLocalI18n } from './translations/getLocalI18n.js'
export * from './types/index.js'
export { getFileByPath } from './uploads/getFileByPath.js'
export type * from './uploads/types.js'

export { addDataAndFileToRequest } from './utilities/addDataAndFileToRequest.js'

export { addLocalesToRequestFromData, sanitizeLocales } from './utilities/addLocalesToRequest.js'
export { commitTransaction } from './utilities/commitTransaction.js'
export {
  configToJSONSchema,
  entityToJSONSchema,
  fieldsToJSONSchema,
  withNullableJSONSchemaType,
} from './utilities/configToJSONSchema.js'
export { createArrayFromCommaDelineated } from './utilities/createArrayFromCommaDelineated.js'
export { createLocalReq } from './utilities/createLocalReq.js'
export { createPayloadRequest } from './utilities/createPayloadRequest.js'
export {
  deepCopyObject,
  deepCopyObjectComplex,
  deepCopyObjectSimple,
} from './utilities/deepCopyObject.js'
export {
  deepMerge,
  deepMergeWithCombinedArrays,
  deepMergeWithReactComponents,
  deepMergeWithSourceArrays,
} from './utilities/deepMerge.js'
export {
  checkDependencies,
  type CustomVersionParser,
} from './utilities/dependencies/dependencyChecker.js'
export { getDependencies } from './utilities/dependencies/getDependencies.js'
export type { FieldSchemaJSON } from './utilities/fieldSchemaToJSON.js'
export {
  findUp,
  findUpSync,
  pathExistsAndIsAccessible,
  pathExistsAndIsAccessibleSync,
} from './utilities/findUp.js'
export { flattenAllFields } from './utilities/flattenAllFields.js'
export { default as flattenTopLevelFields } from './utilities/flattenTopLevelFields.js'
export { formatErrors } from './utilities/formatErrors.js'
export { formatLabels, formatNames, toWords } from './utilities/formatLabels.js'
export { getBlockSelect } from './utilities/getBlockSelect.js'
export { getCollectionIDFieldTypes } from './utilities/getCollectionIDFieldTypes.js'
export { getFieldByPath } from './utilities/getFieldByPath.js'
export { getObjectDotNotation } from './utilities/getObjectDotNotation.js'
export { getRequestLanguage } from './utilities/getRequestLanguage.js'
export { handleEndpoints } from './utilities/handleEndpoints.js'
export { headersWithCors } from './utilities/headersWithCors.js'
export { initTransaction } from './utilities/initTransaction.js'
export { isEntityHidden } from './utilities/isEntityHidden.js'
export { default as isolateObjectProperty } from './utilities/isolateObjectProperty.js'
export { isPlainObject } from './utilities/isPlainObject.js'
export { isValidID } from './utilities/isValidID.js'
export { killTransaction } from './utilities/killTransaction.js'
export { logError } from './utilities/logError.js'
export { defaultLoggerOptions } from './utilities/logger.js'
export { mapAsync } from './utilities/mapAsync.js'
export { mergeHeaders } from './utilities/mergeHeaders.js'
export { sanitizeFallbackLocale } from './utilities/sanitizeFallbackLocale.js'
export { sanitizeJoinParams } from './utilities/sanitizeJoinParams.js'
export { sanitizePopulateParam } from './utilities/sanitizePopulateParam.js'
export { sanitizeSelectParam } from './utilities/sanitizeSelectParam.js'
export { stripUnselectedFields } from './utilities/stripUnselectedFields.js'
export { traverseFields } from './utilities/traverseFields.js'
export type { TraverseFieldsCallback } from './utilities/traverseFields.js'
export { buildVersionCollectionFields } from './versions/buildCollectionFields.js'
export { buildVersionGlobalFields } from './versions/buildGlobalFields.js'
export { buildVersionCompoundIndexes } from './versions/buildVersionCompoundIndexes.js'
export { versionDefaults } from './versions/defaults.js'
export { deleteCollectionVersions } from './versions/deleteCollectionVersions.js'
export { appendVersionToQueryKey } from './versions/drafts/appendVersionToQueryKey.js'
export { getQueryDraftsSort } from './versions/drafts/getQueryDraftsSort.js'
export { enforceMaxVersions } from './versions/enforceMaxVersions.js'
export { getLatestCollectionVersion } from './versions/getLatestCollectionVersion.js'
export { getLatestGlobalVersion } from './versions/getLatestGlobalVersion.js'
export { saveVersion } from './versions/saveVersion.js'
export type { SchedulePublishTaskInput } from './versions/schedule/types.js'
export type { SchedulePublish, TypeWithVersion } from './versions/types.js'
export { deepMergeSimple } from '@convexcms/translations/utilities'
</file>

<file path="packages/payload/.prettierignore">
.tmp
**/.git
**/.hg
**/.pnp.*
**/.svn
**/.yarn/**
**/build
**/dist/**
**/node_modules
**/temp
</file>

<file path="packages/payload/.swcrc">
{
  "$schema": "https://json.schemastore.org/swcrc",
  "sourceMaps": true,
  "jsc": {
    "target": "esnext",
    "parser": {
      "syntax": "typescript",
      "tsx": true,
      "dts": true
    },
    "transform": {
      "react": {
        "runtime": "automatic",
        "pragmaFrag": "React.Fragment",
        "throwIfNamespace": true,
        "development": false,
        "useBuiltins": true
      }
    }
  },
  "module": {
    "type": "es6"
  }
}
</file>

<file path="packages/payload/bin.js">
#!/usr/bin/env node

import path from 'node:path'
import { fileURLToPath, pathToFileURL } from 'node:url'

const useSwc = process.argv.includes('--use-swc')
const disableTranspile = process.argv.includes('--disable-transpile')

if (disableTranspile) {
  // Remove --disable-transpile from arguments
  process.argv = process.argv.filter((arg) => arg !== '--disable-transpile')

  const start = async () => {
    const { bin } = await import('./dist/bin/index.js')
    await bin()
  }

  void start()
} else {
  const filename = fileURLToPath(import.meta.url)
  const dirname = path.dirname(filename)
  const url = pathToFileURL(dirname).toString() + '/'

  if (!useSwc) {
    const start = async () => {
      // Use tsx
      let tsImport = (await import('tsx/esm/api')).tsImport

      const { bin } = await tsImport('./dist/bin/index.js', url)
      await bin()
    }

    void start()
  } else if (useSwc) {
    const { register } = await import('node:module')
    // Remove --use-swc from arguments
    process.argv = process.argv.filter((arg) => arg !== '--use-swc')

    try {
      register('@swc-node/register/esm', url)
    } catch (_) {
      console.error(
        '@swc-node/register is not installed. Please install @swc-node/register in your project, if you want to use swc in payload run.',
      )
    }

    const start = async () => {
      const { bin } = await import('./dist/bin/index.js')
      await bin()
    }

    void start()
  }
}
</file>

<file path="packages/payload/bundle.js">
import * as esbuild from 'esbuild'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

async function build() {
  const resultIndex = await esbuild.build({
    entryPoints: ['src/exports/index.ts'],
    bundle: true,
    platform: 'node',
    format: 'esm',
    outfile: 'dist/exports/index.js',
    splitting: false,
    external: [
      'lodash',
      '*.scss',
      '*.css',
      from '@convexcms/translations',
      'memoizee',
      'pino-pretty',
      'pino',
      //'ajv',
      //'image-size',
    ],
    minify: true,
    metafile: true,
    tsconfig: path.resolve(dirname, './tsconfig.json'),
    // plugins: [commonjs()],
    sourcemap: true,
  })
  console.log('payload server bundled successfully')

  const resultShared = await esbuild.build({
    entryPoints: ['src/exports/shared.ts'],
    bundle: true,
    platform: 'node',
    format: 'esm',
    outfile: 'dist/exports/shared.js',
    splitting: false,
    external: [
      'lodash',
      '*.scss',
      '*.css',
      from '@convexcms/translations',
      'memoizee',
      'pino-pretty',
      'pino',
      //'ajv',
      //'image-size',
    ],
    minify: true,
    metafile: true,
    tsconfig: path.resolve(dirname, './tsconfig.json'),
    // plugins: [commonjs()],
    sourcemap: true,
  })
  console.log('payload shared bundled successfully')

  fs.writeFileSync('meta_index.json', JSON.stringify(resultIndex.metafile))
  fs.writeFileSync('meta_shared.json', JSON.stringify(resultShared.metafile))
}

await build()
</file>

<file path="packages/payload/eslint.config.js">
import { rootEslintConfig, rootParserOptions } from '../../eslint.config.js'

/** @typedef {import('eslint').Linter.Config} Config */


/** @type {Config[]} */
export const index = [
  ...rootEslintConfig,
  {
    languageOptions: {
      parserOptions: {
        ...rootParserOptions,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
]

export default index
</file>

<file path="packages/payload/LICENSE.md">
MIT License

Copyright (c) 2018-2025 Payload CMS, Inc. <info@payloadcms.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="packages/payload/package.json">
{
  "name": '@convexcms/core',
  "version": "3.34.0",
  "description": "Node, React, Headless CMS and Application Framework built on Next.js",
  "keywords": [
    "admin panel",
    "api",
    "cms",
    "content management",
    "dashboard",
    "framework",
    "graphQL",
    "headless",
    "javascript",
    "next.js",
    "node",
    '@convexcms/core',
    "react",
    "self hosted",
    "typescript"
  ],
  "homepage": "https://payloadcms.com",
  "bugs": {
    "url": "https://github.com/payloadcms/payload"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/payloadcms/payload.git",
    "directory": "packages/payload"
  },
  "license": "MIT",
  "author": "Payload <dev@payloadcms.com> (https://payloadcms.com)",
  "maintainers": [
    {
      "name": '@convexcms/core',
      "email": "info@payloadcms.com",
      "url": "https://payloadcms.com"
    }
  ],
  "sideEffects": false,
  "type": "module",
  "exports": {
    ".": {
      "import": "./src/index.ts",
      "types": "./src/index.ts",
      "default": "./src/index.ts"
    },
    "./shared": {
      "import": "./src/exports/shared.ts",
      "types": "./src/exports/shared.ts",
      "default": "./src/exports/shared.ts"
    },
    "./node": {
      "import": "./src/exports/node.ts",
      "types": "./src/exports/node.ts",
      "default": "./src/exports/node.ts"
    },
    "./i18n/*": {
      "import": "./src/exports/i18n/*.ts",
      "types": "./src/exports/i18n/*.ts",
      "default": "./src/exports/i18n/*.ts"
    }
  },
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "bin": {
    '@convexcms/core': "bin.js"
  },
  "files": [
    "dist",
    "bin.js"
  ],
  "scripts": {
    "build": "rimraf .dist && rimraf tsconfig.tsbuildinfo && pnpm copyfiles && pnpm build:types && pnpm build:swc && pnpm build:esbuild",
    "build:esbuild": "echo skipping esbuild",
    "build:swc": "swc ./src -d ./dist --config-file .swcrc --strip-leading-paths",
    "build:types": "concurrently --group \"tsc --emitDeclarationOnly --outDir dist\" \"tsc-strict\"",
    "clean": "rimraf -g {dist,*.tsbuildinfo}",
    "clean:cache": "rimraf node_modules/.cache",
    "copyfiles": "copyfiles -u 1 \"src/**/*.{html,ttf,woff,woff2,eot,svg,jpg,png,json}\" dist/",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "prepublishOnly": "pnpm clean && pnpm turbo build",
    "pretest": "pnpm build"
  },
  "dependencies": {
    "@next/env": "^15.1.5",
    "@payloadcms/translations": "workspace:*",
    "@types/busboy": "1.5.4",
    "ajv": "8.17.1",
    "bson-objectid": "2.0.4",
    "busboy": "^1.6.0",
    "ci-info": "^4.1.0",
    "console-table-printer": "2.12.1",
    "croner": "9.0.0",
    "dataloader": "2.2.3",
    "deepmerge": "4.3.1",
    "file-type": "19.3.0",
    "get-tsconfig": "4.8.1",
    "http-status": "2.1.0",
    "image-size": "2.0.2",
    "jose": "5.9.6",
    "json-schema-to-typescript": "15.0.3",
    "minimist": "1.2.8",
    "path-to-regexp": "6.3.0",
    "pino": "9.5.0",
    "pino-pretty": "13.0.0",
    "pluralize": "8.0.0",
    "qs-esm": "7.0.2",
    "sanitize-filename": "1.6.3",
    "scmp": "2.1.0",
    "ts-essentials": "10.0.3",
    "tsx": "4.19.2",
    "uuid": "10.0.0",
    "ws": "^8.16.0"
  },
  "devDependencies": {
    "@hyrious/esbuild-plugin-commonjs": "^0.2.4",
    "@monaco-editor/react": "4.7.0",
    "@payloadcms/eslint-config": "workspace:*",
    "@types/json-schema": "7.0.15",
    "@types/minimist": "1.2.2",
    "@types/nodemailer": "6.4.17",
    "@types/pluralize": "0.0.33",
    "@types/uuid": "10.0.0",
    "@types/ws": "^8.5.10",
    "concurrently": "9.1.2",
    "copyfiles": "2.4.1",
    "cross-env": "7.0.3",
    "esbuild": "0.24.2",
    "graphql-http": "^1.22.0",
    "react-datepicker": "7.6.0",
    "rimraf": "6.0.1",
    "sharp": "0.32.6",
    "typescript-strict-plugin": "2.4.4"
  },
  "peerDependencies": {
    "graphql": "^16.8.1"
  },
  "engines": {
    "node": "^18.20.2 || >=20.9.0"
  },
  "publishConfig": {
    "exports": {
      ".": {
        "import": "./dist/index.js",
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "./node": {
        "import": "./dist/exports/node.js",
        "types": "./dist/exports/node.d.ts",
        "default": "./dist/exports/node.js"
      },
      "./shared": {
        "import": "./dist/exports/shared.js",
        "types": "./dist/exports/shared.d.ts",
        "default": "./dist/exports/shared.js"
      },
      "./i18n/*": {
        "import": "./dist/exports/i18n/*.js",
        "types": "./dist/exports/i18n/*.d.ts",
        "default": "./dist/exports/i18n/*.js"
      }
    },
    "main": "./dist/index.js",
    "registry": "https://registry.npmjs.org/",
    "types": "./dist/index.d.ts"
  }
}
</file>

<file path="packages/payload/README.md">
<a href="https://payloadcms.com"><img width="100%" src="https://l4wlsi8vxy8hre4v.public.blob.vercel-storage.com/github-banner-new-logo.jpg" alt="Payload headless CMS Admin panel built with React" /></a>
<br />
<br />

<p align="left">
  <a href="https://github.com/payloadcms/payload/actions"><img alt="GitHub Workflow Status" src="https://img.shields.io/github/actions/workflow/status/payloadcms/payload/main.yml?style=flat-square"></a>
  &nbsp;
  <a href="https://discord.gg/payload"><img alt="Discord" src="https://img.shields.io/discord/967097582721572934?label=Discord&color=7289da&style=flat-square" /></a>
  &nbsp;
  <a href="https://www.npmjs.com/package/payload"><img alt="npm" src="https://img.shields.io/npm/dw/payload?style=flat-square" /></a>
  &nbsp;
  <a href="https://www.npmjs.com/package/payload"><img alt="npm" src="https://img.shields.io/npm/v/payload?style=flat-square" /></a>
  &nbsp;
  <a href="https://twitter.com/payloadcms"><img src="https://img.shields.io/badge/follow-payloadcms-1DA1F2?logo=twitter&style=flat-square" alt="Payload Twitter" /></a>
</p>
<hr/>
<h4>
<a target="_blank" href="https://payloadcms.com/docs/getting-started/what-is-payload" rel="dofollow"><strong>Explore the Docs</strong></a>&nbsp;·&nbsp;<a target="_blank" href="https://payloadcms.com/community-help" rel="dofollow"><strong>Community Help</strong></a>&nbsp;·&nbsp;<a target="_blank" href="https://github.com/payloadcms/payload/discussions/1539" rel="dofollow"><strong>Roadmap</strong></a>&nbsp;·&nbsp;<a target="_blank" href="https://www.g2.com/products/payload-cms/reviews#reviews" rel="dofollow"><strong>View G2 Reviews</strong></a>
</h4>
<hr/>

> [!IMPORTANT]
> 🎉 <strong>We've released 3.0!</strong> Star this repo or keep an eye on it to follow along.

Payload is the first-ever Next.js native CMS that can install directly in your existing `/app` folder. It's the start of a new era for headless CMS.

<h3>Benefits over a regular CMS</h3>
<ul>
  <li>Deploy anywhere, including serverless on Vercel for free</li>
  <li>Combine your front+backend in the same <code>/app</code> folder if you want</li>
  <li>Don't sign up for yet another SaaS - Payload is open source</li>
  <li>Query your database in React Server Components</li>
  <li>Both admin and backend are 100% extensible</li>
  <li>No vendor lock-in</li>
  <li>Never touch ancient WP code again</li>
  <li>Build faster, never hit a roadblock</li>
</ul>

## Quickstart

Before beginning to work with Payload, make sure you have all of the [required software](https://payloadcms.com/docs/getting-started/installation).

```text
pnpx create-payload-app@latest
```

**If you're new to Payload, you should start with the website template** (`pnpx create-payload-app@latest -t website`). It shows how to do _everything_ - including custom Rich Text blocks, on-demand revalidation, live preview, and more. It comes with a frontend built with Tailwind all in one `/app` folder.

## One-click templates

Jumpstart your next project by starting with a pre-made template. These are production-ready, end-to-end solutions designed to get you to market as fast as possible.

### [🌐 Website](https://github.com/payloadcms/payload/tree/main/templates/website)

Build any kind of website, blog, or portfolio from small to enterprise. Comes with a fully functional front-end built with RSCs and Tailwind.

We're constantly adding more templates to our [Templates Directory](https://github.com/payloadcms/payload/tree/main/templates). If you maintain your own template, consider adding the `payload-template` topic to your GitHub repository for others to find.

- [Official Templates](https://github.com/payloadcms/payload/tree/main/templates)
- [Community Templates](https://github.com/topics/payload-template)

## ✨ Features

- Completely free and open-source
- Next.js native, built to run inside _your_ `/app` folder
- Use server components to extend Payload UI
- Query your database directly in server components, no need for REST / GraphQL
- Fully TypeScript with automatic types for your data
- [Auth out of the box](https://payloadcms.com/docs/authentication/overview)
- [Versions and drafts](https://payloadcms.com/docs/versions/overview)
- [Localization](https://payloadcms.com/docs/configuration/localization)
- [Block-based layout builder](https://payloadcms.com/docs/fields/blocks)
- [Customizable React admin](https://payloadcms.com/docs/admin/overview)
- [Lexical rich text editor](https://payloadcms.com/docs/fields/rich-text)
- [Conditional field logic](https://payloadcms.com/docs/fields/overview#conditional-logic)
- Extremely granular [Access Control](https://payloadcms.com/docs/access-control/overview)
- [Document and field-level hooks](https://payloadcms.com/docs/hooks/overview) for every action Payload provides
- Intensely fast API
- Highly secure thanks to HTTP-only cookies, CSRF protection, and more

<a target="_blank" href="https://github.com/payloadcms/payload/discussions"><strong>Request Feature</strong></a>

## 🗒️ Documentation

Check out the [Payload website](https://payloadcms.com/docs/getting-started/what-is-payload) to find in-depth documentation for everything that Payload offers.

Migrating from v2 to v3? Check out the [3.0 Migration Guide](https://github.com/payloadcms/payload/blob/main/docs/migration-guide/overview.mdx) on how to do it.

## 🙋 Contributing

If you want to add contributions to this repository, please follow the instructions in [contributing.md](./CONTRIBUTING.md).

## 📚 Examples

The [Examples Directory](./examples) is a great resource for learning how to setup Payload in a variety of different ways, but you can also find great examples in our blog and throughout our social media.

If you'd like to run the examples, you can either copy them to a folder outside this repo or run them directly by (1) navigating to the example's subfolder (`cd examples/your-example-folder`) and (2) using the `--ignore-workspace` flag to bypass workspace restrictions (e.g., `pnpm --ignore-workspace install` or `pnpm --ignore-workspace dev`).

You can see more examples at:

- [Examples Directory](./examples)
- [Payload Blog](https://payloadcms.com/blog)
- [Payload YouTube](https://www.youtube.com/@payloadcms)

## 🔌 Plugins

Payload is highly extensible and allows you to install or distribute plugins that add or remove functionality. There are both officially-supported and community-supported plugins available. If you maintain your own plugin, consider adding the `payload-plugin` topic to your GitHub repository for others to find.

- [Official Plugins](https://github.com/orgs/payloadcms/repositories?q=topic%3Apayload-plugin)
- [Community Plugins](https://github.com/topics/payload-plugin)

## 🚨 Need help?

There are lots of good conversations and resources in our Github Discussions board and our Discord Server. If you're struggling with something, chances are, someone's already solved what you're up against. :point_down:

- [GitHub Discussions](https://github.com/payloadcms/payload/discussions)
- [GitHub Issues](https://github.com/payloadcms/payload/issues)
- [Discord](https://t.co/30APlsQUPB)
- [Community Help](https://payloadcms.com/community-help)

## ⭐ Like what we're doing? Give us a star

![payload-github-star](https://cms.payloadcms.com/media/payload-github-star.gif)

## 👏 Thanks to all our contributors

<img align="left" src="https://contributors-img.web.app/image?repo=payloadcms/payload"/>
</file>

<file path="packages/payload/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    /* TODO: remove the following lines */
    "strict": false,
    "noUncheckedIndexedAccess": false,
    "plugins": [
      {
        "name": "typescript-strict-plugin"
      },
      {
        "name": "tsc-strict"
      }
    ],
  },
  "references": [{ "path": "../translations" }]
}
</file>

</files>
</file>

<file path="docs/repomix-output-payloadcms-ui.xml">
This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/ui
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  ui/
    src/
      @types/
        assets.d.ts
      assets/
        index.ts
        payload-favicon.svg
        payload-logo-dark.svg
        payload-logo-light.svg
      elements/
        AddNewRelation/
          index.scss
          index.tsx
          types.ts
          useRelatedCollections.ts
        AnimateHeight/
          index.scss
          index.tsx
          usePatchAnimateHeight.ts
        AppHeader/
          index.scss
          index.tsx
        ArrayAction/
          index.scss
          index.tsx
        Autosave/
          index.scss
          index.tsx
        Banner/
          index.scss
          index.tsx
        BulkUpload/
          ActionsBar/
            index.scss
            index.tsx
          AddFilesView/
            index.scss
            index.tsx
          AddingFilesView/
            index.scss
            index.tsx
          DiscardWithoutSaving/
            index.tsx
          DrawerCloseButton/
            index.scss
            index.tsx
          EditForm/
            index.scss
            index.tsx
            types.ts
          EditMany/
            DrawerContent.tsx
            index.scss
            index.tsx
          FileSidebar/
            index.scss
            index.tsx
          FormsManager/
            createFormData.ts
            index.tsx
            reducer.ts
          Header/
            index.scss
            index.tsx
          index.tsx
        Button/
          index.scss
          index.tsx
          types.ts
        Card/
          index.scss
          index.tsx
        CodeEditor/
          CodeEditor.tsx
          index.scss
          index.tsx
          types.ts
        Collapsible/
          index.scss
          index.tsx
          provider.tsx
        ColumnSelector/
          index.scss
          index.tsx
        ConfirmationModal/
          index.scss
          index.tsx
        CopyLocaleData/
          index.scss
          index.tsx
        CopyToClipboard/
          index.scss
          index.tsx
        DatePicker/
          DatePicker.tsx
          getFormattedLocale.ts
          index.scss
          index.tsx
          library.scss
          types.ts
        DeleteDocument/
          index.scss
          index.tsx
        DeleteMany/
          index.scss
          index.tsx
        DocumentControls/
          index.scss
          index.tsx
        DocumentDrawer/
          DrawerHeader/
            index.scss
            index.tsx
          DrawerContent.tsx
          index.scss
          index.tsx
          Provider.tsx
          types.ts
        DocumentFields/
          index.scss
          index.tsx
        DocumentLocked/
          index.scss
          index.tsx
        DocumentTakeOver/
          index.scss
          index.tsx
        DraggableSortable/
          DraggableSortableItem/
            index.tsx
            types.ts
          useDraggableSortable/
            index.tsx
            types.ts
          index.tsx
          types.ts
        Drawer/
          index.scss
          index.tsx
          types.ts
          useDrawerSlug.tsx
        Dropzone/
          index.scss
          index.tsx
        DuplicateDocument/
          index.tsx
        EditMany/
          DrawerContent.tsx
          index.scss
          index.tsx
        EditUpload/
          index.scss
          index.tsx
        EmailAndUsername/
          index.tsx
        ErrorPill/
          index.scss
          index.tsx
        FieldDiffLabel/
          index.scss
          index.tsx
        FieldSelect/
          index.scss
          index.tsx
          reduceFieldOptions.ts
        FileDetails/
          DraggableFileDetails/
            index.scss
            index.tsx
          FileMeta/
            index.scss
            index.tsx
          StaticFileDetails/
            index.scss
            index.tsx
          index.tsx
        FullscreenModal/
          index.tsx
        GenerateConfirmation/
          index.tsx
        Gutter/
          index.scss
          index.tsx
        Hamburger/
          index.scss
          index.tsx
        HydrateAuthProvider/
          index.tsx
        IDLabel/
          index.scss
          index.tsx
        LeaveWithoutSaving/
          index.tsx
          usePreventLeave.tsx
        Link/
          formatUrl.ts
          index.tsx
        ListControls/
          ActiveQueryPreset/
            index.scss
            index.tsx
          getTextFieldsToBeSearched.ts
          index.scss
          index.tsx
          types.ts
          useQueryPresets.tsx
        ListDrawer/
          DrawerContent.tsx
          index.tsx
          Provider.tsx
          types.ts
        ListSelection/
          index.scss
          index.tsx
        Loading/
          index.scss
          index.tsx
        LoadingOverlay/
          index.tsx
          reducer.ts
          types.ts
        Localizer/
          LocalizerLabel/
            index.scss
            index.tsx
          index.scss
          index.tsx
        Locked/
          index.scss
          index.tsx
        Logout/
          index.tsx
        Modal/
          index.tsx
        Nav/
          NavToggler/
            index.scss
            index.tsx
          context.tsx
        NavGroup/
          index.scss
          index.tsx
        Pagination/
          ClickableArrow/
            index.scss
            index.tsx
          Page/
            index.tsx
          Separator/
            index.tsx
          index.scss
          index.tsx
        PerPage/
          index.scss
          index.tsx
        Pill/
          index.scss
          index.tsx
        Popup/
          PopupButtonList/
            index.scss
            index.tsx
          PopupDivider/
            index.scss
            index.tsx
          PopupGroupLabel/
            index.scss
            index.tsx
          PopupTrigger/
            index.scss
            index.tsx
          index.scss
          index.tsx
        PreviewButton/
          index.tsx
          usePreviewURL.tsx
        PreviewSizes/
          index.scss
          index.tsx
        PublishButton/
          ScheduleDrawer/
            buildUpcomingColumns.tsx
            index.scss
            index.tsx
            types.ts
          index.tsx
        PublishMany/
          index.scss
          index.tsx
        QueryPresets/
          cells/
            AccessCell/
              index.tsx
            ColumnsCell/
              index.scss
              index.tsx
            WhereCell/
              index.tsx
          fields/
            ColumnsField/
              index.scss
              index.tsx
            WhereField/
              index.scss
              index.tsx
        ReactSelect/
          ClearIndicator/
            index.scss
            index.tsx
          Control/
            index.tsx
          DropdownIndicator/
            index.scss
            index.tsx
          Input/
            index.tsx
          MultiValue/
            index.scss
            index.tsx
          MultiValueLabel/
            index.scss
            index.tsx
          MultiValueRemove/
            index.scss
            index.tsx
          SingleValue/
            index.tsx
          ValueContainer/
            index.scss
            index.tsx
          index.scss
          index.tsx
          types.ts
        RelationshipTable/
          cells/
            DrawerLink/
              index.scss
              index.tsx
          index.scss
          index.tsx
          Pagination.tsx
        RenderComponent/
          index.tsx
        RenderCustomComponent/
          index.tsx
        RenderIfInViewport/
          index.tsx
        RenderServerComponent/
          index.tsx
        RenderTitle/
          index.scss
          index.tsx
        SaveButton/
          index.tsx
        SaveDraftButton/
          index.tsx
        SearchFilter/
          index.scss
          index.tsx
        SelectAll/
          index.scss
          index.tsx
        SelectMany/
          index.tsx
        SelectRow/
          index.scss
          index.tsx
        ShimmerEffect/
          index.scss
          index.tsx
        SortColumn/
          index.scss
          index.tsx
        SortComplex/
          index.scss
          index.tsx
        SortHeader/
          index.scss
          index.tsx
        SortRow/
          index.scss
          index.tsx
        Status/
          index.scss
          index.tsx
        StayLoggedIn/
          index.tsx
        StepNav/
          context.tsx
          index.scss
          index.tsx
          SetStepNav.tsx
          types.ts
        Table/
          DefaultCell/
            fields/
              Array/
                index.tsx
              Blocks/
                index.tsx
              Checkbox/
                index.scss
                index.tsx
              Code/
                index.scss
                index.tsx
              Date/
                index.tsx
              File/
                index.scss
                index.tsx
              JSON/
                index.scss
                index.tsx
              Relationship/
                index.tsx
              Select/
                index.tsx
              Textarea/
                index.tsx
              index.tsx
            index.tsx
          RelationshipProvider/
            index.tsx
            reducer.ts
          index.scss
          index.tsx
          OrderableRow.tsx
          OrderableRowDragPreview.tsx
          OrderableTable.tsx
        Thumbnail/
          createThumbnail.ts
          index.scss
          index.tsx
        ThumbnailCard/
          index.scss
          index.tsx
        TimezonePicker/
          index.scss
          index.tsx
          types.ts
        Toasts/
          fieldErrors.tsx
        Tooltip/
          index.scss
          index.tsx
        Translation/
          index.tsx
        UnpublishMany/
          index.scss
          index.tsx
        Upload/
          index.scss
          index.tsx
        ViewDescription/
          index.tsx
        WhereBuilder/
          Condition/
            Date/
              index.tsx
              types.ts
            DefaultFilter/
              index.tsx
            Number/
              index.scss
              index.tsx
              types.ts
            Relationship/
              index.scss
              index.tsx
              optionsReducer.ts
              types.ts
            Select/
              formatOptions.ts
              index.tsx
              types.ts
            Text/
              index.scss
              index.tsx
              types.ts
            index.scss
            index.tsx
            types.ts
            validOperators.ts
          field-types.tsx
          index.scss
          index.tsx
          reduceFields.tsx
          types.ts
        WindowInfo/
          index.tsx
        withMergedProps/
          index.tsx
        WithServerSideProps/
          index.tsx
      exports/
        client/
          index.ts
        rsc/
          index.ts
        shared/
          index.ts
      fields/
        Array/
          ArrayRow.tsx
          index.scss
          index.tsx
        Blocks/
          BlocksDrawer/
            BlockSearch/
              index.scss
              index.tsx
            index.scss
            index.tsx
          SectionTitle/
            index.scss
            index.tsx
          BlockRow.tsx
          index.scss
          index.tsx
          RowActions.tsx
        Checkbox/
          index.scss
          index.tsx
          Input.tsx
        Code/
          index.scss
          index.tsx
        Collapsible/
          index.scss
          index.tsx
        ConfirmPassword/
          index.scss
          index.tsx
        DateTime/
          index.scss
          index.tsx
        Email/
          index.scss
          index.tsx
        FieldDescription/
          index.scss
          index.tsx
        FieldError/
          index.scss
          index.tsx
        FieldLabel/
          index.scss
          index.tsx
        Group/
          index.scss
          index.tsx
          provider.tsx
        Hidden/
          index.tsx
        Join/
          index.tsx
        JSON/
          index.scss
          index.tsx
        Number/
          index.scss
          index.tsx
        Password/
          index.scss
          index.tsx
          input.tsx
          types.ts
        Point/
          index.scss
          index.tsx
        RadioGroup/
          Radio/
            index.scss
            index.tsx
          index.scss
          index.tsx
        Relationship/
          select-components/
            MultiValueLabel/
              index.scss
              index.tsx
            SingleValue/
              index.scss
              index.tsx
          createRelationMap.ts
          findOptionsByValue.ts
          index.scss
          index.tsx
          optionsReducer.ts
          types.ts
        RichText/
          index.tsx
        Row/
          index.scss
          index.tsx
          provider.tsx
        Select/
          index.scss
          index.tsx
          Input.tsx
        shared/
          index.tsx
        Tabs/
          Tab/
            index.scss
            index.tsx
          index.scss
          index.tsx
          provider.tsx
        Text/
          index.scss
          index.tsx
          Input.tsx
          types.ts
        Textarea/
          index.scss
          index.tsx
          Input.tsx
          types.ts
        UI/
          index.tsx
        Upload/
          HasMany/
            index.scss
            index.tsx
          HasOne/
            index.scss
            index.tsx
          RelationshipContent/
            index.scss
            index.tsx
          UploadCard/
            index.scss
            index.tsx
          index.scss
          index.tsx
          Input.tsx
          types.ts
        index.tsx
        mergeFieldStyles.ts
      forms/
        fieldSchemasToFormState/
          calculateDefaultValues/
            index.ts
            iterateFields.ts
            promise.ts
          addFieldStatePromise.ts
          fieldSchemasToFormState.spec.js
          index.tsx
          iterateFields.ts
          renderField.tsx
          types.ts
        Form/
          context.ts
          createNestedClientFieldPath.ts
          errorMessages.ts
          fieldReducer.ts
          index.scss
          index.tsx
          initContextState.ts
          mergeServerFormState.ts
          reduceToSerializableFields.ts
          rowHelpers.ts
          rows.ts
          types.ts
        NullifyField/
          index.tsx
        RenderFields/
          index.scss
          index.tsx
          RenderField.tsx
          types.ts
        RowLabel/
          Context/
            index.tsx
          index.tsx
          types.ts
        Submit/
          index.scss
          index.tsx
        useField/
          index.tsx
          types.ts
        WatchChildErrors/
          buildPathSegments.ts
          index.tsx
        withCondition/
          index.tsx
          WatchCondition.tsx
      graphics/
        Account/
          Default/
            index.scss
            index.tsx
          Gravatar/
            index.tsx
          index.tsx
        DefaultBlockImage/
          index.tsx
        ExternalLink/
          index.scss
          index.tsx
        File/
          index.tsx
        Icon/
          index.tsx
        Logo/
          index.tsx
      hooks/
        useDebounce.ts
        useDebouncedCallback.ts
        useDebouncedEffect.ts
        useDelay.ts
        useDelayedRender.ts
        useEffectEvent.ts
        useHotkey.ts
        useIntersect.ts
        usePayloadAPI.ts
        useQueues.ts
        useResize.ts
        useThrottledEffect.ts
        useThrottledValue.ts
        useUseAsTitle.ts
      icons/
        Calendar/
          index.scss
          index.tsx
        Check/
          index.scss
          index.tsx
        Chevron/
          index.scss
          index.tsx
        CloseMenu/
          index.scss
          index.tsx
        CodeBlock/
          index.tsx
        Copy/
          index.scss
          index.tsx
        Dots/
          index.scss
          index.tsx
        DragHandle/
          index.scss
          index.tsx
        Edit/
          index.scss
          index.tsx
        Line/
          index.scss
          index.tsx
        Link/
          index.scss
          index.tsx
        Lock/
          index.scss
          index.tsx
        LogOut/
          index.scss
          index.tsx
        Menu/
          index.scss
          index.tsx
        MinimizeMaximize/
          index.tsx
        More/
          index.scss
          index.tsx
        People/
          index.scss
          index.tsx
        Plus/
          index.scss
          index.tsx
        Search/
          index.scss
          index.tsx
        Sort/
          index.scss
          index.tsx
        Swap/
          index.scss
          index.tsx
        X/
          index.scss
          index.tsx
      providers/
        Actions/
          index.tsx
        Auth/
          index.tsx
        ClientFunction/
          index.tsx
        Config/
          index.tsx
        DocumentEvents/
          index.tsx
        DocumentInfo/
          index.tsx
          types.ts
          useGetDocPermissions.tsx
        EditDepth/
          index.tsx
        EntityVisibility/
          index.tsx
        ListQuery/
          context.ts
          index.tsx
          types.ts
        Locale/
          index.tsx
        Operation/
          index.tsx
        Params/
          index.tsx
        Preferences/
          index.tsx
        Root/
          index.tsx
        RouteCache/
          index.tsx
        RouteTransition/
          ProgressBar/
            index.scss
            index.tsx
          index.tsx
        ScrollInfo/
          index.tsx
        SearchParams/
          index.tsx
        Selection/
          index.tsx
        ServerFunctions/
          index.tsx
        TableColumns/
          RenderDefaultCell/
            index.scss
            index.tsx
          buildColumnState.tsx
          buildPolymorphicColumnState.tsx
          context.ts
          filterFields.tsx
          getInitialColumns.ts
          index.tsx
          types.ts
        Theme/
          index.tsx
        ToastContainer/
          icons/
            Error.tsx
            Info.tsx
            Success.tsx
            Warning.tsx
          index.tsx
        Translation/
          index.tsx
        UploadEdits/
          index.tsx
        UploadHandlers/
          index.tsx
        WindowInfo/
          index.tsx
      scss/
        app.scss
        colors.scss
        custom.css
        queries.scss
        resets.scss
        styles.scss
        svg.scss
        toastify.scss
        toasts.scss
        type.scss
        vars.scss
        z-index.scss
      utilities/
        buildClientFieldSchemaMap/
          index.ts
          traverseFields.ts
        buildFieldSchemaMap/
          index.ts
          traverseFields.ts
        formatDocTitle/
          formatDateTitle.ts
          formatLexicalDocTitle.ts
          index.ts
        abortAndIgnore.ts
        api.ts
        buildFormState.ts
        buildTableState.ts
        canUseDOM.ts
        combineFieldLabel.tsx
        copyDataFromLocale.ts
        dateLocales.ts
        deepMerge.ts
        filterOutUploadFields.ts
        findLocaleFromCode.ts
        formatAdminURL.ts
        formatFields.ts
        generateFieldID.ts
        getBestFitFromSizes.ts
        getClientConfig.ts
        getClientSchemaMap.ts
        getDisplayedFieldValue.ts
        getOffsetTop.ts
        getRequestLanguage.ts
        getSchemaMap.ts
        getSupportedMonacoLocale.ts
        groupNavItems.ts
        handleBackToDashboard.tsx
        handleFormStateLocking.ts
        handleGoBack.tsx
        handleTakeOver.tsx
        hasOptionLabelJSXElement.ts
        hasSavePermission.ts
        isClientUserObject.ts
        isEditing.ts
        isURLAllowed.ts
        parseSearchParams.ts
        reduceFieldsToValuesWithValidation.ts
        removeUndefined.ts
        renderTable.tsx
        resolveFilterOptions.ts
        sanitizeID.ts
        schedulePublishHandler.ts
        scrollToID.ts
        setsAreEqual.ts
        upsertPreferences.ts
      views/
        Edit/
          Auth/
            APIKey.tsx
            index.scss
            index.tsx
            types.ts
          SetDocumentStepNav/
            index.tsx
          SetDocumentTitle/
            index.tsx
          index.scss
          index.tsx
          types.ts
        List/
          ListHeader/
            index.scss
            index.tsx
          index.scss
          index.tsx
          types.ts
    .browserslistrc
    .prettierignore
    .swcrc
    babel.config.cjs
    bundle.js
    eslint.config.js
    LICENSE.md
    package.json
    tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/ui/src/@types/assets.d.ts">

</file>

<file path="packages/ui/src/assets/index.ts">

</file>

<file path="packages/ui/src/assets/payload-favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="1024" viewBox="0 0 102.4 102.4">
 <style>
    path {
      fill: #333333;
    }

    @media (prefers-color-scheme: dark) {
      path {
        fill: white;
      }
    }
  </style>
  <path d="M50.67,86.55l-29.8-17.2c-.37-.22-.6-.61-.6-1.04v-26.56c0-.46.5-.75.9-.52l34.6,19.98c.48.28,1.09-.07,1.09-.63v-12.96c0-.52-.28-.99-.72-1.25L14.5,22.32c-.37-.22-.83-.22-1.21,0l-5.45,3.15c-.37.22-.6.61-.6,1.04v49.37c0,.43.23.83.6,1.04l42.75,24.68c.37.22.83.22,1.21,0l35.9-20.73c.48-.28.48-.97,0-1.25l-11.2-6.47c-.45-.26-1-.26-1.45,0l-23.18,13.38c-.37.22-.83.22-1.21,0Z" />
  <path d="M94.56,25.47L51.8.79c-.37-.22-.83-.22-1.21,0l-22.6,13.05c-.48.28-.48.97,0,1.25l11.1,6.41c.45.26,1,.26,1.45,0l10.12-5.84c.37-.22.83-.22,1.21,0l29.8,17.2c.37.22.6.61.6,1.04v26.7c0,.52.28.99.72,1.25l11.08,6.4c.48.28,1.09-.07,1.09-.63V26.52c0-.43-.23-.83-.6-1.04Z" />
</svg>
</file>

<file path="packages/ui/src/assets/payload-logo-dark.svg">
<svg id="b" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 193.38 43.5"><g id="c"><path d="M18.01,35.63l-12.36-7.13c-.15-.09-.25-.25-.25-.43v-11.02c0-.19.21-.31.37-.22l14.35,8.28c.2.12.45-.03.45-.26v-5.37c0-.21-.11-.41-.3-.52L3.01,9c-.15-.09-.35-.09-.5,0l-2.26,1.31c-.15.09-.25.25-.25.43v20.47c0,.18.1.34.25.43l17.73,10.24c.15.09.35.09.5,0l14.89-8.6c.2-.12.2-.4,0-.52l-4.64-2.68c-.19-.11-.41-.11-.6,0l-9.61,5.55c-.15.09-.35.09-.5,0Z"/><path d="M36.21,10.3L18.48.07c-.15-.09-.35-.09-.5,0l-9.37,5.41c-.2.12-.2.4,0,.52l4.6,2.66c.19.11.41.11.6,0l4.2-2.42c.15-.09.35-.09.5,0l12.36,7.13c.15.09.25.25.25.43v11.07c0,.21.11.41.3.52l4.6,2.65c.2.12.45-.03.45-.26V10.74c0-.18-.1-.34-.25-.43Z"/><g id="d"><path d="M193.38,9.47c0,1.94-1.48,3.32-3.3,3.32s-3.31-1.39-3.31-3.32,1.49-3.31,3.31-3.31,3.3,1.39,3.3,3.31ZM192.92,9.47c0-1.68-1.26-2.88-2.84-2.88s-2.84,1.2-2.84,2.88,1.26,2.89,2.84,2.89,2.84-1.2,2.84-2.89ZM188.69,11.17v-3.51h1.61c.85,0,1.35.39,1.35,1.15,0,.53-.3.86-.67,1.02l.79,1.35h-.89l-.72-1.22h-.64v1.22h-.82ZM190.18,9.31c.46,0,.64-.16.64-.5s-.19-.49-.64-.49h-.67v.99h.67Z"/><path d="M54.72,24.84v10.93h-5.4V6.1h12.26c7.02,0,11.1,3.2,11.1,9.39s-4.07,9.35-11.06,9.35h-6.9,0ZM61.12,20.52c4.07,0,6.11-1.66,6.11-5.03s-2.04-5.03-6.11-5.03h-6.4v10.06h6.4Z"/><path d="M85.94,32.45c-1,2.41-3.66,3.78-7.02,3.78-4.11,0-7.11-2.29-7.11-6.11,0-4.24,3.32-5.98,7.61-6.48l6.32-.71v-1c0-2.58-1.58-3.82-3.99-3.82s-3.74,1.29-3.91,3.24h-5.11c.46-4.53,3.99-7.19,9.18-7.19,5.74,0,9.02,2.7,9.02,8.19v8.15c0,1.95.08,3.58.42,5.28h-5.11c-.21-1.16-.29-2.29-.29-3.32h0ZM85.73,27.58v-1.29l-4.7.54c-2.24.29-3.95.79-3.95,2.99,0,1.66,1.16,2.7,3.28,2.7,2.74,0,5.36-1.62,5.36-4.95h0Z"/><path d="M90.39,14.66h5.4l5.86,15.92h.08l5.57-15.92h5.28l-8.23,21.49c-2,5.28-4.45,7.32-8.89,7.36-.71,0-1.7-.08-2.45-.21v-4.03c.62.13.96.13,1.41.13,2.16,0,3.07-.75,4.2-3.66l-8.23-21.07h0Z"/><path d="M113.46,35.77V6.1h5.32v29.67h-5.32Z"/><path d="M130.79,36.27c-6.23,0-10.68-4.2-10.68-11.05s4.45-11.05,10.68-11.05,10.68,4.24,10.68,11.05-4.45,11.05-10.68,11.05ZM130.79,32.32c3.41,0,5.36-2.66,5.36-7.11s-1.95-7.11-5.36-7.11-5.36,2.7-5.36,7.11,1.91,7.11,5.36,7.11Z"/><path d="M156.19,32.45c-1,2.41-3.66,3.78-7.02,3.78-4.11,0-7.11-2.29-7.11-6.11,0-4.24,3.32-5.98,7.61-6.48l6.32-.71v-1c0-2.58-1.58-3.82-3.99-3.82s-3.74,1.29-3.91,3.24h-5.11c.46-4.53,3.99-7.19,9.19-7.19,5.74,0,9.02,2.7,9.02,8.19v8.15c0,1.95.08,3.58.42,5.28h-5.11c-.21-1.16-.29-2.29-.29-3.32h0ZM155.98,27.58v-1.29l-4.7.54c-2.24.29-3.95.79-3.95,2.99,0,1.66,1.16,2.7,3.28,2.7,2.74,0,5.36-1.62,5.36-4.95h0Z"/><path d="M178.5,32.41c-1.04,2.12-3.58,3.87-6.78,3.87-5.53,0-9.31-4.49-9.31-11.05s3.78-11.05,9.31-11.05c3.28,0,5.69,1.83,6.69,3.95V6.1h5.32v29.67h-5.24v-3.37h0ZM178.55,24.84c0-4.11-1.95-6.78-5.32-6.78s-5.45,2.83-5.45,7.15,2,7.15,5.45,7.15,5.32-2.66,5.32-6.78v-.75h0Z"/></g></g></svg>
</file>

<file path="packages/ui/src/assets/payload-logo-light.svg">
<svg id="b" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 193.38 43.5"><g id="c"><path d="M18.01,35.63l-12.36-7.13c-.15-.09-.25-.25-.25-.43v-11.02c0-.19.21-.31.37-.22l14.35,8.28c.2.12.45-.03.45-.26v-5.37c0-.21-.11-.41-.3-.52L3.01,9c-.15-.09-.35-.09-.5,0l-2.26,1.31c-.15.09-.25.25-.25.43v20.47c0,.18.1.34.25.43l17.73,10.24c.15.09.35.09.5,0l14.89-8.6c.2-.12.2-.4,0-.52l-4.64-2.68c-.19-.11-.41-.11-.6,0l-9.61,5.55c-.15.09-.35.09-.5,0Z" fill="#fff"/><path d="M36.21,10.3L18.48.07c-.15-.09-.35-.09-.5,0l-9.37,5.41c-.2.12-.2.4,0,.52l4.6,2.66c.19.11.41.11.6,0l4.2-2.42c.15-.09.35-.09.5,0l12.36,7.13c.15.09.25.25.25.43v11.07c0,.21.11.41.3.52l4.6,2.65c.2.12.45-.03.45-.26V10.74c0-.18-.1-.34-.25-.43Z" fill="#fff"/><g id="d"><path d="M193.38,9.47c0,1.94-1.48,3.32-3.3,3.32s-3.31-1.39-3.31-3.32,1.49-3.31,3.31-3.31,3.3,1.39,3.3,3.31ZM192.92,9.47c0-1.68-1.26-2.88-2.84-2.88s-2.84,1.2-2.84,2.88,1.26,2.89,2.84,2.89,2.84-1.2,2.84-2.89ZM188.69,11.17v-3.51h1.61c.85,0,1.35.39,1.35,1.15,0,.53-.3.86-.67,1.02l.79,1.35h-.89l-.72-1.22h-.64v1.22h-.82ZM190.18,9.31c.46,0,.64-.16.64-.5s-.19-.49-.64-.49h-.67v.99h.67Z" fill="#fff"/><path d="M54.72,24.84v10.93h-5.4V6.1h12.26c7.02,0,11.1,3.2,11.1,9.39s-4.07,9.35-11.06,9.35h-6.9,0ZM61.12,20.52c4.07,0,6.11-1.66,6.11-5.03s-2.04-5.03-6.11-5.03h-6.4v10.06h6.4Z" fill="#fff"/><path d="M85.94,32.45c-1,2.41-3.66,3.78-7.02,3.78-4.11,0-7.11-2.29-7.11-6.11,0-4.24,3.32-5.98,7.61-6.48l6.32-.71v-1c0-2.58-1.58-3.82-3.99-3.82s-3.74,1.29-3.91,3.24h-5.11c.46-4.53,3.99-7.19,9.18-7.19,5.74,0,9.02,2.7,9.02,8.19v8.15c0,1.95.08,3.58.42,5.28h-5.11c-.21-1.16-.29-2.29-.29-3.32h0ZM85.73,27.58v-1.29l-4.7.54c-2.24.29-3.95.79-3.95,2.99,0,1.66,1.16,2.7,3.28,2.7,2.74,0,5.36-1.62,5.36-4.95h0Z" fill="#fff"/><path d="M90.39,14.66h5.4l5.86,15.92h.08l5.57-15.92h5.28l-8.23,21.49c-2,5.28-4.45,7.32-8.89,7.36-.71,0-1.7-.08-2.45-.21v-4.03c.62.13.96.13,1.41.13,2.16,0,3.07-.75,4.2-3.66l-8.23-21.07h0Z" fill="#fff"/><path d="M113.46,35.77V6.1h5.32v29.67h-5.32Z" fill="#fff"/><path d="M130.79,36.27c-6.23,0-10.68-4.2-10.68-11.05s4.45-11.05,10.68-11.05,10.68,4.24,10.68,11.05-4.45,11.05-10.68,11.05ZM130.79,32.32c3.41,0,5.36-2.66,5.36-7.11s-1.95-7.11-5.36-7.11-5.36,2.7-5.36,7.11,1.91,7.11,5.36,7.11Z" fill="#fff"/><path d="M156.19,32.45c-1,2.41-3.66,3.78-7.02,3.78-4.11,0-7.11-2.29-7.11-6.11,0-4.24,3.32-5.98,7.61-6.48l6.32-.71v-1c0-2.58-1.58-3.82-3.99-3.82s-3.74,1.29-3.91,3.24h-5.11c.46-4.53,3.99-7.19,9.19-7.19,5.74,0,9.02,2.7,9.02,8.19v8.15c0,1.95.08,3.58.42,5.28h-5.11c-.21-1.16-.29-2.29-.29-3.32h0ZM155.98,27.58v-1.29l-4.7.54c-2.24.29-3.95.79-3.95,2.99,0,1.66,1.16,2.7,3.28,2.7,2.74,0,5.36-1.62,5.36-4.95h0Z" fill="#fff"/><path d="M178.5,32.41c-1.04,2.12-3.58,3.87-6.78,3.87-5.53,0-9.31-4.49-9.31-11.05s3.78-11.05,9.31-11.05c3.28,0,5.69,1.83,6.69,3.95V6.1h5.32v29.67h-5.24v-3.37h0ZM178.55,24.84c0-4.11-1.95-6.78-5.32-6.78s-5.45,2.83-5.45,7.15,2,7.15,5.45,7.15,5.32-2.66,5.32-6.78v-.75h0Z" fill="#fff"/></g></g></svg>
</file>

<file path="packages/ui/src/elements/AddNewRelation/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .relationship-add-new {
    display: flex;
    align-items: stretch;

    .popup__trigger-wrap {
      display: flex;
      align-items: stretch;
      height: 100%;
    }

    &__add-button:not(.relationship-add-new__add-button--unstyled),
    &__add-button:not(.relationship-add-new__add-button--unstyled).doc-drawer__toggler {
      @include formInput;
      margin: 0;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      position: relative;
      height: 100%;
      margin-left: -1px;
      display: flex;
      padding: 0 base(0.5);
      align-items: center;
      display: flex;
      cursor: pointer;
    }

    &__add-button {
      margin: 0;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      position: relative;
      height: 100%;
      margin-left: -1px;
      display: flex;
      padding: 0 base(0.5);
      align-items: center;
      display: flex;
      cursor: pointer;
    }
  }
}
</file>

<file path="packages/ui/src/elements/AddNewRelation/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { Fragment, useCallback, useEffect, useState } from 'react'
⋮----
import type { Value } from '../../fields/Relationship/types.js'
import type { DocumentDrawerContextType } from '../DocumentDrawer/Provider.js'
import type { Props } from './types.js'
⋮----
import { PlusIcon } from '../../icons/Plus/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
import { useDocumentDrawer } from '../DocumentDrawer/index.js'
import { Popup } from '../Popup/index.js'
⋮----
import { Tooltip } from '../Tooltip/index.js'
⋮----
import { useRelatedCollections } from './useRelatedCollections.js'
⋮----
// ensure the value is not already in the array
⋮----
// dispatchOptions({
//   collection: collectionConfig,
//   // TODO: fix this
//   // @ts-expect-error-next-line
//   type: 'ADD',
//   config,
//   docs: [doc],
//   i18n,
//   sort: true,
// })
⋮----
// the drawer must be rendered on the page before before opening it
// this is why 'selectedCollection' is different from 'collectionConfig'
⋮----
onMouseLeave=
</file>

<file path="packages/ui/src/elements/AddNewRelation/types.ts">
import type { Value } from '../../fields/Relationship/types.js'
⋮----
export type Props = {
  readonly Button?: React.ReactNode
  readonly hasMany: boolean
  readonly path: string
  readonly relationTo: string | string[]
  readonly setValue: (value: unknown) => void
  readonly unstyled?: boolean
  readonly value: Value | Value[]
}
</file>

<file path="packages/ui/src/elements/AddNewRelation/useRelatedCollections.ts">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useState } from 'react'
⋮----
import { useConfig } from '../../providers/Config/index.js'
⋮----
export const useRelatedCollections = (relationTo: string | string[]): ClientCollectionConfig[] =>
</file>

<file path="packages/ui/src/elements/AnimateHeight/index.scss">
@layer payload-default {
  .rah-static {
    interpolate-size: allow-keywords;
    height: 0;

    &--height-auto {
      height: auto;
    }
  }
}
</file>

<file path="packages/ui/src/elements/AnimateHeight/index.tsx">
import React, { useEffect, useRef } from 'react'
⋮----
import { usePatchAnimateHeight } from './usePatchAnimateHeight.js'
⋮----
export const AnimateHeight: React.FC<{
  children: React.ReactNode
  className?: string
  duration?: number
  height?: 'auto' | number
  id?: string
}> = (
⋮----
// `display: none` once closed
⋮----
// reset overflow once open
</file>

<file path="packages/ui/src/elements/AnimateHeight/usePatchAnimateHeight.ts">
import { useEffect, useMemo, useRef, useState } from 'react'
⋮----
export const usePatchAnimateHeight = ({
  containerRef,
  contentRef,
  duration,
  open,
}: {
  containerRef: React.RefObject<HTMLDivElement>
  contentRef: React.RefObject<HTMLDivElement>
  duration: number
  open: boolean
}):
⋮----
const setContainerHeight = (height: string) =>
⋮----
const handleTransitionEnd = () =>
⋮----
const animate = () =>
⋮----
// Skip animation on first render
⋮----
// Trigger reflow
container.offsetHeight // eslint-disable-line @typescript-eslint/no-unused-expressions
⋮----
const onTransitionEnd = () =>
⋮----
// Setup ResizeObserver
</file>

<file path="packages/ui/src/elements/AppHeader/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .app-header {
    position: relative;
    width: 100%;
    height: var(--app-header-height);
    z-index: var(--z-modal);

    &__mobile-nav-toggler {
      display: none;
    }

    &__localizer.localizer {
      position: absolute;
      top: 50%;
      right: base(4.5);
      transform: translate3d(0, -50%, 0);
    }

    // place the localizer outside the `overflow: hidden` container so that the popup is visible
    // this means we need to use a placeholder div so that the space is retained in the DOM
    [dir='rtl'] &__localizer {
      right: unset;
      left: base(4.5);
    }

    &__localizer-spacing {
      visibility: hidden;
    }

    &__bg {
      opacity: 0;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    &--show-bg {
      opacity: 1;
    }

    &__content {
      display: flex;
      align-items: center;
      height: 100%;
      padding: 0 var(--gutter-h);
      position: relative;
      flex-grow: 1;
    }

    &__wrapper {
      display: flex;
      gap: calc(var(--base) / 2);
      align-items: center;
      height: 100%;
      flex-grow: 1;
      justify-content: space-between;
      width: 100%;
    }

    &__account {
      position: relative;

      &:focus:not(:focus-visible) {
        opacity: 1;
      }

      // Use a pseudo element for the accessability so that it doesn't take up DOM space
      // Also because the parent element has `overflow: hidden` which would clip an outline
      &:focus-visible {
        outline: none;

        &::after {
          content: '';
          border: var(--accessibility-outline);
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          pointer-events: none;
        }
      }
    }

    &__controls-wrapper {
      display: flex;
      align-items: center;
      flex-grow: 1;
      width: 100%;
    }

    &__step-nav-wrapper {
      flex-grow: 0;
      overflow: auto;
      display: flex;
      width: 100%;

      &::-webkit-scrollbar {
        display: none;
      }
    }

    &__actions-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      gap: calc(var(--base) / 2);
      margin-right: var(--base);
    }

    &__gradient-placeholder {
      position: absolute;
      top: 0;
      right: 0;
      width: var(--base);
      height: var(--base);
      background: linear-gradient(to right, transparent, var(--theme-bg));
    }

    &__actions {
      display: flex;
      align-items: center;
      gap: calc(var(--base) / 2);
      flex-shrink: 0;
      max-width: 600px;
      white-space: nowrap;

      &::-webkit-scrollbar {
        display: none;
      }
    }

    &__last-action {
      margin-right: var(--base);
    }

    @include large-break {
      &__actions {
        max-width: 500px;
      }
    }

    @include mid-break {
      &__gradient-placeholder {
        right: var(--base);
      }

      &__actions {
        max-width: 300px;
        margin-right: var(--base);
      }
    }

    @include small-break {
      &__localizer.localizer {
        right: base(2);
      }

      &--nav-open {
        .app-header__localizer {
          display: none;
        }
      }

      &__mobile-nav-toggler {
        display: flex;
        align-items: center;

        &.nav-toggler--is-open {
          opacity: 0.5;
        }
      }

      &__step-header {
        // TODO: overflow the step header instead of hide it
        display: none;
      }

      &__gradient-placeholder {
        right: 0;
      }

      &__actions {
        max-width: 150px;
        margin-right: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/AppHeader/index.tsx">
import { formatAdminURL } from '@convexcms/core/shared'
import React, { useEffect, useRef, useState } from 'react'
⋮----
import { Account } from '../../graphics/Account/index.js'
import { useActions } from '../../providers/Actions/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Hamburger } from '../Hamburger/index.js'
import { Link } from '../Link/index.js'
import { Localizer } from '../Localizer/index.js'
import { LocalizerLabel } from '../Localizer/LocalizerLabel/index.js'
import { useNav } from '../Nav/context.js'
import { NavToggler } from '../Nav/NavToggler/index.js'
import { RenderCustomComponent } from '../RenderCustomComponent/index.js'
import { StepNav } from '../StepNav/index.js'
⋮----
type Props = {
  CustomAvatar?: React.ReactNode
  CustomIcon?: React.ReactNode
}
⋮----
const checkIsScrollable = () =>
</file>

<file path="packages/ui/src/elements/ArrayAction/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .array-actions {
    &__button {
      @extend %btn-reset;
      cursor: pointer;
      border-radius: 100px;

      &:hover {
        background: var(--theme-elevation-0);
      }
    }

    &__actions {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    &__action {
      display: flex;
      gap: calc(var(--base) / 2);
      align-items: center;

      svg {
        position: relative;

        .stroke {
          stroke-width: 1px;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ArrayAction/index.tsx">
import React from 'react'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { CopyIcon } from '../../icons/Copy/index.js'
import { MoreIcon } from '../../icons/More/index.js'
import { PlusIcon } from '../../icons/Plus/index.js'
import { XIcon } from '../../icons/X/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Popup, PopupList } from '../Popup/index.js'
⋮----
export type Props = {
  addRow: (current: number, blockType?: string) => Promise<void> | void
  duplicateRow: (current: number) => void
  hasMaxRows: boolean
  index: number
  isSortable?: boolean
  moveRow: (from: number, to: number) => void
  removeRow: (index: number) => void
  rowCount: number
}
⋮----
onClick=
</file>

<file path="packages/ui/src/elements/Autosave/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .autosave {
    white-space: nowrap;
  }
}
</file>

<file path="packages/ui/src/elements/Autosave/index.tsx">
// TODO: abstract the `next/navigation` dependency out from this component
import type { ClientCollectionConfig, ClientGlobalConfig } from '@convexcms/core'
⋮----
import { dequal } from 'dequal/lite'
import { reduceFieldsToValues, versionDefaults } from '@convexcms/core/shared'
import React, { useDeferredValue, useEffect, useRef, useState } from 'react'
import { toast } from 'sonner'
⋮----
import {
  useAllFormFields,
  useForm,
  useFormModified,
  useFormSubmitted,
} from '../../forms/Form/context.js'
import { useDebounce } from '../../hooks/useDebounce.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useQueues } from '../../hooks/useQueues.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentEvents } from '../../providers/DocumentEvents/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { formatTimeToNow } from '../../utilities/formatDocTitle/formatDateTitle.js'
import { reduceFieldsToValuesWithValidation } from '../../utilities/reduceFieldsToValuesWithValidation.js'
import { LeaveWithoutSaving } from '../LeaveWithoutSaving/index.js'
⋮----
// The minimum time the saving state should be shown
⋮----
export type Props = {
  collection?: ClientCollectionConfig
  global?: ClientGlobalConfig
  id?: number | string
  publishedDocUpdatedAt: string
}
⋮----
/**
   * Track the validation internally so Autosave can determine when to run queue processing again
   * Helps us prevent infinite loops when the queue is processing and the form is invalid
   */
⋮----
// Store fields in ref so the autosave func
// can always retrieve the most to date copies
// after the timeout has executed
⋮----
// Store modified in ref so the autosave func
// can bail out if modified becomes false while
// timing out during autosave
⋮----
// Store locale in ref so the autosave func
// can always retrieve the most to date locale
⋮----
// We need to log the time in order to figure out if we need to trigger the state off later
⋮----
const hideIndicator = () =>
⋮----
// If request was faster than minimum animation time, animate the difference
⋮----
// Swallow Error
⋮----
// We need to log the time in order to figure out if we need to trigger the state off later
⋮----
// Set valid to false internally so the queue doesn't process
⋮----
// If it's not an error then we can update the document data inside the context
⋮----
// Manually update the data since this function doesn't fire the `submit` function from useForm
⋮----
// Reset internal state allowing the queue to process
⋮----
// When debounced fields change, autosave
⋮----
/**
     * Ensure autosave doesn't run on mount
     */
⋮----
/**
     * Ensure autosave only runs if the form data changes, not every time the entire form state changes
     */
⋮----
/**
   * If component unmounts, clear the autosave timeout
   */
</file>

<file path="packages/ui/src/elements/Banner/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .banner {
    font-size: 1rem;
    line-height: base(1);
    border: 0;
    vertical-align: middle;
    background: var(--theme-elevation-100);
    color: var(--theme-elevation-800);
    border-radius: $style-radius-m;
    padding: base(0.5);
    margin-bottom: $baseline;

    &--has-action {
      cursor: pointer;
      text-decoration: none;
    }

    &--has-icon {
      display: flex;

      svg {
        display: block;
      }
    }

    &--type-default {
      &.button--has-action {
        &:hover {
          background: var(--theme-elevation-900);
        }

        &:active {
          background: var(--theme-elevation-950);
        }
      }
    }

    &--type-error {
      background: var(--theme-error-100);
      color: var(--theme-error-600);

      svg {
        @include color-svg(var(--theme-error-600));
      }

      &.button--has-action {
        &:hover {
          background: var(--theme-error-200);
        }

        &:active {
          background: var(--theme-error-300);
        }
      }
    }

    &--type-success {
      background: var(--theme-success-100);
      color: var(--theme-success-600);

      &.button--has-action {
        &:hover {
          background: var(--theme-success-200);
        }

        &:active {
          background: var(--theme-success-200);
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Banner/index.tsx">
import type { MouseEvent } from 'react'
⋮----
import React from 'react'
⋮----
import { Link } from '../Link/index.js'
⋮----
type onClick = (event: MouseEvent) => void
⋮----
export type Props = Readonly<{
  alignIcon?: 'left' | 'right'
  children?: React.ReactNode
  className?: string
  icon?: React.ReactNode
  onClick?: onClick
  to?: string
  type?: 'default' | 'error' | 'info' | 'success'
}>
⋮----
export type RenderedTypeProps = {
  children?: React.ReactNode
  className?: string
  onClick?: onClick
  to: string
}
⋮----
export const Banner: React.FC<Props> = ({
  type = 'default',
  alignIcon = 'right',
  children,
  className,
  icon,
  onClick,
  to,
}) =>
</file>

<file path="packages/ui/src/elements/BulkUpload/ActionsBar/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .bulk-upload--actions-bar {
    display: flex;
    padding-inline: var(--gutter-h);
    align-items: center;
    border-bottom: 1px solid var(--theme-border-color);
    position: sticky;
    z-index: 1;
    top: 0;
    background-color: var(--theme-bg);
    height: var(--doc-controls-height);

    &__navigation {
      display: flex;
      gap: var(--base);
      align-items: center;
      width: 100%;
    }

    &__locationText {
      font-variant-numeric: tabular-nums;
      margin: 0;
    }

    &__controls {
      display: flex;
      gap: calc(var(--base) / 2);

      .btn {
        background-color: var(--theme-elevation-100);
        width: calc(var(--base) * 1.2);
        height: calc(var(--base) * 1.2);

        svg {
          max-width: 1rem;
        }

        &:hover {
          background-color: var(--theme-elevation-200);
        }

        &__label {
          display: flex;
        }
      }
    }

    &__buttons {
      display: flex;
      gap: var(--base);
      margin-left: auto;
    }

    @include mid-break {
      &__navigation {
        justify-content: space-between;
      }
      &__saveButtons {
        display: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/ActionsBar/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { ChevronIcon } from '../../../icons/Chevron/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { Button } from '../../Button/index.js'
import { EditManyBulkUploads } from '../EditMany/index.js'
import { useFormsManager } from '../FormsManager/index.js'
⋮----
type Props = {
  readonly collectionConfig: ClientCollectionConfig
}
</file>

<file path="packages/ui/src/elements/BulkUpload/AddFilesView/index.scss">
@layer payload-default {
  .bulk-upload--add-files {
    height: 100%;
    display: flex;
    flex-direction: column;

    &__dropArea {
      height: 100%;
      padding: calc(var(--base) * 2) var(--gutter-h);
    }

    .dropzone {
      flex-direction: column;
      justify-content: center;
      display: flex;
      gap: var(--base);
      background-color: var(--theme-elevation-50);

      p {
        margin: 0;
      }
    }

    &__dragAndDropText {
      margin: 0;
      text-transform: lowercase;
      align-self: center;
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/AddFilesView/index.tsx">
import React from 'react'
⋮----
import { useTranslation } from '../../../providers/Translation/index.js'
import { Button } from '../../Button/index.js'
import { Dropzone } from '../../Dropzone/index.js'
import { DrawerHeader } from '../Header/index.js'
⋮----
type Props = {
  readonly acceptMimeTypes?: string
  readonly onCancel: () => void
  readonly onDrop: (acceptedFiles: FileList) => void
}
</file>

<file path="packages/ui/src/elements/BulkUpload/AddingFilesView/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .bulk-upload--file-manager {
    display: flex;
    height: 100%;
    width: 100%;
    overflow: hidden;

    &__editView {
      flex-grow: 1;
      height: 100%;
      max-height: 100%;
      overflow: auto;
    }

    @include mid-break {
      flex-direction: column-reverse;

      &__editView {
        flex-grow: 1;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/AddingFilesView/index.tsx">
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { reduceFieldsToValues } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { useAuth } from '../../../providers/Auth/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { DocumentInfoProvider } from '../../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { ActionsBar } from '../ActionsBar/index.js'
import { discardBulkUploadModalSlug, DiscardWithoutSaving } from '../DiscardWithoutSaving/index.js'
import { EditForm } from '../EditForm/index.js'
import { FileSidebar } from '../FileSidebar/index.js'
import { useFormsManager } from '../FormsManager/index.js'
import { DrawerHeader } from '../Header/index.js'
</file>

<file path="packages/ui/src/elements/BulkUpload/DiscardWithoutSaving/index.tsx">
import { useModal } from '@faceless-ui/modal'
import React from 'react'
⋮----
import { useTranslation } from '../../../providers/Translation/index.js'
import { ConfirmationModal } from '../../ConfirmationModal/index.js'
import { useBulkUpload } from '../index.js'
⋮----
export function DiscardWithoutSaving()
⋮----
body=
cancelLabel=
confirmLabel=
heading=
</file>

<file path="packages/ui/src/elements/BulkUpload/DrawerCloseButton/index.scss">
@layer payload-default {
  .drawer-close-button {
    --size: calc(var(--base) * 1.2);
    border: 0;
    background-color: transparent;
    padding: 0;
    cursor: pointer;
    overflow: hidden;
    direction: ltr;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--size);
    height: var(--size);

    svg {
      margin: calc(-1 * var(--size));
      width: calc(var(--size) * 2);
      height: calc(var(--size) * 2);

      position: relative;

      .stroke {
        stroke-width: 1px;
        vector-effect: non-scaling-stroke;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/DrawerCloseButton/index.tsx">
import React from 'react'
⋮----
import { XIcon } from '../../../icons/X/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
type Props = {
  readonly onClick: () => void
}
</file>

<file path="packages/ui/src/elements/BulkUpload/EditForm/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .collection-edit {
    width: 100%;

    &__form {
      height: auto;
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/EditForm/index.tsx">
import { useRouter, useSearchParams } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { useCallback, useEffect } from 'react'
⋮----
import type { EditFormProps } from './types.js'
⋮----
import { Form, useForm } from '../../../forms/Form/index.js'
import { type FormProps } from '../../../forms/Form/types.js'
import { WatchChildErrors } from '../../../forms/WatchChildErrors/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useDocumentEvents } from '../../../providers/DocumentEvents/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useEditDepth } from '../../../providers/EditDepth/index.js'
import { OperationProvider } from '../../../providers/Operation/index.js'
import { useRouteTransition } from '../../../providers/RouteTransition/index.js'
import { useServerFunctions } from '../../../providers/ServerFunctions/index.js'
import { abortAndIgnore, handleAbortRef } from '../../../utilities/abortAndIgnore.js'
import { useDocumentDrawerContext } from '../../DocumentDrawer/Provider.js'
import { DocumentFields } from '../../DocumentFields/index.js'
import { Upload_v4 } from '../../Upload/index.js'
import { useFormsManager } from '../FormsManager/index.js'
import { BulkUploadProvider } from '../index.js'
⋮----
// This component receives props only on _pages_
// When rendered within a drawer, props are empty
// This is solely to support custom edit views which get server-rendered
⋮----
// Redirect to the same locale if it's been set
</file>

<file path="packages/ui/src/elements/BulkUpload/EditForm/types.ts">
import type { UploadProps_v4 } from '../../Upload/index.js'
⋮----
export type EditFormProps = {
  readonly submitted?: boolean
} & Pick<UploadProps_v4, 'resetUploadEdits' | 'updateUploadEdits' | 'uploadEdits'>
</file>

<file path="packages/ui/src/elements/BulkUpload/EditMany/DrawerContent.tsx">
import type { ClientCollectionConfig, SelectType } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { unflatten } from '@convexcms/core/shared'
import React, { useCallback, useEffect, useMemo, useState } from 'react'
⋮----
import type { FormProps } from '../../../forms/Form/index.js'
import type { OnFieldSelect } from '../../FieldSelect/index.js'
import type { FieldOption } from '../../FieldSelect/reduceFieldOptions.js'
import type { State } from '../FormsManager/reducer.js'
⋮----
import { Button } from '../../../elements/Button/index.js'
import { Form } from '../../../forms/Form/index.js'
import { RenderField } from '../../../forms/RenderFields/RenderField.js'
import { XIcon } from '../../../icons/X/index.js'
import { useAuth } from '../../../providers/Auth/index.js'
import { useServerFunctions } from '../../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { abortAndIgnore, handleAbortRef } from '../../../utilities/abortAndIgnore.js'
import { FieldSelect } from '../../FieldSelect/index.js'
import { useFormsManager } from '../FormsManager/index.js'
import { baseClass, type EditManyBulkUploadsProps } from './index.js'
</file>

<file path="packages/ui/src/elements/BulkUpload/EditMany/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .edit-many-bulk-uploads {
    &__toggle {
      font-size: 1rem;
      line-height: base(1.2);
      display: inline-flex;
      background: var(--theme-elevation-150);
      color: var(--theme-elevation-800);
      border-radius: $style-radius-s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 0;
      padding: 0 base(0.4);
      align-items: center;
      cursor: pointer;
      text-decoration: none;

      &:active,
      &:focus {
        outline: none;
      }

      &:hover {
        background: var(--theme-elevation-100);
      }

      &:active {
        background: var(--theme-elevation-100);
      }
    }

    &__form {
      height: 100%;
    }

    &__main {
      width: calc(100% - #{base(15)});
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__header {
      display: flex;
      margin-top: base(2.5);
      margin-bottom: base(1);
      width: 100%;

      &__title {
        margin: 0;
        flex-grow: 1;
      }

      &__close {
        border: 0;
        background-color: transparent;
        padding: 0;
        cursor: pointer;
        overflow: hidden;
        width: base(1);
        height: base(1);

        svg {
          width: base(2);
          height: base(2);
          position: relative;
          inset-inline-start: base(-0.5);
          top: base(-0.5);

          .stroke {
            stroke-width: 2px;
            vector-effect: non-scaling-stroke;
          }
        }
      }
    }

    &__edit {
      padding-top: base(1);
      padding-bottom: base(2);
      flex-grow: 1;
    }
    [dir='rtl'] &__sidebar-wrap {
      left: 0;
      border-right: 1px solid var(--theme-elevation-100);
      right: auto;
    }

    &__sidebar-wrap {
      position: fixed;
      width: base(15);
      height: 100%;
      top: 0;
      right: 0;
      overflow: visible;
      border-left: 1px solid var(--theme-elevation-100);
    }

    &__sidebar {
      width: 100%;
      height: 100%;
      overflow-y: auto;
    }

    &__sidebar-sticky-wrap {
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__collection-actions,
    &__meta,
    &__sidebar-fields {
      [dir='ltr'] & {
        padding-left: base(1.5);
      }
      [dir='rtl'] & {
        padding-right: base(1.5);
      }
    }

    &__document-actions {
      padding-right: $baseline;
      position: sticky;
      top: 0;
      z-index: var(--z-nav);

      > * {
        position: relative;
        z-index: 1;
      }

      @include mid-break {
        @include blur-bg;
      }
    }

    &__document-actions {
      display: flex;
      flex-wrap: wrap;
      padding: base(1);
      gap: base(0.5);

      .form-submit {
        width: calc(50% - #{base(1)});

        @include mid-break {
          width: auto;
          flex-grow: 1;
        }

        .btn {
          width: 100%;
          padding-left: base(0.5);
          padding-right: base(0.5);
          margin-bottom: 0;
        }
      }
    }

    @include mid-break {
      &__main {
        width: 100%;
        min-height: initial;
      }

      &__sidebar-wrap {
        position: static;
        width: 100%;
        height: initial;
      }

      &__form {
        display: block;
      }

      &__edit {
        padding-top: 0;
        padding-bottom: 0;
      }

      &__document-actions {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: auto;
        z-index: var(--z-nav);
      }

      &__document-actions,
      &__sidebar-fields {
        padding-left: var(--gutter-h);
        padding-right: var(--gutter-h);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/EditMany/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { useAuth } from '../../../providers/Auth/index.js'
import { EditDepthProvider } from '../../../providers/EditDepth/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { Drawer, DrawerToggler } from '../../Drawer/index.js'
import { useFormsManager } from '../FormsManager/index.js'
import { EditManyBulkUploadsDrawerContent } from './DrawerContent.js'
⋮----
export type EditManyBulkUploadsProps = {
  readonly collection: ClientCollectionConfig
}
⋮----
const { forms } = useFormsManager() // Access forms managed in bulk uploads
</file>

<file path="packages/ui/src/elements/BulkUpload/FileSidebar/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .file-selections {
    --file-gutter-h: calc(var(--gutter-h) / 4);
    border-right: 1px solid var(--theme-border-color);
    padding: 0;
    display: flex;
    flex-direction: column;
    width: 300px;
    overflow: auto;
    max-height: 100%;

    &__header {
      position: sticky;
      top: 0;
      margin-top: var(--base);
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      background: var(--theme-bg);
      flex-wrap: wrap;

      p {
        margin: 0;
      }
    }

    &__headerTopRow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--base);
      width: 100%;
      padding-block: var(--base);
      padding-inline: var(--file-gutter-h);
    }

    &__header__text {
      display: flex;
      flex-direction: column;

      .error-pill {
        align-self: flex-start;
      }
    }

    &__filesContainer {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 4);
      margin-top: calc(var(--base) / 2);
      width: 100%;
      padding-inline: var(--file-gutter-h);

      .shimmer-effect {
        border-radius: var(--style-radius-m);
      }
    }

    &__fileRowContainer {
      --rowPadding: calc(var(--base) / 4);
      position: relative;
      &:last-child {
        margin-bottom: calc(var(--base) / 4);
      }
    }

    &__fileRow {
      @include btn-reset;
      display: flex;
      padding: var(--rowPadding);
      align-items: center;
      gap: calc(var(--base) / 2);
      border-radius: var(--style-radius-m);
      max-width: 100%;
      cursor: pointer;
      width: 100%;

      &:hover {
        background-color: var(--theme-elevation-100);
      }

      .thumbnail {
        width: base(1.2);
        height: base(1.2);
        flex-shrink: 0;
        object-fit: cover;
        border-radius: var(--style-radius-s);
      }

      p {
        margin: 0;
      }
    }

    &__fileDetails {
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    &__fileRowContainer--active {
      .file-selections__fileRow {
        background-color: var(--theme-elevation-100);
      }

      .file-selections__remove {
        .icon--x {
          opacity: 1;
        }
      }
    }

    &__fileRowContainer--error {
      .file-selections__fileRow {
        background-color: var(--theme-error-100);
      }

      &.file-selections__fileRowContainer--active .file-selections__fileRow,
      .file-selections__fileRow:hover {
        background-color: var(--theme-error-200);
      }

      .file-selections__remove--overlay:hover {
        background-color: var(--theme-error-50);

        .icon--x {
          opacity: 1;
        }
      }
    }

    &__errorCount {
      margin-left: auto;
      position: absolute;
      transform: translate(50%, -50%);
      top: 0;
      right: 0;
    }

    &__fileName {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    &__fileSize {
      font-size: calc(var(--base) / 2);
      color: var(--theme-elvation-400);
      flex-shrink: 0;
    }

    &__remove {
      @include btn-reset;
      margin: 0;
      margin-left: auto;

      .icon--x {
        opacity: 0.75;
      }
    }

    &__remove--underlay {
      pointer-events: none;
      opacity: 0;
    }

    &__remove--overlay {
      position: absolute;
      transform: translateY(-50%);
      top: 50%;
      bottom: 50%;
      right: var(--rowPadding);
      height: 20px;
      border-radius: var(--style-radius-m);
      cursor: pointer;

      &:hover {
        background-color: var(--theme-elevation-200);
      }
    }

    &__header__actions {
      display: flex;
      align-items: center;
      gap: var(--base);
    }

    &__header__addFile {
      height: fit-content;
    }

    &__toggler {
      display: none;
      margin: 0;
      padding-block: 0;

      &__text {
        display: none;
      }
    }

    &__header__mobileDocActions {
      display: none;
    }

    &__animateWrapper {
      overflow: auto;
    }

    &__mobileBlur {
      @include blur-bg;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 100ms cubic-bezier(0, 0.2, 0.2, 1);
    }

    &__showingFiles {
      .file-selections__mobileBlur {
        opacity: 1;
      }
    }

    @include mid-break {
      --file-gutter-h: var(--gutter-h);
      flex-direction: column-reverse;
      width: 100%;
      position: sticky;
      bottom: 0;
      flex-shrink: 0;

      &__showingFiles {
        z-index: 2;
      }

      &__filesContainer {
        @include blur-bg;
      }

      &__fileRowContainer {
        z-index: 1;
      }

      &__header {
        margin-top: 0;
      }

      &__headerTopRow {
        border-top: 1px solid var(--theme-border-color);
        padding-block: 0 calc(var(--base) * 0.8) 0;
      }

      &__header__text {
        display: none;
      }

      &__header__actions {
        flex-grow: 2;
        display: flex;
        justify-content: flex-end;
      }

      &__header__mobileDocActions {
        position: relative;
        display: flex;
        width: 100%;
        padding-block: calc(var(--base) * 0.8);
        padding-inline: var(--file-gutter-h);
        border-top: 1px solid var(--theme-border-color);

        > div {
          display: flex;
          justify-content: flex-end;
          width: 100%;
          button {
            flex: 0.5;
          }
        }
      }

      &__toggler {
        padding-right: 0;
        padding-left: 0;
        padding-top: calc(var(--base) * 0.8);
        padding-bottom: calc(var(--base) * 0.8);
        display: flex;
        justify-content: flex-end;
        flex-grow: 1;

        .btn__label {
          width: 100%;
          display: flex;
          align-items: center;
          justify-content: space-between;
        }

        &__text {
          display: flex;
        }

        svg {
          max-width: 1.5rem;
        }

        .btn__content {
          width: 100%;
        }
      }

      .btn {
        margin: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/FileSidebar/index.tsx">
import { useModal } from '@faceless-ui/modal'
import { useWindowInfo } from '@faceless-ui/window-info'
import { isImage } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { ChevronIcon } from '../../../icons/Chevron/index.js'
import { XIcon } from '../../../icons/X/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { AnimateHeight } from '../../AnimateHeight/index.js'
import { Button } from '../../Button/index.js'
import { Drawer } from '../../Drawer/index.js'
import { ErrorPill } from '../../ErrorPill/index.js'
import { Pill } from '../../Pill/index.js'
import { ShimmerEffect } from '../../ShimmerEffect/index.js'
import { Thumbnail } from '../../Thumbnail/index.js'
import { Actions } from '../ActionsBar/index.js'
⋮----
import { AddFilesView } from '../AddFilesView/index.js'
import { useFormsManager } from '../FormsManager/index.js'
import { useBulkUpload } from '../index.js'
</file>

<file path="packages/ui/src/elements/BulkUpload/FormsManager/createFormData.ts">
import type { CollectionSlug, FormState } from '@convexcms/core'
⋮----
import { serialize } from 'object-to-formdata'
import { reduceFieldsToValues } from '@convexcms/core/shared'
⋮----
import type { UploadHandlersContext } from '../../../providers/UploadHandlers/index.js'
⋮----
export async function createFormData(
  formState: FormState = {},
  overrides: Record<string, any> = {},
  collectionSlug: CollectionSlug,
  uploadHandler: ReturnType<UploadHandlersContext['getUploadHandler']>,
)
</file>

<file path="packages/ui/src/elements/BulkUpload/FormsManager/index.tsx">
import type {
  Data,
  DocumentSlots,
  FormState,
  SanitizedDocumentPermissions,
  UploadEdits,
} from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { isImage } from '@convexcms/core/shared'
⋮----
import React from 'react'
import { toast } from 'sonner'
⋮----
import type { State } from './reducer.js'
⋮----
import { fieldReducer } from '../../../forms/Form/fieldReducer.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useLocale } from '../../../providers/Locale/index.js'
import { useServerFunctions } from '../../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { useUploadHandlers } from '../../../providers/UploadHandlers/index.js'
import { hasSavePermission as getHasSavePermission } from '../../../utilities/hasSavePermission.js'
import { LoadingOverlay } from '../../Loading/index.js'
import { useLoadingOverlay } from '../../LoadingOverlay/index.js'
import { createThumbnail } from '../../Thumbnail/createThumbnail.js'
import { useBulkUpload } from '../index.js'
import { createFormData } from './createFormData.js'
import { formsManagementReducer } from './reducer.js'
⋮----
type FormsManagerContext = {
  readonly activeIndex: State['activeIndex']
  readonly addFiles: (filelist: FileList) => Promise<void>
  readonly bulkUpdateForm: (
    updatedFields: Record<string, unknown>,
    afterStateUpdate?: () => void,
  ) => Promise<void>
  readonly collectionSlug: string
  readonly docPermissions?: SanitizedDocumentPermissions
  readonly documentSlots: DocumentSlots
  readonly forms: State['forms']
  getFormDataRef: React.RefObject<() => Data>
  readonly hasPublishPermission: boolean
  readonly hasSavePermission: boolean
  readonly hasSubmitted: boolean
  readonly isInitializing: boolean
  readonly removeFile: (index: number) => void
  readonly resetUploadEdits?: () => void
  readonly saveAllDocs: ({ overrides }?: { overrides?: Record<string, unknown> }) => Promise<void>
  readonly setActiveIndex: (index: number) => void
  readonly setFormTotalErrorCount: ({
    errorCount,
    index,
  }: {
    errorCount: number
    index: number
  }) => void
  readonly thumbnailUrls: string[]
  readonly totalErrorCount?: number
  readonly updateUploadEdits: (args: UploadEdits) => void
}
⋮----
type FormsManagerProps = {
  readonly children: React.ReactNode
}
⋮----
const processedFiles = React.useRef(new Set()) // Track already-processed files
⋮----
// eslint-disable-next-line @typescript-eslint/no-floating-promises
⋮----
// Skip if already processed
⋮----
// Generate thumbnail and update ref
⋮----
// Trigger re-render in batches
⋮----
// FETCH AND SET THE DOCUMENT SLOTS HERE!
⋮----
// swallow error
⋮----
// should expose some sort of helper for this
⋮----
// file too large
⋮----
// swallow
</file>

<file path="packages/ui/src/elements/BulkUpload/FormsManager/reducer.ts">
import type { FormState, UploadEdits } from '@convexcms/core'
⋮----
export type State = {
  activeIndex: number
  forms: {
    errorCount: number
    formState: FormState
    uploadEdits?: UploadEdits
  }[]
  totalErrorCount: number
}
⋮----
type Action =
  | {
      count: number
      index: number
      type: 'UPDATE_ERROR_COUNT'
    }
  | {
      errorCount: number
      formState: FormState
      index: number
      type: 'UPDATE_FORM'
      updatedFields?: Record<string, unknown>
      uploadEdits?: UploadEdits
    }
  | {
      files: FileList
      initialState: FormState | null
      type: 'ADD_FORMS'
    }
  | {
      index: number
      type: 'REMOVE_FORM'
    }
  | {
      index: number
      type: 'SET_ACTIVE_INDEX'
    }
  | {
      state: Partial<State>
      type: 'REPLACE'
    }
⋮----
export function formsManagementReducer(state: State, action: Action): State
⋮----
// Merge the existing formState with the new formState
</file>

<file path="packages/ui/src/elements/BulkUpload/Header/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .bulk-upload--drawer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: calc(var(--base) * 2.5) var(--gutter-h);
    height: 48px;
    border-bottom: 1px solid var(--theme-border-color);

    h2 {
      margin: 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/BulkUpload/Header/index.tsx">
import React from 'react'
⋮----
import { DrawerCloseButton } from '../DrawerCloseButton/index.js'
⋮----
type Props = {
  readonly onClose: () => void
  readonly title: string
}
export function DrawerHeader(
</file>

<file path="packages/ui/src/elements/BulkUpload/index.tsx">
import type { JsonObject } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { validateMimeType } from '@convexcms/core/shared'
import React from 'react'
import { toast } from 'sonner'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Drawer, useDrawerDepth } from '../Drawer/index.js'
import { AddFilesView } from './AddFilesView/index.js'
import { AddingFilesView } from './AddingFilesView/index.js'
import { FormsManagerProvider, useFormsManager } from './FormsManager/index.js'
⋮----
const setCollectionSlug: BulkUploadContext['setCollectionSlug'] = (slug) =>
</file>

<file path="packages/ui/src/elements/Button/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  a.btn {
    display: inline-block;
  }

  .btn--withPopup {
    margin-block: 24px;
    .btn {
      margin: 0;
    }
  }

  .btn {
    * {
      pointer-events: none;
    }

    // colors
    &--style-primary {
      --color: var(--theme-elevation-0);
      --bg-color: var(--theme-elevation-800);
      --box-shadow: none;
      --hover-bg: var(--theme-elevation-600);
      --hover-color: var(--color);

      &.btn--disabled {
        --bg-color: var(--theme-elevation-200);
        --color: var(--theme-elevation-800);
        --hover-bg: var(--bg-color);
        --hover-color: var(--color);
      }
    }

    &--style-secondary {
      --color: var(--theme-text);
      --bg-color: transparent;
      --box-shadow: inset 0 0 0 1px var(--theme-elevation-800);
      --hover-color: var(--theme-elevation-600);
      --hover-box-shadow: inset 0 0 0 1px var(--theme-elevation-400);

      &.btn--disabled {
        --color: var(--theme-elevation-200);
        --box-shadow: inset 0 0 0 1px var(--theme-elevation-200);
        --hover-box-shadow: inset 0 0 0 1px var(--theme-elevation-200);
        --hover-color: var(--color);
      }
    }

    &--style-pill {
      --bg-color: var(--theme-elevation-150);
      --color: var(--theme-elevation-800);
      --hover-color: var(--color);
      --hover-bg: var(--theme-elevation-100);

      &.btn--disabled {
        --color: var(--theme-elevation-600);
        --hover-bg: var(--bg-color);
        --hover-color: var(--color);
      }
    }
  }

  .btn--withPopup {
    .popup-button {
      color: var(--color, inherit);
      background-color: var(--bg-color);
      box-shadow: var(--box-shadow);
      border-radius: $style-radius-m;
      align-items: center;

      html:not([dir='RTL']) & {
        border-left: 1px solid var(--theme-bg);
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
      }

      html[dir='RTL'] & {
        border-right: 1px solid var(--theme-bg);
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }

      &:hover,
      &:focus-visible,
      &:focus,
      &:active {
        background-color: var(--hover-bg);
        color: var(--hover-color);
        box-shadow: var(--hover-box-shadow);
      }
    }
  }

  .btn,
  .btn--withPopup .btn {
    &:hover,
    &:focus-visible,
    &:focus,
    &:active {
      color: var(--hover-color);
      box-shadow: var(--hover-box-shadow);
      background-color: var(--hover-bg);
    }
  }

  .btn--disabled,
  .btn--disabled .btn {
    cursor: not-allowed;
  }

  .btn {
    border-radius: $style-radius-s;
    font-size: var(--base-body-size);
    margin-block: base(1.2);
    line-height: base(1.2);
    border: 0;
    cursor: pointer;
    font-weight: normal;
    text-decoration: none;
    transition-property: border, color, box-shadow, background;
    transition-duration: 100ms;
    transition-timing-function: cubic-bezier(0, 0.2, 0.2, 1);

    color: var(--color, inherit);
    background-color: var(--bg-color, transparent);
    box-shadow: var(--box-shadow, none);

    .icon {
      @include color-svg(var(--color, currentColor));
      width: 100%;
      height: 100%;
    }

    &__content {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    &__icon {
      width: base(1.2);
      height: base(1.2);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid;
      border-radius: 100%;
      padding: base(0.1);
      color: inherit;

      .icon {
        width: 100%;
        height: 100%;
      }

      &.btn--size-small {
        padding: base(0.2);
      }
    }

    &--withPopup {
      display: flex;
    }

    &--has-tooltip {
      position: relative;
    }

    &--icon-style-without-border {
      .btn__icon {
        border: none;
      }
    }

    &--icon-style-none {
      .btn__icon {
        border: none;
      }
    }

    &--size-small {
      padding: 0 base(0.4);

      &.btn--icon-position-left {
        padding-inline-start: base(0.1);
        padding-inline-end: base(0.4);

        .btn__content {
          flex-direction: row-reverse;
        }
      }

      &.btn--icon-position-right {
        padding-inline-start: base(0.4);
        padding-inline-end: base(0.1);
      }
    }

    &--size-medium {
      padding: base(0.2) base(0.6);

      &.btn--icon-position-left {
        padding-inline-start: base(0.4);
        padding-inline-end: base(0.6);

        .btn__content {
          gap: base(0.2);
          flex-direction: row-reverse;
        }
      }

      &.btn--icon-position-right {
        padding-inline-start: base(0.6);
        padding-inline-end: base(0.4);

        .btn__content {
          gap: base(0.2);
        }
      }
    }

    &--size-large {
      padding: base(0.4) base(0.8);

      &.btn--icon-position-left {
        padding-inline-start: base(0.6);
        padding-inline-end: base(0.8);

        .btn__content {
          gap: base(0.4);
          flex-direction: row-reverse;
        }
      }

      &.btn--icon-position-right {
        padding-inline-start: base(0.8);
        padding-inline-end: base(0.6);

        .btn__content {
          gap: base(0.4);
        }
      }
    }

    &--withPopup .btn {
      html:not([dir='RTL']) & {
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }

      html[dir='RTL'] & {
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
      }
    }

    &--style-icon-label,
    &--style-icon-label.btn--icon-position-left,
    &--style-icon-label.btn--icon-position-right {
      padding: 0;
      font-weight: 600;

      .btn__content {
        gap: base(0.4);
      }
    }

    &--style-none {
      padding: 0;
    }

    &:focus:not(:focus-visible) {
      .btn__icon {
        @include color-svg(var(--theme-elevation-800));
        background: var(--theme-elevation-150);
      }

      outline: none;
    }

    &:active {
      .btn__icon {
        @include color-svg(var(--theme-elevation-0));
        background: var(--theme-elevation-700);
      }
    }

    &:focus-visible {
      outline: var(--accessibility-outline);
      outline-offset: var(--accessibility-outline-offset);
    }

    &.btn--disabled {
      cursor: not-allowed;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Button/index.tsx">
import React, { Fragment, isValidElement } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { EditIcon } from '../../icons/Edit/index.js'
import { LinkIcon } from '../../icons/Link/index.js'
import { PlusIcon } from '../../icons/Plus/index.js'
import { SwapIcon } from '../../icons/Swap/index.js'
import { XIcon } from '../../icons/X/index.js'
import { Link } from '../Link/index.js'
import { Popup } from '../Popup/index.js'
import { Tooltip } from '../Tooltip/index.js'
⋮----
function handleClick(event)
⋮----
const Tag = el // eslint-disable-line no-case-declarations
</file>

<file path="packages/ui/src/elements/Button/types.ts">
import type { ElementType, MouseEvent } from 'react'
import type React from 'react'
⋮----
type secondaryAction = {
  label: string
  onClick: (event: MouseEvent) => void
}
⋮----
export type Props = {
  'aria-label'?: string
  buttonId?: string
  buttonStyle?: 'error' | 'icon-label' | 'none' | 'pill' | 'primary' | 'secondary' | 'transparent'
  children?: React.ReactNode
  className?: string
  disabled?: boolean
  el?: 'anchor' | 'link' | ElementType
  /**
   * Setting to `true` will allow the submenu to be opened when the button is disabled
   */
  enableSubMenu?: boolean
  icon?: ['chevron' | 'edit' | 'plus' | 'x'] | React.ReactNode
  iconPosition?: 'left' | 'right'
  iconStyle?: 'none' | 'with-border' | 'without-border'
  id?: string
  /**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
  Link?: React.ElementType
  newTab?: boolean
  onClick?: (event: MouseEvent) => void
  onMouseDown?: (event: MouseEvent) => void
  /**
   * Enables form submission via an onClick handler. This is only needed if
   * type="submit" does not trigger form submission, e.g. if the button DOM
   * element is not a direct child of the form element.
   *
   * @default false
   */
  programmaticSubmit?: boolean
  ref?: React.RefObject<HTMLAnchorElement | HTMLButtonElement | null>
  round?: boolean
  secondaryActions?: secondaryAction | secondaryAction[]
  size?: 'large' | 'medium' | 'small'
  SubMenuPopupContent?: (props: { close: () => void }) => React.ReactNode
  to?: string
  tooltip?: string
  type?: 'button' | 'submit'
  url?: string
}
⋮----
/**
   * Setting to `true` will allow the submenu to be opened when the button is disabled
   */
⋮----
/**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
⋮----
/**
   * Enables form submission via an onClick handler. This is only needed if
   * type="submit" does not trigger form submission, e.g. if the button DOM
   * element is not a direct child of the form element.
   *
   * @default false
   */
</file>

<file path="packages/ui/src/elements/Card/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .card {
    background: var(--theme-elevation-50);
    padding: base(0.8);
    width: 100%;
    min-height: base(4);
    position: relative;
    border-radius: var(--style-radius-m);
    border: 1px solid var(--theme-border-color);
    transition-property: border, box-shadow, background;
    transition-duration: 100ms;
    transition-timing-function: cubic-bezier(0, 0.2, 0.2, 1);
    display: flex;
    justify-content: space-between;
    align-self: start;
    gap: base(0.8);

    &__title {
      @extend %h5;
      letter-spacing: 0;
      font-weight: 600;
      line-height: base(0.8);
      width: 100%;
      margin: base(0.1) 0;
    }

    &__actions {
      position: relative;
      z-index: 2;
      display: inline-flex;
      .btn {
        margin: 0;
        flex-shrink: 0;
      }

      .btn__icon {
        border: 1px solid var(--theme-border-color);
        transition-property: border, box-shadow, color, background;
        transition-duration: 100ms;
        transition-timing-function: cubic-bezier(0, 0.2, 0.2, 1);

        &:hover {
          border: 1px solid var(--theme-elevation-500);
          background-color: var(--theme-elevation-0);
          color: currentColor;
          @include shadow-sm;
        }
      }
    }

    &--has-onclick {
      cursor: pointer;

      &:hover {
        background: var(--theme-elevation-50);
        border: 1px solid var(--theme-elevation-250);
        box-shadow: 0 4px 8px -2px rgba(0, 0, 0, 0.05);
      }
    }

    &__click {
      z-index: 1;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      position: absolute;
      margin: 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Card/index.tsx">
import React from 'react'
⋮----
import { Button } from '../Button/index.js'
⋮----
export type Props = {
  actions?: React.ReactNode
  buttonAriaLabel?: string
  href?: string
  id?: string
  /**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
  Link?: React.ElementType
  onClick?: () => void
  title: string
  titleAs?: React.ElementType
}
⋮----
/**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
⋮----
export const Card: React.FC<Props> = (props) =>
</file>

<file path="packages/ui/src/elements/CodeEditor/CodeEditor.tsx">
import EditorImport from '@monaco-editor/react'
import React, { useState } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
import { useTheme } from '../../providers/Theme/index.js'
import { ShimmerEffect } from '../ShimmerEffect/index.js'
⋮----
const MIN_HEIGHT = minHeight ?? 56 // equivalent to 3 lines
⋮----
// Since we are not building an IDE and the container
// can already have scrolling, we want the height of the
// editor to fit its content.
// See: https://github.com/microsoft/monaco-editor/discussions/3677
height={maxHeight ? Math.min(dynamicHeight, maxHeight) : dynamicHeight}
onChange=
⋮----
// eslint-disable-next-line no-restricted-exports
</file>

<file path="packages/ui/src/elements/CodeEditor/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .code-editor {
    direction: ltr;
    @include formInput;
    height: auto;
    padding: 0;

    .monaco-editor {
      .view-overlays .current-line {
        max-width: calc(100% - 14px);
        border-width: 0px;
      }

      &:focus-within {
        .view-overlays .current-line {
          border-right: 0;
          border-width: 1px;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/CodeEditor/index.tsx">
import React, { lazy, Suspense } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
import { ShimmerEffect } from '../ShimmerEffect/index.js'
⋮----
export const CodeEditor: React.FC<Props> = (props) =>
</file>

<file path="packages/ui/src/elements/CodeEditor/types.ts">
import type { EditorProps } from '@monaco-editor/react'
⋮----
export type Props = {
  maxHeight?: number
  /**
   * @default 56 (3 lines)
   */
  minHeight?: number
  readOnly?: boolean
} & EditorProps
⋮----
/**
   * @default 56 (3 lines)
   */
</file>

<file path="packages/ui/src/elements/Collapsible/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .collapsible {
    --toggle-pad-h: #{base(0.75)};
    --toggle-pad-v: #{base(0.6)};

    border-radius: $style-radius-m;

    &__toggle-wrap {
      position: relative;
      padding: base(0.4) base(0.4) base(0.4) base(0.8);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--theme-elevation-50);
      line-height: base(1.2);
      gap: base(0.2);
      border-top-right-radius: $style-radius-m;
      border-top-left-radius: $style-radius-m;
      width: 100%;

      &:hover {
        background: var(--theme-elevation-100);
      }

      &:has(.collapsible__drag) {
        padding-inline-start: base(0.4);
      }
    }

    &__drag {
      display: flex;
      opacity: 0.5;
      top: var(--toggle-pad-v);
      width: base(1.2);
      height: base(1.2);
      padding: base(0.1);

      icon {
        width: 100%;
        height: 100%;
      }
    }

    &__toggle {
      @extend %btn-reset;
      @extend %body;
      text-align: left;
      cursor: pointer;
      border-top-right-radius: $style-radius-m;
      border-top-left-radius: $style-radius-m;
      width: 100%;
      height: 100%;
      color: transparent;
      position: absolute;
      top: 0;
      left: 0;

      span {
        user-select: none;
      }
    }

    &--style-default {
      border: 1px solid var(--theme-elevation-200);
      &:hover {
        border: 1px solid var(--theme-elevation-300);
      }

      > .collapsible__toggle-wrap {
        .row-label {
          color: var(--theme-text);
        }
      }
    }

    &--style-error {
      border: 1px solid var(--theme-error-400);
      > .collapsible__toggle-wrap {
        background-color: var(--theme-error-100);

        &:hover {
          background: var(--theme-error-150);
        }

        .row-label {
          color: var(--theme-error-950);
        }
      }
    }

    &__header-wrap {
      top: 0;
      right: base(3);
      bottom: 0;
      left: 0;
      pointer-events: none;
      width: 100%;
      overflow: hidden;
      max-width: 100%;
    }

    &__header-wrap--has-drag-handle {
      left: base(1);
    }

    &--collapsed {
      .collapsible__toggle-wrap {
        border-bottom-right-radius: $style-radius-m;
        border-bottom-left-radius: $style-radius-m;
      }
    }

    &__actions-wrap {
      pointer-events: none;
      display: flex;
      gap: base(0.2);
      margin-inline-end: base(0.2);
    }

    &__actions {
      pointer-events: all;
      display: flex;
      align-items: center;
      justify-content: center;
      width: base(1.2);
      height: base(1.2);

      &.icon {
        padding: base(0.1);
      }
    }

    &__indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      width: base(1.2);
      height: base(1.2);

      &.icon {
        padding: base(0.1);
      }
    }

    &__content {
      background-color: var(--theme-elevation-0);
      border-bottom-left-radius: $style-radius-m;
      border-bottom-right-radius: $style-radius-m;
      padding: var(--base);
    }

    @include small-break {
      &__content {
        padding: var(--gutter-h);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Collapsible/index.tsx">
import React, { useState } from 'react'
⋮----
import type { DragHandleProps } from '../DraggableSortable/DraggableSortableItem/types.js'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { DragHandleIcon } from '../../icons/DragHandle/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
import { AnimateHeight } from '../AnimateHeight/index.js'
import { CollapsibleProvider, useCollapsible } from './provider.js'
⋮----
export type Props = {
  actions?: React.ReactNode
  children: React.ReactNode
  className?: string
  collapsibleStyle?: 'default' | 'error'
  dragHandleProps?: DragHandleProps
  header?: React.ReactNode
  initCollapsed?: boolean
  isCollapsed?: boolean
  onToggle?: (collapsed: boolean) => Promise<void> | void
}
⋮----
onMouseLeave=
</file>

<file path="packages/ui/src/elements/Collapsible/provider.tsx">
import React, { createContext, use } from 'react'
⋮----
type ContextType = {
  isCollapsed: boolean
  isVisible: boolean
  isWithinCollapsible: boolean
  toggle: () => void
}
⋮----
export const CollapsibleProvider: React.FC<{
  children?: React.ReactNode
  isCollapsed?: boolean
  isWithinCollapsible?: boolean
  toggle: () => void
}> = (
⋮----
export const useCollapsible = (): ContextType
</file>

<file path="packages/ui/src/elements/ColumnSelector/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .column-selector {
    display: flex;
    flex-wrap: wrap;
    background: var(--theme-elevation-50);
    padding: var(--base);
    gap: calc(var(--base) / 2);

    &__column {
      background-color: transparent;
      box-shadow: 0 0 0 1px var(--theme-elevation-150);

      &.column-selector__column {
        cursor: pointer;

        &:hover {
          background-color: var(--theme-elevation-100);
        }
      }

      &.column-selector__column--active {
        background-color: var(--theme-elevation-0);
        box-shadow:
          0 0px 1px 1px var(--theme-elevation-150),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);

        &:hover {
          background-color: var(--theme-elevation-0);
          box-shadow:
            0 0px 1px 1px var(--theme-elevation-250),
            0 3px 4px -1px rgba(0, 0, 0, 0.1);
        }
      }
    }

    // TODO: delete this once all icons have been migrated to viewbox edge-to-edge
    .pill__icon {
      padding: 0;
    }

    @include small-break {
      padding: calc(var(--base) / 2) calc(var(--base) / 2) 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ColumnSelector/index.tsx">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { fieldIsHiddenOrDisabled, fieldIsID } from '@convexcms/core/shared'
import React, { useId, useMemo } from 'react'
⋮----
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { PlusIcon } from '../../icons/Plus/index.js'
import { XIcon } from '../../icons/X/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useTableColumns } from '../../providers/TableColumns/index.js'
import { DraggableSortable } from '../DraggableSortable/index.js'
import { Pill } from '../Pill/index.js'
⋮----
export type Props = {
  readonly collectionSlug: SanitizedCollectionConfig['slug']
}
⋮----
onDragEnd=
⋮----
onClick=
</file>

<file path="packages/ui/src/elements/ConfirmationModal/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .confirmation-modal {
    @include blur-bg;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;

    &__wrapper {
      z-index: 1;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: base(0.8);
      padding: base(2);
      max-width: base(36);
    }

    &__content {
      display: flex;
      flex-direction: column;
      gap: base(0.4);

      > * {
        margin: 0;
      }
    }

    &__controls {
      display: flex;
      gap: base(0.4);

      .btn {
        margin: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ConfirmationModal/index.tsx">
import { Modal, useModal } from '@faceless-ui/modal'
import React, { useCallback } from 'react'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
import { drawerZBase, useDrawerDepth } from '../Drawer/index.js'
⋮----
export type OnCancel = () => void
⋮----
export type ConfirmationModalProps = {
  body: React.ReactNode
  cancelLabel?: string
  className?: string
  confirmingLabel?: string
  confirmLabel?: string
  heading: React.ReactNode
  modalSlug: string
  onCancel?: OnCancel
  onConfirm: () => Promise<void> | void
}
⋮----
export function ConfirmationModal(props: ConfirmationModalProps)
</file>

<file path="packages/ui/src/elements/CopyLocaleData/index.scss">
@import '../../scss/styles.scss';

.copy-locale-data {
  &__sub-header {
    padding: 0 var(--gutter-h);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--theme-border-color);
  }

  &__content {
    padding: calc(var(--base) * 1.5) var(--gutter-h);
    display: flex;
    flex-direction: column;
    gap: var(--base);

    > * {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) * 0.25);
    }
  }
}
</file>

<file path="packages/ui/src/elements/CopyLocaleData/index.tsx">
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter } from 'next/navigation.js'
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { CheckboxField } from '../../fields/Checkbox/index.js'
import { SelectInput } from '../../fields/Select/index.js'
import { useFormModified } from '../../forms/Form/context.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { DrawerHeader } from '../BulkUpload/Header/index.js'
import { Button } from '../Button/index.js'
import { Drawer } from '../Drawer/index.js'
import { PopupList } from '../Popup/index.js'
⋮----
const getLocaleLabel = (code: string) =>
⋮----
onClick=
⋮----
label=
⋮----
setFromLocale(selectedOption.value)
</file>

<file path="packages/ui/src/elements/CopyToClipboard/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .copy-to-clipboard {
    @extend %btn-reset;
    position: relative;
    cursor: pointer;
    vertical-align: middle;
    border-radius: 100%;

    textarea {
      position: absolute;
      opacity: 0;
      z-index: -1;
      height: 0px;
      width: 0px;
    }

    &:focus,
    &:active {
      outline: none;
    }

    &:focus-visible {
      outline: var(--accessibility-outline);
    }
  }
}
</file>

<file path="packages/ui/src/elements/CopyToClipboard/index.tsx">
import React, { useRef, useState } from 'react'
⋮----
import { CopyIcon } from '../../icons/Copy/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Tooltip } from '../Tooltip/index.js'
⋮----
export type Props = {
  defaultMessage?: string
  successMessage?: string
  value?: string
}
⋮----
export const CopyToClipboard: React.FC<Props> = (
</file>

<file path="packages/ui/src/elements/DatePicker/DatePicker.tsx">
import type { DatePickerProps } from 'react-datepicker'
⋮----
import React from 'react'
import ReactDatePickerDefaultImport, { registerLocale, setDefaultLocale } from 'react-datepicker'
⋮----
import type { Props } from './types.js'
⋮----
import { CalendarIcon } from '../../icons/Calendar/index.js'
import { XIcon } from '../../icons/X/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
import { getFormattedLocale } from './getFormattedLocale.js'
⋮----
// Use the user's AdminUI language preference for the locale
⋮----
// when no displayFormat is provided, determine format based on the picker appearance
⋮----
const onChange: Extract<
    DatePickerProps,
    { selectsMultiple?: never; selectsRange?: never }
>['onChange'] = (incomingDate) =>
⋮----
{ selectsMultiple?: never; selectsRange?: never } // to satisfy TypeScript. Overrides can enable selectsMultiple or selectsRange but then it's up to the user to ensure they pass in the correct onChange
⋮----
// eslint-disable-next-line no-restricted-exports
</file>

<file path="packages/ui/src/elements/DatePicker/getFormattedLocale.ts">
export const getFormattedLocale = (language = 'enUS') =>
⋮----
my: 'enUS', // Burmese is not currently supported
</file>

<file path="packages/ui/src/elements/DatePicker/index.scss">
@import '../../scss/styles';

$cal-icon-width: 18px;

@layer payload-default {
  [dir='rtl'] {
    .date-time-picker {
      .react-datepicker__input-container input {
        padding-right: base(3.4);
      }
    }
  }

  .date-time-picker {
    .react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box,
    .react-datepicker__time-container {
      width: 120px;
    }

    &__icon-wrap {
      position: relative;
      z-index: 1;
    }

    .icon--calendar,
    &__clear-button {
      position: absolute;
    }

    .icon--calendar,
    .icon--x {
      @include color-svg(var(--theme-elevation-800));
      height: auto;
    }

    &__clear-button {
      top: base(0.5);
      right: base(2);
    }

    .icon--calendar {
      top: base(0.5);
      right: base(0.75);
      width: $cal-icon-width;
      pointer-events: none;
    }

    .icon--x {
      width: base(1);
    }

    &__clear-button {
      appearance: none;
      background-color: transparent;
      border: none;
      outline: none;
      padding: 0;
      cursor: pointer;
    }

    &__appearance--timeOnly {
      .react-datepicker {
        width: 100%;

        &__month-container,
        &__navigation--previous,
        &__navigation--next {
          display: none;
          visibility: hidden;
        }

        &-popper,
        &__time-container,
        &__time-box {
          width: base(6);
        }

        &__time-container {
          .react-datepicker__time {
            .react-datepicker__time-box {
              width: 100%;
            }
          }
        }
      }
    }

    .react-datepicker-wrapper {
      display: block;
    }

    .react-datepicker-wrapper,
    .react-datepicker__input-container {
      width: 100%;
    }

    .react-datepicker__input-container input {
      @include formInput;
      padding-right: calc(#{base(0.75)} + #{$cal-icon-width});
    }

    &--has-error {
      .react-datepicker__input-container input {
        background-color: var(--theme-error-200);
      }
    }

    .react-datepicker {
      @include shadow-lg;
      border: 1px solid var(--theme-elevation-100);
      background: var(--theme-input-bg);
      display: inline-flex;
      font-family: var(--font-body);
      font-weight: 100;
      border-radius: 0;
      color: var(--theme-elevation-800);

      &__header {
        padding-top: 0;
        text-transform: none;
        text-align: center;
        border-radius: 0;
        border: none;
        background-color: var(--theme-input-bg);

        &--time {
          padding: 10px 0;
          border-bottom: 1px solid var(--theme-elevation-150);
          font-weight: 600;
        }
      }

      &__navigation {
        background: none;
        line-height: 1.7rem;
        text-align: center;
        cursor: pointer;
        position: absolute;
        top: 10px;
        width: 0;
        padding: 0;
        border: 0.45rem solid transparent;
        z-index: 1;
        height: 10px;
        width: 10px;
        text-indent: -999em;
        overflow: hidden;
        top: 15px;

        &--next {
          border-left-color: var(--theme-elevation-400);

          &:focus {
            border-left-color: var(--theme-elevation-500);
            outline: none;
          }
        }

        &--previous {
          border-right-color: var(--theme-elevation-400);

          &:focus {
            border-right-color: var(--theme-elevation-500);
            outline: none;
          }
        }
      }

      &__current-month,
      &__header,
      &-year-header,
      &__day-name,
      &__day,
      &__time-name,
      &-time__header {
        color: var(--theme-elevation-1000);
      }

      &__current-month {
        display: none;
      }

      &__header__dropdown,
      &-year-header {
        padding: 10px 0;
        font-weight: bold;
      }

      &__month-container {
        border-right: 1px solid var(--theme-elevation-150);
      }

      &__time,
      &__time-container,
      .react-datepicker__time-container .react-datepicker__time {
        background: none;
      }

      &__time-container {
        border-left: none;
      }

      &__month-text {
        padding: base(0.3);
        margin: base(0.15);
        font-size: base(0.55);
        &:hover {
          background: var(--theme-elevation-100);
        }
      }

      &__month-select,
      &__year-select {
        min-width: 70px;
        border: none;
        background: none;
        outline: none;
        cursor: pointer;

        option {
          background-color: var(--theme-elevation-50);
        }
      }

      &__day-names {
        background-color: var(--theme-elevation-100);
      }

      &__day {
        box-shadow: inset 0px 0px 0px 1px var(--theme-elevation-150);
        font-size: base(0.55);

        &:hover {
          background: var(--theme-elevation-100);
        }

        &:focus {
          outline: 0;
          background: var(--theme-elevation-400);
        }

        &--selected {
          font-weight: bold;

          &:focus {
            background-color: var(--theme-elevation-150);
          }
        }

        &--keyboard-selected {
          color: var(--theme-elevation-0);
          font-weight: bold;

          &:focus {
            background-color: var(--theme-elevation-150);
            box-shadow:
              inset 0px 0px 0px 1px var(--theme-elevation-800),
              0px 0px 0px 1px var(--theme-elevation-800);
          }
        }

        &--today {
          font-weight: bold;
        }
      }

      &__day,
      &__day-name {
        width: base(1.5);
        margin: base(0.15);
        line-height: base(1.25);
      }
    }

    .react-datepicker-popper {
      z-index: 10;
      border: none;
    }

    .react-datepicker__time-container
      .react-datepicker__time
      .react-datepicker__time-box
      ul.react-datepicker__time-list {
      max-height: 100%;
    }

    .react-datepicker__day--keyboard-selected,
    .react-datepicker__month-text--keyboard-selected,
    .react-datepicker__time-container
      .react-datepicker__time
      .react-datepicker__time-box
      ul.react-datepicker__time-list
      li.react-datepicker__time-list-item--selected {
      box-shadow: none;
      background-color: var(--theme-elevation-150);
      font-weight: bold;
      color: var(--theme-elevation-800);
      border-radius: 0;
    }

    .react-datepicker__time-container
      .react-datepicker__time
      .react-datepicker__time-box
      ul.react-datepicker__time-list
      li.react-datepicker__time-list-item--selected,
    .react-datepicker__day--selected,
    .react-datepicker__day--in-selecting-range,
    .react-datepicker__day--in-range,
    .react-datepicker__month-text--selected,
    .react-datepicker__month-text--in-selecting-range,
    .react-datepicker__month-text--in-range {
      box-shadow: none;
      background-color: var(--theme-elevation-150);
      color: var(--theme-elevation-800);
      font-weight: bold;
      border-radius: 0;
    }

    .react-datepicker__time-container
      .react-datepicker__time
      .react-datepicker__time-box
      ul.react-datepicker__time-list
      li.react-datepicker__time-list-item:hover {
      background: var(--theme-elevation-100);
    }

    .react-datepicker__day:hover,
    .react-datepicker__month-text:hover {
      border-radius: 0;
    }

    .react-datepicker__navigation--next--with-time:not(
        .react-datepicker__navigation--next--with-today-button
      ) {
      right: 130px;
    }

    .react-datepicker__time-container
      .react-datepicker__time
      .react-datepicker__time-box
      ul.react-datepicker__time-list
      li.react-datepicker__time-list-item {
      line-height: 20px;
      font-size: base(0.5);
    }

    &__appearance--dayOnly,
    &__appearance--monthOnly {
      .react-datepicker {
        &__month-container {
          border-right: none;
        }
      }
    }

    @include small-break {
      .react-datepicker {
        flex-direction: column;
      }
      .react-datepicker__month-container {
        border-right: 0;
      }
      .react-datepicker__time-container {
        width: auto;
      }
      .react-datepicker__header--time {
        background-color: var(--theme-elevation-100);
        padding: 8px 0;
        border-bottom: none;
      }
      .react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box {
        height: 120px;
        width: unset;
        > ul {
          height: 120px;
        }
      }
      .react-datepicker__navigation--next--with-time:not(
          .react-datepicker__navigation--next--with-today-button
        ) {
        right: 0px;
      }
      &__input-wrapper {
        .icon {
          top: calc(50% - #{base(0.25)});
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DatePicker/index.tsx">
import React, { lazy, Suspense } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
import { ShimmerEffect } from '../ShimmerEffect/index.js'
</file>

<file path="packages/ui/src/elements/DatePicker/library.scss">
// CSS manually copied into the payload-default layer from the react-datepicker library
// see: /node_modules/react-datepicker/dist/react-datepicker.css

@layer payload-default {
  .react-datepicker__year-read-view--down-arrow,
  .react-datepicker__month-read-view--down-arrow,
  .react-datepicker__month-year-read-view--down-arrow,
  .react-datepicker__navigation-icon::before {
    border-color: #ccc;
    border-style: solid;
    border-width: 3px 3px 0 0;
    content: '';
    display: block;
    height: 9px;
    position: absolute;
    top: 6px;
    width: 9px;
  }
  .react-datepicker-wrapper {
    display: inline-block;
    padding: 0;
    border: 0;
  }

  .react-datepicker {
    font-family: 'Helvetica Neue', helvetica, arial, sans-serif;
    font-size: 0.8rem;
    background-color: #fff;
    color: #000;
    border: 1px solid #aeaeae;
    border-radius: 0.3rem;
    display: inline-block;
    position: relative;
    line-height: initial;
  }

  .react-datepicker--time-only .react-datepicker__time-container {
    border-left: 0;
  }
  .react-datepicker--time-only .react-datepicker__time,
  .react-datepicker--time-only .react-datepicker__time-box {
    border-bottom-left-radius: 0.3rem;
    border-bottom-right-radius: 0.3rem;
  }

  .react-datepicker-popper {
    z-index: 1;
    line-height: 0;
  }
  .react-datepicker-popper .react-datepicker__triangle {
    stroke: #aeaeae;
  }
  .react-datepicker-popper[data-placement^='bottom'] .react-datepicker__triangle {
    fill: #f0f0f0;
    color: #f0f0f0;
  }
  .react-datepicker-popper[data-placement^='top'] .react-datepicker__triangle {
    fill: #fff;
    color: #fff;
  }

  .react-datepicker__header {
    text-align: center;
    background-color: #f0f0f0;
    border-bottom: 1px solid #aeaeae;
    border-top-left-radius: 0.3rem;
    padding: 8px 0;
    position: relative;
  }
  .react-datepicker__header--time {
    padding-bottom: 8px;
    padding-left: 5px;
    padding-right: 5px;
  }
  .react-datepicker__header--time:not(.react-datepicker__header--time--only) {
    border-top-left-radius: 0;
  }
  .react-datepicker__header:not(.react-datepicker__header--has-time-select) {
    border-top-right-radius: 0.3rem;
  }

  .react-datepicker__year-dropdown-container--select,
  .react-datepicker__month-dropdown-container--select,
  .react-datepicker__month-year-dropdown-container--select,
  .react-datepicker__year-dropdown-container--scroll,
  .react-datepicker__month-dropdown-container--scroll,
  .react-datepicker__month-year-dropdown-container--scroll {
    display: inline-block;
    margin: 0 15px;
  }

  .react-datepicker__current-month,
  .react-datepicker-time__header,
  .react-datepicker-year-header {
    margin-top: 0;
    color: #000;
    font-weight: bold;
    font-size: 0.944rem;
  }

  .react-datepicker-time__header {
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
  }

  .react-datepicker__navigation {
    align-items: center;
    background: none;
    display: flex;
    justify-content: center;
    text-align: center;
    cursor: pointer;
    position: absolute;
    top: 2px;
    padding: 0;
    border: none;
    z-index: 1;
    height: 32px;
    width: 32px;
    text-indent: -999em;
    overflow: hidden;
  }
  .react-datepicker__navigation--previous {
    left: 2px;
  }
  .react-datepicker__navigation--next {
    right: 2px;
  }
  .react-datepicker__navigation--next--with-time:not(
      .react-datepicker__navigation--next--with-today-button
    ) {
    right: 85px;
  }
  .react-datepicker__navigation--years {
    position: relative;
    top: 0;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
  .react-datepicker__navigation--years-previous {
    top: 4px;
  }
  .react-datepicker__navigation--years-upcoming {
    top: -4px;
  }
  .react-datepicker__navigation:hover *::before {
    border-color: #a6a6a6;
  }

  .react-datepicker__navigation-icon {
    position: relative;
    top: -1px;
    font-size: 20px;
    width: 0;
  }
  .react-datepicker__navigation-icon--next {
    left: -2px;
  }
  .react-datepicker__navigation-icon--next::before {
    transform: rotate(45deg);
    left: -7px;
  }
  .react-datepicker__navigation-icon--previous {
    right: -2px;
  }
  .react-datepicker__navigation-icon--previous::before {
    transform: rotate(225deg);
    right: -7px;
  }

  .react-datepicker__month-container {
    float: left;
  }

  .react-datepicker__year {
    margin: 0.4rem;
    text-align: center;
  }
  .react-datepicker__year-wrapper {
    display: flex;
    flex-wrap: wrap;
    max-width: 180px;
  }
  .react-datepicker__year .react-datepicker__year-text {
    display: inline-block;
    width: 4rem;
    margin: 2px;
  }

  .react-datepicker__month {
    margin: 0.4rem;
    text-align: center;
  }
  .react-datepicker__month .react-datepicker__month-text,
  .react-datepicker__month .react-datepicker__quarter-text {
    display: inline-block;
    width: 4rem;
    margin: 2px;
  }

  .react-datepicker__input-time-container {
    clear: both;
    width: 100%;
    float: left;
    margin: 5px 0 10px 15px;
    text-align: left;
  }
  .react-datepicker__input-time-container .react-datepicker-time__caption {
    display: inline-block;
  }
  .react-datepicker__input-time-container .react-datepicker-time__input-container {
    display: inline-block;
  }
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__input {
    display: inline-block;
    margin-left: 10px;
  }
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__input
    input {
    width: auto;
  }
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__input
    input[type='time']::-webkit-inner-spin-button,
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__input
    input[type='time']::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__input
    input[type='time'] {
    -moz-appearance: textfield;
  }
  .react-datepicker__input-time-container
    .react-datepicker-time__input-container
    .react-datepicker-time__delimiter {
    margin-left: 5px;
    display: inline-block;
  }

  .react-datepicker__time-container {
    float: right;
    border-left: 1px solid #aeaeae;
    width: 85px;
  }
  .react-datepicker__time-container--with-today-button {
    display: inline;
    border: 1px solid #aeaeae;
    border-radius: 0.3rem;
    position: absolute;
    right: -87px;
    top: 0;
  }
  .react-datepicker__time-container .react-datepicker__time {
    position: relative;
    background: white;
    border-bottom-right-radius: 0.3rem;
  }
  .react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box {
    width: 85px;
    overflow-x: hidden;
    margin: 0 auto;
    text-align: center;
    border-bottom-right-radius: 0.3rem;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list {
    list-style: none;
    margin: 0;
    height: calc(195px + 1.7rem / 2);
    overflow-y: scroll;
    padding-right: 0;
    padding-left: 0;
    width: 100%;
    box-sizing: content-box;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item {
    height: 30px;
    padding: 5px 10px;
    white-space: nowrap;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item:hover {
    cursor: pointer;
    background-color: #f0f0f0;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item--selected {
    background-color: #216ba5;
    color: white;
    font-weight: bold;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item--selected:hover {
    background-color: #216ba5;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item--disabled {
    color: #ccc;
  }
  .react-datepicker__time-container
    .react-datepicker__time
    .react-datepicker__time-box
    ul.react-datepicker__time-list
    li.react-datepicker__time-list-item--disabled:hover {
    cursor: default;
    background-color: transparent;
  }

  .react-datepicker__week-number {
    color: #ccc;
    display: inline-block;
    width: 1.7rem;
    line-height: 1.7rem;
    text-align: center;
    margin: 0.166rem;
  }
  .react-datepicker__week-number.react-datepicker__week-number--clickable {
    cursor: pointer;
  }
  .react-datepicker__week-number.react-datepicker__week-number--clickable:not(
      .react-datepicker__week-number--selected,
      .react-datepicker__week-number--keyboard-selected
    ):hover {
    border-radius: 0.3rem;
    background-color: #f0f0f0;
  }
  .react-datepicker__week-number--selected {
    border-radius: 0.3rem;
    background-color: #216ba5;
    color: #fff;
  }
  .react-datepicker__week-number--selected:hover {
    background-color: #1d5d90;
  }
  .react-datepicker__week-number--keyboard-selected {
    border-radius: 0.3rem;
    background-color: #2a87d0;
    color: #fff;
  }
  .react-datepicker__week-number--keyboard-selected:hover {
    background-color: #1d5d90;
  }

  .react-datepicker__day-names {
    white-space: nowrap;
    margin-bottom: -8px;
  }

  .react-datepicker__week {
    white-space: nowrap;
  }

  .react-datepicker__day-name,
  .react-datepicker__day,
  .react-datepicker__time-name {
    color: #000;
    display: inline-block;
    width: 1.7rem;
    line-height: 1.7rem;
    text-align: center;
    margin: 0.166rem;
  }

  .react-datepicker__day,
  .react-datepicker__month-text,
  .react-datepicker__quarter-text,
  .react-datepicker__year-text {
    cursor: pointer;
  }
  .react-datepicker__day:hover,
  .react-datepicker__month-text:hover,
  .react-datepicker__quarter-text:hover,
  .react-datepicker__year-text:hover {
    border-radius: 0.3rem;
    background-color: #f0f0f0;
  }
  .react-datepicker__day--today,
  .react-datepicker__month-text--today,
  .react-datepicker__quarter-text--today,
  .react-datepicker__year-text--today {
    font-weight: bold;
  }
  .react-datepicker__day--highlighted,
  .react-datepicker__month-text--highlighted,
  .react-datepicker__quarter-text--highlighted,
  .react-datepicker__year-text--highlighted {
    border-radius: 0.3rem;
    background-color: #3dcc4a;
    color: #fff;
  }
  .react-datepicker__day--highlighted:hover,
  .react-datepicker__month-text--highlighted:hover,
  .react-datepicker__quarter-text--highlighted:hover,
  .react-datepicker__year-text--highlighted:hover {
    background-color: #32be3f;
  }
  .react-datepicker__day--highlighted-custom-1,
  .react-datepicker__month-text--highlighted-custom-1,
  .react-datepicker__quarter-text--highlighted-custom-1,
  .react-datepicker__year-text--highlighted-custom-1 {
    color: magenta;
  }
  .react-datepicker__day--highlighted-custom-2,
  .react-datepicker__month-text--highlighted-custom-2,
  .react-datepicker__quarter-text--highlighted-custom-2,
  .react-datepicker__year-text--highlighted-custom-2 {
    color: green;
  }
  .react-datepicker__day--holidays,
  .react-datepicker__month-text--holidays,
  .react-datepicker__quarter-text--holidays,
  .react-datepicker__year-text--holidays {
    position: relative;
    border-radius: 0.3rem;
    background-color: #ff6803;
    color: #fff;
  }
  .react-datepicker__day--holidays .overlay,
  .react-datepicker__month-text--holidays .overlay,
  .react-datepicker__quarter-text--holidays .overlay,
  .react-datepicker__year-text--holidays .overlay {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: #fff;
    padding: 4px;
    border-radius: 4px;
    white-space: nowrap;
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 0s,
      opacity 0.3s ease-in-out;
  }
  .react-datepicker__day--holidays:hover,
  .react-datepicker__month-text--holidays:hover,
  .react-datepicker__quarter-text--holidays:hover,
  .react-datepicker__year-text--holidays:hover {
    background-color: #cf5300;
  }
  .react-datepicker__day--holidays:hover .overlay,
  .react-datepicker__month-text--holidays:hover .overlay,
  .react-datepicker__quarter-text--holidays:hover .overlay,
  .react-datepicker__year-text--holidays:hover .overlay {
    visibility: visible;
    opacity: 1;
  }
  .react-datepicker__day--selected,
  .react-datepicker__day--in-selecting-range,
  .react-datepicker__day--in-range,
  .react-datepicker__month-text--selected,
  .react-datepicker__month-text--in-selecting-range,
  .react-datepicker__month-text--in-range,
  .react-datepicker__quarter-text--selected,
  .react-datepicker__quarter-text--in-selecting-range,
  .react-datepicker__quarter-text--in-range,
  .react-datepicker__year-text--selected,
  .react-datepicker__year-text--in-selecting-range,
  .react-datepicker__year-text--in-range {
    border-radius: 0.3rem;
    background-color: #216ba5;
    color: #fff;
  }
  .react-datepicker__day--selected:hover,
  .react-datepicker__day--in-selecting-range:hover,
  .react-datepicker__day--in-range:hover,
  .react-datepicker__month-text--selected:hover,
  .react-datepicker__month-text--in-selecting-range:hover,
  .react-datepicker__month-text--in-range:hover,
  .react-datepicker__quarter-text--selected:hover,
  .react-datepicker__quarter-text--in-selecting-range:hover,
  .react-datepicker__quarter-text--in-range:hover,
  .react-datepicker__year-text--selected:hover,
  .react-datepicker__year-text--in-selecting-range:hover,
  .react-datepicker__year-text--in-range:hover {
    background-color: #1d5d90;
  }
  .react-datepicker__day--keyboard-selected,
  .react-datepicker__month-text--keyboard-selected,
  .react-datepicker__quarter-text--keyboard-selected,
  .react-datepicker__year-text--keyboard-selected {
    border-radius: 0.3rem;
    background-color: #bad9f1;
    color: rgb(0, 0, 0);
  }
  .react-datepicker__day--keyboard-selected:hover,
  .react-datepicker__month-text--keyboard-selected:hover,
  .react-datepicker__quarter-text--keyboard-selected:hover,
  .react-datepicker__year-text--keyboard-selected:hover {
    background-color: #1d5d90;
  }
  .react-datepicker__day--in-selecting-range:not(
      .react-datepicker__day--in-range,
      .react-datepicker__month-text--in-range,
      .react-datepicker__quarter-text--in-range,
      .react-datepicker__year-text--in-range
    ),
  .react-datepicker__month-text--in-selecting-range:not(
      .react-datepicker__day--in-range,
      .react-datepicker__month-text--in-range,
      .react-datepicker__quarter-text--in-range,
      .react-datepicker__year-text--in-range
    ),
  .react-datepicker__quarter-text--in-selecting-range:not(
      .react-datepicker__day--in-range,
      .react-datepicker__month-text--in-range,
      .react-datepicker__quarter-text--in-range,
      .react-datepicker__year-text--in-range
    ),
  .react-datepicker__year-text--in-selecting-range:not(
      .react-datepicker__day--in-range,
      .react-datepicker__month-text--in-range,
      .react-datepicker__quarter-text--in-range,
      .react-datepicker__year-text--in-range
    ) {
    background-color: rgba(33, 107, 165, 0.5);
  }
  .react-datepicker__month--selecting-range
    .react-datepicker__day--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__year--selecting-range
    .react-datepicker__day--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__month--selecting-range
    .react-datepicker__month-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__year--selecting-range
    .react-datepicker__month-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__month--selecting-range
    .react-datepicker__quarter-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__year--selecting-range
    .react-datepicker__quarter-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__month--selecting-range
    .react-datepicker__year-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ),
  .react-datepicker__year--selecting-range
    .react-datepicker__year-text--in-range:not(
      .react-datepicker__day--in-selecting-range,
      .react-datepicker__month-text--in-selecting-range,
      .react-datepicker__quarter-text--in-selecting-range,
      .react-datepicker__year-text--in-selecting-range
    ) {
    background-color: #f0f0f0;
    color: #000;
  }
  .react-datepicker__day--disabled,
  .react-datepicker__month-text--disabled,
  .react-datepicker__quarter-text--disabled,
  .react-datepicker__year-text--disabled {
    cursor: default;
    color: #ccc;
  }
  .react-datepicker__day--disabled:hover,
  .react-datepicker__month-text--disabled:hover,
  .react-datepicker__quarter-text--disabled:hover,
  .react-datepicker__year-text--disabled:hover {
    background-color: transparent;
  }
  .react-datepicker__day--disabled .overlay,
  .react-datepicker__month-text--disabled .overlay,
  .react-datepicker__quarter-text--disabled .overlay,
  .react-datepicker__year-text--disabled .overlay {
    position: absolute;
    bottom: 70%;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: #fff;
    padding: 4px;
    border-radius: 4px;
    white-space: nowrap;
    visibility: hidden;
    opacity: 0;
    transition:
      visibility 0s,
      opacity 0.3s ease-in-out;
  }

  .react-datepicker__input-container {
    position: relative;
    display: inline-block;
    width: 100%;
  }
  .react-datepicker__input-container .react-datepicker__calendar-icon {
    position: absolute;
    padding: 0.5rem;
    box-sizing: content-box;
  }

  .react-datepicker__view-calendar-icon input {
    padding: 6px 10px 5px 25px;
  }

  .react-datepicker__year-read-view,
  .react-datepicker__month-read-view,
  .react-datepicker__month-year-read-view {
    border: 1px solid transparent;
    border-radius: 0.3rem;
    position: relative;
  }
  .react-datepicker__year-read-view:hover,
  .react-datepicker__month-read-view:hover,
  .react-datepicker__month-year-read-view:hover {
    cursor: pointer;
  }
  .react-datepicker__year-read-view:hover .react-datepicker__year-read-view--down-arrow,
  .react-datepicker__year-read-view:hover .react-datepicker__month-read-view--down-arrow,
  .react-datepicker__month-read-view:hover .react-datepicker__year-read-view--down-arrow,
  .react-datepicker__month-read-view:hover .react-datepicker__month-read-view--down-arrow,
  .react-datepicker__month-year-read-view:hover .react-datepicker__year-read-view--down-arrow,
  .react-datepicker__month-year-read-view:hover .react-datepicker__month-read-view--down-arrow {
    border-top-color: #b3b3b3;
  }
  .react-datepicker__year-read-view--down-arrow,
  .react-datepicker__month-read-view--down-arrow,
  .react-datepicker__month-year-read-view--down-arrow {
    transform: rotate(135deg);
    right: -16px;
    top: 0;
  }

  .react-datepicker__year-dropdown,
  .react-datepicker__month-dropdown,
  .react-datepicker__month-year-dropdown {
    background-color: #f0f0f0;
    position: absolute;
    width: 50%;
    left: 25%;
    top: 30px;
    z-index: 1;
    text-align: center;
    border-radius: 0.3rem;
    border: 1px solid #aeaeae;
  }
  .react-datepicker__year-dropdown:hover,
  .react-datepicker__month-dropdown:hover,
  .react-datepicker__month-year-dropdown:hover {
    cursor: pointer;
  }
  .react-datepicker__year-dropdown--scrollable,
  .react-datepicker__month-dropdown--scrollable,
  .react-datepicker__month-year-dropdown--scrollable {
    height: 150px;
    overflow-y: scroll;
  }

  .react-datepicker__year-option,
  .react-datepicker__month-option,
  .react-datepicker__month-year-option {
    line-height: 20px;
    width: 100%;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
  .react-datepicker__year-option:first-of-type,
  .react-datepicker__month-option:first-of-type,
  .react-datepicker__month-year-option:first-of-type {
    border-top-left-radius: 0.3rem;
    border-top-right-radius: 0.3rem;
  }
  .react-datepicker__year-option:last-of-type,
  .react-datepicker__month-option:last-of-type,
  .react-datepicker__month-year-option:last-of-type {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    border-bottom-left-radius: 0.3rem;
    border-bottom-right-radius: 0.3rem;
  }
  .react-datepicker__year-option:hover,
  .react-datepicker__month-option:hover,
  .react-datepicker__month-year-option:hover {
    background-color: #ccc;
  }
  .react-datepicker__year-option:hover .react-datepicker__navigation--years-upcoming,
  .react-datepicker__month-option:hover .react-datepicker__navigation--years-upcoming,
  .react-datepicker__month-year-option:hover .react-datepicker__navigation--years-upcoming {
    border-bottom-color: #b3b3b3;
  }
  .react-datepicker__year-option:hover .react-datepicker__navigation--years-previous,
  .react-datepicker__month-option:hover .react-datepicker__navigation--years-previous,
  .react-datepicker__month-year-option:hover .react-datepicker__navigation--years-previous {
    border-top-color: #b3b3b3;
  }
  .react-datepicker__year-option--selected,
  .react-datepicker__month-option--selected,
  .react-datepicker__month-year-option--selected {
    position: absolute;
    left: 15px;
  }

  .react-datepicker__close-icon {
    cursor: pointer;
    background-color: transparent;
    border: 0;
    outline: 0;
    padding: 0 6px 0 0;
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    display: table-cell;
    vertical-align: middle;
  }
  .react-datepicker__close-icon::after {
    cursor: pointer;
    background-color: #216ba5;
    color: #fff;
    border-radius: 50%;
    height: 16px;
    width: 16px;
    padding: 2px;
    font-size: 12px;
    line-height: 1;
    text-align: center;
    display: table-cell;
    vertical-align: middle;
    content: '×';
  }
  .react-datepicker__close-icon--disabled {
    cursor: default;
  }
  .react-datepicker__close-icon--disabled::after {
    cursor: default;
    background-color: #ccc;
  }

  .react-datepicker__today-button {
    background: #f0f0f0;
    border-top: 1px solid #aeaeae;
    cursor: pointer;
    text-align: center;
    font-weight: bold;
    padding: 5px 0;
    clear: left;
  }

  .react-datepicker__portal {
    position: fixed;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    left: 0;
    top: 0;
    justify-content: center;
    align-items: center;
    display: flex;
    z-index: 2147483647;
  }
  .react-datepicker__portal .react-datepicker__day-name,
  .react-datepicker__portal .react-datepicker__day,
  .react-datepicker__portal .react-datepicker__time-name {
    width: 3rem;
    line-height: 3rem;
  }
  @media (max-width: 400px), (max-height: 550px) {
    .react-datepicker__portal .react-datepicker__day-name,
    .react-datepicker__portal .react-datepicker__day,
    .react-datepicker__portal .react-datepicker__time-name {
      width: 2rem;
      line-height: 2rem;
    }
  }
  .react-datepicker__portal .react-datepicker__current-month,
  .react-datepicker__portal .react-datepicker-time__header {
    font-size: 1.44rem;
  }

  .react-datepicker__children-container {
    width: 13.8rem;
    margin: 0.4rem;
    padding-right: 0.2rem;
    padding-left: 0.2rem;
    height: auto;
  }

  .react-datepicker__aria-live {
    position: absolute;
    clip-path: circle(0);
    border: 0;
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    width: 1px;
    white-space: nowrap;
  }

  .react-datepicker__calendar-icon {
    width: 1em;
    height: 1em;
    vertical-align: -0.125em;
  }
}
</file>

<file path="packages/ui/src/elements/DatePicker/types.ts">
import type { DayPickerProps, SharedProps, TimePickerProps } from '@convexcms/core'
⋮----
export type Props = {
  id?: string
  onChange?: (val: Date) => void
  placeholder?: string
  readOnly?: boolean
  value?: Date | string
} & DayPickerProps &
  SharedProps &
  TimePickerProps
</file>

<file path="packages/ui/src/elements/DeleteDocument/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .delete-document {
    @include blur-bg;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;

    &__toggle {
      @extend %btn-reset;
    }
  }
}
</file>

<file path="packages/ui/src/elements/DeleteDocument/index.tsx">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import type { DocumentDrawerContextType } from '../DocumentDrawer/Provider.js'
⋮----
import { useForm } from '../../forms/Form/context.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
import { PopupList } from '../Popup/index.js'
import { Translation } from '../Translation/index.js'
⋮----
export type Props = {
  readonly buttonId?: string
  readonly collectionSlug: SanitizedCollectionConfig['slug']
  readonly id?: string
  readonly onDelete?: DocumentDrawerContextType['onDelete']
  readonly redirectAfterDelete?: boolean
  readonly singularLabel: SanitizedCollectionConfig['labels']['singular']
  readonly title?: string
  readonly useAsTitle: SanitizedCollectionConfig['admin']['useAsTitle']
}
</file>

<file path="packages/ui/src/elements/DeleteMany/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .delete-documents {
    @include blur-bg;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;

    &__toggle {
      font-size: inherit;
      line-height: inherit;
      display: inline-flex;
      background: transparent;
      color: var(--theme-elevation-800);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 0;
      padding: 0;
      align-items: center;
      cursor: pointer;
      text-decoration: underline;
    }
  }
}
</file>

<file path="packages/ui/src/elements/DeleteMany/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter, useSearchParams } from 'next/navigation.js'
import { mergeListSearchAndWhere } from '@convexcms/core/shared'
⋮----
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useRouteCache } from '../../providers/RouteCache/index.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
⋮----
export type Props = {
  collection: ClientCollectionConfig
  title?: string
}
</file>

<file path="packages/ui/src/elements/DocumentControls/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .doc-controls {
    @include blur-bg-light;
    position: sticky;
    top: 0;
    width: 100%;
    z-index: 5;
    display: flex;
    align-items: center;

    &__divider {
      content: '';
      display: block;
      position: absolute;
      height: 1px;
      background: var(--theme-elevation-100);
      width: 100%;
      left: 0;
      top: 100%;
    }

    &__wrapper {
      position: relative;
      width: 100%;
      display: flex;
      align-items: space-between;
      gap: var(--base);
      padding-bottom: 1px;
      z-index: 4;
      height: var(--doc-controls-height);
    }

    &__content {
      display: flex;
      align-items: center;
      flex-grow: 1;
      overflow: hidden;
      padding: base(0.8) 0;
    }

    &__meta {
      flex-grow: 1;
      display: flex;
      list-style: none;
      padding: 0;
      gap: var(--base);
      margin: 0;
      width: 100%;

      & button {
        margin: 0;
      }
    }

    &__locked-controls.locked {
      position: unset;

      .tooltip {
        top: calc(var(--base) * -0.5);
      }
    }

    &__list-item {
      display: flex;
      align-items: center;
      margin: 0;
    }

    &__value-wrap {
      overflow: hidden;
    }

    &__value {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin: 0;
      font-weight: 600;
      line-height: base(1.2);
    }

    &__label {
      color: var(--theme-elevation-500);
      white-space: nowrap;
      margin: 0;
    }

    &__controls-wrapper {
      --controls-gap: calc(var(--base) / 2);
      --dot-button-width: calc(var(--base) * 2);
      display: flex;
      align-items: center;
      margin: 0;
      gap: var(--controls-gap);
      position: relative;
    }

    &__controls {
      display: flex;
      align-items: center;
      margin: 0;
      gap: calc(var(--base) / 2);

      button {
        margin: 0;
        white-space: nowrap;
      }
    }

    &__dots {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 2px;
      border: 1px solid var(--theme-elevation-100);
      border-radius: $style-radius-m;
      height: calc(var(--base) * 1.6);
      width: calc(var(--base) * 1.6);

      &:hover {
        border: 1px solid var(--theme-elevation-500);
        background-color: var(--theme-elevation-100);
      }

      > div {
        width: 3px;
        height: 3px;
        border-radius: 100%;
        background-color: currentColor;
      }
    }

    &__popup {
      position: relative;
    }

    .popup--active {
      .doc-controls {
        &__dots {
          border: 1px solid var(--theme-elevation-500);
          background-color: var(--theme-elevation-100);
        }
      }
    }

    .popup__trigger-wrap {
      display: flex;
    }

    @include mid-break {
      // On mobile, only stick the controls to the top
      // The timestamps and meta can scroll past
      // The same container needs to the sticky, though
      // So we use a static height with a negative top equal to the meta height plus top padding
      top: base(-2.8);
      padding-right: 0;
      padding-left: 0;

      &__wrapper {
        flex-direction: column;
        gap: 0;
        height: unset;
      }

      &__content {
        width: 100%;
        overflow: auto;
        padding-inline: base(2);
        // this container has a fixed height
        // this means the scrollbar (when present) overlaps the content
        &::-webkit-scrollbar {
          display: none;
        }
      }

      &__meta {
        width: auto;
        gap: calc(var(--base) / 2);

        &::after {
          content: '';
          display: block;
          position: absolute;
          right: 0;
          width: base(0.8);
          height: var(--base);
          background: linear-gradient(to right, transparent, var(--theme-bg));
          flex-shrink: 0;
          z-index: 1111;
          pointer-events: none;
        }
      }

      &__controls-wrapper {
        background-color: var(--theme-bg);
        width: 100%;
        transform: translate3d(0, 0, 0);
        padding-right: var(--gutter-h);
        justify-content: space-between;
        height: var(--doc-controls-height);
        border-top: 1px solid var(--theme-elevation-100);
      }

      &__controls {
        padding-left: var(--gutter-h);
        overflow: auto;

        // do not show scrollbar because the parent container has a static height
        // this container has a gradient overlay as visual indication of `overflow: scroll`
        &::-webkit-scrollbar {
          display: none;
        }

        &::after {
          content: '';
          display: block;
          position: sticky;
          right: 0;
          width: calc(var(--base) * 2);
          height: calc(var(--base) * 1.5);
          background: linear-gradient(to right, transparent, var(--theme-bg));
          flex-shrink: 0;
          z-index: 1111;
          pointer-events: none;
        }
      }
    }

    @include small-break {
      &__content {
        padding-inline: base(0.8);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentControls/index.tsx">
import type {
  ClientUser,
  SanitizedCollectionConfig,
  SanitizedCollectionPermission,
  SanitizedGlobalPermission,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { Fragment, useEffect } from 'react'
⋮----
import type { DocumentDrawerContextType } from '../DocumentDrawer/Provider.js'
⋮----
import { useFormInitializing, useFormProcessing } from '../../forms/Form/context.js'
import { useConfig } from '../../providers/Config/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { formatDate } from '../../utilities/formatDocTitle/formatDateTitle.js'
import { Autosave } from '../Autosave/index.js'
import { Button } from '../Button/index.js'
import { CopyLocaleData } from '../CopyLocaleData/index.js'
import { DeleteDocument } from '../DeleteDocument/index.js'
import { DuplicateDocument } from '../DuplicateDocument/index.js'
import { Gutter } from '../Gutter/index.js'
import { Locked } from '../Locked/index.js'
import { Popup, PopupList } from '../Popup/index.js'
import { PreviewButton } from '../PreviewButton/index.js'
import { PublishButton } from '../PublishButton/index.js'
import { RenderCustomComponent } from '../RenderCustomComponent/index.js'
import { SaveButton } from '../SaveButton/index.js'
import { SaveDraftButton } from '../SaveDraftButton/index.js'
import { Status } from '../Status/index.js'
⋮----
/* Only available if `redirectAfterDuplicate` is `false` */
⋮----
// Settings these in state to avoid hydration issues if there is a mismatch between the server and client
⋮----
id=
</file>

<file path="packages/ui/src/elements/DocumentDrawer/DrawerHeader/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .doc-drawer {
    &__header {
      width: 100%;
      margin-top: base(2.5);
      display: flex;
      flex-direction: column;
      gap: base(0.5);
      align-items: flex-start;
    }

    &__header-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
    }

    &__header-text {
      margin: 0;
    }

    &__header-toggler {
      background: transparent;
      border: 0;
      margin: 0;
      padding: 0;
      cursor: pointer;
      color: inherit;

      &:focus,
      &:focus-within {
        outline: none;
      }

      &:disabled {
        pointer-events: none;
      }
    }

    &__header-close {
      border: 0;
      background-color: transparent;
      padding: 0;
      cursor: pointer;
      overflow: hidden;
      width: base(2);
      height: base(2);

      svg {
        width: base(2);
        height: base(2);
        position: relative;

        .stroke {
          stroke-width: 2px;
          vector-effect: non-scaling-stroke;
        }
      }
    }

    @include mid-break {
      .doc-drawer__header {
        margin-top: base(1.5);
        margin-bottom: base(0.5);
        padding-left: var(--gutter-h);
        padding-right: var(--gutter-h);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentDrawer/DrawerHeader/index.tsx">
import { Gutter } from '../../../elements/Gutter/index.js'
import { useModal } from '../../../elements/Modal/index.js'
import { RenderTitle } from '../../../elements/RenderTitle/index.js'
import { XIcon } from '../../../icons/X/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { IDLabel } from '../../IDLabel/index.js'
import { documentDrawerBaseClass } from '../index.js'
⋮----
return id && id !== title ? <IDLabel id=
</file>

<file path="packages/ui/src/elements/DocumentDrawer/DrawerContent.tsx">
import { useModal } from '@faceless-ui/modal'
import React, { useCallback, useEffect, useRef, useState } from 'react'
import { toast } from 'sonner'
⋮----
import type { DocumentDrawerProps } from './types.js'
⋮----
import { LoadingOverlay } from '../../elements/Loading/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { abortAndIgnore, handleAbortRef } from '../../utilities/abortAndIgnore.js'
import { DocumentDrawerContextProvider } from './Provider.js'
⋮----
export const DocumentDrawerContent: React.FC<DocumentDrawerProps> = ({
  id: existingDocID,
  AfterFields,
  collectionSlug,
  disableActions,
  drawerSlug,
  Header,
  initialData,
  onDelete: onDeleteFromProps,
  onDuplicate: onDuplicateFromProps,
  onSave: onSaveFromProps,
  overrideEntityVisibility = true,
  redirectAfterCreate,
  redirectAfterDelete,
  redirectAfterDuplicate,
}) =>
⋮----
const fetchDocumentView = async () =>
⋮----
// toast.error(data?.errors?.[0].message || t('error:unspecific'))
⋮----
// Cleanup any pending requests when the component unmounts
</file>

<file path="packages/ui/src/elements/DocumentDrawer/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .doc-drawer {
    &__toggler {
      background: transparent;
      border: 0;
      margin: 0;
      padding: 0;
      cursor: pointer;
      color: inherit;

      &:focus,
      &:focus-within {
        outline: none;
      }

      &:disabled {
        pointer-events: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentDrawer/index.tsx">
import { useModal } from '@faceless-ui/modal'
import React, { useCallback, useEffect, useId, useMemo, useState } from 'react'
⋮----
import type { DocumentDrawerProps, DocumentTogglerProps, UseDocumentDrawer } from './types.js'
⋮----
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { useRelatedCollections } from '../AddNewRelation/useRelatedCollections.js'
import { Drawer, DrawerToggler } from '../Drawer/index.js'
import { DocumentDrawerContent } from './DrawerContent.js'
⋮----
const formatDocumentDrawerSlug = (
⋮----
uuid: string // supply when creating a new document and no id is available
</file>

<file path="packages/ui/src/elements/DocumentDrawer/Provider.tsx">
import type { ClientCollectionConfig, Data, FormState, TypeWithID } from '@convexcms/core'
⋮----
import { createContext, use } from 'react'
⋮----
export type DocumentDrawerContextProps = {
  readonly clearDoc?: () => void
  readonly drawerSlug: string
  readonly onDelete?: (args: {
    collectionConfig?: ClientCollectionConfig
    id: string
  }) => Promise<void> | void
  /* only available if `redirectAfterDuplicate` is `false` */
  readonly onDuplicate?: (args: {
    collectionConfig?: ClientCollectionConfig
    doc: TypeWithID
  }) => Promise<void> | void
  readonly onSave?: (args: {
    collectionConfig?: ClientCollectionConfig
    doc: TypeWithID
    operation: 'create' | 'update'
    result: Data
  }) => Promise<FormState | void> | void
}
⋮----
/* only available if `redirectAfterDuplicate` is `false` */
⋮----
export type DocumentDrawerContextType = DocumentDrawerContextProps
⋮----
export const DocumentDrawerContextProvider: React.FC<
  {
    children: React.ReactNode
  } & DocumentDrawerContextProps
> = (
⋮----
export const useDocumentDrawerContext = (): DocumentDrawerContextType =>
</file>

<file path="packages/ui/src/elements/DocumentDrawer/types.ts">
import type { Data, FormState } from '@convexcms/core'
import type React from 'react'
import type { HTMLAttributes } from 'react'
⋮----
import type { Props as DrawerProps } from '../Drawer/types.js'
import type { DocumentDrawerContextProps } from './Provider.js'
⋮----
export type DocumentDrawerProps = {
  readonly AfterFields?: React.ReactNode
  readonly collectionSlug: string
  readonly disableActions?: boolean
  readonly drawerSlug?: string
  readonly id?: null | number | string
  readonly initialData?: Data
  /**
   * @deprecated
   */
  readonly initialState?: FormState
  readonly overrideEntityVisibility?: boolean
  readonly redirectAfterCreate?: boolean
  readonly redirectAfterDelete?: boolean
  readonly redirectAfterDuplicate?: boolean
} & Pick<DocumentDrawerContextProps, 'onDelete' | 'onDuplicate' | 'onSave'> &
  Pick<DrawerProps, 'Header'>
⋮----
/**
   * @deprecated
   */
⋮----
export type DocumentTogglerProps = {
  readonly children?: React.ReactNode
  readonly className?: string
  readonly collectionSlug: string
  readonly disabled?: boolean
  readonly drawerSlug?: string
  readonly id?: string
  readonly onClick?: () => void
} & Readonly<HTMLAttributes<HTMLButtonElement>>
⋮----
export type UseDocumentDrawer = (args: {
  collectionSlug: string
  id?: number | string
  overrideEntityVisibility?: boolean
}) => [
  React.FC<Omit<DocumentDrawerProps, 'collectionSlug' | 'id'>>, // drawer
  React.FC<Omit<DocumentTogglerProps, 'collectionSlug' | 'id'>>, // toggler
  {
    closeDrawer: () => void
    drawerDepth: number
    drawerSlug: string
    isDrawerOpen: boolean
    openDrawer: () => void
    toggleDrawer: () => void
  },
]
⋮----
React.FC<Omit<DocumentDrawerProps, 'collectionSlug' | 'id'>>, // drawer
React.FC<Omit<DocumentTogglerProps, 'collectionSlug' | 'id'>>, // toggler
</file>

<file path="packages/ui/src/elements/DocumentFields/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .document-fields {
    width: 100%;
    display: flex;
    --doc-sidebar-width: 325px;

    &--has-sidebar {
      .document-fields {
        &__main {
          width: 66.66%;
        }

        &__edit {
          [dir='ltr'] & {
            top: 0;
            right: 0;
            border-right: 1px solid var(--theme-elevation-100);
            padding-right: calc(var(--base) * 2);
          }

          [dir='rtl'] & {
            top: 0;
            left: 0;
            border-left: 1px solid var(--theme-elevation-100);
            padding-left: calc(var(--base) * 2);
          }
        }

        &__fields {
          & > .tabs-field,
          & > .group-field {
            margin-right: calc(var(--base) * -2);
          }
        }
      }
    }

    &__main {
      width: 100%;
      display: flex;
      flex-direction: column;
      min-height: 100%;
      flex-grow: 1;
    }

    &__edit {
      padding-top: calc(var(--base) * 1.5);
      padding-bottom: var(--spacing-view-bottom);
      flex-grow: 1;
    }

    &__sidebar-wrap {
      position: sticky;
      top: var(--doc-controls-height);
      width: 33.33%;
      height: calc(100vh - var(--doc-controls-height));
      min-width: var(--doc-sidebar-width);
      flex-shrink: 0;
    }

    &__sidebar {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__sidebar-fields {
      display: flex;
      flex-direction: column;
      gap: var(--base);
      padding-top: calc(var(--base) * 1.5);
      padding-left: calc(var(--base) * 2);
      padding-right: var(--gutter-h);
      padding-bottom: var(--spacing-view-bottom);
    }

    &__label {
      color: var(--theme-elevation-400);
    }

    &--force-sidebar-wrap {
      display: block;

      .document-fields {
        &__main {
          width: 100%;
          min-height: initial;
        }

        &__sidebar-wrap {
          position: static;
          width: 100%;
          height: initial;
          border-left: 0;
        }

        &__sidebar {
          padding-bottom: base(3.5);
          overflow: visible;
        }

        &__sidebar-fields {
          padding-top: 0;
          padding-left: var(--gutter-h);
          padding-bottom: 0;
        }
      }
    }

    @include mid-break {
      display: block;

      &--has-sidebar {
        .document-fields {
          &__main {
            width: 100%;
          }

          &__edit {
            [dir='ltr'] & {
              border-right: 0;
              padding-right: var(--gutter-h);
            }

            [dir='rtl'] & {
              border-left: 0;
              padding-left: var(--gutter-h);
            }
          }

          &__fields {
            & > .tabs-field,
            & > .group-field {
              margin-right: calc(var(--gutter-h) * -1);
            }
          }
        }
      }

      &__main {
        width: 100%;
        min-height: initial;
      }

      &__sidebar-wrap {
        position: static;
        width: 100%;
        height: initial;
        border-left: 0;
      }

      &__form {
        display: block;
      }

      &__sidebar-fields {
        padding-top: 0;
        padding-left: var(--gutter-h);
        padding-right: var(--gutter-h);
        padding-bottom: 0;
        gap: base(0.5);

        [dir='ltr'] & {
          padding-right: var(--gutter-h);
        }

        [dir='rtl'] & {
          padding-left: var(--gutter-h);
        }
      }

      &__sidebar {
        padding-bottom: base(3.5);
        overflow: visible;
      }
    }

    @include small-break {
      &__sidebar-wrap {
        min-width: initial;
        width: 100%;
      }

      &__edit {
        padding-top: calc(var(--base) / 2);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentFields/index.tsx">
import type { ClientField, SanitizedDocumentPermissions } from '@convexcms/core'
⋮----
import { fieldIsSidebar } from '@convexcms/core/shared'
import React, { useMemo } from 'react'
⋮----
import { useFormInitializing, useFormProcessing } from '../../forms/Form/context.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { Gutter } from '../Gutter/index.js'
⋮----
type Args = {
  readonly AfterFields?: React.ReactNode
  readonly BeforeFields?: React.ReactNode
  readonly Description?: React.ReactNode
  readonly docPermissions: SanitizedDocumentPermissions
  readonly fields: ClientField[]
  readonly forceSidebarWrap?: boolean
  readonly readOnly?: boolean
  readonly schemaPathSegments: string[]
}
</file>

<file path="packages/ui/src/elements/DocumentLocked/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .document-locked {
    @include blur-bg;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;

    &__wrapper {
      z-index: 1;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: var(--base);
      padding: base(2);
    }

    &__content {
      display: flex;
      flex-direction: column;
      gap: var(--base);
      max-width: base(36);

      > * {
        margin: 0;
      }
    }

    &__controls {
      display: flex;
      gap: var(--base);

      .btn {
        margin: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentLocked/index.tsx">
import type { ClientUser } from '@convexcms/core'
⋮----
import React, { useEffect } from 'react'
⋮----
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { isClientUserObject } from '../../utilities/isClientUserObject.js'
import { Button } from '../Button/index.js'
import { Modal, useModal } from '../Modal/index.js'
⋮----
const formatDate = (date) =>
⋮----
</file>

<file path="packages/ui/src/elements/DocumentTakeOver/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .document-take-over {
    @include blur-bg;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;

    &__wrapper {
      z-index: 1;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: var(--base);
      padding: base(2);
    }

    &__content {
      display: flex;
      flex-direction: column;
      gap: var(--base);

      > * {
        margin: 0;
      }
    }

    &__controls {
      display: flex;
      gap: var(--base);

      .btn {
        margin: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/DocumentTakeOver/index.tsx">
import React, { useEffect } from 'react'
⋮----
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
import { Modal, useModal } from '../Modal/index.js'
</file>

<file path="packages/ui/src/elements/DraggableSortable/DraggableSortableItem/index.tsx">
import type { UseDraggableArguments } from '@dnd-kit/core'
⋮----
import React, { Fragment } from 'react'
⋮----
import type { ChildFunction } from './types.js'
⋮----
import { useDraggableSortable } from '../useDraggableSortable/index.js'
</file>

<file path="packages/ui/src/elements/DraggableSortable/DraggableSortableItem/types.ts">
import type { UseDraggableArguments } from '@dnd-kit/core'
import type { SyntheticListenerMap } from '@dnd-kit/core/dist/hooks/utilities'
import type React from 'react'
⋮----
import type { UseDraggableSortableReturn } from '../useDraggableSortable/types.js'
⋮----
export type DragHandleProps = {
  attributes: UseDraggableArguments['attributes']
  listeners: SyntheticListenerMap
} & UseDraggableArguments
⋮----
export type ChildFunction = (args: UseDraggableSortableReturn) => React.ReactNode
⋮----
export type Props = {
  children: ChildFunction
} & UseDraggableArguments
</file>

<file path="packages/ui/src/elements/DraggableSortable/useDraggableSortable/index.tsx">
import type { UseDraggableArguments } from '@dnd-kit/core'
⋮----
import { useSortable } from '@dnd-kit/sortable'
⋮----
import type { UseDraggableSortableReturn } from './types.js'
⋮----
export const useDraggableSortable = (props: UseDraggableArguments): UseDraggableSortableReturn =>
⋮----
transform: transform && `translate3d(${transform.x}px, ${transform.y}px, 0)`, // translate3d is faster than translate in most browsers
</file>

<file path="packages/ui/src/elements/DraggableSortable/useDraggableSortable/types.ts">
import type { SyntheticListenerMap } from '@dnd-kit/core/dist/hooks/utilities'
import type { HTMLAttributes } from 'react'
⋮----
export type UseDraggableSortableReturn = {
  readonly attributes: HTMLAttributes<unknown>
  readonly isDragging?: boolean
  readonly listeners: SyntheticListenerMap
  readonly setNodeRef: (node: HTMLElement | null) => void
  readonly transform: string
  readonly transition: string
}
</file>

<file path="packages/ui/src/elements/DraggableSortable/index.tsx">
import type { DragEndEvent, DragStartEvent } from '@dnd-kit/core'
⋮----
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useDroppable,
  useSensor,
  useSensors,
} from '@dnd-kit/core'
import { SortableContext, sortableKeyboardCoordinates } from '@dnd-kit/sortable'
import React, { useCallback, useId } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
export const DraggableSortable: React.FC<Props> = (props) =>
</file>

<file path="packages/ui/src/elements/DraggableSortable/types.ts">
import type { DragEndEvent, DragStartEvent } from '@dnd-kit/core'
import type { Ref } from 'react'
⋮----
export type Props = {
  children: React.ReactNode
  className?: string
  droppableRef?: Ref<HTMLElement>
  ids: string[]
  onDragEnd: (e: { event: DragEndEvent; moveFromIndex: number; moveToIndex: number }) => void
  onDragStart?: (e: { event: DragStartEvent; id: number | string }) => void
}
</file>

<file path="packages/ui/src/elements/Drawer/index.scss">
@import '../../scss/styles.scss';

$transTime: 200;

@layer payload-default {
  .drawer {
    display: flex;
    overflow: hidden;
    position: fixed;
    height: 100vh;

    &__blur-bg {
      @include blur-bg;
      position: absolute;
      z-index: 1;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      opacity: 0;
      transition: all #{$transTime}ms linear;
    }

    &__content {
      opacity: 0;
      transform: translateX(calc(var(--base) * 4));
      position: relative;
      z-index: 2;
      // NOTE: width is controlled by js
      // width: calc(100% - var(--gutter-h));
      overflow: hidden;
      transition: all #{$transTime}ms linear;
      background-color: var(--theme-bg);
    }

    &__content-children {
      position: relative;
      z-index: 1;
      overflow: auto;
      height: 100%;
    }

    &--is-open {
      .drawer {
        &__content,
        &__blur-bg {
          opacity: 1;
        }

        &__close {
          opacity: 0.1;
          transition: opacity #{$transTime}ms linear;
          transition-delay: #{calc($transTime / 2)}ms;
        }

        &__content {
          transform: translateX(0);
        }
      }
    }

    &__close {
      @extend %btn-reset;
      position: relative;
      z-index: 2;
      flex-shrink: 0;
      text-indent: -9999px;
      cursor: pointer;
      opacity: 0;
      will-change: opacity;
      transition: none;
      transition-delay: 0ms;
      flex-grow: 1;
      background: var(--theme-elevation-800);

      &:active,
      &:focus {
        outline: 0;
      }
    }

    &__header {
      display: flex;
      align-items: center;
      margin-top: base(2.5);
      margin-bottom: base(1);
      width: 100%;

      &__title {
        margin: 0;
        flex-grow: 1;
      }

      &__close {
        border: 0;
        background-color: transparent;
        padding: 0;
        cursor: pointer;
        overflow: hidden;
        direction: ltr;
        display: flex;
        align-items: center;
        justify-content: center;
        width: base(1.2);
        height: base(1.2);

        svg {
          margin: base(-1.2);
          width: base(2.4);
          height: base(2.4);

          position: relative;

          .stroke {
            stroke-width: 1px;
            vector-effect: non-scaling-stroke;
          }
        }
      }
    }

    @include mid-break {
      &__header {
        margin-top: base(1.5);
      }
    }
  }

  html[data-theme='dark'] {
    .drawer {
      &__close {
        background: var(--color-base-1000);
      }

      &--is-open {
        .drawer__close {
          opacity: 0.25;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Drawer/index.tsx">
import { Modal, useModal } from '@faceless-ui/modal'
import React, { createContext, use, useCallback, useEffect, useState } from 'react'
⋮----
import type { Props, TogglerProps } from './types.js'
⋮----
import { XIcon } from '../../icons/X/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Gutter } from '../Gutter/index.js'
⋮----
export const formatDrawerSlug = (
⋮----
export const DrawerToggler: React.FC<TogglerProps> = ({
  slug,
  children,
  className,
  disabled,
  onClick,
  ...rest
}) =>
⋮----
// IMPORTANT: do not render the drawer until it is explicitly open, this is to avoid large html trees especially when nesting drawers
⋮----
{/* TODO: the `button` HTML element breaks CSS transitions on the drawer for some reason...
                    i.e. changing to a `div` element will fix the animation issue but will break accessibility
                  */}
⋮----
const parentDepth = useDrawerDepth()
⋮----
export const useDrawerDepth = (): number
</file>

<file path="packages/ui/src/elements/Drawer/types.ts">
import type { HTMLAttributes } from 'react'
⋮----
export type Props = {
  readonly children: React.ReactNode
  readonly className?: string
  readonly gutter?: boolean
  readonly Header?: React.ReactNode
  readonly hoverTitle?: boolean
  readonly slug: string
  readonly title?: string
}
⋮----
export type TogglerProps = {
  children: React.ReactNode
  className?: string
  disabled?: boolean
  slug: string
} & HTMLAttributes<HTMLButtonElement>
</file>

<file path="packages/ui/src/elements/Drawer/useDrawerSlug.tsx">
import { useId } from 'react'
⋮----
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { formatDrawerSlug } from './index.js'
⋮----
export const useDrawerSlug = (slug: string): string =>
</file>

<file path="packages/ui/src/elements/Dropzone/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .dropzone {
    position: relative;
    display: flex;
    align-items: center;
    padding: calc(var(--base) * 0.9) var(--base);
    background: transparent;
    border: 1px dotted var(--theme-elevation-400);
    border-radius: var(--style-radius-s);
    height: 100%;
    width: 100%;
    box-shadow: 0 0 0 0 transparent;
    transition: all 100ms cubic-bezier(0, 0.2, 0.2, 1);

    .btn {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    &.dragging {
      border-color: var(--theme-success-500);
      background: var(--theme-success-150);
      @include shadow-m;

      * {
        pointer-events: none;
      }
    }

    @include mid-break {
      display: block;
      text-align: center;
    }

    &.dropzoneStyle--none {
      all: unset;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Dropzone/index.tsx">
import React from 'react'
⋮----
const handleDragOver = (e: DragEvent) =>
⋮----
export type Props = {
  readonly children?: React.ReactNode
  readonly className?: string
  readonly disabled?: boolean
  readonly dropzoneStyle?: 'default' | 'none'
  readonly multipleFiles?: boolean
  readonly onChange: (e: FileList) => void
}
⋮----
export function Dropzone({
  children,
  className,
  disabled = false,
  dropzoneStyle = 'default',
  multipleFiles,
  onChange,
}: Props)
</file>

<file path="packages/ui/src/elements/DuplicateDocument/index.tsx">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import type { DocumentDrawerContextType } from '../DocumentDrawer/Provider.js'
⋮----
import { useForm, useFormModified } from '../../forms/Form/context.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
import { PopupList } from '../Popup/index.js'
⋮----
export type Props = {
  readonly id: string
  readonly onDuplicate?: DocumentDrawerContextType['onDuplicate']
  readonly redirectAfterDuplicate?: boolean
  readonly singularLabel: SanitizedCollectionConfig['labels']['singular']
  readonly slug: string
}
⋮----
body=
confirmLabel=
heading=
</file>

<file path="packages/ui/src/elements/EditMany/DrawerContent.tsx">
import type { SelectType } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter, useSearchParams } from 'next/navigation.js'
import { mergeListSearchAndWhere, unflatten } from '@convexcms/core/shared'
⋮----
import React, { useCallback, useEffect, useMemo, useState } from 'react'
⋮----
import type { FormProps } from '../../forms/Form/index.js'
import type { OnFieldSelect } from '../FieldSelect/index.js'
import type { FieldOption } from '../FieldSelect/reduceFieldOptions.js'
⋮----
import { useForm } from '../../forms/Form/context.js'
import { Form } from '../../forms/Form/index.js'
import { RenderField } from '../../forms/RenderFields/RenderField.js'
import { FormSubmit } from '../../forms/Submit/index.js'
import { XIcon } from '../../icons/X/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { DocumentInfoProvider } from '../../providers/DocumentInfo/index.js'
import { OperationContext } from '../../providers/Operation/index.js'
import { useRouteCache } from '../../providers/RouteCache/index.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { abortAndIgnore, handleAbortRef } from '../../utilities/abortAndIgnore.js'
import { parseSearchParams } from '../../utilities/parseSearchParams.js'
import { FieldSelect } from '../FieldSelect/index.js'
import { baseClass, type EditManyProps } from './index.js'
⋮----
const onSuccess = () =>
⋮----
clearRouteCache() // Use clearRouteCache instead of router.refresh, as we only need to clear the cache if the user has route caching enabled - clearRouteCache checks for this
</file>

<file path="packages/ui/src/elements/EditMany/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .edit-many {
    &__toggle {
      font-size: inherit;
      line-height: inherit;
      display: inline-flex;
      background: transparent;
      color: var(--theme-elevation-800);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 0;
      padding: 0;
      align-items: center;
      cursor: pointer;
      text-decoration: underline;
    }

    &__form {
      height: 100%;
    }

    &__main {
      width: calc(100% - #{base(15)});
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__header {
      display: flex;
      margin-top: base(2.5);
      margin-bottom: base(1);
      width: 100%;

      &__title {
        margin: 0;
        flex-grow: 1;
      }

      &__close {
        border: 0;
        background-color: transparent;
        padding: 0;
        cursor: pointer;
        overflow: hidden;
        width: base(1);
        height: base(1);

        svg {
          width: base(2);
          height: base(2);
          position: relative;
          inset-inline-start: base(-0.5);
          top: base(-0.5);

          .stroke {
            stroke-width: 2px;
            vector-effect: non-scaling-stroke;
          }
        }
      }
    }

    &__edit {
      padding-top: base(1);
      padding-bottom: base(2);
      flex-grow: 1;
    }
    [dir='rtl'] &__sidebar-wrap {
      left: 0;
      border-right: 1px solid var(--theme-elevation-100);
      right: auto;
    }

    &__sidebar-wrap {
      position: fixed;
      width: base(15);
      height: 100%;
      top: 0;
      right: 0;
      overflow: visible;
      border-left: 1px solid var(--theme-elevation-100);
    }

    &__sidebar {
      width: 100%;
      height: 100%;
      overflow-y: auto;
    }

    &__sidebar-sticky-wrap {
      display: flex;
      flex-direction: column;
      min-height: 100%;
    }

    &__collection-actions,
    &__meta,
    &__sidebar-fields {
      [dir='ltr'] & {
        padding-left: base(1.5);
      }
      [dir='rtl'] & {
        padding-right: base(1.5);
      }
    }

    &__document-actions {
      padding-right: $baseline;
      position: sticky;
      top: 0;
      z-index: var(--z-nav);

      > * {
        position: relative;
        z-index: 1;
      }

      @include mid-break {
        @include blur-bg;
      }
    }

    &__save {
      width: calc(50% - #{base(1)});

      @include mid-break {
        width: 100%;
      }
    }

    &__publish,
    &__draft {
      width: 100%;
    }

    &__document-actions {
      display: flex;
      padding: base(1);
      gap: base(0.5);

      .form-submit {
        width: 100%;

        @include mid-break {
          width: auto;
          flex-grow: 1;
        }

        .btn {
          padding-left: base(0.5);
          padding-right: base(0.5);
          margin-bottom: 0;
        }
      }
    }

    @include mid-break {
      &__main {
        width: 100%;
        min-height: initial;
      }

      &__sidebar-wrap {
        position: static;
        width: 100%;
        height: initial;
      }

      &__form {
        display: block;
      }

      &__edit {
        padding-top: 0;
        padding-bottom: 0;
      }

      &__document-actions {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: auto;
        z-index: var(--z-nav);
      }

      &__document-actions,
      &__sidebar-fields {
        padding-left: var(--gutter-h);
        padding-right: var(--gutter-h);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/EditMany/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import React, { useState } from 'react'
⋮----
import type { FieldOption } from '../FieldSelect/reduceFieldOptions.js'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { EditDepthProvider } from '../../providers/EditDepth/index.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Drawer } from '../Drawer/index.js'
import { EditManyDrawerContent } from './DrawerContent.js'
⋮----
export type EditManyProps = {
  readonly collection: ClientCollectionConfig
}
</file>

<file path="packages/ui/src/elements/EditUpload/index.scss">
@import '../../scss/styles.scss';

$header-height: base(5);

@layer payload-default {
  .edit-upload {
    --edit-upload-cell-spacing: calc(var(--base) * 1.5);
    --edit-upload-sidebar-width: calc(350px + var(--gutter-h));
    height: 100%;
    margin-right: calc(var(--gutter-h) * -1);
    margin-left: calc(var(--gutter-h) * -1);

    &__header {
      height: $header-height;
      border-bottom: 1px solid var(--theme-elevation-150);
      padding: 0 var(--gutter-h);
      display: flex;
      justify-content: space-between;
      align-items: center;

      & h2 {
        margin: 0;
        text-wrap: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    }

    [dir='rtl'] &__actions {
      margin-right: auto;
      margin-left: unset;
    }

    &__actions {
      min-width: 350px;
      margin-left: auto;
      padding: base(0.5) 0 base(0.5) base(1.5);
      justify-content: flex-end;
      display: flex;
      gap: base(1);
      text-wrap: nowrap;
    }

    &__toolWrap {
      display: flex;
      justify-content: flex-end;
      height: (calc(100% - #{$header-height}));
    }

    .ReactCrop__selection-addon,
    &__crop-window {
      height: 100%;
      width: 100%;
    }

    &__focal-wrapper {
      position: relative;
      display: inline-flex;
      max-height: 100%;
    }

    &__draggable-container {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      top: 0;
      pointer-events: none;

      &--dragging {
        pointer-events: all;

        .edit-upload__focalPoint {
          cursor: grabbing;
        }
      }
    }

    &__draggable {
      @include btn-reset;
      position: absolute;
    }

    &__focalPoint {
      position: absolute;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      width: 50px;
      height: 50px;
      transform: translate3d(-50%, -50%, 0);
      pointer-events: all;

      svg {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 100%;
        width: base(2);
        height: base(2);
        color: white;
      }
    }

    &__crop,
    &__focalOnly {
      padding: base(1.5) base(1.5) base(1.5) 0;
      width: 100%;
      display: flex;
      justify-content: center;
    }

    &__crop {
      padding: var(--edit-upload-cell-spacing);
      padding-left: var(--gutter-h);
      display: flex;
      align-items: flex-start;
      height: 100%;
    }

    &__imageWrap {
      position: relative;
    }

    &__point {
      cursor: move;
      position: absolute;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 100%;

      & svg {
        width: base(2);
        height: base(2);
      }
    }

    &__sidebar {
      border-left: 1px solid var(--theme-elevation-150);
      padding-top: var(--edit-upload-cell-spacing);
      min-width: var(--edit-upload-sidebar-width);

      & > div:first-child {
        margin-bottom: base(1);
      }
    }

    &__groupWrap {
      display: flex;
      flex-direction: column;
      gap: base(0.5);
      padding-right: var(--gutter-h);
      padding-left: var(--edit-upload-cell-spacing);
      width: 100%;

      + .edit-upload__groupWrap {
        padding-top: var(--edit-upload-cell-spacing);
        margin-top: var(--edit-upload-cell-spacing);
        border-top: 1px solid var(--theme-elevation-150);
      }
    }

    &__inputsWrap,
    &__titleWrap {
      display: flex;
      gap: base(1);
    }

    &__titleWrap {
      justify-content: space-between;
      align-items: center;

      & h3 {
        margin: 0;
      }
    }

    &__reset {
      height: fit-content;
      border-radius: var(--style-radius-s);
      background-color: var(--theme-elevation-150);
      padding: 0 base(0.4);
    }

    &__input {
      flex: 1;
      & input {
        @include formInput;
      }
    }

    @include mid-break {
      --edit-upload-cell-spacing: var(--gutter-h);
      &__sidebar {
        padding-left: 0;
        border-left: 0;
        width: 100%;
      }
      &__toolWrap {
        flex-direction: column-reverse;
      }
    }

    @include small-break {
      flex-direction: column;

      &__focalPoint {
        border-right: none;
        padding: base(1) 0;
      }

      &__inputsWrap {
        flex-direction: column;
        gap: base(1);
      }

      &__sidebar {
        min-width: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/EditUpload/index.tsx">
import type { UploadEdits } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import React, { useRef, useState } from 'react'
import ReactCrop from 'react-image-crop'
⋮----
import { editDrawerSlug } from '../../elements/Upload/index.js'
import { PlusIcon } from '../../icons/Plus/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
⋮----
type Props = {
  name: string
  onChange: (value: string) => void
  ref?: React.RefObject<HTMLInputElement>
  value: string
}
⋮----
const Input: React.FC<Props> = (props) =>
⋮----
type FocalPosition = {
  x: number
  y: number
}
⋮----
export type EditUploadProps = {
  fileName: string
  fileSrc: string
  imageCacheTag?: string
  initialCrop?: UploadEdits['crop']
  initialFocalPoint?: FocalPosition
  onSave?: (uploadEdits: UploadEdits) => void
  showCrop?: boolean
  showFocalPoint?: boolean
}
⋮----
const onImageLoad = (e) =>
⋮----
// set the default image height/width on load
⋮----
const fineTuneCrop = (
⋮----
const fineTuneFocalPosition = ({
    coordinate,
    value,
  }: {
    coordinate: 'x' | 'y'
    value: string
}) =>
⋮----
const saveEdits = () =>
⋮----
const centerFocalPoint = () =>
⋮----
alt=
⋮----
onChange=
⋮----
const [position, setPosition] = useState(
const [isDragging, setIsDragging] = useState(false)
const dragRef = useRef<HTMLButtonElement | undefined>(undefined)
⋮----
const getCoordinates = React.useCallback(
(mouseXArg?: number, mouseYArg?: number, recenter?: boolean) =>
⋮----
const handleMouseDown = (event) =>
event.preventDefault()
setIsDragging(true)
</file>

<file path="packages/ui/src/elements/EmailAndUsername/index.tsx">
import type { TFunction } from '@convexcms/translations'
import type { LoginWithUsernameOptions, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
import { email, username } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { EmailField } from '../../fields/Email/index.js'
import { TextField } from '../../fields/Text/index.js'
⋮----
type RenderEmailAndUsernameFieldsProps = {
  className?: string
  loginWithUsername?: false | LoginWithUsernameOptions
  operation?: 'create' | 'update'
  permissions?:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | true
  readOnly: boolean
  t: TFunction
}
</file>

<file path="packages/ui/src/elements/ErrorPill/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .error-pill {
    align-self: center;
    align-items: center;
    border: 0;
    padding: 0 base(0.25);
    flex-shrink: 0;
    border-radius: var(--style-radius-l);
    line-height: 18px;
    font-size: 11px;
    text-align: center;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--theme-error-300);
    color: var(--theme-error-950);

    &--fixed-width {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      position: relative;
    }

    &__count {
      letter-spacing: 0.5px;
      margin-left: 0.5px;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ErrorPill/index.tsx">
import type { I18nClient } from '@convexcms/translations'
⋮----
import React from 'react'
⋮----
export type ErrorPillProps = {
  className?: string
  count: number
  i18n: I18nClient
  withMessage?: boolean
}
⋮----
export const ErrorPill: React.FC<ErrorPillProps> = (props) =>
</file>

<file path="packages/ui/src/elements/FieldDiffLabel/index.scss">
@layer payload-default {
  .field-diff-label {
    margin-bottom: calc(var(--base) * 0.25);
    font-weight: 600;
  }
}
</file>

<file path="packages/ui/src/elements/FieldDiffLabel/index.tsx">
import React from 'react'
⋮----
export const FieldDiffLabel: React.FC<
</file>

<file path="packages/ui/src/elements/FieldSelect/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-select {
    margin-bottom: base(1);
  }
}
</file>

<file path="packages/ui/src/elements/FieldSelect/index.tsx">
import type { ClientField, FormState, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
import React, { useState } from 'react'
⋮----
import type { FieldAction } from '../../forms/Form/types.js'
import type { FieldOption } from './reduceFieldOptions.js'
⋮----
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useForm } from '../../forms/Form/context.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { filterOutUploadFields } from '../../utilities/filterOutUploadFields.js'
import { ReactSelect } from '../ReactSelect/index.js'
import { reduceFieldOptions } from './reduceFieldOptions.js'
⋮----
export type OnFieldSelect = ({
  dispatchFields,
  formState,
  selected,
}: {
  dispatchFields: React.Dispatch<FieldAction>
  formState: FormState
  selected: FieldOption[]
}) => void
⋮----
export type FieldSelectProps = {
  readonly fields: ClientField[]
  readonly onChange: OnFieldSelect
  readonly permissions:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | SanitizedFieldPermissions
}
⋮----
<FieldLabel label=
</file>

<file path="packages/ui/src/elements/FieldSelect/reduceFieldOptions.ts">
import type { ClientField, FormState, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
import {
  fieldAffectsData,
  fieldHasSubFields,
  fieldIsHiddenOrDisabled,
  getFieldPermissions,
} from '@convexcms/core/shared'
⋮----
import { createNestedClientFieldPath } from '../../forms/Form/createNestedClientFieldPath.js'
import { combineFieldLabel } from '../../utilities/combineFieldLabel.js'
⋮----
export type SelectedField = {
  field: ClientField
  fieldPermissions: SanitizedFieldPermissions
  path: string
}
⋮----
export type FieldOption = {
  label: React.ReactNode
  value: SelectedField
}
⋮----
export const ignoreFromBulkEdit = (field: ClientField): boolean
⋮----
export const reduceFieldOptions = ({
  fields,
  formState,
  labelPrefix = null,
  parentPath = '',
  path = '',
  permissions,
}: {
  readonly fields: ClientField[]
  readonly formState?: FormState
  readonly labelPrefix?: React.ReactNode
  readonly parentPath?: string
  readonly path?: string
  readonly permissions:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | SanitizedFieldPermissions
}): FieldOption[] =>
⋮----
// escape for a variety of reasons, include ui fields as they have `name`.
</file>

<file path="packages/ui/src/elements/FileDetails/DraggableFileDetails/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .file-details-draggable {
    display: flex;
    gap: 0.6rem;
    //justify-content: space-between;
    align-items: center;
    background: var(--theme-elevation-50);
    border-radius: 3px;
    padding: 0.7rem 0.8rem;

    &--drag-wrapper {
      display: flex;
      gap: 0.6rem;
      align-items: center;
    }

    &__thumbnail {
      max-width: 1.5rem;
    }

    &__actions {
      flex-grow: 2;
      display: flex;
      gap: 0.6rem;
      align-items: center;
      justify-content: flex-end;
    }

    &__remove.btn--style-icon-label {
      margin: 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/FileDetails/DraggableFileDetails/index.tsx">
import React from 'react'
⋮----
import { Button } from '../../Button/index.js'
import { Thumbnail } from '../../Thumbnail/index.js'
⋮----
import type { Data, FileSizes, SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { DraggableSortableItem } from '../../../elements/DraggableSortable/DraggableSortableItem/index.js'
import { DragHandleIcon } from '../../../icons/DragHandle/index.js'
import { EditIcon } from '../../../icons/Edit/index.js'
import { useDocumentDrawer } from '../../DocumentDrawer/index.js'
⋮----
export type DraggableFileDetailsProps = {
  collectionSlug: string
  customUploadActions?: React.ReactNode[]
  doc: {
    sizes?: FileSizes
  } & Data
  enableAdjustments?: boolean
  hasImageSizes?: boolean
  hasMany: boolean
  hideRemoveFile?: boolean
  imageCacheTag?: string
  isSortable?: boolean
  removeItem?: (index: number) => void
  rowIndex: number
  uploadConfig: SanitizedCollectionConfig['upload']
}
⋮----
onClick=
</file>

<file path="packages/ui/src/elements/FileDetails/FileMeta/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .file-meta {
    &__url {
      display: flex;
      gap: base(0.4);

      a {
        font-weight: 600;
        text-decoration: none;

        &:hover,
        &:focus-visible {
          text-decoration: underline;
        }
      }
    }

    &__size-type,
    &__url a {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    &__edit {
      position: relative;
    }
  }
}
</file>

<file path="packages/ui/src/elements/FileDetails/FileMeta/index.tsx">
import { formatFilesize } from '@convexcms/core/shared'
import React from 'react'
⋮----
export type FileMetaProps = {
  filename: string
  filesize: number
  height?: number
  mimeType: string
  sizes?: unknown
  url: string
  width?: number
}
⋮----
import { CopyToClipboard } from '../../CopyToClipboard/index.js'
⋮----
</file>

<file path="packages/ui/src/elements/FileDetails/StaticFileDetails/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .file-details {
    background: var(--theme-elevation-50);
    border: 1px solid var(--theme-border-color);
    border-radius: var(--style-radius-m);
    @include inputShadow;

    header {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      position: relative;
    }

    &__remove {
      position: absolute;
      margin: 0;
      top: $baseline;
      right: $baseline;

      & .btn__icon {
        border: 1px solid var(--theme-border-color);
        background: var(--theme-input-bg);
        @include inputShadow;
        transition: border 100ms cubic-bezier(0, 0.2, 0.2, 1);

        &:hover {
          border: 1px solid var(--theme-elevation-400);
        }
      }
    }

    &__main-detail {
      padding: base(0.8) base(1.2);
      width: auto;
      flex-grow: 1;
      min-width: 280px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-self: stretch;
      gap: base(0.2);
    }

    &__toggle-more-info {
      font-weight: 600;
      text-decoration: none;

      &:hover,
      &:focus-visible {
        text-decoration: underline;
      }
    }

    &__toggle-icon {
      padding: calc(var(--base) / 4);
    }

    &__sizes {
      margin: 0;
      padding: base(1.5) $baseline 0;
      list-style: none;
      display: flex;
      flex-wrap: wrap;

      li {
        width: 50%;
        padding: 0 base(0.5);
        margin-bottom: $baseline;
      }
    }

    &__size-label {
      color: var(--theme-elevation-400);
    }

    &__file-mutation {
      display: flex;
      margin-top: base(0.25);
      gap: calc(var(--base) / 2);
    }

    &__edit {
      cursor: pointer;
      background-color: var(--theme-elevation-150);
      border: none;
      border-radius: $style-radius-m;
      padding: base(0.25) base(0.5);

      &:hover {
        background-color: var(--theme-elevation-100);
      }
    }

    @include large-break {
      &__main-detail {
        padding: $baseline;
      }

      &__sizes {
        display: block;
        padding: $baseline $baseline base(0.5);

        li {
          padding: 0;
          width: 100%;
        }
      }
    }

    @include mid-break {
      header {
        flex-wrap: wrap;
      }

      .thumbnail {
        width: 50%;
        order: 1;
      }

      &__remove {
        order: 2;
      }

      &__main-detail {
        order: 3;
        width: 100%;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/FileDetails/StaticFileDetails/index.tsx">
import React from 'react'
⋮----
import { Button } from '../../Button/index.js'
import { Thumbnail } from '../../Thumbnail/index.js'
import { UploadActions } from '../../Upload/index.js'
import { FileMeta } from '../FileMeta/index.js'
⋮----
import type { Data, FileSizes, SanitizedCollectionConfig } from '@convexcms/core'
⋮----
export type StaticFileDetailsProps = {
  customUploadActions?: React.ReactNode[]
  doc: {
    sizes?: FileSizes
  } & Data
  enableAdjustments?: boolean
  handleRemove?: () => void
  hasImageSizes?: boolean
  hideRemoveFile?: boolean
  imageCacheTag?: string
  uploadConfig: SanitizedCollectionConfig['upload']
}
⋮----
// size="small"
</file>

<file path="packages/ui/src/elements/FileDetails/index.tsx">
import type { Data, FileSizes, SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { DraggableFileDetails } from './DraggableFileDetails/index.js'
import { StaticFileDetails } from './StaticFileDetails/index.js'
⋮----
type SharedFileDetailsProps = {
  collectionSlug: string
  customUploadActions?: React.ReactNode[]
  doc: {
    sizes?: FileSizes
  } & Data
  enableAdjustments?: boolean
  hasImageSizes?: boolean
  hideRemoveFile?: boolean
  imageCacheTag?: string
  uploadConfig: SanitizedCollectionConfig['upload']
}
⋮----
type StaticFileDetailsProps = {
  draggableItemProps?: never
  handleRemove?: () => void
  hasMany?: never
  isSortable?: never
  removeItem?: never
  rowIndex?: never
}
⋮----
type DraggableFileDetailsProps = {
  handleRemove?: never
  hasMany: boolean
  isSortable?: boolean
  removeItem?: (index: number) => void
  rowIndex: number
}
⋮----
export type FileDetailsProps = (DraggableFileDetailsProps | StaticFileDetailsProps) &
  SharedFileDetailsProps
</file>

<file path="packages/ui/src/elements/FullscreenModal/index.tsx">
import type { Modal as ModalType } from '@faceless-ui/modal'
⋮----
import { Modal } from '@faceless-ui/modal'
import React from 'react'
⋮----
import { useEditDepth } from '../../providers/EditDepth/index.js'
</file>

<file path="packages/ui/src/elements/GenerateConfirmation/index.tsx">
import { useModal } from '@faceless-ui/modal'
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
import { Translation } from '../Translation/index.js'
⋮----
export type GenerateConfirmationProps = {
  highlightField: (Boolean) => void
  setKey: () => void
}
</file>

<file path="packages/ui/src/elements/Gutter/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .gutter {
    &--left {
      padding-left: var(--gutter-h);
    }

    &--right {
      padding-right: var(--gutter-h);
    }

    &--negative-left {
      margin-left: calc(-1 * var(--gutter-h));
    }

    &--negative-right {
      margin-right: calc(-1 * var(--gutter-h));
    }
  }
}
</file>

<file path="packages/ui/src/elements/Gutter/index.tsx">
import React from 'react'
⋮----
export type GutterProps = {
  children: React.ReactNode
  className?: string
  left?: boolean
  negativeLeft?: boolean
  negativeRight?: boolean
  ref?: React.RefObject<HTMLDivElement>
  right?: boolean
}
⋮----
export const Gutter: React.FC<GutterProps> = (props) =>
</file>

<file path="packages/ui/src/elements/Hamburger/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .hamburger {
    padding: 0;
    border: 0;
    cursor: pointer;
    background-color: var(--theme-bg);
    outline: none;
    position: relative;
    color: var(--theme-text);
    box-shadow: 0px 0px 0px 1px var(--theme-elevation-150);
    padding: base(0.1);
    border-radius: 3px;
    position: relative;
    z-index: 1;
    height: 100%;
    width: 100%;
    transition-property: box-shadow, background-color;
    transition-duration: 100ms;
    transition-timing-function: cubic-bezier(0, 0.2, 0.2, 1);
    --hamburger-size: var(--base);

    &:hover {
      background-color: var(--theme-elevation-100);
      box-shadow: 0px 0px 0px 1px var(--theme-elevation-500);
    }

    &:focus {
      outline: none;
    }

    &::after {
      z-index: -1;
    }

    &__open-icon,
    &__close-icon {
      width: var(--hamburger-size);
      height: var(--hamburger-size);
      display: flex;
      align-items: center;
      justify-content: center;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Hamburger/index.tsx">
import React from 'react'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { CloseMenuIcon } from '../../icons/CloseMenu/index.js'
import { MenuIcon } from '../../icons/Menu/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
</file>

<file path="packages/ui/src/elements/HydrateAuthProvider/index.tsx">
import type { SanitizedPermissions } from '@convexcms/core'
⋮----
import { useEffect } from 'react'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
⋮----
/**
 * The Auth Provider wraps the entire app
 * but each page has specific permissions
 *
 * i.e. access control on documents/fields on a document
 */
⋮----
type Props = {
  permissions: SanitizedPermissions
}
⋮----
export function HydrateAuthProvider(
</file>

<file path="packages/ui/src/elements/IDLabel/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .id-label {
    font-size: base(0.8);
    line-height: base(1.2);
    font-weight: normal;
    color: var(--theme-elevation-600);
    background: var(--theme-elevation-100);
    padding: base(0.2) base(0.4);
    border-radius: $style-radius-m;
    display: inline-flex;
  }
}
</file>

<file path="packages/ui/src/elements/IDLabel/index.tsx">
import React from 'react'
⋮----
import { sanitizeID } from '../../utilities/sanitizeID.js'
⋮----
export const IDLabel: React.FC<
</file>

<file path="packages/ui/src/elements/LeaveWithoutSaving/index.tsx">
import React, { useCallback } from 'react'
⋮----
import type { OnCancel } from '../ConfirmationModal/index.js'
⋮----
import { useForm, useFormModified } from '../../forms/Form/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
import { useModal } from '../Modal/index.js'
import { usePreventLeave } from './usePreventLeave.js'
⋮----
export const LeaveWithoutSaving: React.FC = () =>
⋮----
body=
cancelLabel=
confirmLabel=
heading=
</file>

<file path="packages/ui/src/elements/LeaveWithoutSaving/usePreventLeave.tsx">
// Credit: @Taiki92777
//    - Source: https://github.com/vercel/next.js/discussions/32231#discussioncomment-7284386
// Credit: `react-use` maintainers
//    -  Source: https://github.com/streamich/react-use/blob/ade8d3905f544305515d010737b4ae604cc51024/src/useBeforeUnload.ts#L2
import { useRouter } from 'next/navigation.js'
import { useCallback, useEffect, useRef } from 'react'
⋮----
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
⋮----
function on<T extends Document | EventTarget | HTMLElement | Window>(
  obj: null | T,
  ...args: [string, (() => void) | null, ...any] | Parameters<T['addEventListener']>
): void
⋮----
function off<T extends Document | EventTarget | HTMLElement | Window>(
  obj: null | T,
  ...args: [string, (() => void) | null, ...any] | Parameters<T['removeEventListener']>
): void
⋮----
export const useBeforeUnload = (enabled: (() => boolean) | boolean = true, message?: string) =>
⋮----
export const usePreventLeave = ({
  hasAccepted = false,
  message = 'Are you sure want to leave this page?',
  onAccept,
  onPrevent,
  prevent = true,
}: {
  hasAccepted: boolean
  // if no `onPrevent` is provided, the message will be displayed in a confirm dialog
  message?: string
  onAccept?: () => void
  // to use a custom confirmation dialog, provide a function that returns a boolean
  onPrevent?: () => void
  prevent: boolean
}) =>
⋮----
// if no `onPrevent` is provided, the message will be displayed in a confirm dialog
⋮----
// to use a custom confirmation dialog, provide a function that returns a boolean
⋮----
// check when page is about to be reloaded
⋮----
// check when page is about to be changed
⋮----
function isAnchorOfCurrentUrl(currentUrl: string, newUrl: string)
⋮----
// Compare hostname, pathname, and search parameters
⋮----
// Check if the new URL is just an anchor of the current URL page
⋮----
function findClosestAnchor(element: HTMLElement | null): HTMLAnchorElement | null
⋮----
function handleClick(event: MouseEvent)
⋮----
// Keep a reference of the href
⋮----
// Cancel the route change
⋮----
// Add the global click event listener
⋮----
// Clean up the global click event listener when the component is unmounted
</file>

<file path="packages/ui/src/elements/Link/formatUrl.ts">
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
⋮----
import type { UrlObject } from 'url'
⋮----
function stringifyUrlQueryParam(param: unknown): string
⋮----
export function urlQueryToSearchParams(urlQuery: UrlObject['query']): URLSearchParams
⋮----
export function formatUrl(urlObj: UrlObject)
</file>

<file path="packages/ui/src/elements/Link/index.tsx">
import NextLinkImport from 'next/link.js'
import { useRouter } from 'next/navigation.js'
import React from 'react'
⋮----
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { formatUrl } from './formatUrl.js'
⋮----
// Copied from  https://github.com/vercel/next.js/blob/canary/packages/next/src/client/link.tsx#L180-L191
function isModifiedEvent(event: React.MouseEvent): boolean
⋮----
event.altKey || // triggers resource download
⋮----
type Props = {
  /**
   * Disable the e.preventDefault() call on click if you want to handle it yourself via onClick
   *
   * @default true
   */
  preventDefault?: boolean
} & Parameters<typeof NextLink>[0]
⋮----
/**
   * Disable the e.preventDefault() call on click if you want to handle it yourself via onClick
   *
   * @default true
   */
⋮----
onClick(e)
        }

        // We need a preventDefault here so that a clicked link doesn't trigger twice,
        // once for default browser navigation and once for startRouteTransition
if (preventDefault)
⋮----
// We need a preventDefault here so that a clicked link doesn't trigger twice,
// once for default browser navigation and once for startRouteTransition
</file>

<file path="packages/ui/src/elements/ListControls/ActiveQueryPreset/index.scss">
@import '../../../scss/styles';

@layer payload-default {
  .active-query-preset {
    &.pill {
      max-width: 150px;
      overflow: hidden;
    }

    .pill__label {
      display: flex;
      align-items: center;
    }

    &__label-text {
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ListControls/ActiveQueryPreset/index.tsx">
import type { QueryPreset } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
⋮----
import { PeopleIcon } from '../../../icons/People/index.js'
import { XIcon } from '../../../icons/X/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { Pill } from '../../Pill/index.js'
⋮----
t('general:selectLabel',
⋮----
onClick=
onKeyDown=
</file>

<file path="packages/ui/src/elements/ListControls/getTextFieldsToBeSearched.ts">
import type { ClientField } from '@convexcms/core'
⋮----
import { fieldAffectsData, flattenTopLevelFields } from '@convexcms/core/shared'
⋮----
export const getTextFieldsToBeSearched = (
  listSearchableFields: string[],
  fields: ClientField[],
): ClientField[] =>
</file>

<file path="packages/ui/src/elements/ListControls/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .list-controls {
    &__wrap {
      display: flex;
      align-items: center;
      background-color: var(--theme-elevation-50);
      border-radius: var(--style-radius-m);
      padding: base(0.6);
      gap: base(0.6);
    }

    .search-filter {
      flex-grow: 1;

      input {
        margin: 0;
      }
    }

    &__custom-control {
      padding: 0;
      border-radius: 0;
    }

    &__modified {
      color: var(--theme-elevation-500);
    }

    &__buttons-wrap {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .column-selector,
    .where-builder,
    .sort-complex {
      margin-top: base(1);
    }

    @include small-break {
      &__wrap {
        flex-wrap: wrap;
        background-color: unset;
        padding: 0;
        position: relative;
      }

      .icon--search {
        position: absolute;
        top: base(0.4);
        inset-inline-start: base(0.4);
        z-index: 1;
      }

      .search-filter {
        width: 100%;
        input {
          padding: base(0.4) base(2);
        }
      }

      &__buttons-wrap {
        [dir='ltr'] & {
          margin-right: 0;
        }

        [dir='rtl'] & {
          margin-left: 0;
        }

        .pill {
          padding: base(0.2) base(0.2) base(0.2) base(0.4);
          justify-content: space-between;
        }
      }

      &__buttons {
        margin: 0;
        width: 100%;
      }

      .column-selector,
      .where-builder,
      .sort-complex {
        margin-top: calc(var(--base) / 2);
      }

      &__toggle-columns,
      &__toggle-where,
      &__toggle-sort {
        flex: 1;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ListControls/index.tsx">
import { useWindowInfo } from '@faceless-ui/window-info'
import { getTranslation } from '@convexcms/translations'
import { validateWhereQuery } from '@convexcms/core/shared'
import React, { Fragment, useEffect, useRef, useState } from 'react'
⋮----
import type { ListControlsProps } from './types.js'
⋮----
import { Popup, PopupList } from '../../elements/Popup/index.js'
import { useUseTitleField } from '../../hooks/useUseAsTitle.js'
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { Dots } from '../../icons/Dots/index.js'
import { SearchIcon } from '../../icons/Search/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { AnimateHeight } from '../AnimateHeight/index.js'
import { ColumnSelector } from '../ColumnSelector/index.js'
import { Pill } from '../Pill/index.js'
import { SearchFilter } from '../SearchFilter/index.js'
import { WhereBuilder } from '../WhereBuilder/index.js'
import { ActiveQueryPreset } from './ActiveQueryPreset/index.js'
import { getTextFieldsToBeSearched } from './getTextFieldsToBeSearched.js'
import { useQueryPresets } from './useQueryPresets.js'
⋮----
/**
 * The ListControls component is used to render the controls (search, filter, where)
 * for a collection's list view. You can find those directly above the table which lists
 * the collection's documents.
 */
⋮----
// Cannot push or unshift into `listMenuItemsFromProps` as it will mutate the original array
⋮----
// @ts-expect-error @todo: fix types
⋮----
button=
</file>

<file path="packages/ui/src/elements/ListControls/types.ts">
import type {
  ClientCollectionConfig,
  QueryPreset,
  ResolvedFilterOptions,
  SanitizedCollectionPermission,
  Where,
} from '@convexcms/core'
⋮----
export type ListControlsProps = {
  readonly beforeActions?: React.ReactNode[]
  readonly collectionConfig: ClientCollectionConfig
  readonly collectionSlug: string
  /**
   * @deprecated
   * These are now handled by the `ListSelection` component
   */
  readonly disableBulkDelete?: boolean
  /**
   * @deprecated
   * These are now handled by the `ListSelection` component
   */
  readonly disableBulkEdit?: boolean
  readonly disableQueryPresets?: boolean
  readonly enableColumns?: boolean
  readonly enableSort?: boolean
  readonly handleSearchChange?: (search: string) => void
  readonly handleSortChange?: (sort: string) => void
  readonly handleWhereChange?: (where: Where) => void
  readonly listMenuItems?: React.ReactNode[]
  readonly queryPreset?: QueryPreset
  readonly queryPresetPermissions?: SanitizedCollectionPermission
  readonly renderedFilters?: Map<string, React.ReactNode>
  readonly resolvedFilterOptions?: Map<string, ResolvedFilterOptions>
}
⋮----
/**
   * @deprecated
   * These are now handled by the `ListSelection` component
   */
⋮----
/**
   * @deprecated
   * These are now handled by the `ListSelection` component
   */
</file>

<file path="packages/ui/src/elements/ListControls/useQueryPresets.tsx">
import type { CollectionSlug, QueryPreset, SanitizedCollectionPermission } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { transformColumnsToPreferences, transformColumnsToSearchParams } from '@convexcms/core/shared'
import React, { Fragment, useCallback, useMemo } from 'react'
import { toast } from 'sonner'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useListQuery } from '../../providers/ListQuery/context.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
import { useDocumentDrawer } from '../DocumentDrawer/index.js'
import { useListDrawer } from '../ListDrawer/index.js'
import { PopupList } from '../Popup/index.js'
import { PopupListGroupLabel } from '../Popup/PopupGroupLabel/index.js'
import { Translation } from '../Translation/index.js'
⋮----
// Memoize so that components aren't re-rendered on query and column changes
⋮----
onClick=
⋮----
onSave=
⋮----
heading=
⋮----
// setSelectedPreset(undefined)
⋮----
onSelect=
</file>

<file path="packages/ui/src/elements/ListDrawer/DrawerContent.tsx">
import type { ListQuery } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { hoistQueryParamsToAnd } from '@convexcms/core/shared'
import React, { useCallback, useEffect, useState } from 'react'
⋮----
import type { ListDrawerProps } from './types.js'
⋮----
import { useDocumentDrawer } from '../../elements/DocumentDrawer/index.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useConfig } from '../../providers/Config/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { ListDrawerContextProvider } from '../ListDrawer/Provider.js'
import { LoadingOverlay } from '../Loading/index.js'
import { type Option } from '../ReactSelect/index.js'
⋮----
export const ListDrawerContent: React.FC<ListDrawerProps> = ({
  allowCreate = true,
  collectionSlugs,
  disableQueryPresets,
  drawerSlug,
  enableRowSelections,
  filterOptions,
  onBulkSelect,
  onSelect,
  overrideEntityVisibility = true,
  selectedCollection: selectedCollectionFromProps,
}) =>
⋮----
console.error('Error rendering List View: ', _err) // eslint-disable-line no-console
</file>

<file path="packages/ui/src/elements/ListDrawer/index.tsx">
import { useModal } from '@faceless-ui/modal'
import React, { useCallback, useEffect, useId, useMemo, useState } from 'react'
⋮----
import type { ListDrawerProps, ListTogglerProps, UseListDrawer } from './types.js'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { Drawer, DrawerToggler } from '../Drawer/index.js'
import { ListDrawerContent } from './DrawerContent.js'
⋮----
export const formatListDrawerSlug = (
⋮----
uuid: string // supply when creating a new document and no id is available
</file>

<file path="packages/ui/src/elements/ListDrawer/Provider.tsx">
import type { CollectionSlug, Data, ListQuery } from '@convexcms/core'
⋮----
import { createContext, use } from 'react'
⋮----
import type { useSelection } from '../../providers/Selection/index.js'
import type { UseDocumentDrawer } from '../DocumentDrawer/types.js'
import type { Option } from '../ReactSelect/index.js'
⋮----
export type ListDrawerContextProps = {
  readonly allowCreate?: boolean
  readonly createNewDrawerSlug?: string
  readonly DocumentDrawerToggler?: ReturnType<UseDocumentDrawer>[1]
  readonly drawerSlug?: string
  readonly enabledCollections?: CollectionSlug[]
  readonly onBulkSelect?: (selected: ReturnType<typeof useSelection>['selected']) => void
  readonly onQueryChange?: (query: ListQuery) => void
  readonly onSelect?: (args: {
    collectionSlug: CollectionSlug
    doc: Data
    /**
     * @deprecated
     * The `docID` property is deprecated and will be removed in the next major version of Payload.
     * Use `doc.id` instead.
     */
    docID: string
  }) => void
  readonly selectedOption?: Option<string>
  readonly setSelectedOption?: (option: Option<string>) => void
}
⋮----
/**
     * @deprecated
     * The `docID` property is deprecated and will be removed in the next major version of Payload.
     * Use `doc.id` instead.
     */
⋮----
export type ListDrawerContextType = {
  isInDrawer: boolean
} & ListDrawerContextProps
⋮----
export const ListDrawerContextProvider: React.FC<
  {
    children: React.ReactNode
  } & ListDrawerContextProps
> = (
⋮----
export const useListDrawerContext = (): ListDrawerContextType =>
</file>

<file path="packages/ui/src/elements/ListDrawer/types.ts">
import type { FilterOptionsResult, SanitizedCollectionConfig } from '@convexcms/core'
import type React from 'react'
import type { HTMLAttributes } from 'react'
⋮----
import type { ListDrawerContextProps } from './Provider.js'
⋮----
export type ListDrawerProps = {
  readonly allowCreate?: boolean
  readonly collectionSlugs: SanitizedCollectionConfig['slug'][]
  readonly disableQueryPresets?: boolean
  readonly drawerSlug?: string
  readonly enableRowSelections?: boolean
  readonly filterOptions?: FilterOptionsResult
  readonly overrideEntityVisibility?: boolean
  readonly selectedCollection?: string
} & ListDrawerContextProps
⋮----
export type ListTogglerProps = {
  children?: React.ReactNode
  className?: string
  disabled?: boolean
  drawerSlug?: string
} & HTMLAttributes<HTMLButtonElement>
⋮----
export type UseListDrawer = (args: {
  collectionSlugs?: SanitizedCollectionConfig['slug'][]
  filterOptions?: FilterOptionsResult
  overrideEntityVisibility?: boolean
  selectedCollection?: SanitizedCollectionConfig['slug']
  uploads?: boolean // finds all collections with upload: true
}) => [
  React.FC<Omit<ListDrawerProps, 'collectionSlugs'>>,
  React.FC<Omit<ListTogglerProps, 'drawerSlug'>>,
  {
    closeDrawer: () => void
    collectionSlugs: SanitizedCollectionConfig['slug'][]
    drawerDepth: number
    drawerSlug: string
    isDrawerOpen: boolean
    openDrawer: () => void
    setCollectionSlugs: React.Dispatch<React.SetStateAction<SanitizedCollectionConfig['slug'][]>>
    toggleDrawer: () => void
  },
]
⋮----
uploads?: boolean // finds all collections with upload: true
</file>

<file path="packages/ui/src/elements/ListSelection/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .list-selection {
    display: flex;
    margin-left: auto;
    color: var(--theme-elevation-500);
    gap: 0.5em;

    &__button {
      color: var(--theme-elevation-500);
      background: unset;
      border: none;
      text-decoration: underline;
      cursor: pointer;
      padding: 0;
      font-size: inherit;
    }

    @include small-break {
      margin-bottom: base(0.5);
    }
  }
}
</file>

<file path="packages/ui/src/elements/ListSelection/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import React, { Fragment } from 'react'
⋮----
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { DeleteMany } from '../DeleteMany/index.js'
import { EditMany } from '../EditMany/index.js'
import { PublishMany } from '../PublishMany/index.js'
import { UnpublishMany } from '../UnpublishMany/index.js'
⋮----
export type ListSelectionProps = {
  collectionConfig?: ClientCollectionConfig
  disableBulkDelete?: boolean
  disableBulkEdit?: boolean
  label: string
}
⋮----
aria-label=
</file>

<file path="packages/ui/src/elements/Loading/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .loading-overlay {
    isolation: isolate;
    height: 100%;
    width: 100%;
    left: 0;
    top: 0;
    bottom: 0;
    position: fixed;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    pointer-events: none;
    z-index: calc(var(--z-status) + 1);
    transition-property: left, width;
    transition: 250ms ease;

    &.loading-overlay--entering {
      opacity: 1;
      animation: fade-in ease;
      pointer-events: all;
    }

    &.loading-overlay--exiting {
      opacity: 0;
      animation: fade-out ease;
    }

    &:after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--theme-elevation-0);
      opacity: 0.85;
      z-index: -1;
    }

    &__bars {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
      gap: 7px;
      align-items: center;
    }

    &__bar {
      width: 2px;
      background-color: currentColor;
      height: 15px;

      &:nth-child(1) {
        transform: translateY(0);
        animation: animate-bar--odd 1.25s infinite;
      }

      &:nth-child(2) {
        transform: translateY(-2px);
        animation: animate-bar--even 1.25s infinite;
      }

      &:nth-child(3) {
        transform: translateY(0);
        animation: animate-bar--odd 1.25s infinite;
      }

      &:nth-child(4) {
        transform: translateY(-2px);
        animation: animate-bar--even 1.25s infinite;
      }

      &:nth-child(5) {
        transform: translateY(0);
        animation: animate-bar--odd 1.25s infinite;
      }
    }

    &__text {
      margin-top: base(0.75);
      text-transform: uppercase;
      font-family: var(--font-body);
      font-size: base(0.65);
      letter-spacing: 3px;
    }
  }

  @keyframes animate-bar--even {
    0% {
      transform: translateY(2px);
    }

    50% {
      transform: translateY(-2px);
    }

    100% {
      transform: translateY(2px);
    }
  }

  @keyframes animate-bar--odd {
    0% {
      transform: translateY(-2px);
    }

    50% {
      transform: translateY(2px);
    }

    100% {
      transform: translateY(-2px);
    }
  }

  @keyframes fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes fade-out {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Loading/index.tsx">
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { LoadingOverlayTypes } from '../../elements/LoadingOverlay/types.js'
⋮----
import { useLoadingOverlay } from '../../elements/LoadingOverlay/index.js'
import { useFormProcessing } from '../../forms/Form/context.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
type LoadingOverlayProps = {
  animationDuration?: string
  loadingText?: string
  overlayType?: string
  show?: boolean
}
</file>

<file path="packages/ui/src/elements/LoadingOverlay/index.tsx">
import React, { createContext } from 'react'
⋮----
import type { LoadingOverlayContext, ToggleLoadingOverlay } from './types.js'
⋮----
import { LoadingOverlay } from '../../elements/Loading/index.js'
import { useDelayedRender } from '../../hooks/useDelayedRender.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { defaultLoadingOverlayState, reducer } from './reducer.js'
⋮----
export const LoadingOverlayProvider: React.FC<
⋮----
export const useLoadingOverlay = (): LoadingOverlayContext =>
</file>

<file path="packages/ui/src/elements/LoadingOverlay/reducer.ts">
import type { Action, State } from './types.js'
⋮----
export const reducer = (state: State, action: Action): State =>
</file>

<file path="packages/ui/src/elements/LoadingOverlay/types.ts">
export type LoadingOverlayTypes = 'fullscreen' | 'withoutNav'
⋮----
type ToggleLoadingOverlayOptions = {
  isLoading?: boolean
  key: string
  loadingText?: string
  type?: LoadingOverlayTypes
}
export type ToggleLoadingOverlay = (options: ToggleLoadingOverlayOptions) => void
⋮----
type Add = {
  payload: {
    key: string
    loadingText?: string
    type: LoadingOverlayTypes
  }
  type: 'add'
}
type Remove = {
  payload: {
    key: string
    loadingText?: never
    type: LoadingOverlayTypes
  }
  type: 'remove'
}
export type Action = Add | Remove
export type State = {
  isLoading: boolean
  loaders: {
    key: string
    loadingText: string
    type: LoadingOverlayTypes
  }[]
  loadingText: string
  overlayType: LoadingOverlayTypes | null
}
⋮----
export type LoadingOverlayContext = {
  isOnScreen: boolean
  toggleLoadingOverlay: ToggleLoadingOverlay
}
</file>

<file path="packages/ui/src/elements/Localizer/LocalizerLabel/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .localizer-button {
    display: flex;
    align-items: center;
    white-space: nowrap;
    display: flex;
    padding-inline-start: base(0.4);
    padding-inline-end: base(0.4);
    background-color: var(--theme-elevation-100);
    border-radius: var(--style-radius-s);

    &__label {
      color: var(--theme-elevation-500);
    }

    &__chevron {
      .stroke {
        stroke: currentColor;
      }
    }

    &__current {
      display: flex;
      align-items: center;
      gap: base(0.3);
    }

    button {
      color: currentColor;
      padding: 0;
      font-size: 1rem;
      line-height: base(1);
      background: transparent;
      border: 0;
      font-weight: 600;
      cursor: pointer;

      &:hover,
      &:focus-visible {
        text-decoration: underline;
      }

      &:active,
      &:focus {
        outline: none;
      }
    }

    @include small-break {
      &__label {
        display: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Localizer/LocalizerLabel/index.tsx">
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { ChevronIcon } from '../../../icons/Chevron/index.js'
import { useLocale } from '../../../providers/Locale/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
export const LocalizerLabel: React.FC<{
  ariaLabel?: string
  className?: string
}> = (props) =>
</file>

<file path="packages/ui/src/elements/Localizer/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .localizer {
    position: relative;
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
  }
}
</file>

<file path="packages/ui/src/elements/Localizer/index.tsx">
import { getTranslation } from '@convexcms/translations'
import { useRouter } from 'next/navigation.js'
⋮----
import React, { Fragment } from 'react'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useLocale, useLocaleLoading } from '../../providers/Locale/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Popup, PopupList } from '../Popup/index.js'
⋮----
import { LocalizerLabel } from './LocalizerLabel/index.js'
⋮----
// can't use `useSearchParams` here because it is stale due to `window.history.pushState` in `ListQueryProvider`
</file>

<file path="packages/ui/src/elements/Locked/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .locked {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    pointer-events: all;

    &__tooltip {
      left: 0;
      transform: translate3d(-0%, calc(var(--caret-size) * -1), 0);
    }
  }
}
</file>

<file path="packages/ui/src/elements/Locked/index.tsx">
import type { ClientUser } from '@convexcms/core'
⋮----
import React, { useState } from 'react'
⋮----
import { LockIcon } from '../../icons/Lock/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { isClientUserObject } from '../../utilities/isClientUserObject.js'
import { Tooltip } from '../Tooltip/index.js'
⋮----
export const Locked: React.FC<{
  className?: string
  user: ClientUser
}> = (
⋮----
onMouseLeave=
</file>

<file path="packages/ui/src/elements/Logout/index.tsx">
import { formatAdminURL } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { LogOutIcon } from '../../icons/LogOut/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Link } from '../Link/index.js'
⋮----
/**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
⋮----
href=
</file>

<file path="packages/ui/src/elements/Modal/index.tsx">
import { Modal, useModal } from '@faceless-ui/modal'
</file>

<file path="packages/ui/src/elements/Nav/NavToggler/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .nav-toggler {
    position: relative;
    background: transparent;
    padding: 0;
    margin: 0;
    border: 0;
    cursor: pointer;
  }
}
</file>

<file path="packages/ui/src/elements/Nav/NavToggler/index.tsx">
import { useWindowInfo } from '@faceless-ui/window-info'
import React from 'react'
⋮----
import { usePreferences } from '../../../providers/Preferences/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { useNav } from '../context.js'
⋮----
export const NavToggler: React.FC<{
  children?: React.ReactNode
  className?: string
  id?: string
  tabIndex?: number
}> = (props) =>
⋮----
onClick=
⋮----
// only when the user explicitly toggles the nav on desktop do we want to set the preference
// this is because the js may open or close the nav based on the window size, routing, etc
</file>

<file path="packages/ui/src/elements/Nav/context.tsx">
import { useWindowInfo } from '@faceless-ui/window-info'
import { usePathname } from 'next/navigation.js'
import React, { useEffect, useRef } from 'react'
⋮----
import { usePreferences } from '../../providers/Preferences/index.js'
⋮----
type NavContextType = {
  hydrated: boolean
  navOpen: boolean
  navRef: React.RefObject<HTMLDivElement | null>
  setNavOpen: (value: boolean) => void
  shouldAnimate: boolean
}
⋮----
export const useNav = ()
⋮----
const getNavPreference = async (getPreference): Promise<boolean> =>
⋮----
export const NavProvider: React.FC<{
  children: React.ReactNode
  initialIsOpen?: boolean
}> = (
⋮----
// initialize the nav to be closed
// this is because getting the preference is async
// so instead of closing it after the preference is loaded
// we will open it after the preference is loaded
⋮----
// on load check the user's preference and set "initial" state
⋮----
const setNavFromPreferences = async () =>
⋮----
// on smaller screens where the nav is a modal
// close the nav when the user navigates away
⋮----
// on open and close, lock the body scroll
// do not do this on desktop, the sidebar is not a modal
⋮----
// on smaller screens where the nav is a modal
// close the nav when the user resizes down to mobile
// the sidebar is a modal on mobile
⋮----
// when the component unmounts, clear all body scroll locks
</file>

<file path="packages/ui/src/elements/NavGroup/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .nav-group {
    width: 100%;
    margin-bottom: base(0.5);

    &__toggle {
      cursor: pointer;
      color: var(--theme-elevation-400);
      background: transparent;
      padding-left: 0;
      border: 0;
      margin-bottom: base(0.25);
      width: 100%;
      text-align: left;
      display: flex;
      align-items: flex-start;
      padding: 0;
      gap: base(0.5);
      justify-content: space-between;

      svg {
        flex-shrink: 0;
        margin-top: base(-0.2);
      }

      &:hover,
      &:focus-visible {
        color: var(--theme-elevation-1000);

        .stroke {
          stroke: var(--theme-elevation-1000);
        }
      }

      &:focus-visible {
        outline: none;
      }
    }

    &__indicator {
      position: relative;
      flex-shrink: 0;

      svg .stroke {
        stroke: var(--theme-elevation-200);
      }
    }

    &--collapsed {
      .collapsible__toggle {
        border-bottom-right-radius: $style-radius-m;
        border-bottom-left-radius: $style-radius-m;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/NavGroup/index.tsx">
import type { NavPreferences } from '@convexcms/core'
⋮----
import React, { useState } from 'react'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { usePreferences } from '../../providers/Preferences/index.js'
⋮----
import { AnimateHeight } from '../AnimateHeight/index.js'
import { useNav } from '../Nav/context.js'
⋮----
type Props = {
  children: React.ReactNode
  isOpen?: boolean
  label: string
}
⋮----
const toggleCollapsed = () =>
</file>

<file path="packages/ui/src/elements/Pagination/ClickableArrow/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .clickable-arrow {
    cursor: pointer;
    @extend %btn-reset;
    width: base(2);
    height: base(2);
    display: flex;
    justify-content: center;
    align-content: center;
    align-items: center;
    outline: 0;
    padding: base(0.5);
    color: var(--theme-elevation-800);
    line-height: base(1);

    &:not(.clickable-arrow--is-disabled) {
      &:hover,
      &:focus-visible {
        background: var(--theme-elevation-100);
      }
    }

    &:focus-visible {
      outline: var(--accessibility-outline);
    }

    &--right {
      .icon {
        transform: rotate(-90deg);
      }
    }

    &--left .icon {
      transform: rotate(90deg);
    }

    &--is-disabled {
      cursor: default;

      .icon .stroke {
        stroke: var(--theme-elevation-400);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Pagination/ClickableArrow/index.tsx">
import React from 'react'
⋮----
import { ChevronIcon } from '../../../icons/Chevron/index.js'
⋮----
export type ClickableArrowProps = {
  direction?: 'left' | 'right'
  isDisabled?: boolean
  updatePage?: () => void
}
⋮----
export const ClickableArrow: React.FC<ClickableArrowProps> = (props) =>
</file>

<file path="packages/ui/src/elements/Pagination/Page/index.tsx">
import React from 'react'
⋮----
export type PageProps = {
  isCurrent?: boolean
  isFirstPage?: boolean
  isLastPage?: boolean
  page?: number
  updatePage?: (page) => void
}
⋮----
export const Page: React.FC<PageProps> = ({
  isCurrent,
  isFirstPage = false,
  isLastPage = false,
  page = 1,
  updatePage,
}) =>
</file>

<file path="packages/ui/src/elements/Pagination/Separator/index.tsx">
import React from 'react'
⋮----
export const Separator: React.FC = ()
</file>

<file path="packages/ui/src/elements/Pagination/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .paginator {
    display: flex;
    margin-bottom: $baseline;

    &__page {
      cursor: pointer;

      &--is-current {
        background: var(--theme-elevation-100);
        color: var(--theme-elevation-400);
        cursor: default;
      }

      &--is-last-page {
        margin-right: 0;
      }
    }

    .clickable-arrow--right {
      margin-right: base(0.25);
    }

    &__page {
      @extend %btn-reset;
      width: base(2);
      height: base(2);
      display: flex;
      justify-content: center;
      align-content: center;
      outline: 0;
      padding: base(0.5);
      color: var(--theme-elevation-800);
      line-height: base(1);

      &:focus-visible {
        outline: var(--accessibility-outline);
      }
    }

    &__page,
    &__separator {
      margin-right: base(0.25);
    }

    &__separator {
      align-self: center;
      color: var(--theme-elevation-400);
    }
  }
}
</file>

<file path="packages/ui/src/elements/Pagination/index.tsx">
import React from 'react'
⋮----
import { ClickableArrow } from './ClickableArrow/index.js'
⋮----
import { Page } from './Page/index.js'
import { Separator } from './Separator/index.js'
⋮----
export type PaginationProps = {
  hasNextPage?: boolean
  hasPrevPage?: boolean
  limit?: number
  nextPage?: number
  numberOfNeighbors?: number
  onChange?: (page: number) => void
  page?: number
  prevPage?: number
  totalPages?: number
}
⋮----
export type Node =
  | {
      props?: {
        direction?: 'left' | 'right'
        isDisabled?: boolean
        isFirstPage?: boolean
        isLastPage?: boolean
        page?: number
        updatePage: (page?: number) => void
      }
      type: 'ClickableArrow' | 'Page' | 'Separator'
    }
  | number
⋮----
const updatePage = (page) =>
⋮----
// Create array of integers for each page
⋮----
// Assign indices for start and end of the range of pages that should be shown in paginator
⋮----
// Sanitize rangeStartIndex in case it is less than zero for safe split
⋮----
// Slice out the range of pages that we want to render
⋮----
// Add prev separator if necessary
⋮----
// Add first page if necessary
⋮----
// Add next separator if necessary
⋮----
// Add last page if necessary
⋮----
// Add prev and next arrows based on necessity
</file>

<file path="packages/ui/src/elements/PerPage/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .per-page {
    ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 4);
    }

    &__base-button {
      display: flex;
      align-items: center;
      font-weight: bold;
    }

    &__button {
      @extend %btn-reset;
      cursor: pointer;
      text-align: left;
      width: 100%;
      display: flex;
      align-items: center;
      color: var(--theme-elevation-500);

      &:hover,
      &:focus-visible {
        text-decoration: underline;
      }

      svg .stroke {
        stroke: currentColor;
      }
    }

    &__chevron {
      padding-left: calc(var(--base) / 4);
    }

    &__button-active {
      font-weight: bold;
      color: var(--theme-text);
    }
  }
}
</file>

<file path="packages/ui/src/elements/PerPage/index.tsx">
// TODO: abstract the `next/navigation` dependency out from this component
import { collectionDefaults, isNumber } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Popup, PopupList } from '../Popup/index.js'
⋮----
export type PerPageProps = {
  readonly defaultLimit?: number
  readonly handleChange?: (limit: number) => void
  readonly limit: number
  readonly limits: number[]
  readonly resetPage?: boolean
}
⋮----
<span>
</file>

<file path="packages/ui/src/elements/Pill/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .pill {
    font-size: 1rem;
    line-height: base(1.2);
    display: inline-flex;
    background: var(--theme-elevation-150);
    color: var(--theme-elevation-800);
    border-radius: $style-radius-s;
    cursor: default;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    border: 0;
    padding: 0 base(0.4);
    align-items: center;
    flex-shrink: 0;
    gap: base(0.2);

    &--rounded {
      border-radius: var(--style-radius-l);
      line-height: 18px;
      font-size: 12px;
    }

    &:active,
    &:focus:not(:focus-visible) {
      outline: none;
    }

    &:focus-visible {
      outline: var(--accessibility-outline);
      outline-offset: var(--accessibility-outline-offset);
    }

    .icon {
      flex-shrink: 0;
      margin: base(0.1);
    }

    &__label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    &--has-action {
      cursor: pointer;
      text-decoration: none;
    }

    &--is-dragging {
      cursor: grabbing;
    }

    &--has-icon {
      padding-inline-start: base(0.4);
      padding-inline-end: base(0.3);

      svg {
        display: block;
      }
    }

    &--align-icon-left {
      flex-direction: row-reverse;
      padding-inline-start: base(0.1);
      padding-inline-end: base(0.4);
    }

    &--style-white {
      background: var(--theme-elevation-0);

      &.pill--has-action {
        &:hover,
        &:active {
          background: var(--theme-elevation-100);
        }
      }
    }

    &--style-always-white {
      background: var(--theme-elevation-850);
      color: var(--theme-elevation-0);

      &.pill--has-action {
        &:hover,
        &:active {
          background: var(--theme-elevation-750);
        }
      }
    }

    &--style-light {
      &.pill--has-action {
        &:hover,
        &:active {
          background: var(--theme-elevation-100);
        }
      }
    }

    &--style-light-gray {
      background: var(--theme-elevation-100);
      color: var(--theme-elevation-800);
    }

    &--style-warning {
      background: var(--theme-warning-150);
      color: var(--theme-warning-800);
    }

    &--style-success {
      background: var(--theme-success-150);
      color: var(--theme-success-800);
    }

    &--style-error {
      background: var(--theme-error-150);
      color: var(--theme-error-800);
    }

    &--style-dark {
      background: var(--theme-elevation-800);
      color: var(--theme-elevation-0);

      svg {
        @include color-svg(var(--theme-elevation-0));
      }

      &.pill--has-action {
        &:hover {
          background: var(--theme-elevation-750);
        }

        &:active {
          background: var(--theme-elevation-700);
        }
      }
    }

    &--size-small {
      padding: 0 base(0.2);
      line-height: 18px;
    }
  }

  html[data-theme='light'] {
    .pill {
      &--style-always-white {
        background: var(--theme-elevation-0);
        color: var(--theme-elevation-800);
        border: 1px solid var(--theme-elevation-100);

        &.pill--has-action {
          &:hover,
          &:active {
            background: var(--theme-elevation-100);
          }
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Pill/index.tsx">
import type { ElementType, HTMLAttributes } from 'react'
⋮----
import React from 'react' // TODO: abstract this out to support all routers
⋮----
import { Link } from '../Link/index.js'
⋮----
export type PillProps = {
  alignIcon?: 'left' | 'right'
  'aria-checked'?: boolean
  'aria-controls'?: string
  'aria-expanded'?: boolean
  'aria-label'?: string
  children?: React.ReactNode
  className?: string
  draggable?: boolean
  elementProps?: {
    ref: React.RefCallback<HTMLElement>
  } & HTMLAttributes<HTMLElement>
  icon?: React.ReactNode
  id?: string
  onClick?: () => void
  pillStyle?:
    | 'always-white'
    | 'dark'
    | 'error'
    | 'light'
    | 'light-gray'
    | 'success'
    | 'warning'
    | 'white'
  rounded?: boolean
  size?: 'medium' | 'small'
  to?: string
}
⋮----
export type RenderedTypeProps = {
  children: React.ReactNode
  className?: string
  onClick?: () => void
  to: string
  type?: 'button'
}
⋮----
import { useDraggableSortable } from '../DraggableSortable/useDraggableSortable/index.js'
</file>

<file path="packages/ui/src/elements/Popup/PopupButtonList/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .popup-button-list {
    --list-button-padding: calc(var(--base) * 0.5);
    display: flex;
    flex-direction: column;
    text-align: left;
    gap: 3px;
    [dir='rtl'] &__text-align--left {
      text-align: right;
    }
    &__text-align--left {
      text-align: left;
    }

    &__text-align--center {
      text-align: center;
    }
    [dir='rtl'] &__text-align--right {
      text-align: left;
    }
    &__text-align--right {
      text-align: right;
    }

    &__button {
      @extend %btn-reset;
      padding-left: var(--list-button-padding);
      padding-right: var(--list-button-padding);
      padding-top: 2px;
      padding-bottom: 2px;
      cursor: pointer;
      text-align: inherit;
      line-height: var(--base);
      text-decoration: none;
      border-radius: 3px;

      button {
        @extend %btn-reset;

        &:focus-visible {
          outline: none;
        }
      }

      &:hover,
      &:focus-visible,
      &:focus-within {
        background-color: var(--popup-button-highlight);
      }
    }

    &__button--selected {
      background-color: var(--theme-elevation-150);
    }
  }
}
</file>

<file path="packages/ui/src/elements/Popup/PopupButtonList/index.tsx">
import type { LinkProps } from 'next/link.js'
⋮----
import { Link } from '../../Link/index.js'
⋮----
export const ButtonGroup: React.FC<{
  buttonSize?: 'default' | 'small'
  children: React.ReactNode
  className?: string
  textAlign?: 'center' | 'left' | 'right'
}> = (
⋮----
type MenuButtonProps = {
  active?: boolean
  children: React.ReactNode
  className?: string
  disabled?: boolean
  href?: LinkProps['href']
  id?: string
  onClick?: (e?: React.MouseEvent) => void
}
⋮----
export const Button: React.FC<MenuButtonProps> = ({
  id,
  active,
  children,
  className,
  disabled,
  href,
  onClick,
}) =>
</file>

<file path="packages/ui/src/elements/Popup/PopupDivider/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .popup-divider {
    width: 100%;
    height: 1px;
    background-color: var(--theme-elevation-150);
    border: none;
  }
}
</file>

<file path="packages/ui/src/elements/Popup/PopupDivider/index.tsx">
import React from 'react'
⋮----
export const PopupListDivider: React.FC = () =>
</file>

<file path="packages/ui/src/elements/Popup/PopupGroupLabel/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .popup-list-group-label {
    color: var(--theme-elevation-500);
    padding: 0 var(--list-button-padding);
  }
}
</file>

<file path="packages/ui/src/elements/Popup/PopupGroupLabel/index.tsx">
import React from 'react'
⋮----
export const PopupListGroupLabel: React.FC<{
  label: string
}> = (
</file>

<file path="packages/ui/src/elements/Popup/PopupTrigger/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .popup-button {
    height: 100%;
    color: currentColor;
    padding: 0;
    font-size: inherit;
    line-height: inherit;
    font-family: inherit;
    border: 0;
    cursor: pointer;
    display: inline-flex;

    &--background {
      background: transparent;
    }

    &--size-small {
      padding: base(0.4);
    }

    &--size-medium {
      padding: base(0.6);
    }

    &--size-large {
      padding: base(0.8);
    }

    &--disabled {
      cursor: not-allowed;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Popup/PopupTrigger/index.tsx">
import React from 'react'
⋮----
export type PopupTriggerProps = {
  active: boolean
  button: React.ReactNode
  buttonType: 'custom' | 'default' | 'none'
  className?: string
  disabled?: boolean
  noBackground?: boolean
  setActive: (active: boolean) => void
  size?: 'large' | 'medium' | 'small'
}
⋮----
const handleClick = () =>
</file>

<file path="packages/ui/src/elements/Popup/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .popup {
    --popup-button-highlight: var(--theme-elevation-200);
    --popup-bg: var(--theme-input-bg);
    --popup-text: var(--theme-text);
    --popup-caret-size: 10px;
    --popup-x-padding: calc(var(--base) * 0.33);
    --popup-padding: calc(var(--base) * 0.5);
    --button-size-offset: -8px;
    position: relative;

    &__trigger-wrap {
      display: flex;
      align-items: stretch;
      height: 100%;
    }

    &__content {
      position: absolute;
      background: var(--popup-bg);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      z-index: var(--z-popup);
      max-width: calc(100vw - #{$baseline});
      color: var(--popup-text);
      border-radius: 4px;
      padding-left: var(--popup-padding);
      padding-right: var(--popup-padding);
      min-width: var(--popup-width, auto);
    }

    &__hide-scrollbar {
      overflow: hidden;
    }

    &__scroll-container {
      overflow-y: auto;
      white-space: nowrap;
      width: calc(100% + var(--scrollbar-width));
      padding-top: var(--popup-padding);
      padding-bottom: var(--popup-padding);
    }

    &__scroll-content {
      width: calc(100% - var(--scrollbar-width));
    }

    &--show-scrollbar {
      .popup__scroll-container,
      .popup__scroll-content {
        width: 100%;
      }
    }

    &:focus,
    &:active {
      outline: none;
    }

    ////////////////////////////////
    // SIZE
    ////////////////////////////////

    &--size-small {
      --popup-width: 100px;
      .popup__content {
        @include shadow-m;
      }
    }

    &--size-medium {
      --popup-width: 150px;
      .popup__content {
        @include shadow-lg;
      }
    }

    &--size-large {
      --popup-width: 200px;
      .popup__content {
        @include shadow-lg;
      }
    }

    ////////////////////////////////
    /// BUTTON SIZE
    ////////////////////////////////

    &--button-size-small {
      --button-size-offset: -8px;
    }

    &--button-size-medium {
      --button-size-offset: -4px;
    }

    &--button-size-large {
      --button-size-offset: 0px;
    }

    ////////////////////////////////
    // HORIZONTAL ALIGNMENT
    ////////////////////////////////
    [dir='rtl'] &--h-align-left {
      .popup__caret {
        right: var(--popup-padding);
        left: unset;
      }
    }
    &--h-align-left {
      .popup__caret {
        left: var(--popup-padding);
      }
    }
    &--h-align-center {
      .popup__content {
        left: 50%;
        transform: translateX(-50%);
      }

      .popup__caret {
        left: 50%;
        transform: translateX(-50%);
      }
    }

    [dir='rtl'] &--h-align-right {
      .popup__content {
        right: unset;
        left: 0;
      }

      .popup__caret {
        right: unset;
        left: var(--popup-padding);
      }
    }

    &--h-align-right {
      .popup__content {
        right: var(--button-size-offset);
      }

      .popup__caret {
        right: var(--popup-padding);
      }
    }

    ////////////////////////////////
    // VERTICAL ALIGNMENT
    ////////////////////////////////

    &__caret {
      position: absolute;
      border: var(--popup-caret-size) solid transparent;
    }

    &--v-align-top {
      .popup__content {
        @include shadow-lg;
        bottom: calc(100% + var(--popup-caret-size));
      }

      .popup__caret {
        top: calc(100% - 1px);
        border-top-color: var(--popup-bg);
      }
    }

    &--v-align-bottom {
      .popup__content {
        @include shadow-lg-top;
        top: calc(100% + var(--popup-caret-size));
      }

      .popup__caret {
        bottom: calc(100% - 1px);
        border-bottom-color: var(--popup-bg);
      }
    }

    ////////////////////////////////
    // ACTIVE
    ////////////////////////////////

    &--active {
      .popup__content {
        opacity: 1;
        visibility: visible;
        pointer-events: all;
      }
    }

    @include mid-break {
      --popup-padding: calc(var(--base) * 0.25);

      &--h-align-center {
        .popup__content {
          left: 50%;
          transform: translateX(-0%);
        }

        .popup__caret {
          left: 50%;
          transform: translateX(-0%);
        }
      }

      &--h-align-right {
        .popup__content {
          right: 0;
        }

        .popup__caret {
          right: var(--popup-padding);
        }
      }

      &--force-h-align-left {
        .popup__content {
          left: 0;
          right: unset;
          transform: unset;
        }

        .popup__caret {
          left: var(--popup-padding);
          right: unset;
          transform: unset;
        }
      }

      &--force-h-align-right {
        .popup__content {
          right: 0;
          left: unset;
          transform: unset;
        }

        .popup__caret {
          right: var(--popup-padding);
          left: unset;
          transform: unset;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Popup/index.tsx">
import type { CSSProperties } from 'react'
⋮----
import { useWindowInfo } from '@faceless-ui/window-info'
import React, { useCallback, useEffect, useRef, useState } from 'react'
⋮----
import { useIntersect } from '../../hooks/useIntersect.js'
import { PopupTrigger } from './PopupTrigger/index.js'
⋮----
export type PopupProps = {
  backgroundColor?: CSSProperties['backgroundColor']
  boundingRef?: React.RefObject<HTMLElement>
  button?: React.ReactNode
  buttonClassName?: string
  buttonSize?: 'large' | 'medium' | 'small'
  buttonType?: 'custom' | 'default' | 'none'
  caret?: boolean
  children?: React.ReactNode
  className?: string
  disabled?: boolean
  forceOpen?: boolean
  horizontalAlign?: 'center' | 'left' | 'right'
  id?: string
  initActive?: boolean
  noBackground?: boolean
  onToggleOpen?: (active: boolean) => void
  render?: (any) => React.ReactNode
  showOnHover?: boolean
  showScrollbar?: boolean
  size?: 'fit-content' | 'large' | 'medium' | 'small'
  verticalAlign?: 'bottom' | 'top'
}
</file>

<file path="packages/ui/src/elements/PreviewButton/index.tsx">
import type { PreviewButtonClientProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { Button } from '../Button/index.js'
import { usePreviewURL } from './usePreviewURL.js'
⋮----
export function PreviewButton(props: PreviewButtonClientProps)
⋮----
// disabled={disabled}
</file>

<file path="packages/ui/src/elements/PreviewButton/usePreviewURL.tsx">
import { useCallback, useRef, useState } from 'react'
import { toast } from 'sonner'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export const usePreviewURL = ():
⋮----
// we need to regenerate the preview URL every time the button is clicked
// to do this we need to fetch the document data fresh from the API
// this will ensure the latest data is used when generating the preview URL
⋮----
// eslint-disable-next-line @typescript-eslint/no-misused-promises
</file>

<file path="packages/ui/src/elements/PreviewSizes/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .preview-sizes {
    margin: base(2) calc(var(--gutter-h) * -1) 0 calc(var(--gutter-h) * -1);
    border-top: 1px solid var(--theme-elevation-150);
    max-height: calc(100vh - base(6));
    height: 100%;
    display: flex;
    flex-direction: row;

    &__imageWrap {
      min-width: 60%;
      border-right: 1px solid var(--theme-elevation-150);
    }

    &__preview {
      max-height: calc(100% - base(6));
      padding: base(1.5) base(1.5) base(1.5) var(--gutter-h);
      object-fit: contain;
    }

    &__meta {
      border-bottom: 1px solid var(--theme-elevation-150);
      padding: base(1) var(--gutter-h);
      display: flex;
      flex-wrap: wrap;
      column-gap: base(1);

      .file-meta {
        display: flex;
        flex-wrap: wrap;
        column-gap: base(1);
        text-wrap: wrap;
        width: 100%;
      }

      .file-meta__url {
        width: 100%;
      }
    }

    &__sizeName,
    .file-meta__size-type {
      color: var(--theme-elevation-600);
    }

    &__listWrap {
      padding-right: var(--gutter-h);
      overflow-y: scroll;

      &::-webkit-scrollbar {
        width: 0;
      }

      &::after {
        content: '';
        display: block;
        position: sticky;
        bottom: 0;
        left: 0;
        height: base(4);
        width: 100%;
        background: linear-gradient(180deg, transparent 0, var(--theme-bg) 100%);
        pointer-events: none;
      }
    }

    &__list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: base(0.5);
      margin: 0;
      padding: base(1.5) 0 base(1.5) base(1.5);
    }

    &__sizeOption {
      padding: base(0.5);
      display: flex;
      gap: base(1);
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;

      &:hover {
        background-color: var(--theme-elevation-100);
      }
    }

    &--selected {
      background-color: var(--theme-elevation-100);
    }

    &__image {
      display: flex;
      width: 30%;
      min-width: 30%;
      align-items: center;
      justify-content: center;
    }

    &__sizeMeta {
      padding: base(0.5) 0;
    }

    &__sizeName,
    &__sizeMeta {
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @include mid-break {
      margin-top: base(1);
      max-height: calc(100vh - base(4));
    }

    @include small-break {
      margin-top: 0;
      max-height: calc(100vh - base(3.5));
      flex-direction: column;
      justify-content: space-between;

      &__imageWrap {
        height: 60%;
        border: none;
      }

      &__list,
      &__preview {
        padding: calc(var(--gutter-h) * 2) var(--gutter-h);
      }

      &__preview {
        max-height: calc(100% - base(4));
      }

      &__sizeOption {
        padding: base(0.25);
      }

      &__listWrap {
        border-top: 1px solid var(--theme-elevation-150);
        height: 40%;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/PreviewSizes/index.tsx">
import type { Data, FileSize, SanitizedCollectionConfig, SanitizedUploadConfig } from '@convexcms/core'
⋮----
import React, { useEffect, useMemo, useState } from 'react'
⋮----
import { FileMeta } from '../FileDetails/FileMeta/index.js'
⋮----
type FileInfo = {
  url: string
} & FileSize
type FilesSizesWithUrl = {
  [key: string]: FileInfo
}
⋮----
const sortSizes = (sizes: FilesSizesWithUrl, imageSizes: SanitizedUploadConfig['imageSizes']) =>
⋮----
type PreviewSizeCardProps = {
  active: boolean
  meta: FileInfo
  name: string
  onClick?: () => void
  previewSrc: string
}
⋮----
const generateImageUrl = (doc) =>
⋮----
onClick=
</file>

<file path="packages/ui/src/elements/PublishButton/ScheduleDrawer/buildUpcomingColumns.tsx">
import type { ClientConfig, Column } from '@convexcms/core'
⋮----
import { getTranslation, type I18nClient, type TFunction } from '@convexcms/translations'
import React from 'react'
⋮----
import type { UpcomingEvent } from './types.js'
⋮----
import { formatDate } from '../../../utilities/formatDocTitle/formatDateTitle.js'
import { Button } from '../../Button/index.js'
import { Pill } from '../../Pill/index.js'
⋮----
type Args = {
  dateFormat: string
  deleteHandler: (id: number | string) => void
  docs: UpcomingEvent[]
  i18n: I18nClient
  localization: ClientConfig['localization']
  supportedTimezones: ClientConfig['admin']['timezones']['supportedTimezones']
  t: TFunction
}
⋮----
Heading: <span>
</file>

<file path="packages/ui/src/elements/PublishButton/ScheduleDrawer/index.scss">
@layer payload-default {
  .schedule-publish {
    &__drawer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: calc(var(--base) * 2.5) var(--gutter-h);
      height: 48px;
      border-bottom: 1px solid var(--theme-border-color);

      h2 {
        margin: 0;
      }
    }

    &__scheduler {
      padding-top: calc(var(--base) * 2);
      padding-bottom: calc(var(--base) * 2);
      border-bottom: 1px solid var(--theme-border-color);
    }

    &__type {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;

      li {
        margin-right: calc(var(--base) * 2);
      }
    }

    &__actions {
      button {
        margin-right: var(--base);
      }
    }

    &__upcoming {
      padding-top: calc(var(--base) * 2);
      padding-bottom: calc(var(--base) * 2);

      h4 {
        margin-bottom: var(--base);
      }
    }

    &__delete {
      margin: 0;
    }
  }
}
</file>

<file path="packages/ui/src/elements/PublishButton/ScheduleDrawer/index.tsx">
/* eslint-disable no-console */
⋮----
import type { Column, SchedulePublish, Where } from '@convexcms/core'
⋮----
import { TZDateMini as TZDate } from '@date-fns/tz/date/mini'
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { transpose } from 'date-fns/transpose'
⋮----
import React, { useCallback, useMemo } from 'react'
import { toast } from 'sonner'
⋮----
import type { PublishType, UpcomingEvent } from './types.js'
⋮----
import { FieldLabel } from '../../../fields/FieldLabel/index.js'
import { Radio } from '../../../fields/RadioGroup/Radio/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useServerFunctions } from '../../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { requests } from '../../../utilities/api.js'
import { Banner } from '../../Banner/index.js'
import { DrawerCloseButton } from '../../BulkUpload/DrawerCloseButton/index.js'
import { Button } from '../../Button/index.js'
import { DatePickerField } from '../../DatePicker/index.js'
import { Drawer } from '../../Drawer/index.js'
import { Gutter } from '../../Gutter/index.js'
import { ReactSelect } from '../../ReactSelect/index.js'
import { ShimmerEffect } from '../../ShimmerEffect/index.js'
⋮----
import { Table } from '../../Table/index.js'
import { TimezonePicker } from '../../TimezonePicker/index.js'
import { buildUpcomingColumns } from './buildUpcomingColumns.js'
⋮----
type Props = {
  defaultType?: PublishType
  schedulePublishConfig?: SchedulePublish
  slug: string
}
⋮----
// Get the user timezone so we can adjust the displayed value against it
⋮----
// eslint-disable-next-line @typescript-eslint/no-misused-promises
⋮----
// Create TZDate instances for the selected timezone and the user's timezone
// These instances allow us to transpose the date between timezones while keeping the same time value
⋮----
// Transpose the date to the selected timezone
⋮----
// Transpose the date to the user's timezone - this is necessary because the react-datepicker component insists on displaying the date in the user's timezone
⋮----
// Create TZDate instances for the selected timezone
⋮----
// Creates a TZDate instance for the user's timezone  — this is default behaviour of TZDate as it wraps the Date constructor
⋮----
// Transpose the date to the selected timezone
⋮----
const fetchInitialUpcoming = async () =>
⋮----
<FieldLabel label=
⋮----
onChange=
</file>

<file path="packages/ui/src/elements/PublishButton/ScheduleDrawer/types.ts">
export type PublishType = 'publish' | 'unpublish'
⋮----
export type UpcomingEvent = {
  id: number | string
  input: {
    locale?: string
    timezone?: string
    type: PublishType
  }
  waitUntil: Date
}
</file>

<file path="packages/ui/src/elements/PublishButton/index.tsx">
import type { PublishButtonClientProps } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
⋮----
import React, { useCallback } from 'react'
⋮----
import { useForm, useFormModified } from '../../forms/Form/context.js'
import { FormSubmit } from '../../forms/Submit/index.js'
import { useHotkey } from '../../hooks/useHotkey.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { PopupList } from '../Popup/index.js'
import { ScheduleDrawer } from './ScheduleDrawer/index.js'
⋮----
// If autosave is enabled the modified will always be true so only conditionally check on modified state
</file>

<file path="packages/ui/src/elements/PublishMany/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .publish-many {
    &__toggle {
      font-size: inherit;
      line-height: inherit;
      display: inline-flex;
      background: transparent;
      color: var(--theme-elevation-800);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 0;
      padding: 0;
      align-items: center;
      cursor: pointer;
      text-decoration: underline;
    }
  }
}
</file>

<file path="packages/ui/src/elements/PublishMany/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter, useSearchParams } from 'next/navigation.js'
⋮----
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useRouteCache } from '../../providers/RouteCache/index.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { parseSearchParams } from '../../utilities/parseSearchParams.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
⋮----
export type PublishManyProps = {
  collection: ClientCollectionConfig
}
⋮----
clearRouteCache() // Use clearRouteCache instead of router.refresh, as we only need to clear the cache if the user has route caching enabled - clearRouteCache checks for this
</file>

<file path="packages/ui/src/elements/QueryPresets/cells/AccessCell/index.tsx">
import type { DefaultCellComponentProps } from '@convexcms/core'
import type { JSX } from 'react'
⋮----
import { toWords } from '@convexcms/core/shared'
import React, { Fragment } from 'react'
⋮----
export const QueryPresetsAccessCell: React.FC<DefaultCellComponentProps> = (
⋮----
// first sort the operations in the order they should be displayed
</file>

<file path="packages/ui/src/elements/QueryPresets/cells/ColumnsCell/index.scss">
@import '../../../../scss/styles';

@layer payload-default {
  .query-preset-columns-cell {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
  }
}
</file>

<file path="packages/ui/src/elements/QueryPresets/cells/ColumnsCell/index.tsx">
import type { ColumnPreference, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import { toWords, transformColumnsToSearchParams } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { Pill } from '../../../Pill/index.js'
⋮----
// to void very lengthy cells, only display the active columns
</file>

<file path="packages/ui/src/elements/QueryPresets/cells/WhereCell/index.tsx">
import type { DefaultCellComponentProps, Where } from '@convexcms/core'
⋮----
import { toWords } from '@convexcms/core/shared'
import React from 'react'
⋮----
/** @todo: improve this */
const transformWhereToNaturalLanguage = (where: Where): string =>
</file>

<file path="packages/ui/src/elements/QueryPresets/fields/ColumnsField/index.scss">
@import '../../../../scss/styles';

@layer payload-default {
  .query-preset-columns-field {
    .field-label {
      margin-bottom: calc(var(--base) / 2);
    }

    .value-wrapper {
      background-color: var(--theme-elevation-50);
      padding: var(--base);
      display: flex;
      flex-wrap: wrap;
      gap: calc(var(--base) / 2);
    }
  }
}
</file>

<file path="packages/ui/src/elements/QueryPresets/fields/ColumnsField/index.tsx">
import type { ColumnPreference, JSONFieldClientComponent } from '@convexcms/core'
⋮----
import { toWords, transformColumnsToSearchParams } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { FieldLabel } from '../../../../fields/FieldLabel/index.js'
import { useField } from '../../../../forms/useField/index.js'
import { Pill } from '../../../Pill/index.js'
</file>

<file path="packages/ui/src/elements/QueryPresets/fields/WhereField/index.scss">
@import '../../../../scss/styles';

@layer payload-default {
  .query-preset-where-field {
    .field-label {
      margin-bottom: calc(var(--base) / 2);
    }

    .value-wrapper {
      background-color: var(--theme-elevation-50);
      padding: var(--base);
    }
  }

  .query-preset-where-field {
    .pill {
      &--style-always-white {
        background: var(--theme-elevation-250);
        color: var(--theme-elevation-1000);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/QueryPresets/fields/WhereField/index.tsx">
import type { JSONFieldClientComponent, Where } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { toWords } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { FieldLabel } from '../../../../fields/FieldLabel/index.js'
import { useField } from '../../../../forms/useField/index.js'
import { useConfig } from '../../../../providers/Config/index.js'
import { useListQuery } from '../../../../providers/ListQuery/index.js'
import { useTranslation } from '../../../../providers/Translation/index.js'
import { Pill } from '../../../Pill/index.js'
⋮----
/** @todo: improve this */
⋮----
const renderCondition = (condition: any): React.ReactNode =>
⋮----
// TODO: this is not right, but works for now at least.
// Ideally we look up iterate _fields_ so we know the type of the field
// Currently, we're only iterating over the `where` field's value, so we don't know the type
⋮----
</file>

<file path="packages/ui/src/elements/ReactSelect/ClearIndicator/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .clear-indicator {
    cursor: pointer;

    &:focus-visible {
      outline: var(--accessibility-outline);
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/ClearIndicator/index.tsx">
import type { ClearIndicatorProps } from 'react-select'
⋮----
import React from 'react'
⋮----
import type { Option as OptionType } from '../types.js'
⋮----
import { XIcon } from '../../../icons/X/index.js'
⋮----
export const ClearIndicator: React.FC<ClearIndicatorProps<OptionType, true>> = (props) =>
⋮----
// TODO Fix this - Broke with React 19 types
</file>

<file path="packages/ui/src/elements/ReactSelect/Control/index.tsx">
import type { ControlProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
export const Control: React.FC<ControlProps<Option, any>> = (props) =>
⋮----
// @ts-expect-error-next-line // TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
// Create event for keydown listeners which specifically want to bypass this stopPropagation
⋮----
// react-select has this typed incorrectly so we disable the linting rule
// we need to prevent react-select from hijacking the 'onKeyDown' event while modals are open (i.e. the 'Relationship' field component)
⋮----
// we need to prevent react-select from hijacking the 'onMouseDown' event while modals are open (i.e. the 'Relationship' field component)
</file>

<file path="packages/ui/src/elements/ReactSelect/DropdownIndicator/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .dropdown-indicator {
    cursor: pointer;
    @include btn-reset;

    &:focus-visible {
      outline: var(--accessibility-outline);
    }

    &__icon {
      .stroke {
        stroke-width: 1px;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/DropdownIndicator/index.tsx">
import type { DropdownIndicatorProps } from 'react-select'
⋮----
import React, { type JSX } from 'react'
⋮----
import type { Option as OptionType } from '../types.js'
⋮----
import { ChevronIcon } from '../../../icons/Chevron/index.js'
⋮----
export const DropdownIndicator: React.FC<
  {
    innerProps: JSX.IntrinsicElements['button']
  } & DropdownIndicatorProps<OptionType, true>
> = (props) =>
</file>

<file path="packages/ui/src/elements/ReactSelect/Input/index.tsx">
import type { InputProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
export const Input: React.FC<InputProps<Option, any>> = (props) =>
⋮----
/**
         * Adding `aria-activedescendant` fixes hydration error
         * source: https://github.com/JedWatson/react-select/issues/5459#issuecomment-1878037196
         */
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValue/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .multi-value {
    &.rs__multi-value {
      display: flex;
      padding: 0;
      border: 1px solid var(--theme-border-color);
      border-radius: var(--style-radius-s);
      line-height: calc(#{$baseline} - 2px);
      margin: base(0.25) base(0.5) base(0.25) 0;
      transition: border 0.2s cubic-bezier(0.2, 0, 0, 1);

      &:hover {
        border: 1px solid var(--theme-elevation-250);
      }
    }

    &--is-dragging {
      z-index: 2;
    }
  }

  html[data-theme='light'] {
    .multi-value {
      &.rs__multi-value {
        background: var(--theme-elevation-50);
      }
    }
  }

  html[data-theme='dark'] {
    .multi-value {
      &.rs__multi-value {
        background: var(--theme-elevation-50);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValue/index.tsx">
import type { MultiValueProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
import { useDraggableSortable } from '../../DraggableSortable/useDraggableSortable/index.js'
⋮----
export function generateMultiValueDraggableID(optionData, valueFunction)
⋮----
// @ts-expect-error // TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
// we need to prevent the dropdown from opening when clicking on the drag handle, but not when a modal is open (i.e. the 'Relationship' field component)
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValueLabel/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .multi-value-label {
    @extend %small;
    display: flex;
    align-items: center;
    max-width: 150px;
    color: currentColor;
    padding: 0 base(0.4);

    &__text {
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;

      &--editable {
        cursor: text;
        outline: var(--accessibility-outline);
      }
    }

    &:focus-visible {
      outline: var(--accessibility-outline);
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValueLabel/index.tsx">
import type { MultiValueProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
export const MultiValueLabel: React.FC<MultiValueProps<Option>> = (props) =>
⋮----
// @ts-expect-error-next-line// TODO Fix this - moduleResolution 16 breaks our declare module
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValueRemove/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .multi-value-remove {
    cursor: pointer;
    width: base(1);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    background-color: transparent;
    border: none;
    padding: 0;
    color: inherit;

    &:hover {
      color: var(--theme-elevation-800);
      background: var(--theme-elevation-150);
    }

    &__icon {
      width: 100%;
      height: 100%;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/MultiValueRemove/index.tsx">
import type { MultiValueRemoveProps } from 'react-select'
⋮----
import React, { type JSX } from 'react'
⋮----
import type { Option as OptionType } from '../types.js'
⋮----
import { XIcon } from '../../../icons/X/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { Tooltip } from '../../Tooltip/index.js'
</file>

<file path="packages/ui/src/elements/ReactSelect/SingleValue/index.tsx">
import type { SingleValueProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
export const SingleValue: React.FC<SingleValueProps<Option>> = (props) =>
</file>

<file path="packages/ui/src/elements/ReactSelect/ValueContainer/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .value-container {
    flex-grow: 1;
    min-width: 0;

    .rs__value-container {
      overflow: visible;
      padding: 2px;
      gap: 2px;

      > * {
        margin: 0;
        padding-top: 0;
        padding-bottom: 0;
        color: currentColor;

        .field-label {
          padding-bottom: 0;
        }
      }

      &--is-multi {
        width: calc(100% + base(0.25));

        &.rs__value-container--has-value {
          padding: 0;
          margin-inline-start: -4px;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/ValueContainer/index.tsx">
import type { ValueContainerProps } from 'react-select'
⋮----
import React from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { Option } from '../types.js'
⋮----
export const ValueContainer: React.FC<ValueContainerProps<Option, any>> = (props) =>
⋮----
// @ts-expect-error-next-line // TODO Fix this - moduleResolution 16 breaks our declare module
</file>

<file path="packages/ui/src/elements/ReactSelect/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .react-select-container {
    width: 100%;
  }

  .react-select {
    .rs__control {
      @include formInput;
      height: auto;
      padding: base(0.35) base(0.6);
      flex-wrap: nowrap;
    }

    .rs__menu-notice {
      padding: base(0.5) base(0.6);
    }

    .rs__indicators {
      gap: calc(var(--base) / 4);
    }

    .rs__indicator {
      padding: 0px 4px;
      cursor: pointer;
    }

    .rs__indicator-separator {
      display: none;
    }

    .rs__input-container {
      color: var(--theme-elevation-1000);
    }

    .rs__input {
      font-family: var(--font-body);
      width: 10px;
    }

    .rs__menu {
      z-index: 4;
      border-radius: 0;
      @include shadow-lg;
      background: var(--theme-input-bg);
    }

    .rs__group-heading {
      color: var(--theme-elevation-800);
      padding-left: base(0.5);
      margin-top: base(0.25);
      margin-bottom: base(0.25);
    }

    .rs__option {
      font-family: var(--font-body);
      font-size: $baseline-body-size;
      padding: base(0.375) base(0.75);
      color: var(--theme-elevation-800);

      &--is-focused {
        background-color: var(--theme-elevation-100);
      }

      &--is-selected {
        background-color: var(--theme-elevation-300);
      }
    }

    &--error,
    &--error:hover,
    &--error:focus-within {
      div.rs__control {
        background-color: var(--theme-error-50);
        border: 1px solid var(--theme-error-500);

        & > div.rs__indicator > button.dropdown-indicator[type='button'] {
          border: none;
        }
      }
    }

    &.rs--is-disabled .rs__control {
      @include readOnly;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ReactSelect/index.tsx">
import type { KeyboardEventHandler } from 'react'
⋮----
import { arrayMove } from '@dnd-kit/sortable'
import { getTranslation } from '@convexcms/translations'
import React, { useEffect, useId } from 'react'
import Select, { type StylesConfig } from 'react-select'
import CreatableSelect from 'react-select/creatable'
⋮----
import type { Option, ReactSelectAdapterProps } from './types.js'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
import { DraggableSortable } from '../DraggableSortable/index.js'
import { ShimmerEffect } from '../ShimmerEffect/index.js'
import { ClearIndicator } from './ClearIndicator/index.js'
import { Control } from './Control/index.js'
import { DropdownIndicator } from './DropdownIndicator/index.js'
⋮----
import { Input } from './Input/index.js'
import { generateMultiValueDraggableID, MultiValue } from './MultiValue/index.js'
import { MultiValueLabel } from './MultiValueLabel/index.js'
import { MultiValueRemove } from './MultiValueRemove/index.js'
import { SingleValue } from './SingleValue/index.js'
import { ValueContainer } from './ValueContainer/index.js'
⋮----
const createOption = (label: string) => (
⋮----
const [inputValue, setInputValue] = React.useState('') // for creatable select
⋮----
const loadingMessage = ()
⋮----
// Remove the default react-select z-index from the menu so that our custom
// z-index in the "payload-default" css layer can take effect, in such a way
// that end users can easily override it as with other styles.
⋮----
placeholder=
</file>

<file path="packages/ui/src/elements/ReactSelect/types.ts">
import type { CommonProps, GroupBase, Props as ReactSelectStateManagerProps } from 'react-select'
⋮----
import type { DocumentDrawerProps, UseDocumentDrawer } from '../DocumentDrawer/types.js'
⋮----
type CustomSelectProps = {
  disableKeyDown?: boolean
  disableMouseDown?: boolean
  DocumentDrawerToggler?: ReturnType<UseDocumentDrawer>[1]
  draggableProps?: any
  droppableRef?: React.RefObject<HTMLDivElement | null>
  editableProps?: (
    data: Option<{ label: string; value: string }>,
    className: string,
    selectProps: ReactSelectStateManagerProps,
  ) => any
  onDelete?: DocumentDrawerProps['onDelete']
  onDocumentDrawerOpen?: (args: {
    collectionSlug: string
    hasReadPermission: boolean
    id: number | string
  }) => void
  onDuplicate?: DocumentDrawerProps['onSave']
  onSave?: DocumentDrawerProps['onSave']
}
⋮----
// augment the types for the `Select` component from `react-select`
// this is to include the `selectProps` prop at the top-level `Select` component
// @ts-expect-error-next-line // TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
export interface Props<Option, IsMulti extends boolean, Group extends GroupBase<Option>> {
    customProps?: CustomSelectProps
  }
⋮----
// augment the types for the `CommonPropsAndClassName` from `react-select`
// this will include the `selectProps` prop to every `react-select` component automatically
// @ts-expect-error-next-line // TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
export interface CommonPropsAndClassName<
    Option,
    IsMulti extends boolean,
    Group extends GroupBase<Option>,
  > extends CommonProps<Option, IsMulti, Group> {
    customProps?: CustomSelectProps & ReactSelectStateManagerProps<Option, IsMulti, Group>
  }
⋮----
export type Option<TValue = unknown> = {
  [key: string]: unknown
  //* The ID is used to identify the option in the UI. If it doesn't exist and value cannot be transformed into a string, sorting won't work */
  id?: string
  value: TValue
}
⋮----
//* The ID is used to identify the option in the UI. If it doesn't exist and value cannot be transformed into a string, sorting won't work */
⋮----
export type OptionGroup = {
  label: string
  options: Option[]
}
⋮----
export type ReactSelectAdapterProps = {
  backspaceRemovesValue?: boolean
  blurInputOnSelect?: boolean
  className?: string
  components?: {
    [key: string]: React.FC<any>
  }
  customProps?: CustomSelectProps
  disabled?: boolean
  filterOption?:
    | ((
        {
          allowEdit,
          data,
          label,
          value,
        }: { allowEdit: boolean; data: Option; label: string; value: string },
        search: string,
      ) => boolean)
    | undefined
  getOptionValue?: ReactSelectStateManagerProps<
    Option,
    boolean,
    GroupBase<Option>
  >['getOptionValue']
  inputId?: string
  isClearable?: boolean
  /** Allows you to create own values in the UI despite them not being pre-specified */
  isCreatable?: boolean
  isLoading?: boolean
  /** Allows you to specify multiple values instead of just one */
  isMulti?: boolean
  isOptionSelected?: any
  isSearchable?: boolean
  isSortable?: boolean
  menuIsOpen?: boolean
  noOptionsMessage?: (obj: { inputValue: string }) => string
  numberOnly?: boolean
  onChange?: (value: Option | Option[]) => void
  onInputChange?: (val: string) => void
  onMenuClose?: () => void
  onMenuOpen?: () => void
  onMenuScrollToBottom?: () => void
  options: Option[] | OptionGroup[]
  placeholder?: string
  showError?: boolean
  value?: Option | Option[]
}
⋮----
/** Allows you to create own values in the UI despite them not being pre-specified */
⋮----
/** Allows you to specify multiple values instead of just one */
</file>

<file path="packages/ui/src/elements/RelationshipTable/cells/DrawerLink/index.scss">
@layer payload-default {
  .drawer-link {
    display: flex;
    gap: calc(var(--base) / 2);
  }
}
</file>

<file path="packages/ui/src/elements/RelationshipTable/cells/DrawerLink/index.tsx">
import React, { useCallback } from 'react'
⋮----
import type { DocumentDrawerProps } from '../../../DocumentDrawer/types.js'
⋮----
import { EditIcon } from '../../../../icons/Edit/index.js'
import { useCellProps } from '../../../../providers/TableColumns/RenderDefaultCell/index.js'
import { useDocumentDrawer } from '../../../DocumentDrawer/index.js'
import { DefaultCell } from '../../../Table/DefaultCell/index.js'
⋮----
export const DrawerLink: React.FC<{
  readonly onDrawerDelete?: DocumentDrawerProps['onDelete']
  readonly onDrawerSave?: DocumentDrawerProps['onSave']
}> = (props) =>
</file>

<file path="packages/ui/src/elements/RelationshipTable/index.scss">
@layer payload-default {
  .relationship-table {
    position: relative;

    &__header {
      display: flex;
      justify-content: space-between;
      margin-bottom: var(--base);
    }

    &__actions {
      display: flex;
      align-items: center;
      gap: var(--base);
    }

    &__columns-inner {
      padding-bottom: var(--base);
    }

    &__add-new-polymorphic .btn__label {
      display: flex;
      text-wrap: nowrap;
      align-items: center;
    }

    .table {
      table {
        width: 100%;
        overflow: auto;

        [class^='cell'] > p,
        [class^='cell'] > span,
        [class^='cell'] > a {
          line-clamp: 4;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 4;
          overflow: hidden;
          display: -webkit-box;
          max-width: 100vw;
        }
      }

      th,
      td:first-child {
        min-width: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/RelationshipTable/index.tsx">
import { getTranslation } from '@convexcms/translations'
import {
  type CollectionSlug,
  type Column,
  type JoinFieldClient,
  type ListQuery,
  type PaginatedDocs,
  type Where,
} from '@convexcms/core'
import { hoistQueryParamsToAnd, transformColumnsToPreferences } from '@convexcms/core/shared'
import React, { Fragment, useCallback, useEffect, useState } from 'react'
⋮----
import type { DocumentDrawerProps } from '../DocumentDrawer/types.js'
⋮----
import { Button } from '../../elements/Button/index.js'
import { Pill } from '../../elements/Pill/index.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { PlusIcon } from '../../icons/Plus/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { ListQueryProvider } from '../../providers/ListQuery/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { TableColumnsProvider } from '../../providers/TableColumns/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { AnimateHeight } from '../AnimateHeight/index.js'
import { ColumnSelector } from '../ColumnSelector/index.js'
import { useDocumentDrawer } from '../DocumentDrawer/index.js'
import { Popup, PopupList } from '../Popup/index.js'
import { RelationshipProvider } from '../Table/RelationshipProvider/index.js'
import { DrawerLink } from './cells/DrawerLink/index.js'
import { RelationshipTablePagination } from './Pagination.js'
⋮----
type RelationshipTableComponentProps = {
  readonly AfterInput?: React.ReactNode
  readonly allowCreate?: boolean
  readonly BeforeInput?: React.ReactNode
  readonly disableTable?: boolean
  readonly field: JoinFieldClient
  readonly filterOptions?: Where
  readonly initialData?: PaginatedDocs
  readonly initialDrawerData?: DocumentDrawerProps['initialData']
  readonly Label?: React.ReactNode
  readonly parent?: {
    collectionSlug: CollectionSlug
    id: number | string
    joinPath: string
  }
  readonly relationTo: string | string[]
}
⋮----
// map columns from string[] to ListPreferences['columns']
⋮----
// eslint-disable-next-line react-hooks/exhaustive-deps
⋮----
onClick=
⋮----
columns=
</file>

<file path="packages/ui/src/elements/RelationshipTable/Pagination.tsx">
import React from 'react'
⋮----
import { useListQuery } from '../../providers/ListQuery/index.js'
import { Pagination } from '../Pagination/index.js'
⋮----
export const RelationshipTablePagination: React.FC = () =>
</file>

<file path="packages/ui/src/elements/RenderComponent/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/elements/RenderCustomComponent/index.tsx">
type Args = {
  CustomComponent?: React.ReactNode
  Fallback: React.ReactNode
}
⋮----
/**
 * Renders a CustomComponent or a Fallback component.
 * Only fallback if the Custom Component is undefined.
 *
 * If the CustomComponent is null, render null.
 *
 * @param {Object} args - Arguments object.
 * @param {React.ReactNode} [args.CustomComponent] - Optional custom component to render.
 * @param {React.ReactNode} args.Fallback - Fallback component to render if CustomComponent is undefined.
 * @returns {React.ReactNode} Rendered component.
 */
export function RenderCustomComponent(
</file>

<file path="packages/ui/src/elements/RenderIfInViewport/index.tsx">
import React from 'react'
⋮----
import { useIntersect } from '../../hooks/useIntersect.js'
⋮----
export const RenderIfInViewport: React.FC<{
  children: React.ReactNode
  className?: string
  forceRender?: boolean
}> = (
</file>

<file path="packages/ui/src/elements/RenderServerComponent/index.tsx">
import type { ImportMap, PayloadComponent } from '@convexcms/core'
⋮----
import { getFromImportMap, isPlainObject, isReactServerComponentOrFunction } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { removeUndefined } from '../../utilities/removeUndefined.js'
⋮----
type RenderServerComponentFn = (args: {
  readonly clientProps?: object
  readonly Component?:
    | PayloadComponent
    | PayloadComponent[]
    | React.ComponentType
    | React.ComponentType[]
  readonly Fallback?: React.ComponentType
  readonly importMap: ImportMap
  readonly key?: string
  readonly serverProps?: object
}) => React.ReactNode
⋮----
/**
 * Can be used to render both MappedComponents and React Components.
 */
export const RenderServerComponent: RenderServerComponentFn = ({
  clientProps = {},
  Component,
  Fallback,
  importMap,
  key,
  serverProps,
}) =>
⋮----
// prevent $undefined from being passed through the rsc requests
⋮----
// prevent $undefined from being passed through rsc requests
</file>

<file path="packages/ui/src/elements/RenderTitle/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .render-title {
    display: inline-block;
    &__id {
      vertical-align: middle;
      position: relative;
    }
  }
}
</file>

<file path="packages/ui/src/elements/RenderTitle/index.tsx">
import React, { Fragment } from 'react'
⋮----
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { IDLabel } from '../IDLabel/index.js'
⋮----
export type RenderTitleProps = {
  className?: string
  element?: React.ElementType
  fallback?: string
  fallbackToID?: boolean
  title?: string
}
⋮----
// Render and invisible character to prevent layout shift when the title populates from context
</file>

<file path="packages/ui/src/elements/SaveButton/index.tsx">
import type { SaveButtonClientProps } from '@convexcms/core'
⋮----
import React, { useRef } from 'react'
⋮----
import { useForm, useFormModified } from '../../forms/Form/context.js'
import { FormSubmit } from '../../forms/Submit/index.js'
import { useHotkey } from '../../hooks/useHotkey.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export function SaveButton(
⋮----
// absorb the event
⋮----
const handleSubmit = () =>
</file>

<file path="packages/ui/src/elements/SaveDraftButton/index.tsx">
import type { SaveDraftButtonClientProps } from '@convexcms/core'
⋮----
import React, { useCallback, useRef } from 'react'
⋮----
import { useForm, useFormModified } from '../../forms/Form/context.js'
import { FormSubmit } from '../../forms/Submit/index.js'
import { useHotkey } from '../../hooks/useHotkey.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
// absorb the event
</file>

<file path="packages/ui/src/elements/SearchFilter/index.scss">
@import '../../scss/styles';

@layer payload-default {
  [dir='rtl'] .search-filter {
    svg {
      right: base(0.5);
      left: 0;
    }
    &__input {
      padding-right: base(2);
      padding-left: 0;
    }
  }
  .search-filter {
    position: relative;

    svg {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      left: base(0.5);
    }

    &__input {
      @include formInput;
      height: auto;
      padding: 0;
      box-shadow: none;
      background-color: var(--theme-elevation-50);
      border: none;

      &:not(:disabled) {
        &:hover,
        &:focus {
          box-shadow: none;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/SearchFilter/index.tsx">
import React, { useEffect, useRef, useState } from 'react'
⋮----
export type SearchFilterProps = {
  fieldName?: string
  handleChange?: (search: string) => void
  initialParams?: ParsedQs
  label: string
  setValue?: (arg: string) => void
  value?: string
}
⋮----
import type { ParsedQs } from 'qs-esm'
⋮----
import { usePathname } from 'next/navigation.js'
⋮----
import { useDebounce } from '../../hooks/useDebounce.js'
⋮----
export const SearchFilter: React.FC<SearchFilterProps> = (props) =>
⋮----
/**
   * Tracks whether the state should be updated based on the search value.
   * If the value is updated from the URL, we don't want to update the state as it causes additional renders.
   */
⋮----
/**
   * Tracks the previous search value to compare with the current debounced search value.
   */
</file>

<file path="packages/ui/src/elements/SelectAll/index.scss">
@layer payload-default {
  .select-all {
    &__checkbox {
      display: block;
    }
  }
}
</file>

<file path="packages/ui/src/elements/SelectAll/index.tsx">
import React from 'react'
⋮----
import { CheckboxInput } from '../../fields/Checkbox/Input.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
</file>

<file path="packages/ui/src/elements/SelectMany/index.tsx">
import React from 'react'
⋮----
import { useSelection } from '../../providers/Selection/index.js'
// import { useTranslation } from '../../providers/Translation/index.js'
import { Pill } from '../Pill/index.js'
⋮----
// const { t } = useTranslation()
⋮----
// className={`${baseClass}__toggle`}
</file>

<file path="packages/ui/src/elements/SelectRow/index.scss">
@layer payload-default {
  .select-row {
    &__checkbox {
      display: block;
      width: min-content;
    }
  }
}
</file>

<file path="packages/ui/src/elements/SelectRow/index.tsx">
import type { ClientUser } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { CheckboxInput } from '../../fields/Checkbox/Input.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useSelection } from '../../providers/Selection/index.js'
import { Locked } from '../Locked/index.js'
</file>

<file path="packages/ui/src/elements/ShimmerEffect/index.scss">
@layer payload-default {
  .shimmer-effect {
    position: relative;
    overflow: hidden;
    background-color: var(--theme-elevation-50);

    &__shine {
      position: absolute;
      scale: 1.5;
      width: 100%;
      height: 100%;
      transform: translateX(-100%);
      animation: shimmer 1.75s infinite;
      opacity: 0.75;
      background: linear-gradient(
        100deg,
        var(--theme-elevation-50) 0%,
        var(--theme-elevation-50) 15%,
        var(--theme-elevation-150) 50%,
        var(--theme-elevation-50) 85%,
        var(--theme-elevation-50) 100%
      );
    }
  }

  @keyframes shimmer {
    100% {
      transform: translate3d(100%, 0, 0);
    }
  }
}
</file>

<file path="packages/ui/src/elements/ShimmerEffect/index.tsx">
import { useDelay } from '../../hooks/useDelay.js'
⋮----
export type ShimmerEffectProps = {
  readonly animationDelay?: string
  readonly height?: number | string
  readonly width?: number | string
}
</file>

<file path="packages/ui/src/elements/SortColumn/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .sort-column {
    display: flex;
    gap: calc(var(--base) / 2);
    align-items: center;

    &__label {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    &__label,
    .btn {
      vertical-align: middle;
      display: inline-block;
    }

    &__label {
      cursor: default;
    }

    &__buttons {
      display: flex;
      align-items: center;
      gap: calc(var(--base) / 4);
    }

    &__button {
      margin: 0;
      opacity: 0.3;
      padding: calc(var(--base) / 4);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      cursor: pointer;

      &.sort-column--active {
        opacity: 1;
        visibility: visible;
      }

      &:hover {
        opacity: 0.7;
      }
    }

    &:hover {
      .btn {
        opacity: 0.4;
        visibility: visible;
      }
    }

    &--appearance-condensed {
      gap: calc(var(--base) / 4);

      .sort-column__buttons {
        gap: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/SortColumn/index.tsx">
import type { StaticLabel } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { ChevronIcon } from '../../icons/Chevron/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export type SortColumnProps = {
  readonly appearance?: 'condensed' | 'default'
  readonly disable?: boolean
  readonly Label: React.ReactNode
  readonly label?: StaticLabel
  readonly name: string
}
</file>

<file path="packages/ui/src/elements/SortComplex/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .sort-complex {
    background: var(--theme-elevation-100);
    padding: base(0.5);
    display: flex;

    &__wrap {
      width: 100%;
      display: flex;
      align-items: center;
    }

    &__select {
      width: 50%;
      margin-bottom: base(0.5);
      padding: 0 base(0.5);
      flex-grow: 1;
    }

    &__label {
      color: var(--theme-elevation-400);
      margin: base(0.5) 0;
    }

    @include mid-break {
      &__wrap {
        display: block;
      }

      &__select {
        margin: 0 0 base(0.5);
        width: 100%;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/SortComplex/index.tsx">
import type { OptionObject, SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
// TODO: abstract the `next/navigation` dependency out from this component
import { usePathname, useRouter, useSearchParams } from 'next/navigation.js'
import { sortableFieldTypes } from '@convexcms/core'
import { fieldAffectsData } from '@convexcms/core/shared'
⋮----
import React, { useEffect, useState } from 'react'
⋮----
export type SortComplexProps = {
  collection: SanitizedCollectionConfig
  handleChange?: (sort: string) => void
  modifySearchQuery?: boolean
  sort?: string
}
⋮----
import type { Option } from '../ReactSelect/index.js'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
import { ReactSelect } from '../ReactSelect/index.js'
</file>

<file path="packages/ui/src/elements/SortHeader/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .sort-header {
    display: flex;
    gap: calc(var(--base) / 2);
    align-items: center;

    &__buttons {
      display: flex;
      align-items: center;
      gap: calc(var(--base) / 4);
    }

    &__button {
      margin: 0;
      padding: 0 !important;
      opacity: 0.3;
      padding: calc(var(--base) / 4);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      cursor: pointer;

      &.sort-header--active {
        opacity: 1;
        visibility: visible;
      }

      &:hover {
        opacity: 0.7;
      }
    }

    &:hover {
      .btn {
        opacity: 0.4;
        visibility: visible;
      }
    }

    &--appearance-condensed {
      gap: calc(var(--base) / 4);

      .sort-header__buttons {
        gap: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/SortHeader/index.tsx">
import React, { useEffect, useRef } from 'react'
⋮----
import { SortDownIcon, SortUpIcon } from '../../icons/Sort/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export type SortHeaderProps = {
  readonly appearance?: 'condensed' | 'default'
  readonly disable?: boolean
}
⋮----
function useSort()
⋮----
// This is necessary if you initialize the page without sort url param
// but your preferences are to sort by -_order.
// Since sort isn't updated, the arrow would incorrectly point upward.
⋮----
const handleSortPress = () =>
⋮----
// If it's already sorted by the "_order" field, toggle between "asc" and "desc"
⋮----
// If NOT sorted by the "_order" field, sort by that field but do not toggle the current value of "asc" or "desc".
</file>

<file path="packages/ui/src/elements/SortRow/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .sort-row {
    opacity: 0.3;
    cursor: not-allowed;

    &.active {
      cursor: grab;
      opacity: 1;
    }

    &__icon {
      height: 22px;
      width: 22px;
      margin-left: -2px;
      margin-top: -2px;
      display: block;
      width: min-content;
    }
  }
}
</file>

<file path="packages/ui/src/elements/SortRow/index.tsx">
import React from 'react'
⋮----
import { DragHandleIcon } from '../../icons/DragHandle/index.js'
⋮----
import { useListQuery } from '../../providers/ListQuery/index.js'
⋮----
export const SortRow = () =>
</file>

<file path="packages/ui/src/elements/Status/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .status {
    &__label {
      color: var(--theme-elevation-500);
    }

    &__value {
      font-weight: 600;
    }

    &__value-wrap {
      white-space: nowrap;
    }

    &__action {
      text-decoration: underline;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Status/index.tsx">
import { useModal } from '@faceless-ui/modal'
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { useForm } from '../../forms/Form/context.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { Button } from '../Button/index.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
⋮----
// eslint-disable-next-line @typescript-eslint/no-floating-promises
</file>

<file path="packages/ui/src/elements/StayLoggedIn/index.tsx">
import { useRouter } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { useCallback } from 'react'
⋮----
import type { OnCancel } from '../ConfirmationModal/index.js'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
⋮----
export const StayLoggedInModal: React.FC = () =>
⋮----
body=
cancelLabel=
confirmLabel=
heading=
</file>

<file path="packages/ui/src/elements/StepNav/context.tsx">
import React, { createContext, use, useState } from 'react'
⋮----
import type { ContextType } from './types.js'
⋮----
export const useStepNav = (): ContextType
⋮----
export const StepNavProvider: React.FC<
</file>

<file path="packages/ui/src/elements/StepNav/index.scss">
@import '../../scss/styles.scss';
@layer payload-default {
  .step-nav {
    display: flex;
    align-items: center;
    gap: calc(var(--base) / 2);

    &::after {
      content: ' ';
      position: sticky;
      top: 0;
      right: 0;
      width: var(--base);
      background: linear-gradient(to right, transparent, var(--theme-bg));
    }

    // Use a pseudo element for the accessability so that it doesn't take up DOM space
    // Also because the parent element has `overflow: hidden` which would clip an outline
    &__home {
      width: 18px;
      height: 18px;
      position: relative;

      &:focus-visible {
        outline: none;

        &::after {
          content: '';
          border: var(--accessibility-outline);
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          pointer-events: none;
        }
      }
    }

    * {
      display: block;
    }

    a {
      border: 0;
      display: flex;
      align-items: center;
      font-weight: 600;
      text-decoration: none;

      label {
        cursor: pointer;
      }

      &:hover,
      &:focus-visible {
        text-decoration: underline;
      }
    }

    span {
      max-width: base(8);
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }

    @include mid-break {
      .step-nav {
        &__home {
          width: 16px;
          height: 16px;
        }
      }
    }

    @include small-break {
      gap: base(0.4);
    }
  }
}
</file>

<file path="packages/ui/src/elements/StepNav/index.tsx">
import { getTranslation } from '@convexcms/translations'
import React, { Fragment } from 'react'
⋮----
import type { StepNavItem } from './types.js'
⋮----
import { PayloadIcon } from '../../graphics/Icon/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Link } from '../Link/index.js'
import { RenderCustomComponent } from '../RenderCustomComponent/index.js'
import { StepNavProvider, useStepNav } from './context.js'
⋮----
/**
   * @deprecated
   * This prop is deprecated and will be removed in the next major version.
   * Components now import their own `Link` directly from `next/link`.
   */
⋮----
<span title=
</file>

<file path="packages/ui/src/elements/StepNav/SetStepNav.tsx">
import { useEffect } from 'react'
⋮----
import type { StepNavItem } from './types.js'
⋮----
import { useStepNav } from './context.js'
⋮----
export const SetStepNav: React.FC<{
  nav: StepNavItem[]
}> = (
</file>

<file path="packages/ui/src/elements/StepNav/types.ts">
import type { LabelFunction, StaticLabel } from '@convexcms/core'
⋮----
export type StepNavItem = {
  label: LabelFunction | StaticLabel
  url?: string
}
⋮----
export type ContextType = {
  setStepNav: (items: StepNavItem[]) => void
  stepNav: StepNavItem[]
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Array/index.tsx">
import type { ArrayFieldClient, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useTranslation } from '../../../../../providers/Translation/index.js'
⋮----
export interface ArrayCellProps extends DefaultCellComponentProps<ArrayFieldClient> {}
⋮----
export const ArrayCell: React.FC<ArrayCellProps> = (
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Blocks/index.tsx">
import type { BlocksFieldClient, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useConfig } from '../../../../../providers/Config/index.js'
import { useTranslation } from '../../../../../providers/Translation/index.js'
⋮----
export interface BlocksCellProps extends DefaultCellComponentProps<BlocksFieldClient> {}
⋮----
export const BlocksCell: React.FC<BlocksCellProps> = ({
  cellData,
  field: { blockReferences, blocks, labels },
}) =>
⋮----
const formatBlockList = (blocks)
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Checkbox/index.scss">
@import '../../../../../scss/styles.scss';

@layer payload-default {
  .bool-cell {
    font-size: 1rem;
    line-height: base(1);
    border: 0;
    display: inline-flex;
    vertical-align: middle;
    background: var(--theme-elevation-150);
    color: var(--theme-elevation-800);
    border-radius: $style-radius-s;
    padding: 0 base(0.25);
    [dir='ltr'] & {
      padding-left: base(0.0875 + 0.25);
    }
    [dir='rtl'] & {
      padding-right: base(0.0875 + 0.25);
    }

    background: var(--theme-elevation-100);
    color: var(--theme-elevation-800);
  }
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Checkbox/index.tsx">
import type { CheckboxFieldClient, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { useTranslation } from '../../../../../providers/Translation/index.js'
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Code/index.scss">
@import '../../../../../scss/styles.scss';

@layer payload-default {
  .code-cell {
    font-size: 1rem;
    line-height: base(1);
    border: 0;
    display: inline-flex;
    vertical-align: middle;
    background: var(--theme-elevation-150);
    color: var(--theme-elevation-800);
    border-radius: $style-radius-m;
    padding: 0 base(0.25);
    background: var(--theme-elevation-100);
    color: var(--theme-elevation-800);

    [dir='ltr'] & {
      padding-left: base(0.0875 + 0.25);
    }

    [dir='rtl'] & {
      padding-right: base(0.0875 + 0.25);
    }

    &:hover {
      text-decoration: inherit;
    }
  }
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Code/index.tsx">
import type { ClientCollectionConfig, CodeFieldClient, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export interface CodeCellProps extends DefaultCellComponentProps<CodeFieldClient> {
  readonly collectionConfig: ClientCollectionConfig
  readonly nowrap?: boolean
}
⋮----
export const CodeCell: React.FC<CodeCellProps> = (
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Date/index.tsx">
import type { DateFieldClient, DefaultCellComponentProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { useConfig } from '../../../../../providers/Config/index.js'
import { useTranslation } from '../../../../../providers/Translation/index.js'
import { formatDate } from '../../../../../utilities/formatDocTitle/formatDateTitle.js'
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/File/index.scss">
@import '../../../../../scss/styles.scss';

@layer payload-default {
  .file {
    display: flex;
    flex-wrap: nowrap;

    &__thumbnail {
      display: inline-block;
      max-width: calc(var(--base) * 2);
      height: calc(var(--base) * 2);
      border-radius: var(--style-radius-s);
    }

    &__filename {
      align-self: center;
      [dir='ltr'] & {
        margin-left: var(--base);
      }
      [dir='rtl'] & {
        margin-right: var(--base);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/File/index.tsx">
import type {
  ClientCollectionConfig,
  DefaultCellComponentProps,
  TextFieldClient,
  UploadFieldClient,
} from '@convexcms/core'
⋮----
import { isImage } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { getBestFitFromSizes } from '../../../../../utilities/getBestFitFromSizes.js'
import { Thumbnail } from '../../../../Thumbnail/index.js'
⋮----
export interface FileCellProps
  extends DefaultCellComponentProps<TextFieldClient | UploadFieldClient> {
  readonly collectionConfig: ClientCollectionConfig
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/JSON/index.scss">
@import '../../../../../scss/styles.scss';

@layer payload-default {
  .json-cell {
    font-size: 1rem;
    line-height: base(1);
    border: 0;
    display: inline-flex;
    vertical-align: middle;
    background: var(--theme-elevation-150);
    color: var(--theme-elevation-800);
    border-radius: $style-radius-m;
    padding: 0 base(0.25);
    [dir='ltr'] & {
      padding-left: base(0.0875 + 0.25);
    }
    [dir='rtl'] & {
      padding-right: base(0.0875 + 0.25);
    }

    background: var(--theme-elevation-100);
    color: var(--theme-elevation-800);
  }
}
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/JSON/index.tsx">
import type { DefaultCellComponentProps, JSONFieldClient } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export const JSONCell: React.FC<DefaultCellComponentProps<JSONFieldClient>> = (
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Relationship/index.tsx">
import type {
  DefaultCellComponentProps,
  JoinFieldClient,
  RelationshipFieldClient,
  UploadFieldClient,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useEffect, useMemo, useState } from 'react'
⋮----
import { useIntersect } from '../../../../../hooks/useIntersect.js'
import { useConfig } from '../../../../../providers/Config/index.js'
import { useTranslation } from '../../../../../providers/Translation/index.js'
import { canUseDOM } from '../../../../../utilities/canUseDOM.js'
import { formatDocTitle } from '../../../../../utilities/formatDocTitle/index.js'
import { useListRelationships } from '../../../RelationshipProvider/index.js'
import { FileCell } from '../File/index.js'
⋮----
type Value = { relationTo: string; value: number | string }
⋮----
export type RelationshipCellProps = DefaultCellComponentProps<
  JoinFieldClient | RelationshipFieldClient | UploadFieldClient
>
⋮----
export const RelationshipCell: React.FC<RelationshipCellProps> = ({
  cellData: cellDataFromProps,
  customCellProps: customCellContext,
  field,
  field: { label },
}) =>
⋮----
// conditionally extract relationTo both both relationship and join fields
⋮----
// conditionally extract docs from join fields
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Select/index.tsx">
import type { DefaultCellComponentProps, OptionObject, SelectFieldClient } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { optionsAreObjects } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { useTranslation } from '../../../../../providers/Translation/index.js'
⋮----
export interface SelectCellProps extends DefaultCellComponentProps<SelectFieldClient> {}
⋮----
export const SelectCell: React.FC<SelectCellProps> = (
⋮----
const findLabel = (items: string[])
⋮----
? findLabel(cellData) // hasMany
⋮----
? cellData.join(', ') // hasMany
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/Textarea/index.tsx">
import type { DefaultCellComponentProps, TextareaFieldClient } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export const TextareaCell: React.FC<DefaultCellComponentProps<TextareaFieldClient>> = ({
  cellData,
}) =>
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/fields/index.tsx">
import { ArrayCell } from './Array/index.js'
import { BlocksCell } from './Blocks/index.js'
import { CheckboxCell } from './Checkbox/index.js'
import { CodeCell } from './Code/index.js'
import { DateCell } from './Date/index.js'
import { FileCell } from './File/index.js'
import { JSONCell } from './JSON/index.js'
import { RelationshipCell } from './Relationship/index.js'
import { SelectCell } from './Select/index.js'
import { TextareaCell } from './Textarea/index.js'
</file>

<file path="packages/ui/src/elements/Table/DefaultCell/index.tsx">
import type { DefaultCellComponentProps, UploadFieldClient } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { fieldAffectsData, fieldIsID } from '@convexcms/core/shared'
import React from 'react' // TODO: abstract this out to support all routers
⋮----
import { useConfig } from '../../../providers/Config/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { formatAdminURL } from '../../../utilities/formatAdminURL.js'
import { getDisplayedFieldValue } from '../../../utilities/getDisplayedFieldValue.js'
import { Link } from '../../Link/index.js'
import { CodeCell } from './fields/Code/index.js'
import { cellComponents } from './fields/index.js'
⋮----
// Handle JSX labels before using DefaultCellComponent
⋮----
// DefaultCellComponent does not exist for certain field types like `text`
if (
      collectionConfig?.upload &&
      fieldAffectsData(field) &&
      field.name === 'filename' &&
      field.type === 'text'
)
</file>

<file path="packages/ui/src/elements/Table/RelationshipProvider/index.tsx">
import type { TypeWithID } from '@convexcms/core'
⋮----
import React, { createContext, use, useCallback, useEffect, useReducer, useRef } from 'react'
⋮----
import { useDebounce } from '../../../hooks/useDebounce.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useLocale } from '../../../providers/Locale/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { reducer } from './reducer.js'
⋮----
// documents are first set to null when requested
// set to false when no doc is returned
// or set to the document returned
export type Documents = {
  [slug: string]: {
    [id: number | string]: false | null | TypeWithID
  }
}
⋮----
type ListRelationshipContext = {
  documents: Documents
  getRelationships: (
    docs: {
      relationTo: string
      value: number | string
    }[],
  ) => void
}
⋮----
export const RelationshipProvider: React.FC<{ readonly children?: React.ReactNode }> = ({
  children,
}) =>
⋮----
export const useListRelationships = (): ListRelationshipContext
</file>

<file path="packages/ui/src/elements/Table/RelationshipProvider/reducer.ts">
import type { TypeWithID } from '@convexcms/core'
⋮----
import type { Documents } from './index.js'
⋮----
type RequestDocuments = {
  docs: { relationTo: string; value: number | string }[]
  type: 'REQUEST'
}
⋮----
type AddLoadedDocuments = {
  docs: TypeWithID[]
  idsToLoad: (number | string)[]
  relationTo: string
  type: 'ADD_LOADED'
}
⋮----
type Action = AddLoadedDocuments | RequestDocuments
⋮----
export function reducer(state: Documents, action: Action): Documents
</file>

<file path="packages/ui/src/elements/Table/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .table {
    margin-bottom: $baseline;
    overflow: auto;
    max-width: 100%;

    table {
      min-width: 100%;
    }

    thead {
      color: var(--theme-elevation-400);

      th {
        font-weight: normal;
        text-align: left;
        [dir='rtl'] & {
          text-align: right;
        }
      }
    }

    th,
    td {
      vertical-align: top;
      padding: base(0.8) base(0.6);
      min-width: 150px;

      &:first-child {
        padding-inline-start: base(0.8);
      }

      &:last-child {
        padding-inline-end: base(0.8);
      }
    }

    tbody {
      tr {
        &:nth-child(odd) {
          background: var(--theme-elevation-50);
          border-radius: $style-radius-s;
        }
      }
    }

    a:focus-visible {
      outline: var(--accessibility-outline);
      outline-offset: var(--accessibility-outline-offset);
    }

    &--appearance-condensed {
      thead {
        th:first-child {
          border-top-left-radius: $style-radius-s;
        }

        th:last-child {
          border-top-right-radius: $style-radius-s;
        }

        background: var(--theme-elevation-50);
      }

      tbody {
        tr {
          &:nth-child(odd) {
            background: transparent;
            border-radius: 0;
          }
        }
      }

      th,
      td {
        padding: base(0.3) base(0.3);

        &:first-child {
          padding-inline-start: base(0.6);
        }

        &:last-child {
          padding-inline-end: base(0.6);
        }
      }

      th {
        padding: base(0.3);
      }

      tr td,
      th {
        border: 0.5px solid var(--theme-elevation-100);
      }
    }

    &--drag-preview {
      cursor: grabbing;
      z-index: var(--z-popup);
    }

    @include mid-break {
      th,
      td {
        max-width: 70vw;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Table/index.tsx">
import type { Column } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export type Props = {
  readonly appearance?: 'condensed' | 'default'
  readonly columns?: Column[]
  readonly data: Record<string, unknown>[]
}
</file>

<file path="packages/ui/src/elements/Table/OrderableRow.tsx">
import type { DraggableSyntheticListeners } from '@dnd-kit/core'
import type { Column } from '@convexcms/core'
import type { HTMLAttributes, Ref } from 'react'
⋮----
export type Props = {
  readonly cellMap: Record<string, number>
  readonly columns: Column[]
  readonly dragAttributes?: HTMLAttributes<unknown>
  readonly dragListeners?: DraggableSyntheticListeners
  readonly ref?: Ref<HTMLTableRowElement>
  readonly rowId: number | string
} & HTMLAttributes<HTMLTableRowElement>
⋮----
export const OrderableRow = ({
  cellMap,
  columns,
  dragAttributes = {},
  dragListeners = {},
  rowId,
  ...rest
}: Props) => (
  <tr {...rest}>
⋮----
// Use the cellMap to find which index in the renderedCells to use
⋮----
// For drag handles, wrap in div with drag attributes
</file>

<file path="packages/ui/src/elements/Table/OrderableRowDragPreview.tsx">
import type { ReactNode } from 'react'
⋮----
export type Props = {
  readonly children: ReactNode
  readonly className?: string
  readonly rowId?: number | string
}
⋮----
export const OrderableRowDragPreview = (
</file>

<file path="packages/ui/src/elements/Table/OrderableTable.tsx">
import type { ClientCollectionConfig, Column, OrderableEndpointBody } from '@convexcms/core'
⋮----
import { DragOverlay } from '@dnd-kit/core'
import React, { useEffect, useState } from 'react'
import { toast } from 'sonner'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
import { DraggableSortableItem } from '../DraggableSortable/DraggableSortableItem/index.js'
import { DraggableSortable } from '../DraggableSortable/index.js'
import { OrderableRow } from './OrderableRow.js'
import { OrderableRowDragPreview } from './OrderableRowDragPreview.js'
⋮----
export type Props = {
  readonly appearance?: 'condensed' | 'default'
  readonly collection: ClientCollectionConfig
  readonly columns?: Column[]
  readonly data: Record<string, unknown>[]
}
⋮----
// Use the data from ListQueryProvider if available, otherwise use the props
⋮----
// Local state to track the current order of rows
⋮----
// id -> index for each column
⋮----
// Update local data when server data changes
⋮----
const handleDragEnd = async (
⋮----
// Store the original data for rollback
⋮----
// Optimisitc update of local state to reorder the rows
⋮----
// Update the rendered cell for the moved row to show "pending"
⋮----
// Move the item in the array
⋮----
// Rollback to previous state if the request fails
⋮----
const handleDragStart = (
</file>

<file path="packages/ui/src/elements/Thumbnail/createThumbnail.ts">
/**
 * Create a thumbnail from a File object by drawing it onto an OffscreenCanvas
 */
export const createThumbnail = (file: File): Promise<string> =>
⋮----
img.src = URL.createObjectURL(file) // Use Object URL directly
⋮----
// Calculate aspect ratio
⋮----
// Determine dimensions to fit within maxDimension while maintaining aspect ratio
⋮----
// Image is wider than tall
⋮----
// Image is taller than wide, or square
⋮----
const canvas = new OffscreenCanvas(drawWidth, drawHeight) // Create an OffscreenCanvas
⋮----
// Draw the image onto the OffscreenCanvas with calculated dimensions
⋮----
// Convert the OffscreenCanvas to a Blob and free up memory
⋮----
URL.revokeObjectURL(img.src) // Release the Object URL
⋮----
reader.onload = () => resolve(reader.result as string) // Resolve as data URL
⋮----
URL.revokeObjectURL(img.src) // Release Object URL on error
// eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
</file>

<file path="packages/ui/src/elements/Thumbnail/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .thumbnail {
    min-height: 100%;
    flex-shrink: 0;
    align-self: stretch;
    overflow: hidden;

    img,
    svg {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    &--size-expand {
      max-height: 100%;
      width: 100%;
      padding-top: 100%;
      position: relative;

      img,
      svg {
        position: absolute;
        top: 0;
      }
    }

    &--size-large {
      max-height: base(9);
      width: base(9);
    }

    &--size-medium {
      max-height: base(7);
      width: base(7);
    }

    &--size-small {
      max-height: base(5);
      width: base(5);
    }

    @include large-break {
      .thumbnail {
        width: base(5);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Thumbnail/index.tsx">
import React from 'react'
⋮----
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
import { File } from '../../graphics/File/index.js'
import { ShimmerEffect } from '../ShimmerEffect/index.js'
⋮----
export type ThumbnailProps = {
  className?: string
  collectionSlug?: string
  doc?: Record<string, unknown>
  fileSrc?: string
  imageCacheTag?: string
  size?: 'expand' | 'large' | 'medium' | 'small'
  uploadConfig?: SanitizedCollectionConfig['upload']
}
⋮----
/**
   * If an imageCacheTag is provided, append it to the fileSrc
   * Check if the fileSrc already has a query string, if it does, append the imageCacheTag with an ampersand
   */
⋮----
/**
   * If an imageCacheTag is provided, append it to the fileSrc
   * Check if the fileSrc already has a query string, if it does, append the imageCacheTag with an ampersand
   */
</file>

<file path="packages/ui/src/elements/ThumbnailCard/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .thumbnail-card {
    @include btn-reset;
    @include shadow-m;
    width: 100%;
    background: var(--theme-input-bg);
    border: 1px solid var(--theme-border-color);
    border-radius: var(--style-radius-m);
    transition: border 100ms cubic-bezier(0, 0.2, 0.2, 1);
    padding: base(0.5);

    &__label {
      padding: base(0.75) base(0.5) base(0.25) base(0.5);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    &--has-on-click {
      cursor: pointer;

      &:hover,
      &:focus,
      &:active {
        border: 1px solid var(--theme-elevation-350);
      }
    }

    &--align-label-center {
      text-align: center;
    }

    &__thumbnail {
      display: flex;
      align-items: center;
      justify-content: center;
    }
  }
}
</file>

<file path="packages/ui/src/elements/ThumbnailCard/index.tsx">
import type { ClientCollectionConfig, TypeWithID } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { formatDocTitle } from '../../utilities/formatDocTitle/index.js'
⋮----
export type ThumbnailCardProps = {
  alignLabel?: 'center' | 'left'
  className?: string
  collection?: ClientCollectionConfig
  doc?: { filename?: string } & TypeWithID
  label?: string
  onClick?: () => void
  onKeyDown?: () => void
  thumbnail: React.ReactNode
}
⋮----
export const ThumbnailCard: React.FC<ThumbnailCardProps> = (props) =>
</file>

<file path="packages/ui/src/elements/TimezonePicker/index.scss">
@layer payload-default {
  .timezone-picker-wrapper {
    display: flex;
    gap: calc(var(--base) / 4);
    margin-top: calc(var(--base) / 4);
    align-items: center;

    .field-label {
      margin-right: unset;
      color: var(--theme-elevation-400);
      flex-shrink: 0;
    }

    .timezone-picker {
      display: inline-block;

      .rs__menu {
        min-width: calc(var(--base) * 14);
        overflow: hidden;
        border-radius: calc(var(--base) * 0.25);
      }

      .rs__value-container {
        text-align: center;
      }

      .rs__control {
        background: none;
        border: none;
        padding: 0;
        min-height: auto !important;
        position: relative;
        box-shadow: unset;
        min-width: var(--base);

        &:hover {
          cursor: pointer;
          box-shadow: unset;
        }

        &.rs__control--menu-is-open::before {
          display: block;
        }
      }

      .rs__indicators {
        margin-inline-start: calc(var(--base) * 0.25);
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/TimezonePicker/index.tsx">
import type { OptionObject } from '@convexcms/core'
import type React from 'react'
⋮----
import { useMemo } from 'react'
⋮----
import type { Props } from './types.js'
⋮----
import { FieldLabel } from '../../fields/FieldLabel/index.js'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
import { ReactSelect } from '../ReactSelect/index.js'
import { formatOptions } from '../WhereBuilder/Condition/Select/formatOptions.js'
⋮----
export const TimezonePicker: React.FC<Props> = (props) =>
</file>

<file path="packages/ui/src/elements/TimezonePicker/types.ts">
import type { SelectFieldClient } from '@convexcms/core'
⋮----
export type Props = {
  id: string
  onChange?: (val: string) => void
  required?: boolean
  selectedTimezone?: string
} & Pick<SelectFieldClient, 'options'>
</file>

<file path="packages/ui/src/elements/Toasts/fieldErrors.tsx">
import React from 'react'
⋮----
function groupSimilarErrors(items: string[]): string[]
⋮----
// Find a place where a similar path exists
⋮----
// If no similar path was found, add to the end
⋮----
function createErrorsFromMessage(message: string):
⋮----
export function FieldErrorsToast(
</file>

<file path="packages/ui/src/elements/Tooltip/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .tooltip {
    --caret-size: 6px;

    opacity: 0;
    background-color: var(--theme-elevation-800);
    position: absolute;
    z-index: 3;
    left: 50%;
    padding: base(0.2) base(0.4);
    color: var(--theme-elevation-0);
    line-height: base(0.75);
    font-weight: normal;
    white-space: nowrap;
    border-radius: 2px;
    visibility: hidden;

    &::after {
      content: ' ';
      display: block;
      position: absolute;
      transform: translate3d(-50%, 100%, 0);
      width: 0;
      height: 0;
      border-left: var(--caret-size) solid transparent;
      border-right: var(--caret-size) solid transparent;
    }

    &--show {
      visibility: visible;
      opacity: 1;
      transition: opacity 0.2s ease-in-out;
      cursor: default;
    }

    &--caret-center {
      &::after {
        left: 50%;
      }
    }

    &--caret-left {
      &::after {
        left: calc(var(--base) * 0.5);
      }
    }

    &--caret-right {
      &::after {
        right: calc(var(--base) * 0.5);
      }
    }

    &--position-top {
      top: calc(var(--base) * -1.25);
      transform: translate3d(-50%, calc(var(--caret-size) * -1), 0);

      &::after {
        bottom: 1px;
        border-top: var(--caret-size) solid var(--theme-elevation-800);
      }
    }

    &--position-bottom {
      bottom: calc(var(--base) * -1.25);
      transform: translate3d(-50%, var(--caret-size), 0);

      &::after {
        bottom: calc(100% + var(--caret-size) - 1px);
        border-bottom: var(--caret-size) solid var(--theme-elevation-800);
      }
    }

    .tooltip-content {
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
    }

    @include mid-break {
      display: none;
    }
  }

  html[data-theme='light'] {
    .tooltip:not(.field-error) {
      background-color: var(--theme-elevation-100);
      color: var(--theme-elevation-1000);
    }

    .tooltip--position-top:not(.field-error):after {
      border-top-color: var(--theme-elevation-100);
    }

    .tooltip--position-bottom:not(.field-error):after {
      border-bottom-color: var(--theme-elevation-100);
    }
  }
}
</file>

<file path="packages/ui/src/elements/Tooltip/index.tsx">
import React, { useEffect } from 'react'
⋮----
import { useIntersect } from '../../hooks/useIntersect.js'
⋮----
export type Props = {
  alignCaret?: 'center' | 'left' | 'right'
  boundingRef?: React.RefObject<HTMLElement | null>
  children: React.ReactNode
  className?: string
  delay?: number
  position?: 'bottom' | 'top'
  show?: boolean
  /**
   * If the tooltip position should not change depending on if the toolbar is outside the boundingRef. @default false
   */
  staticPositioning?: boolean
}
⋮----
/**
   * If the tooltip position should not change depending on if the toolbar is outside the boundingRef. @default false
   */
⋮----
const getTitleAttribute = (content)
⋮----
// do not use the delay on transition-out
⋮----
// The first aside is always on top. The purpose of that is that it can reliably be used for the interaction observer (as it's not moving around), to calculate the position of the actual tooltip.
</file>

<file path="packages/ui/src/elements/Translation/index.tsx">
import type { ClientTranslationKeys, TFunction } from '@convexcms/translations'
⋮----
const RecursiveTranslation: React.FC<{
  elements?: Record<string, React.FC<{ children: React.ReactNode }>>
  translationString: string
}> = (
⋮----
export type TranslationProps = {
  elements?: Record<string, React.FC<{ children: React.ReactNode }>>
  i18nKey: ClientTranslationKeys
  t: TFunction
  variables?: Record<string, unknown>
}
⋮----
export const Translation: React.FC<TranslationProps> = (
</file>

<file path="packages/ui/src/elements/UnpublishMany/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .unpublish-many {
    &__toggle {
      font-size: inherit;
      line-height: inherit;
      display: inline-flex;
      background: transparent;
      color: var(--theme-elevation-800);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 0;
      padding: 0;
      align-items: center;
      cursor: pointer;
      text-decoration: underline;
    }
  }
}
</file>

<file path="packages/ui/src/elements/UnpublishMany/index.tsx">
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import { useRouter, useSearchParams } from 'next/navigation.js'
⋮----
import React, { useCallback } from 'react'
import { toast } from 'sonner'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useRouteCache } from '../../providers/RouteCache/index.js'
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { parseSearchParams } from '../../utilities/parseSearchParams.js'
import { ConfirmationModal } from '../ConfirmationModal/index.js'
⋮----
export type UnpublishManyProps = {
  collection: ClientCollectionConfig
}
⋮----
clearRouteCache() // Use clearRouteCache instead of router.refresh, as we only need to clear the cache if the user has route caching enabled - clearRouteCache checks for this
</file>

<file path="packages/ui/src/elements/Upload/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .file-field {
    position: relative;
    margin-bottom: var(--base);
    background: var(--theme-elevation-50);
    border-radius: var(--style-radius-s);

    &__upload {
      display: flex;
    }

    .tooltip.error-message {
      z-index: 3;
      bottom: calc(100% - #{base(0.5)});
    }

    &__file-selected {
      display: flex;
    }

    &__thumbnail-wrap {
      position: relative;
      width: 150px;

      .thumbnail {
        position: relative;
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: var(--style-radius-s) 0 0 var(--style-radius-s);
      }
    }

    &__remove {
      margin: calc($baseline * 1.5) $baseline $baseline 0;
      place-self: flex-start;
    }

    &__file-adjustments,
    &__remote-file-wrap {
      padding: $baseline;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);
    }

    &__filename,
    &__remote-file {
      @include formInput;
      background-color: var(--theme-bg);
    }

    &__upload-actions,
    &__add-file-wrap {
      display: flex;
      gap: calc(var(--base) / 2);
      flex-wrap: wrap;

      & button {
        cursor: pointer;
        background-color: var(--theme-elevation-150);
        border: none;
        border-radius: $style-radius-m;
        padding: base(0.25) base(0.5);
        text-wrap: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        &:hover {
          background-color: var(--theme-elevation-100);
        }
      }
    }

    &__previewDrawer {
      & h2 {
        margin: 0 base(1) 0 0;
        text-wrap: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: calc(100% - base(2));
      }
    }

    .dropzone {
      background-color: transparent;
      padding-block: calc(var(--base) * 2.25);
    }

    &__dropzoneContent {
      display: flex;
      flex-wrap: wrap;
      gap: base(0.4);
      justify-content: space-between;
      width: 100%;
    }

    &__dropzoneButtons {
      display: flex;
      gap: calc(var(--base) * 0.5);
    }

    &__orText {
      color: var(--theme-elevation-500);
      text-transform: lowercase;
    }

    &__dragAndDropText {
      flex-shrink: 0;
      margin: 0;
      text-transform: lowercase;
      align-self: center;
      color: var(--theme-elevation-500);
    }

    @include small-break {
      &__upload {
        flex-wrap: wrap;
        justify-content: space-between;
      }

      &__remove {
        margin: $baseline;
        order: 2;
      }

      &__file-adjustments {
        order: 3;
        border-top: 2px solid var(--theme-elevation-0);
        padding: calc($baseline * 0.5);
        gap: 0;
      }

      &__thumbnail-wrap {
        order: 1;
        width: 50%;

        .thumbnail {
          width: 100%;
        }
      }

      &__edit {
        display: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/Upload/index.tsx">
import type { FormState, SanitizedCollectionConfig, UploadEdits } from '@convexcms/core'
⋮----
import { isImage } from '@convexcms/core/shared'
import React, { Fragment, useCallback, useEffect, useRef, useState } from 'react'
import { toast } from 'sonner'
⋮----
import { FieldError } from '../../fields/FieldError/index.js'
import { fieldBaseClass } from '../../fields/shared/index.js'
import { useForm, useFormProcessing } from '../../forms/Form/index.js'
import { useField } from '../../forms/useField/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { EditDepthProvider } from '../../providers/EditDepth/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { useUploadEdits } from '../../providers/UploadEdits/index.js'
import { Button } from '../Button/index.js'
import { Drawer, DrawerToggler } from '../Drawer/index.js'
import { Dropzone } from '../Dropzone/index.js'
import { EditUpload } from '../EditUpload/index.js'
import { FileDetails } from '../FileDetails/index.js'
import { PreviewSizes } from '../PreviewSizes/index.js'
import { Thumbnail } from '../Thumbnail/index.js'
⋮----
const validate = (value) =>
⋮----
type UploadActionsArgs = {
  readonly customActions?: React.ReactNode[]
  readonly enableAdjustments: boolean
  readonly enablePreviewSizes: boolean
  readonly mimeType: string
}
⋮----
// Creating a new File object with updated properties
⋮----
// Attempt client-side fetch
⋮----
return // Exit if client-side fetch succeeds
⋮----
// If server-side fetch is not enabled, show client-side error
⋮----
// Attempt server-side fetch if client-side fetch fails and useServerSideFetch is true
⋮----
// urlInputRef.current.focus() // Focus on the remote-url input field when showUrlInput is true
⋮----
// Explicity check if set to true, default is undefined
⋮----
{/* eslint-disable-next-line jsx-a11y/control-has-associated-label */}
⋮----
{/* eslint-disable-next-line jsx-a11y/control-has-associated-label */}
</file>

<file path="packages/ui/src/elements/ViewDescription/index.tsx">
import type { DescriptionFunction, StaticDescription, ViewDescriptionClientProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export type ViewDescriptionComponent = React.ComponentType<any>
⋮----
type Description = DescriptionFunction | StaticDescription | string | ViewDescriptionComponent
⋮----
export function isComponent(description: Description): description is ViewDescriptionComponent
⋮----
export function ViewDescription(props: ViewDescriptionClientProps)
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Date/index.tsx">
import React from 'react'
⋮----
import type { DateFilterProps as Props } from './types.js'
⋮----
import { DatePickerField } from '../../../DatePicker/index.js'
⋮----
export const DateFilter: React.FC<Props> = (
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Date/types.ts">
import type { DateFieldClient } from '@convexcms/core'
⋮----
import type { DefaultFilterProps } from '../types.js'
⋮----
export type DateFilterProps = {
  readonly field: DateFieldClient
  readonly value: Date | string
} & DefaultFilterProps
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/DefaultFilter/index.tsx">
import type {
  Operator,
  Option,
  ResolvedFilterOptions,
  SelectFieldClient,
  TextFieldClient,
} from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import type { ReducedField, Value } from '../../types.js'
⋮----
import { DateFilter } from '../Date/index.js'
import { NumberFilter } from '../Number/index.js'
import { RelationshipFilter } from '../Relationship/index.js'
import { Select } from '../Select/index.js'
import { Text } from '../Text/index.js'
⋮----
type Props = {
  booleanSelect: boolean
  disabled: boolean
  filterOptions: ResolvedFilterOptions
  internalField: ReducedField
  onChange: React.Dispatch<React.SetStateAction<string>>
  operator: Operator
  options: Option[]
  value: Value
}
⋮----
export const DefaultFilter: React.FC<Props> = ({
  booleanSelect,
  disabled,
  filterOptions,
  internalField,
  onChange,
  operator,
  options,
  value,
}) =>
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Number/index.scss">
@import '../../../../scss/styles.scss';

@layer payload-default {
  .condition-value-number {
    @include formInput;
  }
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Number/index.tsx">
import React from 'react'
⋮----
import type { NumberFilterProps as Props } from './types.js'
⋮----
import { useTranslation } from '../../../../providers/Translation/index.js'
import { ReactSelect } from '../../../ReactSelect/index.js'
⋮----
id: `${val}${index}`, // append index to avoid duplicate keys but allow duplicate numbers
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Number/types.ts">
import type { NumberFieldClient } from '@convexcms/core'
⋮----
import type { DefaultFilterProps } from '../types.js'
⋮----
export type NumberFilterProps = {
  readonly field: NumberFieldClient
  readonly onChange: (e: string) => void
  readonly value: number | number[]
} & DefaultFilterProps
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Relationship/index.scss">
@import '../../../../scss/styles.scss';

@layer payload-default {
  .condition-value-relationship {
    &__error-loading {
      border: 1px solid var(--theme-error-600);
      min-height: base(2);
      padding: base(0.5) base(0.75);
      background-color: var(--theme-error-100);
      color: var(--theme-elevation-0);
    }
  }
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Relationship/index.tsx">
import type { PaginatedDocs, Where } from '@convexcms/core'
⋮----
import React, { useCallback, useEffect, useReducer, useState } from 'react'
⋮----
import type { Option } from '../../../ReactSelect/types.js'
import type { RelationshipFilterProps as Props, ValueWithRelation } from './types.js'
⋮----
import { useDebounce } from '../../../../hooks/useDebounce.js'
import { useEffectEvent } from '../../../../hooks/useEffectEvent.js'
import { useConfig } from '../../../../providers/Config/index.js'
import { useLocale } from '../../../../providers/Locale/index.js'
import { useTranslation } from '../../../../providers/Translation/index.js'
import { ReactSelect } from '../../../ReactSelect/index.js'
import optionsReducer from './optionsReducer.js'
⋮----
console.error(e) // eslint-disable-line no-console
⋮----
// eslint-disable-next-line no-console
⋮----
/**
   * When `relationTo` changes externally, reset the options and reload them from scratch
   * The `loadOptions` dependency is a useEffectEvent which has no dependencies of its own
   * This means we can safely depend on it without it triggering this effect to run
   * This is useful because this effect should _only_ run when `relationTo` changes
   */
⋮----
// swallow error
⋮----
/**
   * Load any other options that might exist in the value that were not loaded already
   */
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Relationship/optionsReducer.ts">
import { getTranslation } from '@convexcms/translations'
⋮----
import type { Action, Option } from './types.js'
⋮----
const reduceToIDs = (options)
⋮----
const optionsReducer = (state: Option[], action: Action): Option[] =>
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Relationship/types.ts">
import type { I18nClient } from '@convexcms/translations'
import type {
  ClientCollectionConfig,
  PaginatedDocs,
  RelationshipFieldClient,
  ResolvedFilterOptions,
} from '@convexcms/core'
⋮----
import type { DefaultFilterProps } from '../types.js'
⋮----
export type RelationshipFilterProps = {
  readonly field: RelationshipFieldClient
  readonly filterOptions: ResolvedFilterOptions
} & DefaultFilterProps
⋮----
export type Option = {
  label: string
  options?: Option[]
  relationTo?: string | string[]
  value: string
}
⋮----
type CLEAR = {
  i18n: I18nClient
  required: boolean
  type: 'CLEAR'
}
⋮----
type ADD = {
  collection: ClientCollectionConfig
  data: PaginatedDocs<any>
  hasMultipleRelations: boolean
  i18n: I18nClient
  relation: string
  type: 'ADD'
}
⋮----
export type Action = ADD | CLEAR
⋮----
export type ValueWithRelation = {
  relationTo: string
  value: string
}
⋮----
export type GetResults = (args: {
  lastFullyLoadedRelation?: number
  lastLoadedPage?: number
  search?: string
}) => Promise<void>
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Select/formatOptions.ts">
import type { Option, OptionObject } from '@convexcms/core'
⋮----
/**
 * Formats an array of options for use in a select input.
 */
export const formatOptions = (options: Option[]): OptionObject[]
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Select/index.tsx">
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { SelectFilterProps as Props } from './types.js'
⋮----
import { useTranslation } from '../../../../providers/Translation/index.js'
import { ReactSelect } from '../../../ReactSelect/index.js'
import { formatOptions } from './formatOptions.js'
⋮----
export const Select: React.FC<Props> = ({
  disabled,
  isClearable,
  onChange,
  operator,
  options: optionsFromProps,
  value,
}) =>
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Select/types.ts">
import type { Option, SelectFieldClient } from '@convexcms/core'
⋮----
import type { DefaultFilterProps } from '../types.js'
⋮----
export type SelectFilterProps = {
  readonly field: SelectFieldClient
  readonly isClearable?: boolean
  readonly onChange: (val: string) => void
  readonly options: Option[]
  readonly value: string
} & DefaultFilterProps
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Text/index.scss">
@import '../../../../scss/styles.scss';

@layer payload-default {
  .condition-value-text {
    @include formInput;
  }
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Text/index.tsx">
import React from 'react'
⋮----
import type { TextFilterProps as Props } from './types.js'
⋮----
import { useTranslation } from '../../../../providers/Translation/index.js'
import { ReactSelect } from '../../../ReactSelect/index.js'
⋮----
id: `${val}${index}`, // append index to avoid duplicate keys but allow duplicate numbers
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/Text/types.ts">
import type { TextFieldClient } from '@convexcms/core'
⋮----
import type { DefaultFilterProps } from '../types.js'
⋮----
export type TextFilterProps = {
  readonly field: TextFieldClient
  readonly onChange: (val: string) => void
  readonly value: string | string[]
} & DefaultFilterProps
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .condition {
    &__wrap {
      display: flex;
      align-items: center;
      gap: var(--base);
    }

    &__inputs {
      display: flex;
      flex-grow: 1;
      align-items: center;
      gap: var(--base);

      > div {
        flex-basis: 100%;
      }
    }

    &__field {
      .field-label {
        padding-bottom: 0;
      }
    }

    &__actions {
      flex-shrink: 0;
      display: flex;
      gap: calc(var(--base) / 2);
      padding: calc(var(--base) / 2) 0;
    }

    .btn {
      vertical-align: middle;
      margin: 0;
    }

    @include mid-break {
      &__wrap {
        align-items: initial;
        gap: calc(var(--base) / 2);
      }

      &__inputs {
        flex-direction: column;
        gap: calc(var(--base) / 2);
        align-items: stretch;
      }

      &__actions {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
    }
  }
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/index.tsx">
import React, { useCallback, useEffect, useState } from 'react'
⋮----
import type {
  AddCondition,
  ReducedField,
  RemoveCondition,
  UpdateCondition,
  Value,
} from '../types.js'
⋮----
export type Props = {
  readonly addCondition: AddCondition
  readonly andIndex: number
  readonly fieldName: string
  readonly filterOptions: ResolvedFilterOptions
  readonly operator: Operator
  readonly orIndex: number
  readonly reducedFields: ReducedField[]
  readonly removeCondition: RemoveCondition
  readonly RenderedFilter: React.ReactNode
  readonly updateCondition: UpdateCondition
  readonly value: Value
}
⋮----
import type { Operator, Option as PayloadOption, ResolvedFilterOptions } from '@convexcms/core'
⋮----
import type { Option } from '../../ReactSelect/index.js'
⋮----
import { useDebounce } from '../../../hooks/useDebounce.js'
import { useEffectEvent } from '../../../hooks/useEffectEvent.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { Button } from '../../Button/index.js'
import { ReactSelect } from '../../ReactSelect/index.js'
import { DefaultFilter } from './DefaultFilter/index.js'
import { getOperatorValueTypes } from './validOperators.js'
⋮----
// if the current value is not valid for the new operator
// reset the value before passing it to updateCondition
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/types.ts">
import type { Operator, Where } from '@convexcms/core'
⋮----
import type { Action, ReducedField } from '../types.js'
⋮----
export type Props = {
  andIndex: number
  dispatch: (action: Action) => void
  fields: ReducedField[]
  orIndex: number
  value: Where
}
⋮----
export type DefaultFilterProps = {
  readonly disabled: boolean
  readonly onChange: (val: any) => void
  readonly operator: Operator
  readonly value: unknown
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/Condition/validOperators.ts">
export const getOperatorValueTypes = (fieldType) =>
⋮----
/*
     * exists:
     * The expected value is boolean, but it's passed as a string ('true' or 'false').
     * Need to additionally check if the value is strictly 'true' or 'false' as a string,
     * rather than using a direct typeof comparison.
     * This is handled as:
     * validOperatorValue === 'boolean' && (value === 'true' || value === 'false')
     */
⋮----
/*
     * greater_than, greater_than_equal, less_than, less_than_equal:
     * Used for number and date fields:
     * - For date fields, the value is an object (e.g., Mon Feb 17 2025 12:00:00 GMT+0000).
     * - For number fields, the value is a string representing the number.
     */
</file>

<file path="packages/ui/src/elements/WhereBuilder/field-types.tsx">

</file>

<file path="packages/ui/src/elements/WhereBuilder/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .where-builder {
    background: var(--theme-elevation-50);
    padding: var(--base);
    display: flex;
    flex-direction: column;
    gap: calc(var(--base) / 2);

    .btn {
      margin: 0;
      align-self: flex-start;
    }

    &__no-filters {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);
    }

    &__or-filters,
    &__and-filters {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);

      li {
        display: flex;
        flex-direction: column;
        gap: calc(var(--base) / 2);
      }
    }

    @include small-break {
      padding: calc(var(--base) / 2);
    }
  }
}
</file>

<file path="packages/ui/src/elements/WhereBuilder/index.tsx">
import type { Operator } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { transformWhereQuery, validateWhereQuery } from '@convexcms/core/shared'
import React, { useMemo } from 'react'
⋮----
import type { AddCondition, RemoveCondition, UpdateCondition, WhereBuilderProps } from './types.js'
⋮----
import { useListQuery } from '../../providers/ListQuery/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { Button } from '../Button/index.js'
import { Condition } from './Condition/index.js'
import fieldTypes from './field-types.js'
import { reduceFields } from './reduceFields.js'
⋮----
/**
 * The WhereBuilder component is used to render the filter controls for a collection's list view.
 * It is part of the {@link ListControls} component which is used to render the controls (search, filter, where).
 */
⋮----
// Transform the where query to be in the right format. This will transform something simple like [text][equals]=example%20post to the right format
⋮----
console.warn(`Invalid where query in URL: ${JSON.stringify(whereFromSearch)}`) // eslint-disable-line no-console
⋮----
onClick=
</file>

<file path="packages/ui/src/elements/WhereBuilder/reduceFields.tsx">
import type { ClientTranslationKeys, I18nClient } from '@convexcms/translations'
import type { ClientField } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { fieldIsHiddenOrDisabled, fieldIsID, tabHasName } from '@convexcms/core/shared'
⋮----
import type { ReducedField } from './types.js'
⋮----
import { createNestedClientFieldPath } from '../../forms/Form/createNestedClientFieldPath.js'
import { combineFieldLabel } from '../../utilities/combineFieldLabel.js'
import fieldTypes from './field-types.js'
⋮----
type ReduceFieldOptionsArgs = {
  fields: ClientField[]
  i18n: I18nClient
  labelPrefix?: string
  pathPrefix?: string
}
⋮----
/**
 * Reduces a field map to a flat array of fields with labels and values.
 * Used in the WhereBuilder component to render the fields in the dropdown.
 */
export const reduceFields = ({
  fields,
  i18n,
  labelPrefix,
  pathPrefix,
}: ReduceFieldOptionsArgs): ReducedField[] =>
⋮----
// Do not filter out `field.admin.disableListFilter` fields here, as these should still render as disabled if they appear in the URL query
⋮----
// Make sure we handle nested tabs
⋮----
// Rows cant have labels, so we need to handle them differently
⋮----
// Make sure we handle deeply nested groups
</file>

<file path="packages/ui/src/elements/WhereBuilder/types.ts">
import type {
  ClientField,
  Operator,
  ResolvedFilterOptions,
  SanitizedCollectionConfig,
  Where,
} from '@convexcms/core'
⋮----
export type WhereBuilderProps = {
  readonly collectionPluralLabel: SanitizedCollectionConfig['labels']['plural']
  readonly collectionSlug: SanitizedCollectionConfig['slug']
  readonly fields?: ClientField[]
  readonly renderedFilters?: Map<string, React.ReactNode>
  readonly resolvedFilterOptions?: Map<string, ResolvedFilterOptions>
}
⋮----
export type Value = Date | number | number[] | string | string[]
⋮----
export type ReducedField = {
  field: ClientField
  label: React.ReactNode
  operators: {
    label: string
    value: Operator
  }[]
  value: Value
}
⋮----
export type Relation = 'and' | 'or'
⋮----
export type ADD = {
  andIndex?: number
  field: string
  orIndex?: number
  relation?: Relation
  type: 'add'
}
⋮----
export type REMOVE = {
  andIndex: number
  orIndex: number
  type: 'remove'
}
⋮----
export type UPDATE = {
  andIndex: number
  field?: string
  operator?: string
  orIndex: number
  type: 'update'
  value?: unknown
}
⋮----
export type Action = ADD | REMOVE | UPDATE
⋮----
export type State = {
  or: Where[]
}
⋮----
export type AddCondition = ({
  andIndex,
  field,
  orIndex,
  relation,
}: {
  andIndex: number
  field: ReducedField
  orIndex: number
  relation: 'and' | 'or'
}) => Promise<void> | void
⋮----
export type UpdateCondition = ({
  andIndex,
  field,
  operator,
  orIndex,
  value,
}: {
  andIndex: number
  field: ReducedField
  operator: string
  orIndex: number
  value: Value
}) => Promise<void> | void
⋮----
export type RemoveCondition = ({
  andIndex,
  orIndex,
}: {
  andIndex: number
  orIndex: number
}) => Promise<void> | void
</file>

<file path="packages/ui/src/elements/WindowInfo/index.tsx">
import { useWindowInfo, WindowInfoProvider } from '@faceless-ui/window-info'
</file>

<file path="packages/ui/src/elements/withMergedProps/index.tsx">
import { isReactServerComponentOrFunction, serverProps } from '@convexcms/core/shared'
import React from 'react'
⋮----
/**
 * Creates a higher-order component (HOC) that merges predefined properties (`toMergeIntoProps`)
 * with any properties passed to the resulting component.
 *
 * Use this when you want to pre-specify some props for a component, while also allowing users to
 * pass in their own props. The HOC ensures the passed props and predefined props are combined before
 * rendering the original component.
 *
 * @example
 * const PredefinedComponent = getMergedPropsComponent({
 *   Component: OriginalComponent,
 *   toMergeIntoProps: { someExtraValue: 5 }
 * });
 * // Using <PredefinedComponent customProp="value" /> will result in
 * // <OriginalComponent customProp="value" someExtraValue={5} />
 *
 * @returns A higher-order component with combined properties.
 *
 * @param Component - The original component to wrap.
 * @param sanitizeServerOnlyProps - If true, server-only props will be removed from the merged props. @default true if the component is not a server component, false otherwise.
 * @param toMergeIntoProps - The properties to merge into the passed props.
 */
export function withMergedProps<ToMergeIntoProps, CompleteReturnProps>({
  Component,
  sanitizeServerOnlyProps,
  toMergeIntoProps,
}: {
  Component: React.FC<CompleteReturnProps>
  sanitizeServerOnlyProps?: boolean
  toMergeIntoProps: ToMergeIntoProps
}): React.FC<CompleteReturnProps>
⋮----
// A wrapper around the args.Component to inject the args.toMergeArgs as props, which are merged with the passed props
const MergedPropsComponent: React.FC<CompleteReturnProps> = (passedProps) =>
⋮----
function simpleMergeProps(props, toMerge)
</file>

<file path="packages/ui/src/elements/WithServerSideProps/index.tsx">
import type { WithServerSidePropsComponent } from '@convexcms/core'
⋮----
import { isReactServerComponentOrFunction } from '@convexcms/core/shared'
import React from 'react'
⋮----
export const WithServerSideProps: WithServerSidePropsComponent = ({
  Component,
  serverOnlyProps,
  ...rest
}) =>
⋮----
const WithServerSideProps: React.FC = (passedProps) =>
</file>

<file path="packages/ui/src/exports/client/index.ts">
/* eslint-disable perfectionist/sort-exports */
⋮----
// IMPORTANT: this file cannot use any wildcard exports because it is wrapped in a `use client` boundary
// IMPORTANT: do _not_ alias any of the exports in this file, this will cause a mismatch between the unbundled exports
⋮----
// hooks
⋮----
// query preset elements
⋮----
// elements
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import { Column } from '@convexcms/core'` instead.
   */
⋮----
import { toast } from 'sonner'
⋮----
// fields
⋮----
// forms
⋮----
// graphics
⋮----
// icons
⋮----
// providers
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import type { ListViewSlots } from '@convexcms/core'` instead.
   */
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import type { ListViewClientProps } from '@convexcms/core'` instead.
   */
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import type { ListViewClientProps } from '@convexcms/core'` instead.
   */
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import type { ListViewServerProps } from '@convexcms/core'` instead.
   */
⋮----
/**
   * @deprecated
   * This export will be removed in the next major version.
   * Use `import type { ListPreferences } from '@convexcms/core'` instead.
   */
</file>

<file path="packages/ui/src/exports/rsc/index.ts">

</file>

<file path="packages/ui/src/exports/shared/index.ts">
export { withMergedProps } from '../../elements/withMergedProps/index.js' // cannot be within a 'use client', thus we export this from shared
⋮----
// IMPORTANT: the shared.ts file CANNOT contain any Server Components _that import client components_.
⋮----
/**
 * @deprecated
 * The `mergeListSearchAndWhere` function is deprecated.
 * Import this from `payload/shared` instead.
 */
</file>

<file path="packages/ui/src/fields/Array/ArrayRow.tsx">
import type { ArrayField, ClientField, Row, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { UseDraggableSortableReturn } from '../../elements/DraggableSortable/useDraggableSortable/types.js'
⋮----
import { ArrayAction } from '../../elements/ArrayAction/index.js'
import { Collapsible } from '../../elements/Collapsible/index.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { ShimmerEffect } from '../../elements/ShimmerEffect/index.js'
import { useFormSubmitted } from '../../forms/Form/context.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { RowLabel } from '../../forms/RowLabel/index.js'
import { useThrottledValue } from '../../hooks/useThrottledValue.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
type ArrayRowProps = {
  readonly addRow: (rowIndex: number) => Promise<void> | void
  readonly CustomRowLabel?: React.ReactNode
  readonly duplicateRow: (rowIndex: number) => void
  readonly errorCount: number
  readonly fields: ClientField[]
  readonly forceRender?: boolean
  readonly hasMaxRows?: boolean
  readonly isLoading?: boolean
  readonly isSortable?: boolean
  readonly labels: Partial<ArrayField['labels']>
  readonly moveRow: (fromIndex: number, toIndex: number) => void
  readonly parentPath: string
  readonly path: string
  readonly permissions: SanitizedFieldPermissions
  readonly readOnly?: boolean
  readonly removeRow: (rowIndex: number) => void
  readonly row: Row
  readonly rowCount: number
  readonly rowIndex: number
  readonly schemaPath: string
  readonly setCollapse: (rowID: string, collapsed: boolean) => void
} & UseDraggableSortableReturn
</file>

<file path="packages/ui/src/fields/Array/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .array-field {
    display: flex;
    flex-direction: column;
    gap: calc(var(--base) / 2);

    &__header {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);

      &__header-content {
        display: flex;
        flex-direction: column;
        gap: calc(var(--base) / 4);
      }
    }

    &--has-no-error {
      > .array-field__header .array-field__header-content {
        color: var(--theme-text);
      }
    }

    &__header-content {
      display: flex;
      align-items: center;
      gap: base(0.5);
    }

    &__header-wrap {
      display: flex;
      align-items: flex-end;
      width: 100%;
      justify-content: space-between;
    }

    &__header-actions {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      color: var(--theme-elevation-800);
    }

    &__header-action {
      @extend %btn-reset;
      cursor: pointer;
      margin-left: base(0.5);

      &:hover,
      &:focus-visible {
        text-decoration: underline;
        color: var(--theme-elevation-600);
      }
    }

    &__row-header {
      display: flex;
      align-items: center;
      gap: base(0.5);
      pointer-events: none;
    }

    &__draggable-rows {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);
    }

    &__title {
      margin-bottom: 0;
    }

    &__add-row {
      align-self: flex-start;
      color: var(--theme-elevation-400);
      margin: 2px 0;

      &:hover {
        color: var(--theme-elevation-800);
      }
    }
  }

  html[data-theme='light'] {
    .array-field {
      &--has-error {
        > .array-field__header .array-field__header-content {
          color: var(--theme-error-750);
        }
      }
    }
  }

  html[data-theme='dark'] {
    .array-field {
      &--has-error {
        > .array-field__header .array-field__header-content {
          color: var(--theme-error-500);
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Array/index.tsx">
import type {
  ArrayFieldClientComponent,
  ArrayFieldClientProps,
  ArrayField as ArrayFieldType,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useCallback } from 'react'
⋮----
import { Banner } from '../../elements/Banner/index.js'
import { Button } from '../../elements/Button/index.js'
import { DraggableSortableItem } from '../../elements/DraggableSortable/DraggableSortableItem/index.js'
import { DraggableSortable } from '../../elements/DraggableSortable/index.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useForm, useFormSubmitted } from '../../forms/Form/context.js'
import { extractRowsAndCollapsedIDs, toggleAllRows } from '../../forms/Form/rowHelpers.js'
import { NullifyLocaleField } from '../../forms/NullifyField/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { scrollToID } from '../../utilities/scrollToID.js'
import { fieldBaseClass } from '../shared/index.js'
import { ArrayRow } from './ArrayRow.js'
⋮----
// Handle labeling for Arrays, Global Arrays, and Blocks
const getLabels = (p: ArrayFieldClientProps): Partial<ArrayFieldType['labels']> =>
⋮----
// alternative locales can be null
⋮----
onClick=
</file>

<file path="packages/ui/src/fields/Blocks/BlocksDrawer/BlockSearch/index.scss">
@import '../../../../scss/styles.scss';

$icon-width: base(2);
$icon-margin: base(0.25);

@layer payload-default {
  .block-search {
    position: sticky;
    top: 0;
    display: flex;
    width: 100%;
    align-items: center;
    z-index: 1;

    &__input {
      @include formInput;
    }

    .icon--search {
      position: absolute;
      top: 50%;
      transform: translate3d(0, -50%, 0);
      right: 0;
      width: $icon-width;
      margin: 0 $icon-margin;

      .stroke {
        stroke: var(--theme-elevation-300);
      }
    }

    @include mid-break {
      &__input {
        margin-bottom: 0;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Blocks/BlocksDrawer/BlockSearch/index.tsx">
import React from 'react'
⋮----
import { SearchIcon } from '../../../../icons/Search/index.js'
import { useTranslation } from '../../../../providers/Translation/index.js'
⋮----
const handleChange = (e) =>
</file>

<file path="packages/ui/src/fields/Blocks/BlocksDrawer/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .blocks-drawer {
    &__blocks-wrapper {
      padding-top: base(1.5);
    }

    &__blocks {
      position: relative;
      padding: 0;
      list-style: none;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: base(1);
    }

    &__default-image {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      aspect-ratio: 3 / 2;
      overflow: hidden;

      img,
      svg {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
    }

    &__block-groups {
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: base(1.5);
    }

    &__block-group {
      list-style: none;
    }

    &__block-group-label {
      padding-bottom: base(0.5);
    }

    &__block-group-none {
      order: 1;
      padding-top: base(1.5);
      border-top: 1px solid var(--theme-border-color);

      &:only-child {
        padding-top: 0;
        border-top: 0;
      }
    }

    @include large-break {
      &__blocks {
        grid-template-columns: repeat(5, 1fr);
      }
    }

    @include mid-break {
      &__blocks-wrapper {
        padding-top: base(1.75);
      }

      &__blocks {
        grid-template-columns: repeat(3, 1fr);
      }

      &__block-groups {
        gap: base(1.75);
      }

      &__block-group-none {
        padding-top: base(1.75);
      }
    }

    @include small-break {
      &__blocks-wrapper {
        padding-top: base(0.75);
      }

      &__blocks {
        grid-template-columns: repeat(2, 1fr);
      }

      &__block-groups {
        gap: base(0.75);
      }

      &__block-group-none {
        padding-top: base(0.75);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Blocks/BlocksDrawer/index.tsx">
import type { I18nClient } from '@convexcms/translations'
import type { ClientBlock, Labels } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import React, { useEffect, useMemo, useState } from 'react'
⋮----
import { Drawer } from '../../../elements/Drawer/index.js'
import { ThumbnailCard } from '../../../elements/ThumbnailCard/index.js'
import { DefaultBlockImage } from '../../../graphics/DefaultBlockImage/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
import { BlockSearch } from './BlockSearch/index.js'
⋮----
export type Props = {
  readonly addRow: (index: number, blockType?: string) => Promise<void> | void
  readonly addRowIndex: number
  readonly blocks: (ClientBlock | string)[]
  readonly drawerSlug: string
  readonly labels: Labels
}
⋮----
const getBlockLabel = (block: ClientBlock, i18n: I18nClient) =>
⋮----
title=
</file>

<file path="packages/ui/src/fields/Blocks/SectionTitle/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .section-title {
    position: relative;
    min-width: base(4);
    max-width: 100%;
    pointer-events: all;
    display: flex;
    overflow: hidden;

    &:after {
      display: block;
      content: attr(data-value) ' ';
      visibility: hidden;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    &:after,
    &__input {
      font-family: var(--font-body);
      font-weight: 600;
      font-size: base(0.625);
      padding: 0;
      width: 100%;
    }

    &__input {
      color: var(--theme-elevation-800);
      background-color: transparent;
      border: none;
      min-width: min-content;
      width: 100%;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      resize: none;
      appearance: none;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;

      &:hover {
        box-shadow: inset 0px -2px 0px -1px var(--theme-elevation-150);
      }

      &:hover,
      &:focus {
        outline: 0;
      }

      &:focus {
        box-shadow: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Blocks/SectionTitle/index.tsx">
import React from 'react'
⋮----
import { useField } from '../../../forms/useField/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
export type Props = {
  customOnChange?: (e: React.ChangeEvent<HTMLInputElement>) => void
  customValue?: string
  path: string
  readOnly: boolean
}
⋮----
/**
 * An input field representing the block's `blockName` property - responsible for reading and saving the `blockName`
 * property from/into the provided path.
 */
</file>

<file path="packages/ui/src/fields/Blocks/BlockRow.tsx">
import type { ClientBlock, ClientField, Labels, Row, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { UseDraggableSortableReturn } from '../../elements/DraggableSortable/useDraggableSortable/types.js'
import type { RenderFieldsProps } from '../../forms/RenderFields/types.js'
⋮----
import { Collapsible } from '../../elements/Collapsible/index.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { Pill } from '../../elements/Pill/index.js'
import { ShimmerEffect } from '../../elements/ShimmerEffect/index.js'
import { useFormSubmitted } from '../../forms/Form/context.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { RowLabel } from '../../forms/RowLabel/index.js'
import { useThrottledValue } from '../../hooks/useThrottledValue.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { RowActions } from './RowActions.js'
import { SectionTitle } from './SectionTitle/index.js'
⋮----
type BlocksFieldProps = {
  addRow: (rowIndex: number, blockType: string) => Promise<void> | void
  block: ClientBlock
  blocks: (ClientBlock | string)[] | ClientBlock[]
  duplicateRow: (rowIndex: number) => void
  errorCount: number
  fields: ClientField[]
  hasMaxRows?: boolean
  isLoading?: boolean
  isSortable?: boolean
  Label?: React.ReactNode
  labels: Labels
  moveRow: (fromIndex: number, toIndex: number) => void
  parentPath: string
  path: string
  permissions: SanitizedFieldPermissions
  readOnly: boolean
  removeRow: (rowIndex: number) => void
  row: Row
  rowCount: number
  rowIndex: number
  schemaPath: string
  setCollapse: (id: string, collapsed: boolean) => void
} & UseDraggableSortableReturn
</file>

<file path="packages/ui/src/fields/Blocks/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .blocks-field {
    display: flex;
    flex-direction: column;
    gap: calc(var(--base) / 2);

    &__header {
      h3 {
        margin: 0;
      }
    }

    &__header-wrap {
      display: flex;
      align-items: flex-end;
      width: 100%;
      justify-content: space-between;
    }

    &__heading-with-error {
      display: flex;
      align-items: center;
      gap: base(0.5);
    }

    &--has-no-error {
      > .array-field__header .array-field__heading-with-error {
        color: var(--theme-text);
      }
    }

    &--has-error {
      > .array-field__header {
        color: var(--theme-error-500);
      }
    }

    &__error-pill {
      align-self: center;
    }

    &__header-actions {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
    }

    &__header-action {
      @extend %btn-reset;
      cursor: pointer;
      margin-left: base(0.5);

      &:hover,
      &:focus-visible {
        text-decoration: underline;
      }
    }

    &__block-header {
      display: inline-flex;
      max-width: 100%;
      width: 100%;
      overflow: hidden;
      gap: base(0.375);
    }

    &__block-number {
      flex-shrink: 0;
    }

    &__block-pill {
      flex-shrink: 0;
      display: block;
      line-height: unset;
    }

    &__rows {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 2);
    }

    &__drawer-toggler {
      background-color: transparent;
      margin: 0;
      padding: 0;
      border: none;
      align-self: flex-start;

      .btn {
        color: var(--theme-elevation-400);
        margin: 0;

        &:hover {
          color: var(--theme-elevation-800);
        }
      }
    }
  }

  html[data-theme='light'] {
    .blocks-field--has-error {
      .section-title__input,
      .blocks-field__heading-with-error {
        color: var(--theme-error-750);
      }
    }
  }

  html[data-theme='dark'] {
    .blocks-field--has-error {
      .section-title__input,
      .blocks-field__heading-with-error {
        color: var(--theme-error-500);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Blocks/index.tsx">
import type { BlocksFieldClientComponent, ClientBlock } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { Fragment, useCallback } from 'react'
⋮----
import { Banner } from '../../elements/Banner/index.js'
import { Button } from '../../elements/Button/index.js'
import { DraggableSortableItem } from '../../elements/DraggableSortable/DraggableSortableItem/index.js'
import { DraggableSortable } from '../../elements/DraggableSortable/index.js'
import { DrawerToggler } from '../../elements/Drawer/index.js'
import { useDrawerSlug } from '../../elements/Drawer/useDrawerSlug.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { useForm, useFormSubmitted } from '../../forms/Form/context.js'
import { extractRowsAndCollapsedIDs, toggleAllRows } from '../../forms/Form/rowHelpers.js'
import { NullifyLocaleField } from '../../forms/NullifyField/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { scrollToID } from '../../utilities/scrollToID.js'
import { FieldDescription } from '../FieldDescription/index.js'
import { FieldError } from '../FieldError/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { fieldBaseClass } from '../shared/index.js'
import { BlockRow } from './BlockRow.js'
import { BlocksDrawer } from './BlocksDrawer/index.js'
⋮----
// alternative locales can be null
</file>

<file path="packages/ui/src/fields/Blocks/RowActions.tsx">
import type { ClientBlock, ClientField, Labels } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import React from 'react'
⋮----
import { ArrayAction } from '../../elements/ArrayAction/index.js'
import { useDrawerSlug } from '../../elements/Drawer/useDrawerSlug.js'
import { BlocksDrawer } from './BlocksDrawer/index.js'
⋮----
setIndexToAdd(index)
openModal(drawerSlug)
</file>

<file path="packages/ui/src/fields/Checkbox/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .checkbox {
    position: relative;
    margin-bottom: $baseline;

    .tooltip:not([aria-hidden='true']) {
      right: auto;
      position: static;
      transform: translateY(calc(var(--caret-size) * -1));
      margin-bottom: 0.2em;
      max-width: fit-content;
    }
  }

  .checkbox-input {
    display: inline-flex;
    &:hover:not(&--read-only) {
      label,
      input {
        cursor: pointer;
      }
    }

    label {
      padding-bottom: 0;
      padding-left: base(0.5);
    }

    [dir='rtl'] &__input {
      margin-right: 0;
      margin-left: base(0.5);
    }

    &__input {
      @include formInput;
      display: flex;
      padding: 0;
      line-height: 0;
      position: relative;
      width: $baseline;
      height: $baseline;

      & input[type='checkbox'] {
        position: absolute;
        // Without the extra 4px, there is an uncheckable area due to the border of the parent element
        width: calc(100% + 4px);
        height: calc(100% + 4px);
        padding: 0;
        margin: 0;
        margin-left: -2px;
        margin-top: -2px;
        opacity: 0;
        border-radius: 0;
        z-index: 1;
      }
    }

    &__icon {
      position: absolute;

      svg {
        opacity: 0;
      }
    }

    &:not(&--read-only) {
      &:active,
      &:focus-within,
      &:focus {
        .checkbox-input__input,
        & input[type='checkbox'] {
          outline: 0;
          box-shadow: 0 0 3px 3px var(--theme-success-400) !important;
          border: 1px solid var(--theme-elevation-150);
        }
      }

      &:hover {
        .checkbox-input__input,
        & input[type='checkbox'] {
          border-color: var(--theme-elevation-250);
        }
      }
    }

    &:not(&--read-only):not(&--checked) {
      &:hover {
        cursor: pointer;

        svg {
          opacity: 0.2;
        }
      }
    }

    &--checked {
      .checkbox-input__icon {
        svg {
          opacity: 1;
        }
      }
    }

    .checkbox-input__icon {
      .icon--line {
        width: 1.4rem;
        height: 1.4rem;
      }

      &.partial {
        svg {
          opacity: 1;
        }
      }
    }

    &--read-only {
      .checkbox-input__input {
        @include readOnly;
      }

      label {
        color: var(--theme-elevation-400);
      }
    }
  }

  html[data-theme='light'] {
    .checkbox {
      &.error {
        .checkbox-input__input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .checkbox {
      &.error {
        .checkbox-input__input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Checkbox/index.tsx">
import type {
  CheckboxFieldClientComponent,
  CheckboxFieldClientProps,
  CheckboxFieldValidation,
} from '@convexcms/core'
⋮----
import React, { useCallback, useMemo } from 'react'
⋮----
import type { CheckboxInputProps } from './Input.js'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { useForm } from '../../forms/Form/context.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { generateFieldID } from '../../utilities/generateFieldID.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { fieldBaseClass } from '../shared/index.js'
import { CheckboxInput } from './Input.js'
⋮----
const CheckboxFieldComponent: CheckboxFieldClientComponent = (props) =>
</file>

<file path="packages/ui/src/fields/Checkbox/Input.tsx">
import type { StaticLabel } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { CheckIcon } from '../../icons/Check/index.js'
import { LineIcon } from '../../icons/Line/index.js'
⋮----
export type CheckboxInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly BeforeInput?: React.ReactNode
  readonly checked?: boolean
  readonly className?: string
  readonly id?: string
  readonly inputRef?: React.RefObject<HTMLInputElement | null>
  readonly Label?: React.ReactNode
  readonly label?: StaticLabel
  readonly localized?: boolean
  readonly name?: string
  readonly onToggle: (event: React.ChangeEvent<HTMLInputElement>) => void
  readonly partialChecked?: boolean
  readonly readOnly?: boolean
  readonly required?: boolean
}
</file>

<file path="packages/ui/src/fields/Code/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .code-field {
    position: relative;

    &.error {
      textarea {
        border: 1px solid var(--theme-error-500) !important;
      }
      .code-editor {
        border-color: var(--theme-error-500);
      }
      .monaco-editor-background,
      .margin {
        background-color: var(--theme-error-50);
      }
    }

    .read-only {
      .code-editor {
        @include readOnly;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Code/index.tsx">
import type { CodeFieldClientComponent } from '@convexcms/core'
⋮----
import React, { useCallback, useMemo } from 'react'
⋮----
import { CodeEditor } from '../../elements/CodeEditor/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
⋮----
const CodeFieldComponent: CodeFieldClientComponent = (props) =>
</file>

<file path="packages/ui/src/fields/Collapsible/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .collapsible-field {
    &__row-label-wrap {
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: base(0.5);
    }
  }
}
</file>

<file path="packages/ui/src/fields/Collapsible/index.tsx">
import type { CollapsibleFieldClientComponent, DocumentPreferences } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { Fragment, useCallback, useEffect, useMemo, useState } from 'react'
⋮----
import { Collapsible as CollapsibleElement } from '../../elements/Collapsible/index.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { RowLabel } from '../../forms/RowLabel/index.js'
import { useField } from '../../forms/useField/index.js'
import { WatchChildErrors } from '../../forms/WatchChildErrors/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { usePreferences } from '../../providers/Preferences/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
⋮----
const fetchInitialState = async () =>
⋮----
// removes the 'collapsible' path segment, i.e. `_index-0`
</file>

<file path="packages/ui/src/fields/ConfirmPassword/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.confirm-password {
    position: relative;

    input {
      @include formInput;
    }
  }

  html[data-theme='light'] {
    .field-type.field-type.confirm-password {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.field-type.confirm-password {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/ConfirmPassword/index.tsx">
import { confirmPassword } from '@convexcms/core/shared'
import React from 'react'
⋮----
import { useField } from '../../forms/useField/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { FieldError } from '../FieldError/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
export type ConfirmPasswordFieldProps = {
  readonly disabled?: boolean
  readonly path?: string
}
</file>

<file path="packages/ui/src/fields/DateTime/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  html[data-theme='light'] {
    .date-time-field {
      &--has-error {
        .react-datepicker__input-container input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .date-time-field {
      &--has-error {
        .react-datepicker__input-container input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/DateTime/index.tsx">
import type { DateFieldClientComponent, DateFieldValidation } from '@convexcms/core'
⋮----
import { TZDateMini as TZDate } from '@date-fns/tz/date/mini'
import { getTranslation } from '@convexcms/translations'
import { transpose } from 'date-fns'
import { useCallback, useMemo } from 'react'
⋮----
import { DatePickerField } from '../../elements/DatePicker/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { TimezonePicker } from '../../elements/TimezonePicker/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useForm, useFormFields } from '../../forms/Form/context.js'
import { useField } from '../../forms/useField/index.js'
⋮----
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
// Get the user timezone so we can adjust the displayed value against it
⋮----
/**
   * Date appearance doesn't include timestamps,
   * which means we need to pin the time to always 12:00 for the selected date
   */
⋮----
// The displayed value should be the original value, adjusted to the user's timezone
⋮----
// Create TZDate instances for the selected timezone and the user's timezone
// These instances allow us to transpose the date between timezones while keeping the same time value
⋮----
// Transpose the date to the selected timezone
⋮----
// Transpose the date to the user's timezone - this is necessary because the react-datepicker component insists on displaying the date in the user's timezone
⋮----
// Create TZDate instances for the selected timezone
⋮----
// We need to offset this hardcoded hour offset from the DatePicker elemenent
// this can be removed in 4.0 when we remove the hardcoded offset as it is a breaking change
// const tzOffset = incomingDate.getTimezoneOffset() / 60
⋮----
// Convert the original date as picked into the desired timezone.
⋮----
// Creates a TZDate instance for the user's timezone  — this is default behaviour of TZDate as it wraps the Date constructor
⋮----
// Transpose the date to the selected timezone
</file>

<file path="packages/ui/src/fields/Email/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.email {
    position: relative;

    input {
      @include formInput;
    }

    &.error {
      input {
        background-color: var(--theme-error-200);
      }
    }
  }

  html[data-theme='light'] {
    .field-type.email {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.email {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Email/index.tsx">
import type {
  EmailFieldClientComponent,
  EmailFieldClientProps,
  EmailFieldValidation,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useCallback, useMemo } from 'react'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
⋮----
const EmailFieldComponent: EmailFieldClientComponent = (props) =>
⋮----
{/* disable eslint here because the label is dynamic */}
{/* eslint-disable-next-line jsx-a11y/control-has-associated-label */}
</file>

<file path="packages/ui/src/fields/FieldDescription/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-description {
    display: flex;
    color: var(--theme-elevation-400);
    margin-top: calc(var(--base) / 4);

    &--margin-bottom {
      margin-top: 0;
      margin-bottom: calc(var(--base) / 2);
    }
  }
}
</file>

<file path="packages/ui/src/fields/FieldDescription/index.tsx">
import type { GenericDescriptionProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
export const FieldDescription: React.FC<GenericDescriptionProps> = (props) =>
</file>

<file path="packages/ui/src/fields/FieldError/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .field-error.tooltip {
    font-family: var(--font-body);
    left: auto;
    max-width: 75%;
    right: 0;
    transform: translateY(calc(var(--caret-size) * -1));
    color: var(--theme-error-950);
    background-color: var(--theme-error-300);

    &::after {
      border-top-color: var(--theme-error-300);
      border-bottom-color: var(--theme-error-300);
    }
  }
}
</file>

<file path="packages/ui/src/fields/FieldError/index.tsx">
import type { GenericErrorProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { Tooltip } from '../../elements/Tooltip/index.js'
import { useFormFields, useFormSubmitted } from '../../forms/Form/context.js'
</file>

<file path="packages/ui/src/fields/FieldLabel/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  label.field-label {
    display: flex;
    align-items: center;
  }

  label.field-label:not(.unstyled) {
    @extend %body;
    display: flex;
    padding-bottom: base(0.25);
    color: var(--theme-elevation-800);
    font-family: var(--font-body);
    [dir='ltr'] & {
      margin-right: auto;
    }
    [dir='rtl'] & {
      margin-left: auto;
    }

    .required {
      color: var(--theme-error-500);
    }

    .required {
      [dir='ltr'] & {
        margin-left: base(0.25);
      }
      [dir='rtl'] & {
        margin-right: base(0.25);
      }
    }
  }

  .localized {
    @extend %body;
    [dir='ltr'] & {
      margin-left: base(0.25);
    }
    [dir='rtl'] & {
      margin-right: base(0.25);
    }
  }
}
</file>

<file path="packages/ui/src/fields/FieldLabel/index.tsx">
import type { GenericLabelProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useForm } from '../../forms/Form/context.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { generateFieldID } from '../../utilities/generateFieldID.js'
⋮----
export const FieldLabel: React.FC<GenericLabelProps> = (props) =>
⋮----
</file>

<file path="packages/ui/src/fields/Group/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .group-field {
    margin-left: calc(var(--gutter-h) * -1);
    margin-right: calc(var(--gutter-h) * -1);
    border-bottom: 1px solid var(--theme-elevation-100);
    border-top: 1px solid var(--theme-elevation-100);

    &--top-level {
      padding: base(2) var(--gutter-h);

      &:first-child {
        padding-top: 0;
        border-top: 0;
      }
    }

    &--within-collapsible {
      margin-left: calc(var(--base) * -1);
      margin-right: calc(var(--base) * -1);
      padding: var(--base);

      &:first-child {
        border-top: 0;
        padding-top: 0;
        margin-top: 0;
      }

      &:last-child {
        padding-bottom: 0;
        border-bottom: 0;
      }
    }

    &--within-group {
      margin-left: 0;
      margin-right: 0;
      padding: 0;
      border-top: 0;
      border-bottom: 0;
    }

    &--within-row {
      margin: 0;
      border-top: 0;
      border-bottom: 0;
    }

    &--within-tab:first-child {
      margin-top: 0;
      border-top: 0;
      padding-top: 0;
    }

    &--within-tab:last-child {
      margin-bottom: 0;
      border-bottom: 0;
      padding-bottom: 0;
    }

    &--gutter {
      border-left: 1px solid var(--theme-elevation-100);
      padding: 0 0 0 $baseline;
    }

    &__header {
      margin-bottom: calc(var(--base) / 2);
      display: flex;
      align-items: center;
      gap: base(0.5);

      > header {
        display: flex;
        flex-direction: column;
        gap: calc(var(--base) / 4);
      }
    }

    &__title {
      margin-bottom: 0;
    }

    @include small-break {
      &--top-level {
        padding: var(--base) var(--gutter-h);

        &:first-child {
          padding-top: 0;
          border-top: 0;
        }
      }

      &__header {
        margin-bottom: calc(var(--base) / 2);
      }

      &--within-collapsible {
        margin-left: calc(var(--gutter-h) * -1);
        margin-right: calc(var(--gutter-h) * -1);
      }

      &--within-group {
        padding: 0;
      }

      &--gutter {
        padding-left: var(--gutter-h);
      }
    }
  }

  .group-field + .group-field {
    border-top: 0;
    padding-top: 0;
  }

  .group-field--within-row + .group-field--within-row {
    margin-top: 0;
  }

  .group-field--within-tab + .group-field--within-row {
    padding-top: 0;
  }

  html[data-theme='light'] {
    .group-field {
      &--has-error {
        .group-field__header {
          color: var(--theme-error-750);

          &:after {
            background: var(--theme-error-500);
          }
        }
      }
    }
  }

  html[data-theme='dark'] {
    .group-field {
      &--has-error {
        .group-field__header {
          color: var(--theme-error-500);

          &:after {
            background: var(--theme-error-500);
          }
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Group/index.tsx">
import type { GroupFieldClientComponent } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useMemo } from 'react'
⋮----
import { useCollapsible } from '../../elements/Collapsible/provider.js'
import { ErrorPill } from '../../elements/ErrorPill/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useFormSubmitted } from '../../forms/Form/context.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { useRow } from '../Row/provider.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
import { useTabs } from '../Tabs/provider.js'
import { GroupProvider, useGroup } from './provider.js'
</file>

<file path="packages/ui/src/fields/Group/provider.tsx">
import React, { createContext, use } from 'react'
⋮----
export const GroupProvider: React.FC<{ children?: React.ReactNode; withinGroup?: boolean }> = ({
  children,
  withinGroup = true,
}) =>
⋮----
export const useGroup = (): boolean
</file>

<file path="packages/ui/src/fields/Hidden/index.tsx">
import type { HiddenFieldProps } from '@convexcms/core'
⋮----
import React, { useEffect } from 'react'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
⋮----
/**
 * This is mainly used to save a value on the form that is not visible to the user.
 * For example, this sets the `ìd` property of a block in the Blocks field.
 */
const HiddenFieldComponent: React.FC<HiddenFieldProps> = (props) =>
</file>

<file path="packages/ui/src/fields/Join/index.tsx">
import type {
  ClientConfig,
  ClientField,
  JoinFieldClient,
  JoinFieldClientComponent,
  PaginatedDocs,
  Where,
} from '@convexcms/core'
⋮----
import ObjectIdImport from 'bson-objectid'
import { flattenTopLevelFields } from '@convexcms/core/shared'
import React, { useMemo } from 'react'
⋮----
import { RelationshipTable } from '../../elements/RelationshipTable/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { FieldDescription } from '../FieldDescription/index.js'
import { FieldError } from '../FieldError/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { fieldBaseClass } from '../index.js'
⋮----
/**
 * Recursively builds the default data for joined collection
 */
const getInitialDrawerData = ({
  collectionSlug,
  config,
  docID,
  fields,
  segments,
}: {
  collectionSlug: string
  config: ClientConfig
  docID: number | string
  fields: ClientField[]
  segments: string[]
}) =>
</file>

<file path="packages/ui/src/fields/JSON/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .json-field {
    position: relative;

    &.error {
      .code-editor {
        border-color: var(--theme-error-500);
      }

      .monaco-editor-background,
      .margin {
        background-color: var(--theme-error-50);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/JSON/index.tsx">
import type { JSONFieldClientComponent } from '@convexcms/core'
⋮----
import { type OnMount } from '@monaco-editor/react'
import React, { useCallback, useEffect, useMemo, useState } from 'react'
import { v4 as uuidv4 } from 'uuid'
⋮----
import { CodeEditor } from '../../elements/CodeEditor/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { FieldDescription } from '../FieldDescription/index.js'
import { FieldError } from '../FieldError/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { fieldBaseClass } from '../shared/index.js'
</file>

<file path="packages/ui/src/fields/Number/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.number {
    position: relative;

    &:not(.has-many) {
      input {
        @include formInput;
      }
    }
  }

  html[data-theme='light'] {
    .field-type.number {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.number {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Number/index.tsx">
import type { NumberFieldClientComponent, NumberFieldClientProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { isNumber } from '@convexcms/core/shared'
import React, { useCallback, useEffect, useMemo, useState } from 'react'
⋮----
import type { Option } from '../../elements/ReactSelect/types.js'
⋮----
import { ReactSelect } from '../../elements/ReactSelect/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { FieldDescription } from '../FieldDescription/index.js'
import { FieldError } from '../FieldError/index.js'
import { FieldLabel } from '../FieldLabel/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
⋮----
>([]) // Only for hasMany
⋮----
// useEffect update valueToRender:
⋮----
id: `${val}${index}`, // append index to avoid duplicate keys but allow duplicate numbers
⋮----
}, // You're probably wondering, why the hell is this done that way? Well, React-select automatically uses "label-value" as a key, so we will get that react duplicate key warning if we just pass in the value as multiple values can be the same. So we need to append the index to the toString() of the value to avoid that warning, as it uses that as the key.
⋮----
// numberOnly
⋮----
// @ts-expect-error
</file>

<file path="packages/ui/src/fields/Password/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.password {
    position: relative;

    input {
      @include formInput;
    }
  }

  html[data-theme='light'] {
    .field-type.password {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.password {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Password/index.tsx">
import type { PasswordFieldValidation, PayloadRequest } from '@convexcms/core'
⋮----
import { password } from '@convexcms/core/shared'
import React, { useCallback, useMemo } from 'react'
⋮----
import type { PasswordFieldProps } from './types.js'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { isFieldRTL } from '../shared/index.js'
import { PasswordInput } from './input.js'
⋮----
const PasswordFieldComponent: React.FC<PasswordFieldProps> = (props) =>
</file>

<file path="packages/ui/src/fields/Password/input.tsx">
import type { ChangeEvent } from 'react'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { PasswordInputProps } from './types.js'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
export const PasswordInput: React.FC<PasswordInputProps> = (props) =>
⋮----
placeholder=
</file>

<file path="packages/ui/src/fields/Password/types.ts">
import type {
  FieldBaseClient,
  PasswordFieldValidation,
  StaticDescription,
  TextFieldClient,
} from '@convexcms/core'
import type { ChangeEvent, CSSProperties } from 'react'
import type React from 'react'
import type { MarkOptional } from 'ts-essentials'
⋮----
export type PasswordFieldProps = {
  readonly autoComplete?: string
  readonly field: MarkOptional<TextFieldClient, 'type'>
  /**
   * @default ''
   */
  readonly indexPath?: string
  readonly inputRef?: React.RefObject<HTMLInputElement>
  /**
   * @default ''
   */
  readonly parentPath?: string
  /**
   * @default ''
   */
  readonly parentSchemaPath?: string
  /**
   * @default field.name
   */
  readonly path: string
  /**
   * @default field.name
   */
  readonly schemaPath?: string
  readonly validate?: PasswordFieldValidation
}
⋮----
/**
   * @default ''
   */
⋮----
/**
   * @default ''
   */
⋮----
/**
   * @default ''
   */
⋮----
/**
   * @default field.name
   */
⋮----
/**
   * @default field.name
   */
⋮----
export type PasswordInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly autoComplete?: string
  readonly BeforeInput?: React.ReactNode
  readonly className?: string
  readonly description?: StaticDescription
  readonly Description?: React.ReactNode
  readonly Error?: React.ReactNode
  readonly field?: MarkOptional<TextFieldClient, 'type'>
  readonly inputRef?: React.RefObject<HTMLInputElement>
  readonly Label?: React.ReactNode
  readonly label: FieldBaseClient['label']
  readonly localized?: boolean
  readonly onChange?: (e: ChangeEvent<HTMLInputElement>) => void
  readonly onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>
  readonly path: string
  readonly placeholder?: Record<string, string> | string
  readonly readOnly?: boolean
  readonly required?: boolean
  readonly rtl?: boolean
  readonly showError?: boolean
  readonly style?: React.CSSProperties
  readonly value?: string
  readonly width?: CSSProperties['width']
}
</file>

<file path="packages/ui/src/fields/Point/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .point {
    position: relative;

    & .input-wrapper {
      position: relative;
    }

    &__wrap {
      display: flex;
      width: calc(100% + #{base(1)});
      margin: 0;
      margin-left: base(-0.5);
      margin-right: base(-0.5);
      list-style: none;
      padding: 0;

      li {
        padding: 0 base(0.5);
        width: 50%;
      }
    }

    input {
      @include formInput;
    }
  }

  html[data-theme='light'] {
    .point {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .point {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Point/index.tsx">
import type { PointFieldClientComponent, PointFieldValidation } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useCallback, useMemo } from 'react'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
⋮----
export const PointFieldComponent: PointFieldClientComponent = (props) =>
⋮----
const getCoordinateFieldLabel = (type: 'latitude' | 'longitude') =>
⋮----
label=
⋮----
{/* disable eslint rule because the label is dynamic */}
{/* eslint-disable-next-line jsx-a11y/control-has-associated-label */}
⋮----
onChange=
⋮----
{/* disable eslint rule because the label is dynamic */}
{/* eslint-disable-next-line jsx-a11y/control-has-associated-label */}
</file>

<file path="packages/ui/src/fields/RadioGroup/Radio/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .radio-input {
    display: flex;
    align-items: center;
    cursor: pointer;
    margin: base(0.1) 0;
    position: relative;

    input[type='radio'] {
      opacity: 0;
      margin: 0;
      position: absolute;
    }

    input[type='radio']:focus + .radio-input__styled-radio {
      box-shadow: 0 0 3px 3px var(--theme-success-400);
    }

    &__styled-radio {
      border: 1px solid var(--theme-border-color);
      background-color: var(--theme-input-bg);
      @include shadow-sm;
      width: $baseline;
      height: $baseline;
      position: relative;
      padding: 0;
      display: inline-block;
      border-radius: 50%;

      &:before {
        content: ' ';
        display: block;
        border-radius: 100%;
        background-color: var(--theme-elevation-800);
        width: calc(100% - 8px);
        height: calc(100% - 8px);
        border: 4px solid var(--theme-elevation-0);
        opacity: 0;
      }

      &--disabled {
        @include readOnly;
        &::before {
          border-color: var(--theme-elevation-100);
        }
      }
    }

    [dir='rtl'] &__label {
      margin-left: 0;
      margin-right: base(0.5);
    }

    &__label {
      margin-left: base(0.5);
    }

    &--is-selected {
      .radio-input {
        &__styled-radio {
          &:before {
            opacity: 1;
          }
        }
      }
    }

    &:not(&--is-selected) {
      &:hover {
        .radio-input {
          &__styled-radio {
            &:before {
              opacity: 0.2;
            }
          }
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/RadioGroup/Radio/index.tsx">
import type { OptionObject, RadioFieldClientProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { useEditDepth } from '../../../providers/EditDepth/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
</file>

<file path="packages/ui/src/fields/RadioGroup/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .radio-group {
    .tooltip:not([aria-hidden='true']) {
      right: auto;
      position: static;
      margin-bottom: 0.2em;
      max-width: fit-content;
    }

    &--layout-horizontal {
      ul {
        display: flex;
        flex-wrap: wrap;
      }

      li {
        flex-shrink: 0;
        [dir='ltr'] & {
          padding-right: $baseline;
        }
        [dir='rtl'] & {
          padding-left: $baseline;
        }
      }
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
  }

  .radio-group--read-only {
    .radio-input {
      cursor: default;

      &:hover {
        border-color: var(--theme-elevation-50);
      }

      &__label {
        color: var(--theme-elevation-400);
      }

      &--is-selected {
        .radio-input__styled-radio {
          &:before {
            background-color: var(--theme-elevation-250);
          }
        }
      }

      &:not(.radio-input--is-selected) {
        &:hover {
          .radio-input__styled-radio {
            &:before {
              opacity: 0;
            }
          }
        }
      }
    }
  }

  html[data-theme='light'] {
    .radio-group {
      &.error {
        .radio-input__styled-radio {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .radio-group {
      &.error {
        .radio-input__styled-radio {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/RadioGroup/index.tsx">
import type { RadioFieldClientComponent, RadioFieldClientProps } from '@convexcms/core'
⋮----
import { optionIsObject } from '@convexcms/core/shared'
import React, { useCallback, useMemo } from 'react'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useForm } from '../../forms/Form/context.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { fieldBaseClass } from '../shared/index.js'
import { Radio } from './Radio/index.js'
⋮----
onChangeFromProps(optionValue)
                    }

if (!(readOnly || disabled))
⋮----
option=
</file>

<file path="packages/ui/src/fields/Relationship/select-components/MultiValueLabel/index.scss">
@import '../../../../scss/styles.scss';

@layer payload-default {
  .relationship--multi-value-label {
    display: flex;
    padding-inline-start: base(0.4);
    gap: base(0.2);

    &__content {
      @extend %small;
      line-height: base(1.1);
      max-width: 150px;
      color: currentColor;
      display: flex;
      align-items: center;
    }

    &__text {
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }

    &__drawer-toggler {
      border: none;
      background-color: transparent;
      padding: 0;
      cursor: pointer;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: base(0.2);
      pointer-events: all;

      .icon {
        width: base(1);
        height: base(1);
        padding: base(0.1);
      }

      &:hover {
        background-color: var(--theme-elevation-150);
      }

      &:focus-visible {
        outline: var(--accessibility-outline);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Relationship/select-components/MultiValueLabel/index.tsx">
import type { MultiValueProps } from 'react-select'
⋮----
import React, { Fragment, useState } from 'react'
import { components } from 'react-select'
⋮----
import type { ReactSelectAdapterProps } from '../../../../elements/ReactSelect/types.js'
import type { Option } from '../../types.js'
⋮----
import { Tooltip } from '../../../../elements/Tooltip/index.js'
import { EditIcon } from '../../../../icons/Edit/index.js'
import { useAuth } from '../../../../providers/Auth/index.js'
import { useTranslation } from '../../../../providers/Translation/index.js'
⋮----
// TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
onMouseDown={(e) => e.stopPropagation()} // prevents react-select dropdown from opening
⋮----
onMouseLeave=
onTouchEnd={(e) => e.stopPropagation()} // prevents react-select dropdown from opening
</file>

<file path="packages/ui/src/fields/Relationship/select-components/SingleValue/index.scss">
@import '../../../../scss/styles.scss';

@layer payload-default {
  .relationship--single-value {
    &.rs__single-value {
      overflow: visible;
      min-width: 0;
    }

    &__label-text {
      max-width: unset;
      display: flex;
      align-items: center;
      overflow: visible;
      width: 100%;
      flex-shrink: 1;
    }

    &__text {
      overflow: hidden;
      text-overflow: ellipsis;
    }

    &__drawer-toggler {
      border: none;
      background-color: transparent;
      padding: 0;
      cursor: pointer;
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: base(0.25);
      pointer-events: all;

      .icon {
        width: base(0.75);
        height: base(0.75);
      }

      &:focus-visible {
        outline: var(--accessibility-outline);
      }

      &:hover {
        background-color: var(--theme-elevation-100);
      }
    }

    &__label {
      flex-grow: 1;
    }
  }
}
</file>

<file path="packages/ui/src/fields/Relationship/select-components/SingleValue/index.tsx">
import type { SingleValueProps } from 'react-select'
⋮----
import React, { Fragment, useState } from 'react'
import { components as SelectComponents } from 'react-select'
⋮----
import type { ReactSelectAdapterProps } from '../../../../elements/ReactSelect/types.js'
import type { Option } from '../../types.js'
⋮----
import { Tooltip } from '../../../../elements/Tooltip/index.js'
import { EditIcon } from '../../../../icons/Edit/index.js'
import { useAuth } from '../../../../providers/Auth/index.js'
import { useTranslation } from '../../../../providers/Translation/index.js'
⋮----
// TODO Fix this - moduleResolution 16 breaks our declare module
⋮----
onMouseDown={(e) => e.stopPropagation()} // prevents react-select dropdown from opening
⋮----
onMouseLeave=
onTouchEnd={(e) => e.stopPropagation()} // prevents react-select dropdown from openingtype="button"
</file>

<file path="packages/ui/src/fields/Relationship/createRelationMap.ts">
import type { Value } from './types.js'
⋮----
type RelationMap = {
  [relation: string]: (number | string)[]
}
⋮----
type CreateRelationMap = (args: {
  hasMany: boolean
  relationTo: string | string[]
  value: null | Value | Value[] // really needs to be `ValueWithRelation`
}) => RelationMap
⋮----
value: null | Value | Value[] // really needs to be `ValueWithRelation`
⋮----
export const createRelationMap: CreateRelationMap = (
⋮----
const add = (relation: string, id: unknown) =>
</file>

<file path="packages/ui/src/fields/Relationship/findOptionsByValue.ts">
import type { Option } from '../../elements/ReactSelect/types.js'
import type { OptionGroup, Value } from './types.js'
⋮----
type Args = {
  allowEdit: boolean
  options: OptionGroup[]
  value: Value | Value[]
}
⋮----
export const findOptionsByValue = (
</file>

<file path="packages/ui/src/fields/Relationship/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.relationship {
    position: relative;
  }

  .relationship {
    &__wrap {
      display: flex;
      width: 100%;

      div.react-select {
        width: 100%;
        min-width: 0;
      }
    }

    &__error-loading {
      border: 1px solid var(--theme-error-500);
      min-height: base(2);
      padding: base(0.5) base(0.75);
      background-color: var(--theme-error-500);
      color: var(--theme-elevation-0);
    }

    &--allow-create {
      .rs__control {
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
      }
    }
  }

  html[data-theme='light'] {
    .relationship {
      &.error {
        > .relationship__wrap {
          .rs__control {
            @include lightInputError;
          }
        }

        button.relationship-add-new__add-button {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .relationship {
      &.error {
        > .relationship__wrap {
          .rs__control {
            @include darkInputError;
          }
        }

        button.relationship-add-new__add-button {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Relationship/index.tsx">
import type { PaginatedDocs, RelationshipFieldClientComponent, Where } from '@convexcms/core'
⋮----
import { dequal } from 'dequal/lite'
import { wordBoundariesRegex } from '@convexcms/core/shared'
⋮----
import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react'
⋮----
import type { DocumentDrawerProps } from '../../elements/DocumentDrawer/types.js'
import type { ReactSelectAdapterProps } from '../../elements/ReactSelect/types.js'
import type { GetResults, Option, Value } from './types.js'
⋮----
import { AddNewRelation } from '../../elements/AddNewRelation/index.js'
import { useDocumentDrawer } from '../../elements/DocumentDrawer/index.js'
import { ReactSelect } from '../../elements/ReactSelect/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useDebouncedCallback } from '../../hooks/useDebouncedCallback.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { fieldBaseClass } from '../shared/index.js'
import { createRelationMap } from './createRelationMap.js'
import { findOptionsByValue } from './findOptionsByValue.js'
import { optionsReducer } from './optionsReducer.js'
import { MultiValueLabel } from './select-components/MultiValueLabel/index.js'
import { SingleValue } from './select-components/SingleValue/index.js'
⋮----
// ///////////////////////////////////
// Ensure we have an option for each value
// ///////////////////////////////////
⋮----
// Determine if we should switch to word boundary search
⋮----
// When (`relationTo` || `filterOptions` || `locale`) changes, reset component
// Note - effect should not run on first run
⋮----
// If the menu is open while filterOptions changes
// due to latency of form state and fast clicking into this field,
// re-fetch options
⋮----
// If the menu is not open, still reset the field state
// because we need to get new options next time the menu opens
⋮----
// breaking the labels to search into smaller parts increases performance
⋮----
// strings less than breakApartThreshold length won't be chunked
⋮----
// slicing by the next space after the length of the search input prevents slicing the string up by partial words
⋮----
onMenuOpen=
</file>

<file path="packages/ui/src/fields/Relationship/optionsReducer.ts">
import { getTranslation } from '@convexcms/translations'
⋮----
import type { Action, Option, OptionGroup } from './types.js'
⋮----
import { formatDocTitle } from '../../utilities/formatDocTitle/index.js'
⋮----
const reduceToIDs = (options)
⋮----
const sortOptions = (options: Option[]): Option[]
⋮----
export const optionsReducer = (state: OptionGroup[], action: Action): OptionGroup[] =>
</file>

<file path="packages/ui/src/fields/Relationship/types.ts">
import type { I18nClient } from '@convexcms/translations'
import type { ClientCollectionConfig, ClientConfig, FilterOptionsResult } from '@convexcms/core'
⋮----
export type Option = {
  allowEdit: boolean
  label: string
  options?: Option[]
  relationTo?: string
  value: number | string
}
⋮----
export type OptionGroup = {
  label: string
  options: Option[]
}
⋮----
export type ValueWithRelation = {
  relationTo: string
  value: number | string
}
⋮----
export type Value = number | string | ValueWithRelation
⋮----
type CLEAR = {
  exemptValues?: Value | Value[]
  type: 'CLEAR'
}
⋮----
type UPDATE = {
  collection: ClientCollectionConfig
  config: ClientConfig
  doc: any
  i18n: I18nClient
  type: 'UPDATE'
}
⋮----
type ADD = {
  collection: ClientCollectionConfig
  config: ClientConfig
  docs: any[]
  i18n: I18nClient
  ids?: (number | string)[]
  sort?: boolean
  type: 'ADD'
}
⋮----
type REMOVE = {
  collection: ClientCollectionConfig
  config: ClientConfig
  i18n: I18nClient
  id: string
  type: 'REMOVE'
}
⋮----
export type Action = ADD | CLEAR | REMOVE | UPDATE
⋮----
export type GetResults = (args: {
  filterOptions?: FilterOptionsResult
  lastFullyLoadedRelation?: number
  lastLoadedPage: Record<string, number>
  onSuccess?: () => void
  search?: string
  sort?: boolean
  value?: Value | Value[]
}) => Promise<void>
</file>

<file path="packages/ui/src/fields/RichText/index.tsx">
import type { RichTextFieldClientProps } from '@convexcms/core'
import type React from 'react'
⋮----
export const RichTextField: React.FC<RichTextFieldClientProps> = () =>
</file>

<file path="packages/ui/src/fields/Row/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.row {
    margin-bottom: 0;

    .row__fields {
      display: flex;
      flex-wrap: wrap;
      row-gap: calc(var(--base) * 0.8);

      > * {
        flex: 0 1 var(--field-width);
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
      }

      // add margin if the row has children
      &:has(> *:nth-child(1)) {
        margin-bottom: var(--base);
      }

      // If there is more than one child, add inline-margins to space them out.
      &:has(> *:nth-child(2)) {
        margin-inline: calc(var(--base) / -4); // add negative margin to counteract the gap.

        > * {
          flex: 0 1 calc(var(--field-width) - var(--base) * 0.5);
          margin-inline: calc(var(--base) / 4);
        }
      }
    }

    @include mid-break {
      .row__fields {
        display: block;
        margin-left: 0;
        margin-right: 0;
        width: 100%;

        > * {
          margin-left: 0;
          margin-right: 0;
          width: 100% !important;
          padding-left: 0;
          padding-right: 0;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Row/index.tsx">
import type { RowFieldClientComponent } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { RenderFields } from '../../forms/RenderFields/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
import { RowProvider } from './provider.js'
⋮----
const RowFieldComponent: RowFieldClientComponent = (props) =>
</file>

<file path="packages/ui/src/fields/Row/provider.tsx">
import React, { createContext, use } from 'react'
⋮----
export const RowProvider: React.FC<{ children?: React.ReactNode; withinRow?: boolean }> = ({
  children,
  withinRow = true,
}) =>
⋮----
export const useRow = (): boolean
</file>

<file path="packages/ui/src/fields/Select/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.select {
    position: relative;
  }

  html[data-theme='light'] {
    .field-type.select {
      &.error {
        .rs__control {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.select {
      &.error {
        .rs__control {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Select/index.tsx">
import type {
  Option,
  OptionObject,
  SelectFieldClientComponent,
  SelectFieldClientProps,
} from '@convexcms/core'
⋮----
import React, { useCallback, useMemo } from 'react'
⋮----
import type { ReactSelectAdapterProps } from '../../elements/ReactSelect/types.js'
import type { SelectInputProps } from './Input.js'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { SelectInput } from './Input.js'
⋮----
const formatOptions = (options: Option[]): OptionObject[]
⋮----
const SelectFieldComponent: SelectFieldClientComponent = (props) =>
</file>

<file path="packages/ui/src/fields/Select/Input.tsx">
import type { OptionObject, StaticDescription, StaticLabel } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { ReactSelectAdapterProps } from '../../elements/ReactSelect/types.js'
⋮----
import { ReactSelect } from '../../elements/ReactSelect/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
export type SelectInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly BeforeInput?: React.ReactNode
  readonly className?: string
  readonly Description?: React.ReactNode
  readonly description?: StaticDescription
  readonly Error?: React.ReactNode
  readonly hasMany?: boolean
  readonly isClearable?: boolean
  readonly isSortable?: boolean
  readonly Label?: React.ReactNode
  readonly label?: StaticLabel
  readonly localized?: boolean
  readonly name: string
  readonly onChange?: ReactSelectAdapterProps['onChange']
  readonly onInputChange?: ReactSelectAdapterProps['onInputChange']
  readonly options?: OptionObject[]
  readonly path: string
  readonly readOnly?: boolean
  readonly required?: boolean
  readonly showError?: boolean
  readonly style?: React.CSSProperties
  readonly value?: string | string[]
}
⋮----
export const SelectInput: React.FC<SelectInputProps> = (props) =>
⋮----
// If value is not present then render nothing, allowing select fields to reset to their initial 'Select an option' state
</file>

<file path="packages/ui/src/fields/shared/index.tsx">
import type { Locale, SanitizedLocalizationConfig } from '@convexcms/core'
⋮----
/**
 * Determines whether a field should be displayed as right-to-left (RTL) based on its configuration, payload's localization configuration and the adming user's currently enabled locale.

 * @returns Whether the field should be displayed as RTL.
 */
export function isFieldRTL({
  fieldLocalized,
  fieldRTL,
  locale,
  localizationConfig,
}: {
  fieldLocalized: boolean
  fieldRTL: boolean
  locale: Locale
  localizationConfig?: SanitizedLocalizationConfig
})
⋮----
(!fieldLocalized && !hasMultipleLocales) || // If there is only one locale which is also rtl, that field is rtl too
(!fieldLocalized && isCurrentLocaleDefaultLocale))) || // If the current locale is the default locale, but the field is not localized, that field is rtl too
⋮----
) // If fieldRTL is true. This should be useful for when no localization is set at all in the payload config, but you still want fields to be rtl.
</file>

<file path="packages/ui/src/fields/Tabs/Tab/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .tabs-field__tab-button {
    @extend %btn-reset;
    @extend %h4;
    display: flex;
    padding-bottom: base(1);
    margin: 0;
    margin-inline-end: $baseline;
    cursor: pointer;
    opacity: 0.5;
    position: relative;
    white-space: nowrap;
    flex-shrink: 0;
    gap: base(0.5);

    &:last-child {
      margin: 0;
    }

    &:after {
      content: ' ';
      position: absolute;
      right: 0;
      bottom: -1px;
      left: 0;
      height: 1px;
      background: var(--theme-elevation-800);
      opacity: 0;
    }

    &:hover {
      opacity: 0.75;

      &:after {
        opacity: 0.2;
      }
    }

    &--hidden {
      display: none;
    }

    &--active {
      opacity: 1 !important;

      &:after {
        opacity: 1 !important;
        height: 2px;
      }
    }

    &__description {
      margin-bottom: calc(var(--base) / 2);
    }

    @include small-break {
      margin: 0 base(0.75) 0 0;
      padding-bottom: base(0.5);

      &:last-child {
        margin: 0;
      }
    }
  }

  html[data-theme='light'] {
    .tabs-field__tab-button--has-error {
      color: var(--theme-error-750);
      &:after {
        background: var(--theme-error-500);
      }
    }
  }

  html[data-theme='dark'] {
    .tabs-field__tab-button--has-error {
      color: var(--theme-error-500);
      &:after {
        background: var(--theme-error-500);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Tabs/Tab/index.tsx">
import type { ClientTab } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { tabHasName } from '@convexcms/core/shared'
import React, { useState } from 'react'
⋮----
import { ErrorPill } from '../../../elements/ErrorPill/index.js'
import { WatchChildErrors } from '../../../forms/WatchChildErrors/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
type TabProps = {
  readonly hidden?: boolean
  readonly isActive?: boolean
  readonly parentPath: string
  readonly setIsActive: () => void
  readonly tab: ClientTab
}
⋮----
export const TabComponent: React.FC<TabProps> = ({
  hidden,
  isActive,
  parentPath,
  setIsActive,
  tab,
}) =>
⋮----
// removes parent 'tabs' path segment, i.e. `_index-0`
</file>

<file path="packages/ui/src/fields/Tabs/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .tabs-field {
    margin-top: base(2);
    margin-left: calc(var(--gutter-h) * -1);
    margin-right: calc(var(--gutter-h) * -1);

    &--hidden {
      display: none;
    }

    &__content-wrap {
      padding-left: var(--gutter-h);
      padding-right: var(--gutter-h);
    }

    &--within-collapsible {
      margin: 0 calc(#{$baseline} * -1);

      .tabs-field__content-wrap {
        padding-left: $baseline;
        padding-right: $baseline;
      }

      .tabs-field__tabs {
        &:before,
        &:after {
          content: ' ';
          display: block;
          width: $baseline;
        }
      }
    }

    &__tabs-wrap {
      overflow-x: auto;
      overflow-y: hidden;
      margin-bottom: $baseline;
    }

    &__tabs {
      border-bottom: 1px solid var(--theme-elevation-100);
      display: inline-flex;
      min-width: 100%;
      vertical-align: bottom;

      &:before,
      &:after {
        content: ' ';
        display: block;
        width: var(--gutter-h);
        flex-shrink: 0;
      }
    }

    &__tab--hidden {
      display: none;
    }

    &__description {
      margin-bottom: calc(var(--base) / 2);
    }

    @include small-break {
      &--within-collapsible {
        margin-left: calc(var(--gutter-h) * -1);
        margin-right: calc(var(--gutter-h) * -1);
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Tabs/index.tsx">
import type {
  ClientField,
  ClientTab,
  DocumentPreferences,
  SanitizedFieldPermissions,
  StaticDescription,
  TabsFieldClientComponent,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { tabHasName, toKebabCase } from '@convexcms/core/shared'
import React, { useCallback, useEffect, useState } from 'react'
⋮----
import { useCollapsible } from '../../elements/Collapsible/provider.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { useFormFields } from '../../forms/Form/index.js'
import { RenderFields } from '../../forms/RenderFields/index.js'
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { usePreferences } from '../../providers/Preferences/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { FieldDescription } from '../FieldDescription/index.js'
import { fieldBaseClass } from '../shared/index.js'
import { TabsProvider } from './provider.js'
import { TabComponent } from './Tab/index.js'
⋮----
function generateTabPath(
⋮----
const TabsFieldComponent: TabsFieldClientComponent = (props) =>
⋮----
const getInitialPref = async () =>
⋮----
tabHasName(activeTabConfig)
⋮----
type ActiveTabProps = {
  readonly description: StaticDescription
  readonly fields: ClientField[]
  readonly forceRender?: boolean
  readonly hidden: boolean
  readonly label?: string
  readonly parentIndexPath: string
  readonly parentPath: string
  readonly parentSchemaPath: string
  readonly path: string
  readonly permissions: SanitizedFieldPermissions
  readonly readOnly: boolean
}
⋮----
function TabContent({
  description,
  fields,
  forceRender,
  hidden,
  label,
  parentIndexPath,
  parentPath,
  parentSchemaPath,
  path,
  permissions,
  readOnly,
}: ActiveTabProps)
</file>

<file path="packages/ui/src/fields/Tabs/provider.tsx">
import React, { createContext, use } from 'react'
⋮----
export const TabsProvider: React.FC<{ children?: React.ReactNode; withinTab?: boolean }> = ({
  children,
  withinTab = true,
}) =>
⋮----
export const useTabs = (): boolean
</file>

<file path="packages/ui/src/fields/Text/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.text {
    position: relative;

    &:not(.has-many) {
      input {
        @include formInput;
      }
    }
  }

  .has-many {
    .rs__input-container {
      overflow: hidden;
    }
  }

  html[data-theme='light'] {
    .field-type.text {
      &.error {
        input {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.text {
      &.error {
        input {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Text/index.tsx">
import type { TextFieldClientComponent } from '@convexcms/core'
⋮----
import React, { useCallback, useEffect, useMemo, useState } from 'react'
⋮----
import type { Option } from '../../elements/ReactSelect/types.js'
import type { TextInputProps } from './types.js'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { isFieldRTL } from '../shared/index.js'
import { TextInput } from './Input.js'
⋮----
const TextFieldComponent: TextFieldClientComponent = (props) =>
⋮----
>([]) // Only for hasMany
⋮----
// useEffect update valueToRender:
⋮----
id: `${val}${index}`, // append index to avoid duplicate keys but allow duplicate numbers
⋮----
// React-select automatically uses "label-value" as a key, so we will get that react duplicate key warning if we just pass in the value as multiple values can be the same. So we need to append the index to the toString() of the value to avoid that warning, as it uses that as the key.
</file>

<file path="packages/ui/src/fields/Text/Input.tsx">
import type { ChangeEvent } from 'react'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { ReactSelectAdapterProps } from '../../elements/ReactSelect/types.js'
import type { TextInputProps } from './types.js'
⋮----
import { ReactSelect } from '../../elements/ReactSelect/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
const editableProps: ReactSelectAdapterProps['customProps']['editableProps'] = (
    data,
    className,
    selectProps,
) =>
⋮----
// prevent adding additional options if maxRows is reached
⋮----
placeholder=
</file>

<file path="packages/ui/src/fields/Text/types.ts">
import type { StaticDescription, StaticLabel } from '@convexcms/core'
import type { ChangeEvent } from 'react'
import type React from 'react'
⋮----
import type { Option, ReactSelectAdapterProps } from '../../elements/ReactSelect/types.js'
⋮----
export type SharedTextFieldProps =
  | {
      readonly hasMany?: false
      readonly onChange?: (e: ChangeEvent<HTMLInputElement>) => void
    }
  | {
      readonly hasMany?: true
      readonly onChange?: ReactSelectAdapterProps['onChange']
    }
⋮----
export type TextInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly BeforeInput?: React.ReactNode
  readonly className?: string
  readonly Description?: React.ReactNode
  readonly description?: StaticDescription
  readonly Error?: React.ReactNode
  readonly inputRef?: React.RefObject<HTMLInputElement>
  readonly Label?: React.ReactNode
  readonly label?: StaticLabel
  readonly localized?: boolean
  readonly maxRows?: number
  readonly minRows?: number
  readonly onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>
  readonly path: string
  readonly placeholder?: Record<string, string> | string
  readonly readOnly?: boolean
  readonly required?: boolean
  readonly rtl?: boolean
  readonly showError?: boolean
  readonly style?: React.CSSProperties
  readonly value?: string
  readonly valueToRender?: Option[]
} & SharedTextFieldProps
</file>

<file path="packages/ui/src/fields/Textarea/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .field-type.textarea {
    position: relative;
    display: flex;
    flex-direction: column;

    textarea {
      @include formInput();
      field-sizing: content;
      overflow-y: auto;
      resize: vertical;
      min-height: base(3);
      height: 100%;
      display: flex;
    }

    &.read-only {
      .textarea-outer {
        @include readOnly;
      }
    }

  }

  html[data-theme='light'] {
    .field-type.textarea {
      &.error {
        textarea {
          @include lightInputError;
        }
      }
    }
  }

  html[data-theme='dark'] {
    .field-type.textarea {
      &.error {
        textarea {
          @include darkInputError;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Textarea/index.tsx">
import type { TextareaFieldClientComponent, TextareaFieldValidation } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React, { useCallback, useMemo } from 'react'
⋮----
import type { TextAreaInputProps } from './types.js'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { mergeFieldStyles } from '../mergeFieldStyles.js'
⋮----
import { isFieldRTL } from '../shared/index.js'
import { TextareaInput } from './Input.js'
</file>

<file path="packages/ui/src/fields/Textarea/Input.tsx">
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import type { TextAreaInputProps } from './types.js'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { fieldBaseClass } from '../shared/index.js'
⋮----
placeholder=
</file>

<file path="packages/ui/src/fields/Textarea/types.ts">
import type { StaticDescription, StaticLabel } from '@convexcms/core'
import type React from 'react'
⋮----
import { type ChangeEvent } from 'react'
⋮----
export type TextAreaInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly BeforeInput?: React.ReactNode
  readonly className?: string
  readonly Description?: React.ReactNode
  readonly description?: StaticDescription
  readonly Error?: React.ReactNode
  readonly inputRef?: React.RefObject<HTMLInputElement>
  readonly Label?: React.ReactNode
  readonly label?: StaticLabel
  readonly localized?: boolean
  readonly onChange?: (e: ChangeEvent<HTMLTextAreaElement>) => void
  readonly onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>
  readonly path: string
  readonly placeholder?: string
  readonly readOnly?: boolean
  readonly required?: boolean
  readonly rows?: number
  readonly rtl?: boolean
  readonly showError?: boolean
  readonly style?: React.CSSProperties
  readonly value?: string
  readonly valueToRender?: string
}
</file>

<file path="packages/ui/src/fields/UI/index.tsx">
import type React from 'react'
⋮----
export const UIField: React.FC = () =>
</file>

<file path="packages/ui/src/fields/Upload/HasMany/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .upload--has-many {
    position: relative;
    max-width: 100%;

    &__drag {
      &[aria-disabled='true'] {
        &:hover {
          cursor: default;
        }
      }
    }

    &__draggable-rows {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 4);
    }

    &__dragItem {
      .icon--drag-handle {
        color: var(--theme-elevation-400);
      }

      .thumbnail {
        width: 26px;
        height: 26px;
      }

      .uploadDocRelationshipContent__details {
        line-height: 1.2;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Upload/HasMany/index.tsx">
import type { JsonObject } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { DraggableSortableItem } from '../../../elements/DraggableSortable/DraggableSortableItem/index.js'
import { DraggableSortable } from '../../../elements/DraggableSortable/index.js'
import { DragHandleIcon } from '../../../icons/DragHandle/index.js'
import { RelationshipContent } from '../RelationshipContent/index.js'
import { UploadCard } from '../UploadCard/index.js'
⋮----
import { isImage } from '@convexcms/core/shared'
⋮----
import type { ReloadDoc } from '../types.js'
⋮----
import { getBestFitFromSizes } from '../../../utilities/getBestFitFromSizes.js'
⋮----
type Props = {
  readonly className?: string
  readonly displayPreview?: boolean
  readonly fileDocs: {
    relationTo: string
    value: JsonObject
  }[]
  readonly isSortable?: boolean
  readonly onRemove?: (value) => void
  readonly onReorder?: (value) => void
  readonly readonly?: boolean
  readonly reloadDoc: ReloadDoc
  readonly serverURL: string
}
</file>

<file path="packages/ui/src/fields/Upload/HasOne/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .upload {
    position: relative;
    max-width: 100%;
  }
}
</file>

<file path="packages/ui/src/fields/Upload/HasOne/index.tsx">
import type { JsonObject } from '@convexcms/core'
⋮----
import { isImage } from '@convexcms/core/shared'
import React from 'react'
⋮----
import type { ReloadDoc } from '../types.js'
⋮----
import { getBestFitFromSizes } from '../../../utilities/getBestFitFromSizes.js'
⋮----
import { RelationshipContent } from '../RelationshipContent/index.js'
import { UploadCard } from '../UploadCard/index.js'
⋮----
type Props = {
  readonly className?: string
  readonly displayPreview?: boolean
  readonly fileDoc: {
    relationTo: string
    value: JsonObject
  }
  readonly onRemove?: () => void
  readonly readonly?: boolean
  readonly reloadDoc: ReloadDoc
  readonly serverURL: string
}
⋮----
export function UploadComponentHasOne(props: Props)
</file>

<file path="packages/ui/src/fields/Upload/RelationshipContent/index.scss">
@layer payload-default {
  .upload-relationship-details {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    min-width: 0;

    &__imageAndDetails {
      display: flex;
      gap: calc(var(--base) / 2);
      align-items: center;
      min-width: 0;
    }

    &__thumbnail {
      align-self: center;
      border-radius: var(--style-radius-s);
    }

    &__details {
      display: flex;
      flex-direction: column;
      gap: 0;
      overflow: hidden;
      margin-right: calc(var(--base) * 2);
    }

    &__filename {
      margin: 0;
      text-wrap: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      a {
        text-decoration: none;
      }
    }

    &__meta {
      margin: 0;
      color: var(--theme-elevation-500);
      text-wrap: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    &__actions {
      flex-shrink: 0;
      display: flex;
    }

    .btn {
      margin: 0;
    }
  }
}
</file>

<file path="packages/ui/src/fields/Upload/RelationshipContent/index.tsx">
import type { TypeWithID } from '@convexcms/core'
⋮----
import { formatFilesize, isImage } from '@convexcms/core/shared'
import React from 'react'
⋮----
import type { ReloadDoc } from '../types.js'
⋮----
import { Button } from '../../../elements/Button/index.js'
import { useDocumentDrawer } from '../../../elements/DocumentDrawer/index.js'
import { ThumbnailComponent } from '../../../elements/Thumbnail/index.js'
import { useConfig } from '../../../providers/Config/index.js'
⋮----
type Props = {
  readonly allowEdit?: boolean
  readonly allowRemove?: boolean
  readonly alt: string
  readonly byteSize: number
  readonly className?: string
  readonly collectionSlug: string
  readonly displayPreview?: boolean
  readonly filename: string
  readonly id?: number | string
  readonly mimeType: string
  readonly onRemove: () => void
  readonly reloadDoc: ReloadDoc
  readonly src: string
  readonly thumbnailSrc: string
  readonly withMeta?: boolean
  readonly x?: number
  readonly y?: number
}
⋮----
function generateMetaText(mimeType: string, size: number): string
⋮----
onClick=
</file>

<file path="packages/ui/src/fields/Upload/UploadCard/index.scss">
@layer payload-default {
  .upload-field-card {
    background: var(--theme-elevation-50);
    border: 1px solid var(--theme-border-color);
    border-radius: var(--style-radius-s);
    display: flex;
    align-items: center;
    width: 100%;
    gap: calc(var(--base) / 2);

    &--size-medium {
      padding: calc(var(--base) * 0.5);

      .thumbnail {
        width: 40px;
        height: 40px;
      }
    }

    &--size-small {
      padding: calc(var(--base) / 3) calc(var(--base) / 2);
      .thumbnail {
        width: 25px;
        height: 25px;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Upload/UploadCard/index.tsx">
import React from 'react'
⋮----
type Props = {
  readonly children: React.ReactNode
  readonly className?: string
  readonly size?: 'medium' | 'small'
}
export function UploadCard(
</file>

<file path="packages/ui/src/fields/Upload/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .upload {
    &__dropzoneAndUpload {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 4);
    }

    &__dropzoneContent {
      display: flex;
      flex-wrap: wrap;
      gap: base(0.4);
      justify-content: space-between;
      width: 100%;
    }

    &__dropzoneContent__buttons {
      display: flex;
      gap: calc(var(--base) / 2);
      position: relative;
      left: -2px;

      .btn .btn__content {
        gap: calc(var(--base) / 5);
      }

      .btn__label {
        font-weight: 100;
      }
    }

    &__dropzoneContent__orText {
      color: var(--theme-elevation-500);
      text-transform: lowercase;
    }

    &__dragAndDropText {
      flex-shrink: 0;
      margin: 0;
      text-transform: lowercase;
      align-self: center;
      color: var(--theme-elevation-500);
    }

    &__loadingRows {
      display: flex;
      flex-direction: column;
      gap: calc(var(--base) / 4);
    }

    .shimmer-effect {
      border-radius: var(--style-radius-s);
      border: 1px solid var(--theme-border-color);
    }

    @include small-break {
      &__dragAndDropText {
        display: none;
      }
    }
  }
}
</file>

<file path="packages/ui/src/fields/Upload/index.tsx">
import type { UploadFieldClientProps } from '@convexcms/core'
⋮----
import React, { useMemo } from 'react'
⋮----
import { useField } from '../../forms/useField/index.js'
import { withCondition } from '../../forms/withCondition/index.js'
import { useConfig } from '../../providers/Config/index.js'
⋮----
import { mergeFieldStyles } from '../mergeFieldStyles.js'
import { UploadInput } from './Input.js'
⋮----
export function UploadComponent(props: UploadFieldClientProps)
</file>

<file path="packages/ui/src/fields/Upload/Input.tsx">
import type {
  ClientCollectionConfig,
  FieldLabelClientProps,
  FilterOptionsResult,
  JsonObject,
  StaticDescription,
  StaticLabel,
  UploadFieldClient,
  UploadField as UploadFieldType,
  Where,
} from '@convexcms/core'
import type { MarkOptional } from 'ts-essentials'
⋮----
import { useModal } from '@faceless-ui/modal'
⋮----
import React, { useCallback, useEffect, useMemo } from 'react'
⋮----
import type { ListDrawerProps } from '../../elements/ListDrawer/types.js'
import type { PopulateDocs, ReloadDoc } from './types.js'
⋮----
import { useBulkUpload } from '../../elements/BulkUpload/index.js'
import { Button } from '../../elements/Button/index.js'
import { useDocumentDrawer } from '../../elements/DocumentDrawer/index.js'
import { Dropzone } from '../../elements/Dropzone/index.js'
import { useListDrawer } from '../../elements/ListDrawer/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { ShimmerEffect } from '../../elements/ShimmerEffect/index.js'
import { FieldDescription } from '../../fields/FieldDescription/index.js'
import { FieldError } from '../../fields/FieldError/index.js'
import { FieldLabel } from '../../fields/FieldLabel/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { fieldBaseClass } from '../shared/index.js'
import { UploadComponentHasMany } from './HasMany/index.js'
import { UploadComponentHasOne } from './HasOne/index.js'
⋮----
type PopulatedDocs = { relationTo: string; value: JsonObject }[]
⋮----
export type UploadInputProps = {
  readonly AfterInput?: React.ReactNode
  readonly allowCreate?: boolean
  /**
   * Controls the visibility of the "Create new collection" button
   */
  readonly api?: string
  readonly BeforeInput?: React.ReactNode
  readonly className?: string
  readonly collection?: ClientCollectionConfig
  readonly customUploadActions?: React.ReactNode[]
  readonly Description?: React.ReactNode
  readonly description?: StaticDescription
  readonly displayPreview?: boolean
  readonly Error?: React.ReactNode
  readonly filterOptions?: FilterOptionsResult
  readonly hasMany?: boolean
  readonly hideRemoveFile?: boolean
  readonly isSortable?: boolean
  readonly Label?: React.ReactNode
  readonly label?: StaticLabel
  readonly labelProps?: FieldLabelClientProps<MarkOptional<UploadFieldClient, 'type'>>
  readonly localized?: boolean
  readonly maxRows?: number
  readonly onChange?: (e) => void
  readonly path: string
  readonly readOnly?: boolean
  readonly relationTo: UploadFieldType['relationTo']
  readonly required?: boolean
  readonly serverURL?: string
  readonly showError?: boolean
  readonly style?: React.CSSProperties
  readonly value?: (number | string)[] | (number | string)
}
⋮----
/**
   * Controls the visibility of the "Create new collection" button
   */
⋮----
/**
   * Prevent initial retrieval of documents from running more than once
   */
⋮----
// only hasMany can bulk select
⋮----
// only hasMany can reorder
⋮----
async function loadInitialDocs()
⋮----
</file>

<file path="packages/ui/src/fields/Upload/types.ts">
import type { PaginatedDocs } from '@convexcms/core'
⋮----
export type PopulateDocs = (
  ids: (number | string)[],
  relatedCollectionSlug: string,
) => Promise<null | PaginatedDocs>
⋮----
export type ReloadDoc = (docID: number | string, collectionSlug: string) => Promise<void>
</file>

<file path="packages/ui/src/fields/index.tsx">
import type {
  ClientFieldBase,
  FieldTypes,
  GenericDescriptionProps,
  GenericErrorProps,
  GenericLabelProps,
  HiddenFieldProps,
} from '@convexcms/core'
import type React from 'react'
⋮----
import type { ConfirmPasswordFieldProps } from './ConfirmPassword/index.js'
⋮----
import { RowLabel } from '../forms/RowLabel/index.js'
import { ArrayField } from './Array/index.js'
import { BlocksField } from './Blocks/index.js'
import { CheckboxField } from './Checkbox/index.js'
import { CodeField } from './Code/index.js'
import { CollapsibleField } from './Collapsible/index.js'
import { ConfirmPasswordField } from './ConfirmPassword/index.js'
import { DateTimeField } from './DateTime/index.js'
import { EmailField } from './Email/index.js'
import { FieldDescription } from './FieldDescription/index.js'
import { FieldError } from './FieldError/index.js'
import { FieldLabel } from './FieldLabel/index.js'
import { GroupField } from './Group/index.js'
import { HiddenField } from './Hidden/index.js'
import { JoinField } from './Join/index.js'
import { JSONField } from './JSON/index.js'
import { NumberField } from './Number/index.js'
import { PasswordField } from './Password/index.js'
import { PointField } from './Point/index.js'
import { RadioGroupField } from './RadioGroup/index.js'
import { RelationshipField } from './Relationship/index.js'
import { RichTextField } from './RichText/index.js'
import { RowField } from './Row/index.js'
import { SelectField } from './Select/index.js'
import { TabsField } from './Tabs/index.js'
import { TextField } from './Text/index.js'
import { TextareaField } from './Textarea/index.js'
import { UIField } from './UI/index.js'
import { UploadField } from './Upload/index.js'
⋮----
export type FieldTypesComponents = {
  [K in 'password' | FieldTypes]: React.FC<ClientFieldBase>
} & {
  confirmPassword: React.FC<ConfirmPasswordFieldProps>
  hidden: React.FC<HiddenFieldProps>
}
⋮----
export type FieldComponentsWithSlots = {
  Description: React.FC<GenericDescriptionProps>
  Error: React.FC<GenericErrorProps>
  Label: React.FC<GenericLabelProps>
  RowLabel: React.FC
} & FieldTypesComponents
</file>

<file path="packages/ui/src/fields/mergeFieldStyles.ts">
import type { ClientField } from '@convexcms/core'
⋮----
export const mergeFieldStyles = (
  field: ClientField | Omit<ClientField, 'type'>,
): React.CSSProperties => (
⋮----
// allow flex overrides to still take precedence over the fallback
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/index.ts">
import type {
  Data,
  Field as FieldSchema,
  PayloadRequest,
  SelectMode,
  SelectType,
  User,
} from '@convexcms/core'
⋮----
import { iterateFields } from './iterateFields.js'
⋮----
type Args = {
  data: Data
  fields: FieldSchema[]
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}
⋮----
export const calculateDefaultValues = async ({
  id,
  data,
  fields,
  locale,
  req,
  select,
  selectMode,
  user,
}: Args): Promise<Data> =>
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/iterateFields.ts">
import type { Data, Field, PayloadRequest, SelectMode, SelectType, TabAsField, User } from '@convexcms/core'
⋮----
import { defaultValuePromise } from './promise.js'
⋮----
type Args<T> = {
  data: T
  fields: (Field | TabAsField)[]
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}
⋮----
export const iterateFields = async <T>({
  id,
  data,
  fields,
  locale,
  req,
  select,
  selectMode,
  siblingData,
  user,
}: Args<T>): Promise<void> =>
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/calculateDefaultValues/promise.ts">
import type {
  Data,
  Field,
  FlattenedBlock,
  PayloadRequest,
  SelectMode,
  SelectType,
  TabAsField,
  User,
} from '@convexcms/core'
⋮----
import { getBlockSelect, getDefaultValue, stripUnselectedFields } from '@convexcms/core'
import { fieldAffectsData, tabHasName } from '@convexcms/core/shared'
⋮----
import { iterateFields } from './iterateFields.js'
⋮----
type Args<T> = {
  data: T
  field: Field | TabAsField
  id?: number | string
  locale: string | undefined
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  siblingData: Data
  user: User
}
⋮----
// TODO: Make this works for rich text subfields
export const defaultValuePromise = async <T>({
  id,
  data,
  field,
  locale,
  req,
  select,
  selectMode,
  siblingData,
  user,
}: Args<T>): Promise<void> =>
⋮----
// Traverse subfields
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/addFieldStatePromise.ts">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FieldState,
  FlattenedBlock,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  Row,
  SanitizedFieldPermissions,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
  Validate,
} from '@convexcms/core'
⋮----
import ObjectIdImport from 'bson-objectid'
import { getBlockSelect } from '@convexcms/core'
import {
  deepCopyObjectSimple,
  fieldAffectsData,
  fieldHasSubFields,
  fieldIsHiddenOrDisabled,
  fieldIsID,
  fieldIsLocalized,
  getFieldPaths,
  tabHasName,
} from '@convexcms/core/shared'
⋮----
import type { RenderFieldMethod } from './types.js'
⋮----
import { resolveFilterOptions } from '../../utilities/resolveFilterOptions.js'
import { iterateFields } from './iterateFields.js'
⋮----
export type AddFieldStatePromiseArgs = {
  addErrorPathToParent: (fieldPath: string) => void
  /**
   * if all parents are localized, then the field is localized
   */
  anyParentLocalized?: boolean
  /**
   * Data of the nearest parent block, or undefined
   */
  blockData: Data | undefined
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data: Data
  field: Field
  fieldIndex: number
  fieldSchemaMap: FieldSchemaMap
  /**
   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.
   */
  filter?: (args: AddFieldStatePromiseArgs) => boolean
  /**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
  forceFullValue?: boolean
  fullData: Data
  id: number | string
  /**
   * Whether the field schema should be included in the state
   */
  includeSchema?: boolean
  indexPath: string
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  /**
   * Whether to omit parent fields in the state. @default false
   */
  omitParents?: boolean
  operation: 'create' | 'update'
  parentIndexPath: string
  parentPath: string
  parentPermissions: SanitizedFieldsPermissions
  parentSchemaPath: string
  passesCondition: boolean
  path: string
  preferences: DocumentPreferences
  previousFormState: FormState
  renderAllFields: boolean
  renderFieldFn: RenderFieldMethod
  /**
   * Req is used for validation and defaultValue calculation. If you don't need validation,
   * just create your own req and pass in the locale and the user
   */
  req: PayloadRequest
  schemaPath: string
  select?: SelectType
  selectMode?: SelectMode
  /**
   * Whether to skip checking the field's condition. @default false
   */
  skipConditionChecks?: boolean
  /**
   * Whether to skip validating the field. @default false
   */
  skipValidation?: boolean
  state: FormStateWithoutComponents
}
⋮----
/**
   * if all parents are localized, then the field is localized
   */
⋮----
/**
   * Data of the nearest parent block, or undefined
   */
⋮----
/**
   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.
   */
⋮----
/**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
⋮----
/**
   * Whether the field schema should be included in the state
   */
⋮----
/**
   * Whether to omit parent fields in the state. @default false
   */
⋮----
/**
   * Req is used for validation and defaultValue calculation. If you don't need validation,
   * just create your own req and pass in the locale and the user
   */
⋮----
/**
   * Whether to skip checking the field's condition. @default false
   */
⋮----
/**
   * Whether to skip validating the field. @default false
   */
⋮----
/**
 * Flattens the fields schema and fields data.
 * The output is the field path (e.g. array.0.name) mapped to a FormField object.
 */
export const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> =>
⋮----
// Append only if true to avoid sending '$undefined' through the network
⋮----
// If we're rendering all fields, no need to flag this as added by server
⋮----
// Append only if true to avoid sending '$undefined' through the network
⋮----
// Append only if true to avoid sending '$undefined' through the network
⋮----
// Append only if true to avoid sending '$undefined' through the network
⋮----
// @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d
// @ts-expect-error-next-line
⋮----
const addErrorPathToParent = (errorPath: string) =>
⋮----
// First, check if `previousFormState` has a matching row
⋮----
// If previousFormState is undefined, check preferences
⋮----
return collapsedRowIDsFromPrefs.includes(row.id) // Check if collapsed in preferences
⋮----
// If neither exists, fallback to `field.admin.initCollapsed`
⋮----
// Wait for all promises and update fields with the results
⋮----
// Add values to field state
⋮----
// Add field to state
⋮----
// Handle block `id` field
⋮----
// Handle `blockType` field
⋮----
// Handle `blockName` field
⋮----
// First, check if `previousFormState` has a matching row
⋮----
// Add values to field state
⋮----
// Add field to state
⋮----
// Add field to state
⋮----
// Handle field types that do not use names (row, collapsible, etc)
⋮----
// passthrough parent functionality
⋮----
permissions: parentPermissions, // TODO: Verify this is correct
⋮----
// If passesCondition is false then this should always result to false
// If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result
⋮----
// Some fields (ie `Tab`) do not live in form state
// therefore we cannot attach customComponents to them
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/fieldSchemasToFormState.spec.js">
describe('Form - fieldSchemasToFormState', () => {
⋮----
it('populates default value - normal fields', async () => {
⋮----
const state = await fieldSchemasToFormState({ fields: fieldSchema })
expect(state.text.value).toBe(defaultValue)
⋮----
it('field value overrides defaultValue - normal fields', async () => {
⋮----
const state = await fieldSchemasToFormState({ data, fields: fieldSchema })
expect(state.text.value).toBe(value)
⋮----
it('populates default value from a function - normal fields', async () => {
⋮----
defaultValue: (args) => {
⋮----
const state = await fieldSchemasToFormState({ fields: fieldSchema, locale, user })
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/index.tsx">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FieldState,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
} from '@convexcms/core'
⋮----
import type { RenderFieldMethod } from './types.js'
⋮----
import { calculateDefaultValues } from './calculateDefaultValues/index.js'
import { iterateFields } from './iterateFields.js'
⋮----
type Args = {
  /**
   * The client field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the client field schema map is not required.
   */
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data?: Data
  /**
   * If this is undefined, the `data` passed to this function will serve as `fullData` and `data` when iterating over
   * the top-level-fields to generate form state.
   * For sub fields, the `data` will be narrowed down to the sub fields, while `fullData` remains the same.
   *
   * Usually, the `data` passed to this function will be the document data. This means that running validation, read access control
   * or executing filterOptions here will have access to the full document through the passed `fullData` parameter, and that `fullData` and `data` will be identical.
   *
   * In some cases however, this function is used to generate form state solely for sub fields - independent from the parent form state.
   * This means that `data` will be the form state of the sub fields - the document data won't be available here.
   *
   * In these cases, you can pass `documentData` which will be used as `fullData` instead of `data`.
   *
   * This is useful for lexical blocks, as lexical block fields there are not part of the parent form state, yet we still want
   * document data to be available for validation and filterOptions, under the `data` key.
   */
  documentData?: Data
  fields: Field[] | undefined
  /**
   * The field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the field schema map is not required.
   */
  fieldSchemaMap: FieldSchemaMap | undefined
  id?: number | string
  /**
   * Validation, filterOptions and read access control will receive the `blockData`, which is the data of the nearest parent block. You can pass in
   * the initial block data here, which will be used as `blockData` for the top-level fields, until the first block is encountered.
   */
  initialBlockData?: Data
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  operation?: 'create' | 'update'
  permissions: SanitizedFieldsPermissions
  preferences: DocumentPreferences
  /**
   * Optionally accept the previous form state,
   * to be able to determine if custom fields need to be re-rendered.
   */
  previousFormState?: FormState
  /**
   * If renderAllFields is true, then no matter what is in previous form state,
   * all custom fields will be re-rendered.
   */
  renderAllFields: boolean
  renderFieldFn?: RenderFieldMethod
  req: PayloadRequest
  schemaPath: string
  select?: SelectType
  selectMode?: SelectMode
  skipValidation?: boolean
}
⋮----
/**
   * The client field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the client field schema map is not required.
   */
⋮----
/**
   * If this is undefined, the `data` passed to this function will serve as `fullData` and `data` when iterating over
   * the top-level-fields to generate form state.
   * For sub fields, the `data` will be narrowed down to the sub fields, while `fullData` remains the same.
   *
   * Usually, the `data` passed to this function will be the document data. This means that running validation, read access control
   * or executing filterOptions here will have access to the full document through the passed `fullData` parameter, and that `fullData` and `data` will be identical.
   *
   * In some cases however, this function is used to generate form state solely for sub fields - independent from the parent form state.
   * This means that `data` will be the form state of the sub fields - the document data won't be available here.
   *
   * In these cases, you can pass `documentData` which will be used as `fullData` instead of `data`.
   *
   * This is useful for lexical blocks, as lexical block fields there are not part of the parent form state, yet we still want
   * document data to be available for validation and filterOptions, under the `data` key.
   */
⋮----
/**
   * The field schema map is required for field rendering.
   * If fields should not be rendered (=> `renderFieldFn` is not provided),
   * then the field schema map is not required.
   */
⋮----
/**
   * Validation, filterOptions and read access control will receive the `blockData`, which is the data of the nearest parent block. You can pass in
   * the initial block data here, which will be used as `blockData` for the top-level fields, until the first block is encountered.
   */
⋮----
/**
   * Optionally accept the previous form state,
   * to be able to determine if custom fields need to be re-rendered.
   */
⋮----
/**
   * If renderAllFields is true, then no matter what is in previous form state,
   * all custom fields will be re-rendered.
   */
⋮----
export const fieldSchemasToFormState = async ({
  id,
  clientFieldSchemaMap,
  collectionSlug,
  data = {},
  documentData,
  fields,
  fieldSchemaMap,
  initialBlockData,
  mockRSCs,
  operation,
  permissions,
  preferences,
  previousFormState,
  renderAllFields,
  renderFieldFn,
  req,
  schemaPath,
  select,
  selectMode,
  skipValidation,
}: Args): Promise<FormState> =>
⋮----
// By the time this function is used to get form state for nested forms, their default values should have already been calculated
// => no need to run calculateDefaultValues here
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/iterateFields.ts">
import type {
  BuildFormStateArgs,
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field as FieldSchema,
  FieldSchemaMap,
  FieldState,
  FormState,
  FormStateWithoutComponents,
  PayloadRequest,
  SanitizedFieldsPermissions,
  SelectMode,
  SelectType,
} from '@convexcms/core'
⋮----
import { stripUnselectedFields } from '@convexcms/core'
import { getFieldPaths } from '@convexcms/core/shared'
⋮----
import type { AddFieldStatePromiseArgs } from './addFieldStatePromise.js'
import type { RenderFieldMethod } from './types.js'
⋮----
import { addFieldStatePromise } from './addFieldStatePromise.js'
⋮----
type Args = {
  addErrorPathToParent: (fieldPath: string) => void
  /**
   * if any parents is localized, then the field is localized. @default false
   */
  anyParentLocalized?: boolean
  /**
   * Data of the nearest parent block, or undefined
   */
  blockData: Data | undefined
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug?: string
  data: Data
  fields: FieldSchema[]
  fieldSchemaMap: FieldSchemaMap
  filter?: (args: AddFieldStatePromiseArgs) => boolean
  /**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
  forceFullValue?: boolean
  fullData: Data
  id?: number | string
  /**
   * Whether the field schema should be included in the state. @default false
   */
  includeSchema?: boolean
  mockRSCs?: BuildFormStateArgs['mockRSCs']
  /**
   * Whether to omit parent fields in the state. @default false
   */
  omitParents?: boolean
  /**
   * operation is only needed for validation
   */
  operation: 'create' | 'update'
  parentIndexPath: string
  parentPassesCondition?: boolean
  parentPath: string
  parentSchemaPath: string
  permissions: SanitizedFieldsPermissions
  preferences?: DocumentPreferences
  previousFormState: FormState
  renderAllFields: boolean
  renderFieldFn: RenderFieldMethod
  req: PayloadRequest
  select?: SelectType
  selectMode?: SelectMode
  /**
   * Whether to skip checking the field's condition. @default false
   */
  skipConditionChecks?: boolean
  /**
   * Whether to skip validating the field. @default false
   */
  skipValidation?: boolean
  state?: FormStateWithoutComponents
}
⋮----
/**
   * if any parents is localized, then the field is localized. @default false
   */
⋮----
/**
   * Data of the nearest parent block, or undefined
   */
⋮----
/**
   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false
   */
⋮----
/**
   * Whether the field schema should be included in the state. @default false
   */
⋮----
/**
   * Whether to omit parent fields in the state. @default false
   */
⋮----
/**
   * operation is only needed for validation
   */
⋮----
/**
   * Whether to skip checking the field's condition. @default false
   */
⋮----
/**
   * Whether to skip validating the field. @default false
   */
⋮----
/**
 * Flattens the fields schema and fields data
 */
export const iterateFields = async ({
  id,
  addErrorPathToParent: addErrorPathToParentArg,
  anyParentLocalized = false,
  blockData,
  clientFieldSchemaMap,
  collectionSlug,
  data,
  fields,
  fieldSchemaMap,
  filter,
  forceFullValue = false,
  fullData,
  includeSchema = false,
  mockRSCs,
  omitParents = false,
  operation,
  parentIndexPath,
  parentPassesCondition = true,
  parentPath,
  parentSchemaPath,
  permissions,
  preferences,
  previousFormState,
  renderAllFields,
  renderFieldFn: renderFieldFn,
  req,
  select,
  selectMode,
  skipConditionChecks = false,
  skipValidation = false,
  state = {},
}: Args): Promise<void> =>
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/renderField.tsx">
import type {
  ClientComponentProps,
  ClientField,
  FieldPaths,
  FlattenedBlock,
  ServerComponentProps,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { createClientField, MissingEditorProp } from '@convexcms/core'
import { fieldIsHiddenOrDisabled } from '@convexcms/core/shared'
⋮----
import type { RenderFieldMethod } from './types.js'
⋮----
import { RenderServerComponent } from '../../elements/RenderServerComponent/index.js'
⋮----
// eslint-disable-next-line payload/no-imports-from-exports-dir -- need this to reference already existing bundle. Otherwise, bundle size increases., payload/no-imports-from-exports-dir
import { FieldDescription, WatchCondition } from '../../exports/client/index.js'
⋮----
// fields with subfields
⋮----
// TODO: Should we pass explicit values? initialValue, value, valid
// value and initialValue should be typed
⋮----
/**
   * Set the `lastRenderedPath` equal to the new path of the field, this will prevent it from being rendered again
   */
⋮----
/**
   * Only create the `customComponents` object if needed.
   * This will prevent unnecessary data from being transferred to the client.
   */
⋮----
throw new MissingEditorProp(fieldConfig) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
⋮----
{RenderServerComponent({
            clientProps,
            Component: fieldConfig.editor.FieldComponent,
            importMap: req.payload.importMap,
            serverProps,
          })}
        </WatchCondition>
      ) : (
        'Mock'
      )

      break
    }

    case 'ui': {
if (fieldConfig?.admin?.components)
⋮----
// Render any extra, untyped components
</file>

<file path="packages/ui/src/forms/fieldSchemasToFormState/types.ts">
import type {
  ClientFieldSchemaMap,
  Data,
  DocumentPreferences,
  Field,
  FieldSchemaMap,
  FieldState,
  FormState,
  Operation,
  PayloadRequest,
  SanitizedFieldPermissions,
} from '@convexcms/core'
⋮----
export type RenderFieldArgs = {
  clientFieldSchemaMap?: ClientFieldSchemaMap
  collectionSlug: string
  data: Data
  fieldConfig: Field
  fieldSchemaMap: FieldSchemaMap
  fieldState: FieldState
  formState: FormState
  id?: number | string
  indexPath: string
  lastRenderedPath: string
  mockRSCs?: boolean
  operation: Operation
  parentPath: string
  parentSchemaPath: string
  path: string
  permissions: SanitizedFieldPermissions
  preferences: DocumentPreferences
  previousFieldState: FieldState
  renderAllFields: boolean
  req: PayloadRequest
  schemaPath: string
  siblingData: Data
}
⋮----
export type RenderFieldMethod = (args: RenderFieldArgs) => void
</file>

<file path="packages/ui/src/forms/Form/context.ts">
import type { RenderedField } from '@convexcms/core'
⋮----
import { createContext, use } from 'react'
import {
  createContext as createSelectorContext,
  useContextSelector,
  useContext as useFullContext,
} from 'use-context-selector'
⋮----
import type { Context, FormFieldsContext as FormFieldsContextType } from './types.js'
⋮----
/**
 * If the form has started processing in the background (e.g.
 * if autosave is running), this will be true.
 */
⋮----
export type RenderedFieldSlots = Map<string, RenderedField>
⋮----
/**
 * Get the state of the form, can be used to submit & validate the form.
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#useform
 */
const useForm = (): Context
/**
 * Get the state of the document-level form. This is useful if you need to access the document-level Form from within a child Form.
 * This is the case withing lexical Blocks, as each lexical blocks renders their own Form.
 */
const useDocumentForm = (): Context
⋮----
const useWatchForm = (): Context
const useFormSubmitted = (): boolean
const useFormProcessing = (): boolean
/**
 * If the form has started processing in the background (e.g.
 * if autosave is running), this will be true.
 */
const useFormBackgroundProcessing = (): boolean
const useFormModified = (): boolean
const useFormInitializing = (): boolean
⋮----
/**
 * Get and set the value of a form field based on a selector
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#useformfields
 */
const useFormFields = <Value = unknown>(
⋮----
/**
 * Get the state of all form fields.
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#useallformfields
 */
const useAllFormFields = (): FormFieldsContextType
</file>

<file path="packages/ui/src/forms/Form/createNestedClientFieldPath.ts">
import type { ClientField } from '@convexcms/core'
⋮----
import { fieldAffectsData } from '@convexcms/core/shared'
⋮----
export const createNestedClientFieldPath = (parentPath: string, field: ClientField): string =>
</file>

<file path="packages/ui/src/forms/Form/errorMessages.ts">

</file>

<file path="packages/ui/src/forms/Form/fieldReducer.ts">
import type { FormField, FormState, Row } from '@convexcms/core'
⋮----
import ObjectIdImport from 'bson-objectid'
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
import { deepCopyObjectSimpleWithoutReactComponents } from '@convexcms/core/shared'
⋮----
import type { FieldAction } from './types.js'
⋮----
import { mergeServerFormState } from './mergeServerFormState.js'
import { flattenRows, separateRows } from './rows.js'
⋮----
/**
 * Reducer which modifies the form field state (all the current data of the fields in the form). When called using dispatch, it will return a new state object.
 */
export function fieldReducer(state: FormState, action: FieldAction): FormState
⋮----
// add new row to array _field state_
⋮----
// If there are subfields
⋮----
// Add new object containing subfield names to unflattenedRows array
⋮----
// Handle moving rows on the top-level, i.e. `array.0.text` -> `array.1.text`
⋮----
// modify array/block internal row state (i.e. collapsed, blockType)
⋮----
// replace form _field state_
⋮----
// Only update fields that have changed
// by comparing old value / initialValue to new
// ..
// This is a performance enhancement for saving
// large documents with hundreds of fields
⋮----
// TODO: Remove this in 4.0 - this is a temporary fix to prevent a breaking change
⋮----
// If we're not optimizing, just set the state to the new state
</file>

<file path="packages/ui/src/forms/Form/index.scss">
@layer payload-default {
  .form {
    > * {
      width: 100%;
    }
  }
}
</file>

<file path="packages/ui/src/forms/Form/index.tsx">
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
import { useRouter } from 'next/navigation.js'
import { serialize } from 'object-to-formdata'
import { type FormState, type PayloadRequest } from '@convexcms/core'
import {
  deepCopyObjectSimpleWithoutReactComponents,
  getDataByPath as getDataByPathFunc,
  getSiblingData as getSiblingDataFunc,
  reduceFieldsToValues,
  wait,
} from '@convexcms/core/shared'
import React, { useCallback, useEffect, useReducer, useRef, useState } from 'react'
import { toast } from 'sonner'
⋮----
import type {
  CreateFormData,
  Context as FormContextType,
  FormProps,
  GetDataByPath,
  SubmitOptions,
} from './types.js'
⋮----
import { FieldErrorsToast } from '../../elements/Toasts/fieldErrors.js'
import { useDebouncedEffect } from '../../hooks/useDebouncedEffect.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useQueues } from '../../hooks/useQueues.js'
import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { useUploadHandlers } from '../../providers/UploadHandlers/index.js'
import { abortAndIgnore, handleAbortRef } from '../../utilities/abortAndIgnore.js'
import { requests } from '../../utilities/api.js'
import {
  BackgroundProcessingContext,
  DocumentFormContext,
  FormContext,
  FormFieldsContext,
  FormWatchContext,
  InitializingContext,
  ModifiedContext,
  ProcessingContext,
  SubmittedContext,
  useDocumentForm,
} from './context.js'
import { errorMessages } from './errorMessages.js'
import { fieldReducer } from './fieldReducer.js'
import { initContextState } from './initContextState.js'
⋮----
// fields: fieldsFromProps = collection?.fields || global?.fields,
⋮----
initialState, // fully formed initial field state
⋮----
/**
   * Tracks wether the form state passes validation.
   * For example the state could be submitted but invalid as field errors have been returned.
   */
⋮----
// If there is a parent document form, we can get the data from that form
blockData: undefined, // Will be expensive to get - not worth to pass to client-side validation, as this can be obtained by the user using `useFormFields()`
⋮----
// create new toast promise which will resolve manually later
⋮----
// Do not show submitting toast, as the promise toast may never disappear under these conditions.
// Instead, make successToast() or errorToast() throw toast.success / toast.error
successToast = (data)
errorToast = (data)
⋮----
// Execute server side validations
⋮----
// If not valid, prevent submission
⋮----
// If submit handler comes through via props, run that
⋮----
// No action provided, so we should return. An example where this happens are lexical link drawers. Upon submitting the drawer, we
// want to close it without submitting the form. Stuff like validation would be handled by lexical before this, through beforeSubmit
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
contextRef.current = { ...contextRef.current } // triggers rerender of all components that subscribe to form
⋮----
console.error('Error submitting form', err) // eslint-disable-line no-console
⋮----
// nullAsUndefineds is important to allow uploads and relationship fields to clear themselves
⋮----
// dispatch ADD_ROW adds a blank row to local form state.
// This performs no form state request, as the debounced onChange effect will do that for us.
⋮----
contextRef.current = { ...contextRef.current } // triggers rerender of all components that subscribe to form
⋮----
// Edit view default onChange is in packages/ui/src/views/Edit/index.tsx. This onChange usually sends a form state request
⋮----
{/* eslint-disable-next-line @eslint-react/no-context-provider */}
</file>

<file path="packages/ui/src/forms/Form/initContextState.ts">
import type { Data, FormField, FormState } from '@convexcms/core'
⋮----
import type {
  Context,
  CreateFormData,
  DispatchFields,
  GetSiblingData,
  Reset,
  SetModified,
  SetProcessing,
  SetSubmitted,
  Submit,
  ValidateForm,
} from './types.js'
⋮----
const submit: Submit = ()
const getSiblingData: GetSiblingData = ()
const dispatchFields: DispatchFields = ()
const validateForm: ValidateForm = ()
const createFormData: CreateFormData = ()
⋮----
const setModified: SetModified = ()
const setProcessing: SetProcessing = ()
const setBackgroundProcessing: SetProcessing = ()
const setSubmitted: SetSubmitted = ()
const reset: Reset = ()
</file>

<file path="packages/ui/src/forms/Form/mergeServerFormState.ts">
import type { FormState } from '@convexcms/core'
⋮----
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
⋮----
type Args = {
  acceptValues?: boolean
  currentState?: FormState
  incomingState: FormState
}
⋮----
/**
 * This function receives form state from the server and intelligently merges it into the client state.
 * The server contains extra properties that the client may not have, e.g. custom components and error states.
 * We typically do not want to merge properties that rely on user input, however, such as values, unless explicitly requested.
 * Doing this would cause the client to lose any local changes to those fields.
 *
 * This function will also a few defaults, as well as clean up the server response in preparation for the client.
 * e.g. it will set `valid` and `passesCondition` to true if undefined, and remove `addedByServer` from the response.
 */
export const mergeServerFormState = ({
  acceptValues,
  currentState = {},
  incomingState,
}: Args): FormState =>
⋮----
/**
     * Intelligently merge the rows array to ensure changes to local state are not lost while the request was pending
     * For example, the server response could come back with a row which has been deleted on the client
     * Loop over the incoming rows, if it exists in client side form state, merge in any new properties from the server
     * Note: read `currentState` and not `newState` here, as the `rows` property have already been merged above
     */
⋮----
newState[path].rows = [...(currentState[path]?.rows || [])] // shallow copy to avoid mutating the original array
⋮----
// If `valid` is `undefined`, mark it as `true`
⋮----
// If `passesCondition` is `undefined`, mark it as `true`
⋮----
// Strip away the `addedByServer` property from the client
// This will prevent it from being passed back to the server
⋮----
// Return the original object reference if the state is unchanged
// This will avoid unnecessary re-renders and dependency updates
</file>

<file path="packages/ui/src/forms/Form/reduceToSerializableFields.ts">
import { type FormField, type FormState } from '@convexcms/core'
⋮----
type BlacklistedKeys = 'customComponents' | 'validate'
⋮----
const sanitizeField = (incomingField: FormField): FormField =>
⋮----
const field = { ...incomingField } // shallow copy, as we only need to remove top-level keys
⋮----
/**
 * Takes in FormState and removes fields that are not serializable.
 * Returns FormState without blacklisted keys.
 */
export const reduceToSerializableFields = (
  fields: FormState,
):
</file>

<file path="packages/ui/src/forms/Form/rowHelpers.ts">
import type { Row } from '@convexcms/core'
⋮----
export const extractRowsAndCollapsedIDs = ({
  collapsed,
  rowID,
  rows,
}: {
  collapsed: boolean
  rowID: string
  rows: Row[]
}):
⋮----
export const toggleAllRows = ({
  collapsed,
  rows,
}):
</file>

<file path="packages/ui/src/forms/Form/rows.ts">
import type { FormState } from '@convexcms/core'
⋮----
type Result = {
  remainingFields: FormState
  rows: FormState[]
}
⋮----
export const separateRows = (path: string, fields: FormState): Result =>
⋮----
export const flattenRows = (path: string, rows: FormState[]): FormState =>
</file>

<file path="packages/ui/src/forms/Form/types.ts">
import type {
  ClientField,
  Data,
  FormField,
  FormState,
  Row,
  User,
  ValidationFieldError,
} from '@convexcms/core'
import type React from 'react'
import type { Dispatch } from 'react'
⋮----
export type Preferences = {
  [key: string]: unknown
}
⋮----
export type FormProps = {
  beforeSubmit?: ((args: { formState: FormState }) => Promise<FormState>)[]
  children?: React.ReactNode
  className?: string
  disabled?: boolean
  disableSuccessStatus?: boolean
  /**
   * If you would like to solely leverage server-side validation on submit,
   * you can disable checks that the form makes before it submits
   */
  disableValidationOnSubmit?: boolean
  /**
   * If you don't want the form to be a <form> element, you can pass a string here to use as the wrapper element.
   */
  el?: string
  /**
   * By default, the form will get the field schema (not data) from the current document. If you pass this in, you can override that behavior.
   * This is very useful for sub-forms, where the form's field schema is not necessarily the field schema of the current document (e.g. for the Blocks
   * feature of the Lexical Rich Text field)
   */
  fields?: ClientField[]
  handleResponse?: (
    res: Response,
    successToast: (value: string) => void,
    errorToast: (value: string) => void,
  ) => void
  initialState?: FormState
  /**
   * Determines if this Form is the main, top-level Form of a document. If set to true, the
   * Form's children will be wrapped in a DocumentFormContext, which lets you access this document
   * Form's data and fields from any child component - even if that child component is wrapped in a child
   * Form (e.g. a lexical block).
   */
  isDocumentForm?: boolean
  isInitializing?: boolean
  log?: boolean
  onChange?: ((args: { formState: FormState; submitted?: boolean }) => Promise<FormState>)[]
  onSubmit?: (fields: FormState, data: Data) => void
  onSuccess?: (json: unknown) => Promise<FormState | void> | void
  redirect?: string
  submitted?: boolean
  uuid?: string
  validationOperation?: 'create' | 'update'
  waitForAutocomplete?: boolean
} & (
  | {
      action: (formData: FormData) => Promise<void>
    }
  | {
      action?: string
      method?: 'DELETE' | 'GET' | 'PATCH' | 'POST'
    }
)
⋮----
/**
   * If you would like to solely leverage server-side validation on submit,
   * you can disable checks that the form makes before it submits
   */
⋮----
/**
   * If you don't want the form to be a <form> element, you can pass a string here to use as the wrapper element.
   */
⋮----
/**
   * By default, the form will get the field schema (not data) from the current document. If you pass this in, you can override that behavior.
   * This is very useful for sub-forms, where the form's field schema is not necessarily the field schema of the current document (e.g. for the Blocks
   * feature of the Lexical Rich Text field)
   */
⋮----
/**
   * Determines if this Form is the main, top-level Form of a document. If set to true, the
   * Form's children will be wrapped in a DocumentFormContext, which lets you access this document
   * Form's data and fields from any child component - even if that child component is wrapped in a child
   * Form (e.g. a lexical block).
   */
⋮----
export type SubmitOptions = {
  action?: string
  method?: string
  overrides?: ((formState) => FormData) | Record<string, unknown>
  skipValidation?: boolean
}
⋮----
export type DispatchFields = React.Dispatch<any>
export type Submit = (
  options?: SubmitOptions,
  e?: React.FormEvent<HTMLFormElement>,
) => Promise<void>
⋮----
export type ValidateForm = () => Promise<boolean>
⋮----
export type CreateFormData = (
  overrides?: Record<string, unknown>,
  /**
   * If mergeOverrideData true, the data will be merged with the existing data in the form state.
   * @default true
   */
  options?: { mergeOverrideData?: boolean },
) => FormData | Promise<FormData>
⋮----
/**
   * If mergeOverrideData true, the data will be merged with the existing data in the form state.
   * @default true
   */
⋮----
export type GetFields = () => FormState
export type GetField = (path: string) => FormField
export type GetData = () => Data
export type GetSiblingData = (path: string) => Data
export type GetDataByPath = <T = unknown>(path: string) => T
export type SetModified = (modified: boolean) => void
export type SetSubmitted = (submitted: boolean) => void
export type SetProcessing = (processing: boolean) => void
⋮----
export type Reset = (data: unknown) => Promise<void>
⋮----
export type REPLACE_STATE = {
  optimize?: boolean
  /**
   * If `sanitize` is true, default values will be set for form field properties that are not present in the incoming state.
   * For example, `valid` will be set to true if it is not present in the incoming state.
   */
  sanitize?: boolean
  state: FormState
  type: 'REPLACE_STATE'
}
⋮----
/**
   * If `sanitize` is true, default values will be set for form field properties that are not present in the incoming state.
   * For example, `valid` will be set to true if it is not present in the incoming state.
   */
⋮----
export type REMOVE = {
  path: string
  type: 'REMOVE'
}
⋮----
export type MODIFY_CONDITION = {
  path: string
  result: boolean
  type: 'MODIFY_CONDITION'
  user: User
}
⋮----
export type UPDATE = {
  path: string
  type: 'UPDATE'
} & Partial<FormField>
⋮----
export type UPDATE_MANY = {
  formState: FormState
  type: 'UPDATE_MANY'
}
⋮----
export type REMOVE_ROW = {
  path: string
  rowIndex: number
  type: 'REMOVE_ROW'
}
⋮----
export type ADD_ROW = {
  blockType?: string
  path: string
  rowIndex?: number
  subFieldState?: FormState
  type: 'ADD_ROW'
}
⋮----
export type MERGE_SERVER_STATE = {
  acceptValues?: boolean
  prevStateRef: React.RefObject<FormState>
  serverState: FormState
  type: 'MERGE_SERVER_STATE'
}
⋮----
export type REPLACE_ROW = {
  blockType?: string
  path: string
  rowIndex: number
  subFieldState?: FormState
  type: 'REPLACE_ROW'
}
⋮----
export type DUPLICATE_ROW = {
  path: string
  rowIndex: number
  type: 'DUPLICATE_ROW'
}
⋮----
export type MOVE_ROW = {
  moveFromIndex: number
  moveToIndex: number
  path: string
  type: 'MOVE_ROW'
}
⋮----
export type ADD_SERVER_ERRORS = {
  errors: ValidationFieldError[]
  type: 'ADD_SERVER_ERRORS'
}
⋮----
export type SET_ROW_COLLAPSED = {
  path: string
  type: 'SET_ROW_COLLAPSED'
  updatedRows: Row[]
}
⋮----
export type SET_ALL_ROWS_COLLAPSED = {
  path: string
  type: 'SET_ALL_ROWS_COLLAPSED'
  updatedRows: Row[]
}
⋮----
export type FieldAction =
  | ADD_ROW
  | ADD_SERVER_ERRORS
  | DUPLICATE_ROW
  | MERGE_SERVER_STATE
  | MODIFY_CONDITION
  | MOVE_ROW
  | REMOVE
  | REMOVE_ROW
  | REPLACE_ROW
  | REPLACE_STATE
  | SET_ALL_ROWS_COLLAPSED
  | SET_ROW_COLLAPSED
  | UPDATE
  | UPDATE_MANY
⋮----
export type FormFieldsContext = [FormState, Dispatch<FieldAction>]
⋮----
export type Context = {
  addFieldRow: ({
    blockType,
    path,
    rowIndex,
    schemaPath,
    subFieldState,
  }: {
    blockType?: string
    path: string
    rowIndex?: number
    schemaPath: string
    subFieldState?: FormState
  }) => void
  buildRowErrors: () => void
  createFormData: CreateFormData
  disabled: boolean
  dispatchFields: Dispatch<FieldAction>
  /**
   * Form context fields may be outdated and should not be relied on. Instead, prefer `useFormFields`.
   */
  fields: FormState
  formRef: React.RefObject<HTMLFormElement>
  getData: GetData
  getDataByPath: GetDataByPath
  getField: GetField
  getFields: GetFields
  getSiblingData: GetSiblingData
  initializing: boolean
  /**
   * Tracks wether the form state passes validation.
   * For example the state could be submitted but invalid as field errors have been returned.
   */
  isValid: boolean
  moveFieldRow: ({
    moveFromIndex,
    moveToIndex,
    path,
  }: {
    moveFromIndex: number
    moveToIndex: number
    path: string
  }) => void
  removeFieldRow: ({ path, rowIndex }: { path: string; rowIndex: number }) => void
  replaceFieldRow: ({
    blockType,
    path,
    rowIndex,
    schemaPath,
    subFieldState,
  }: {
    blockType?: string
    path: string
    rowIndex: number
    schemaPath: string
    subFieldState?: FormState
  }) => void
  replaceState: (state: FormState) => void
  reset: Reset
  /**
   * If the form has started processing in the background (e.g.
   * if autosave is running), this will be true.
   */
  setBackgroundProcessing: SetProcessing
  setDisabled: (disabled: boolean) => void
  setIsValid: (processing: boolean) => void
  setModified: SetModified
  setProcessing: SetProcessing
  setSubmitted: SetSubmitted
  submit: Submit
  uuid?: string
  validateForm: ValidateForm
}
⋮----
/**
   * Form context fields may be outdated and should not be relied on. Instead, prefer `useFormFields`.
   */
⋮----
/**
   * Tracks wether the form state passes validation.
   * For example the state could be submitted but invalid as field errors have been returned.
   */
⋮----
/**
   * If the form has started processing in the background (e.g.
   * if autosave is running), this will be true.
   */
</file>

<file path="packages/ui/src/forms/NullifyField/index.tsx">
import { Banner } from '../../elements/Banner/index.js'
import { CheckboxField } from '../../fields/Checkbox/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useLocale } from '../../providers/Locale/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
⋮----
type NullifyLocaleFieldProps = {
  readonly fieldValue?: [] | null | number
  readonly localized: boolean
  readonly path: string
}
⋮----
export const NullifyLocaleField: React.FC<NullifyLocaleFieldProps> = ({
  fieldValue,
  localized,
  path,
}) =>
⋮----
// hide when field is not localized or localization is not enabled
⋮----
// if editing default locale or when fallback is disabled
⋮----
} // uncheck when field has value
⋮----
// onToggle={onChange}
</file>

<file path="packages/ui/src/forms/RenderFields/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  // Positioned field-type__wrap is needed for correct positioning of field tooltips.
  // This is set outside of .render-fields, so that manually rendered fields (e.g. in Auth/index.tsx)
  // outside RenderFields also receive this styling.
  .field-type__wrap {
    position: relative;
  }

  .render-fields {
    --spacing-field: var(--base);

    &--margins-small {
      --spacing-field: var(--base);
    }

    &--margins-none {
      --spacing-field: 0;
    }

    & > .field-type {
      margin-bottom: var(--spacing-field);
      position: relative;

      &[type='hidden'] {
        margin-bottom: 0;
      }

      &:first-child {
        margin-top: 0;
      }

      &:last-of-type {
        margin-bottom: 0;
      }
    }

    // at the top-level, add extra margins for the following field types
    &:not(.render-fields--margins-small) {
      & > .field-type {
        &.group-field,
        &.blocks-field,
        &.array-field,
        &.collapsible-field,
        &.rich-text {
          margin-top: calc(var(--spacing-field) * 2);
          margin-bottom: calc(var(--spacing-field) * 2);

          &:first-child {
            margin-top: 0;
          }

          &:last-child {
            margin-bottom: 0;
          }
        }
      }
    }

    @include small-break {
      --spacing-field: calc(var(--base) / 2);
    }
  }
}
</file>

<file path="packages/ui/src/forms/RenderFields/index.tsx">
import { fieldIsHiddenOrDisabled, getFieldPaths, getFieldPermissions } from '@convexcms/core/shared'
import React from 'react'
⋮----
import type { RenderFieldsProps } from './types.js'
⋮----
import { RenderIfInViewport } from '../../elements/RenderIfInViewport/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { RenderField } from './RenderField.js'
⋮----
export const RenderFields: React.FC<RenderFieldsProps> = (props) =>
⋮----
// For sidebar fields in the main fields array, `field` will be `null`, and visa versa
// This is to keep the order of the fields consistent and maintain the correct index paths for the main fields (i)
⋮----
// If the user cannot read the field, then filter it out
// This is different from `admin.readOnly` which is executed based on `operation`
⋮----
// `admin.readOnly` displays the value but prevents the field from being edited
⋮----
// If parent field is `readOnly: true`, but this field is `readOnly: false`, the field should still be editable
⋮----
// If the user does not have access at the operation level, to begin with, force it to be read-only
</file>

<file path="packages/ui/src/forms/RenderFields/RenderField.tsx">
import type {
  ClientComponentProps,
  ClientField,
  FieldPaths,
  SanitizedFieldPermissions,
} from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { ArrayField } from '../../fields/Array/index.js'
import { BlocksField } from '../../fields/Blocks/index.js'
import { CheckboxField } from '../../fields/Checkbox/index.js'
import { CodeField } from '../../fields/Code/index.js'
import { CollapsibleField } from '../../fields/Collapsible/index.js'
import { DateTimeField } from '../../fields/DateTime/index.js'
import { EmailField } from '../../fields/Email/index.js'
import { GroupField } from '../../fields/Group/index.js'
import { HiddenField } from '../../fields/Hidden/index.js'
import { JoinField } from '../../fields/Join/index.js'
import { JSONField } from '../../fields/JSON/index.js'
import { NumberField } from '../../fields/Number/index.js'
import { PointField } from '../../fields/Point/index.js'
import { RadioGroupField } from '../../fields/RadioGroup/index.js'
import { RelationshipField } from '../../fields/Relationship/index.js'
import { RichTextField } from '../../fields/RichText/index.js'
import { RowField } from '../../fields/Row/index.js'
import { SelectField } from '../../fields/Select/index.js'
import { TabsField } from '../../fields/Tabs/index.js'
import { TextField } from '../../fields/Text/index.js'
import { TextareaField } from '../../fields/Textarea/index.js'
import { UIField } from '../../fields/UI/index.js'
import { UploadField } from '../../fields/Upload/index.js'
import { useFormFields } from '../../forms/Form/index.js'
⋮----
type RenderFieldProps = {
  clientFieldConfig: ClientField
  permissions: SanitizedFieldPermissions
} & FieldPaths &
  Pick<ClientComponentProps, 'forceRender' | 'readOnly' | 'schemaPath'>
⋮----
export function RenderField({
  clientFieldConfig,
  forceRender,
  indexPath,
  parentPath,
  parentSchemaPath,
  path,
  permissions,
  readOnly,
  schemaPath,
}: RenderFieldProps)
</file>

<file path="packages/ui/src/forms/RenderFields/types.ts">
import type { ClientField, SanitizedFieldPermissions } from '@convexcms/core'
⋮----
export type RenderFieldsProps = {
  readonly className?: string
  readonly fields: ClientField[]
  /**
   * Controls the rendering behavior of the fields, i.e. defers rendering until they intersect with the viewport using the Intersection Observer API.
   *
   * If true, the fields will be rendered immediately, rather than waiting for them to intersect with the viewport.
   *
   * If a number is provided, will immediately render fields _up to that index_.
   */
  readonly forceRender?: boolean
  readonly margins?: 'small' | false
  readonly parentIndexPath: string
  readonly parentPath: string
  readonly parentSchemaPath: string
  readonly permissions:
    | {
        [fieldName: string]: SanitizedFieldPermissions
      }
    | SanitizedFieldPermissions
  readonly readOnly?: boolean
}
⋮----
/**
   * Controls the rendering behavior of the fields, i.e. defers rendering until they intersect with the viewport using the Intersection Observer API.
   *
   * If true, the fields will be rendered immediately, rather than waiting for them to intersect with the viewport.
   *
   * If a number is provided, will immediately render fields _up to that index_.
   */
</file>

<file path="packages/ui/src/forms/RowLabel/Context/index.tsx">
import React from 'react'
⋮----
import { useWatchForm } from '../../Form/context.js'
⋮----
type RowLabelType<T = unknown> = {
  readonly data: T
  readonly path: string
  readonly rowNumber?: number
}
⋮----
type Props<T> = {
  readonly children: React.ReactNode
} & Omit<RowLabelType<T>, 'data'>
⋮----
export const RowLabelProvider: React.FC<Props<unknown>> = (
</file>

<file path="packages/ui/src/forms/RowLabel/index.tsx">
import React from 'react'
⋮----
import type { RowLabelProps } from './types.js'
⋮----
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { RowLabelProvider } from './Context/index.js'
</file>

<file path="packages/ui/src/forms/RowLabel/types.ts">
export type RowLabelProps = {
  readonly className?: string
  readonly CustomComponent?: React.ReactNode
  readonly label?: React.ReactNode | string
  readonly path: string
  readonly rowNumber?: number
}
</file>

<file path="packages/ui/src/forms/Submit/index.scss">
@layer payload-default {
  form > .form-submit {
    .btn {
      width: 100%;
    }
  }
}
</file>

<file path="packages/ui/src/forms/Submit/index.tsx">
import React from 'react'
⋮----
import type { Props } from '../../elements/Button/types.js'
⋮----
import { Button } from '../../elements/Button/index.js'
import {
  useForm,
  useFormBackgroundProcessing,
  useFormInitializing,
  useFormProcessing,
} from '../Form/context.js'
⋮----
export const FormSubmit: React.FC<Props> = (props) =>
</file>

<file path="packages/ui/src/forms/useField/index.tsx">
import type { PayloadRequest } from '@convexcms/core'
⋮----
import { useCallback, useMemo, useRef } from 'react'
⋮----
import type { UPDATE } from '../Form/types.js'
import type { FieldType, Options } from './types.js'
⋮----
import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useOperation } from '../../providers/Operation/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import {
  useDocumentForm,
  useForm,
  useFormFields,
  useFormInitializing,
  useFormModified,
  useFormProcessing,
  useFormSubmitted,
} from '../Form/context.js'
⋮----
/**
 * Get and set the value of a form field.
 *
 * @see https://payloadcms.com/docs/admin/react-hooks#usefield
 */
export const useField = <TValue,>(options: Options): FieldType<TValue> =>
⋮----
// Method to return from `useField`, used to
// update field values from field component(s)
⋮----
// Only update setModified to true if the form is not already set to modified. Otherwise the following could happen:
// 1. Text field: someone types in it in an unmodified form
// 2. After setTimeout triggers setModified(true): form is set to modified. Save Button becomes available. Good!
// 3. Type something in text field
// 4. Click on save button before setTimeout in useField has finished (so setModified(true) has not been run yet)
// 5. Form is saved, setModified(false) is set in the Form/index.tsx `submit` function, "saved successfully" toast appears
// 6. setModified(true) inside the timeout is run, form is set to modified again, even though it was already saved and thus set to unmodified. Bad! This should have happened before the form is saved. Now the form should be unmodified and stay that way
//    until a NEW change happens. Due to this, the "Leave without saving" modal appears even though it should not when leaving the page fast immediately after saving the document.
// This is only an issue for forms which have already been set to modified true, as that causes the save button to be enabled. If we prevent this setTimeout to be run
// for already-modified forms first place (which is unnecessary), we can avoid this issue. As for unmodified forms, this race issue will not happen, because you cannot click the save button faster
// than the timeout in useField is run. That's because the save button won't even be enabled for clicking until the setTimeout in useField has run.
// This fixes e2e test flakes, as e2e tests were often so fast that they were saving the form before the timeout in useField has run.
// Specifically, this fixes the 'should not warn about unsaved changes when navigating to lexical editor with blocks node and then leaving the page after making a change and saving' lexical e2e test.
⋮----
// Update modified state after field value comes back
// to avoid cursor jump caused by state value / DOM mismatch
⋮----
// Store result from hook as ref
// to prevent unnecessary rerenders
⋮----
// Throttle the validate function
⋮----
const validateField = async () =>
⋮----
blockData: undefined, // Will be expensive to get - not worth to pass to client-side validation, as this can be obtained by the user using `useFormFields()`
⋮----
// Only dispatch if the validation result has changed
// This will prevent unnecessary rerenders
</file>

<file path="packages/ui/src/forms/useField/types.ts">
import type { FieldState, FilterOptionsResult, Row, Validate } from '@convexcms/core'
⋮----
export type Options = {
  disableFormData?: boolean
  hasRows?: boolean
  path: string
  validate?: Validate
}
⋮----
export type FieldType<T> = {
  customComponents?: FieldState['customComponents']
  disabled: boolean
  errorMessage?: string
  errorPaths?: string[]
  filterOptions?: FilterOptionsResult
  formInitializing: boolean
  formProcessing: boolean
  formSubmitted: boolean
  initialValue?: T
  readOnly?: boolean
  rows?: Row[]
  setValue: (val: unknown, disableModifyingForm?: boolean) => void
  showError: boolean
  valid?: boolean
  value: T
}
</file>

<file path="packages/ui/src/forms/WatchChildErrors/buildPathSegments.ts">
import type { ClientField } from '@convexcms/core'
⋮----
import { fieldAffectsData } from '@convexcms/core/shared'
⋮----
export const buildPathSegments = (fields: ClientField[]): (`$
⋮----
// group, block, array
⋮----
// rows, collapsibles, unnamed-tab
⋮----
// tabs
⋮----
// text, number, date, etc.
</file>

<file path="packages/ui/src/forms/WatchChildErrors/index.tsx">
import type { ClientField } from '@convexcms/core'
import type React from 'react'
⋮----
import { useThrottledEffect } from '../../hooks/useThrottledEffect.js'
import { useAllFormFields, useFormSubmitted } from '../Form/context.js'
import { buildPathSegments } from './buildPathSegments.js'
⋮----
type TrackSubSchemaErrorCountProps = {
  fields?: ClientField[]
  /**
   * This path should only include path segments that affect data
   * i.e. it should not include _index-0 type segments
   *
   * For collapsibles and tabs you can simply pass their parent path
   */
  path: (number | string)[]
  setErrorCount: (count: number) => void
}
⋮----
/**
   * This path should only include path segments that affect data
   * i.e. it should not include _index-0 type segments
   *
   * For collapsibles and tabs you can simply pass their parent path
   */
⋮----
export const WatchChildErrors: React.FC<TrackSubSchemaErrorCountProps> = ({
  fields,
  path: parentPath,
  setErrorCount,
}) =>
⋮----
// match fields with same parent path
⋮----
// match fields with same path
</file>

<file path="packages/ui/src/forms/withCondition/index.tsx">
import type { FieldPaths } from '@convexcms/core'
import type { MarkOptional } from 'ts-essentials'
⋮----
import React from 'react'
⋮----
import { WatchCondition } from './WatchCondition.js'
⋮----
export const withCondition = <P extends MarkOptional<FieldPaths, 'indexPath' | 'path'>>(
  Field: React.ComponentType<P>,
): React.FC<P> =>
⋮----
const CheckForCondition: React.FC<P> = (props) =>
</file>

<file path="packages/ui/src/forms/withCondition/WatchCondition.tsx">
import type React from 'react'
⋮----
import { useFormFields } from '../Form/context.js'
⋮----
export const WatchCondition: React.FC<{
  children: React.ReactNode
  path: string
}> = (props) =>
</file>

<file path="packages/ui/src/graphics/Account/Default/index.scss">
@layer payload-default {
  .graphic-account {
    vector-effect: non-scaling-stroke;
    overflow: visible;
    position: relative;

    &__bg {
      fill: var(--theme-elevation-50);
      stroke: var(--theme-elevation-200);
      stroke-width: 1px;
    }

    &__head,
    &__body {
      fill: var(--theme-elevation-200);
    }

    &--active {
      .graphic-account {
        &__bg {
          fill: var(--theme-elevation-500);
          stroke: var(--theme-text);
        }

        &__head,
        &__body {
          fill: var(--theme-text);
        }
      }
    }

    &:hover:not(.graphic-account--active) {
      .graphic-account {
        &__bg {
          fill: var(--theme-elevation-200);
          stroke: var(--theme-elevation-600);
        }

        &__head,
        &__body {
          fill: var(--theme-elevation-600);
        }
      }
    }
  }

  [data-theme='light'] {
    .graphic-account {
      &--active {
        .graphic-account {
          &__bg {
            fill: var(--theme-elevation-300);
            stroke: var(--theme-elevation-600);
          }

          &__head,
          &__body {
            fill: var(--theme-elevation-600);
          }
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/graphics/Account/Default/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/graphics/Account/Gravatar/index.tsx">
import md5 from 'md5'
import React from 'react'
⋮----
import { useAuth } from '../../../providers/Auth/index.js'
⋮----
export const GravatarAccountIcon: React.FC = () =>
</file>

<file path="packages/ui/src/graphics/Account/index.tsx">
import { usePathname } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React from 'react'
⋮----
// import { RenderComponent } from '../../elements/RenderComponent/client.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { DefaultAccountIcon } from './Default/index.js'
import { GravatarAccountIcon } from './Gravatar/index.js'
⋮----
export const Account = () =>
</file>

<file path="packages/ui/src/graphics/DefaultBlockImage/index.tsx">
import React, { useState } from 'react'
import { v4 as uuid } from 'uuid'
⋮----
export const DefaultBlockImage: React.FC = () =>
⋮----
xmlns="http://www.w3.org/2000/svg"
</file>

<file path="packages/ui/src/graphics/ExternalLink/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--externalLink {
    height: $baseline;
    width: $baseline;
    shape-rendering: auto;

    .stroke {
      fill: none;
      stroke: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/graphics/ExternalLink/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/graphics/File/index.tsx">
import React from 'react'
⋮----
<svg height="150" viewBox="0 0 150 150" width="150" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="packages/ui/src/graphics/Icon/index.tsx">
import React from 'react'
⋮----
export const PayloadIcon: React.FC<{
  fill?: string
}> = (
</file>

<file path="packages/ui/src/graphics/Logo/index.tsx">
import React from 'react'
⋮----
export const PayloadLogo: React.FC = ()
</file>

<file path="packages/ui/src/hooks/useDebounce.ts">
import { useEffect, useState } from 'react'
⋮----
export function useDebounce<T = unknown>(value: T, delay: number): T
⋮----
// State and setters for debounced value
</file>

<file path="packages/ui/src/hooks/useDebouncedCallback.ts">
import { useCallback, useRef } from 'react'
⋮----
/**
 * Returns a memoized function that will only call the passed function when it hasn't been called for the wait period
 * @param func The function to be called
 * @param wait Wait period after function hasn't been called for
 * @returns A memoized function that is debounced
 */
export const useDebouncedCallback = (func, wait) =>
⋮----
// Use a ref to store the timeout between renders
// and prevent changes to it from causing re-renders
⋮----
const later = () =>
</file>

<file path="packages/ui/src/hooks/useDebouncedEffect.ts">
import type { DependencyList } from 'react'
⋮----
import { useEffect, useState } from 'react'
⋮----
export function useDebouncedEffect(effect: () => void, deps: DependencyList, delay: number): void
</file>

<file path="packages/ui/src/hooks/useDelay.ts">
type Result = [boolean, () => void]
export const useDelay = (delay: number, triggerOnMount = false): Result =>
</file>

<file path="packages/ui/src/hooks/useDelayedRender.ts">
import { useDelay } from './useDelay.js'
⋮----
type DelayedRenderProps = {
  /** Time in ms to wait before "mounting" the component. */
  delayBeforeShow: number
  /** Time in ms for the "enter" phase of the transition, after delay completes. */
  inTimeout: number
  /** Min time in ms for the "entered" phase of the transition. */
  minShowTime: number
  /** Time in ms for the exit phase of the transition. */
  outTimeout: number
  /** `true` starts the mount process.
   * `false` starts the unmount process.
   * */
  show: boolean
}
⋮----
/** Time in ms to wait before "mounting" the component. */
⋮----
/** Time in ms for the "enter" phase of the transition, after delay completes. */
⋮----
/** Min time in ms for the "entered" phase of the transition. */
⋮----
/** Time in ms for the exit phase of the transition. */
⋮----
/** `true` starts the mount process.
   * `false` starts the unmount process.
   * */
⋮----
type useDelayedRenderT = (props: DelayedRenderProps) => {
  /** `true` if the component has mounted after the timeout. */
  isMounted: boolean
  /** `true` if the component is unmounting. */
  isUnmounting: boolean
  /** Call this function to trigger the timeout delay before rendering. */
  triggerDelayedRender: () => void
}
⋮----
/** `true` if the component has mounted after the timeout. */
⋮----
/** `true` if the component is unmounting. */
⋮----
/** Call this function to trigger the timeout delay before rendering. */
⋮----
export const useDelayedRender: useDelayedRenderT = ({
  delayBeforeShow,
  inTimeout,
  minShowTime,
  outTimeout,
  show,
}) =>
</file>

<file path="packages/ui/src/hooks/useEffectEvent.ts">
/**

Taken and modified from https://github.com/bluesky-social/social-app/blob/ce0bf867ff3b50a495d8db242a7f55371bffeadc/src/lib/hooks/useNonReactiveCallback.ts

Copyright 2023–2025 Bluesky PBC

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
⋮----
import { useCallback, useInsertionEffect, useRef } from 'react'
⋮----
// This should be used sparingly. It erases reactivity, i.e. when the inputs
// change, the function itself will remain the same. This means that if you
// use this at a higher level of your tree, and then some state you read in it
// changes, there is no mechanism for anything below in the tree to "react"
// to this change (e.g. by knowing to call your function again).
//
// Also, you should avoid calling the returned function during rendering
// since the values captured by it are going to lag behind.
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
export function useEffectEvent<T extends Function>(fn: T): T
</file>

<file path="packages/ui/src/hooks/useHotkey.ts">
import { useModal } from '@faceless-ui/modal'
import { setsAreEqual } from '@convexcms/core/shared'
import { useCallback, useEffect } from 'react'
⋮----
// Required to be outside of hook, else debounce would be necessary
// and then one could not prevent the default behaviour.
⋮----
// It maps the pressed keys with the time they were pressed, in order to implement a maximum time
// for the user to press the next key in the sequence
⋮----
// This is necessary to prevent a bug where the keyup event, which unsets the key as pressed
// is not fired when the window is not focused.
// When the user then comes back to the window, the key is still registered as pressed, even though it's not.
⋮----
const stripKey = (key: string) =>
⋮----
const pushToKeys = (code: string) =>
⋮----
// There is a weird bug with macos that if the keys are not cleared they remain in the
// pressed keys set.
⋮----
const removeFromKeys = (code: string) =>
⋮----
// There is a weird bug with macos that if the keys are not cleared they remain in the
// pressed keys set.
⋮----
/**
 * Hook function to work with hotkeys.
 * @param param0.keyCode {string[]} The keys to listen for (`Event.code` without `'Key'` and lowercased)
 * @param param0.cmdCtrlKey {boolean} Whether Ctrl on windows or Cmd on mac must be pressed
 * @param param0.editDepth {boolean} This ensures that the hotkey is only triggered for the most top-level drawer in case there are nested drawers
 * @param func The callback function
 */
export const useHotkey = (
  options: {
    cmdCtrlKey: boolean
    editDepth: number
    keyCodes: string[]
  },
  func: (e: KeyboardEvent) => void,
): void =>
⋮----
// Autofill events, or other synthetic events, can be ignored
⋮----
// Filter out pressed keys which have been pressed > 3 seconds ago
⋮----
// Check for Mac and iPad
⋮----
// Check whether arrays contain the same values (regardless of number of occurrences)
⋮----
// get the maximum edit depth by counting the number of open drawers. modalState is and object which contains the state of all drawers.
⋮----
// We only want to execute the hotkey from the most top-level drawer / edit depth.
⋮----
// execute the function associated with the maximum edit depth
⋮----
document.addEventListener('bypassKeyDown', keydown, false) // this is called if the keydown event's propagation is stopped by react-select
</file>

<file path="packages/ui/src/hooks/useIntersect.ts">
import type React from 'react'
⋮----
import { useEffect, useRef, useState } from 'react'
⋮----
type Intersect = [
  setNode: React.Dispatch<HTMLElement>,
  entry: IntersectionObserverEntry,
  node: HTMLElement,
]
⋮----
export const useIntersect = (
  { root = null, rootMargin = '0px', threshold = 0 } = {},
  disable?: boolean,
): Intersect =>
</file>

<file path="packages/ui/src/hooks/usePayloadAPI.ts">
import type React from 'react'
⋮----
import { useEffect, useRef, useState } from 'react'
⋮----
import { useLocale } from '../providers/Locale/index.js'
import { useTranslation } from '../providers/Translation/index.js'
import { requests } from '../utilities/api.js'
⋮----
type Result = [
  {
    data: any
    isError: boolean
    isLoading: boolean
  },
  {
    setParams: React.Dispatch<unknown>
  },
]
⋮----
type Options = {
  initialData?: any
  initialParams?: unknown
}
⋮----
type UsePayloadAPI = (url: string, options?: Options) => Result
⋮----
export const usePayloadAPI: UsePayloadAPI = (url, options =
⋮----
// If `initialData`, no need to make a request
⋮----
const fetchData = async () =>
⋮----
// swallow error
⋮----
// If `initialData` changes, reset the state
</file>

<file path="packages/ui/src/hooks/useQueues.ts">
import { useCallback, useRef } from 'react'
⋮----
type QueuedFunction = () => Promise<void>
⋮----
type QueuedTaskOptions = {
  /**
   * A function that is called after the queue has processed a function
   * Used to perform side effects after processing the queue
   * @returns {void}
   */
  afterProcess?: () => void
  /**
   * A function that can be used to prevent the queue from processing under certain conditions
   * Can also be used to perform side effects before processing the queue
   * @returns {boolean} If `false`, the queue will not process
   */
  beforeProcess?: () => boolean
}
⋮----
/**
   * A function that is called after the queue has processed a function
   * Used to perform side effects after processing the queue
   * @returns {void}
   */
⋮----
/**
   * A function that can be used to prevent the queue from processing under certain conditions
   * Can also be used to perform side effects before processing the queue
   * @returns {boolean} If `false`, the queue will not process
   */
⋮----
type QueueTask = (fn: QueuedFunction, options?: QueuedTaskOptions) => void
⋮----
/**
 * A React hook that allows you to queue up functions to be executed in order.
 * This is useful when you need to ensure long running networks requests are processed sequentially.
 * Builds up a "queue" of functions to be executed in order, only ever processing the last function in the queue.
 * This ensures that a long queue of tasks doesn't cause a backlog of tasks to be processed.
 * E.g. if you queue a task and it begins running, then you queue 9 more tasks:
 *   1. The currently task will finish
 *   2. The next task in the queue will run
 *   3. All remaining tasks will be discarded
 * @returns {queueTask} A function used to queue a function.
 * @example
 * const { queueTask } = useQueues()
 * queueTask(async () => {
 *   await fetch('https://api.example.com')
 * })
 */
export function useQueues():
⋮----
async function processQueue()
⋮----
// Allow the consumer to prevent the queue from processing under certain conditions
⋮----
const latestTask = queue.current.pop() // Only process the last task in the queue
queue.current = [] // Discard all other tasks
⋮----
console.error('Error in queued function:', err) // eslint-disable-line no-console
</file>

<file path="packages/ui/src/hooks/useResize.ts">
import { useEffect, useState } from 'react'
⋮----
interface Size {
  height: number
  width: number
}
⋮----
interface Resize {
  size?: Size
}
⋮----
export const useResize = (element: HTMLElement): Resize =>
⋮----
let observer: any // eslint-disable-line
⋮----
contentRect, // for Safari iOS compatibility, will be deprecated eventually (see https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect)
⋮----
// see note above for why this block is needed
</file>

<file path="packages/ui/src/hooks/useThrottledEffect.ts">
import type React from 'react'
⋮----
import { useEffect, useRef } from 'react'
⋮----
type useThrottledEffect = (
  callback: React.EffectCallback,
  delay: number,
  deps: React.DependencyList,
) => void
⋮----
/**
 * A hook that will throttle the execution of a callback function inside a useEffect.
 * This is useful for things like throttling loading states or other UI updates.
 * @param callback The callback function to be executed.
 * @param delay The delay in milliseconds to throttle the callback.
 * @param deps The dependencies to watch for changes.
 */
export const useThrottledEffect: useThrottledEffect = (callback, delay, deps = []) =>
</file>

<file path="packages/ui/src/hooks/useThrottledValue.ts">
import { useEffect, useState } from 'react'
⋮----
/**
 * A custom React hook to throttle a value so that it updates no more than once every `delay` milliseconds.
 * @param {any} value - The value to be throttled.
 * @param {number} delay - The minimum delay (in milliseconds) between updates.
 * @returns {any} - The throttled value.
 */
export function useThrottledValue(value, delay)
⋮----
// Cleanup the timeout if the value changes before the delay is completed
</file>

<file path="packages/ui/src/hooks/useUseAsTitle.ts">
import type { ClientCollectionConfig, ClientField } from '@convexcms/core'
⋮----
import { flattenTopLevelFields } from '@convexcms/core/shared'
⋮----
export const useUseTitleField = (collection: ClientCollectionConfig): ClientField =>
</file>

<file path="packages/ui/src/icons/Calendar/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--calendar {
    height: $baseline;
    width: $baseline;

    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Calendar/index.tsx">
import React from 'react'
⋮----
export const CalendarIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Check/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--check {
    height: $baseline;
    width: $baseline;

    .stroke {
      fill: none;
      stroke: currentColor;
      stroke-width: $style-stroke-width-m;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Check/index.tsx">
import React from 'react'
⋮----
export const CheckIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Chevron/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--chevron {
    height: calc(var(--base) / 2);
    width: calc(var(--base) / 2);

    .stroke {
      fill: none;
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
      vector-effect: non-scaling-stroke;
    }

    &.icon--size-large {
      height: var(--base);
      width: var(--base);
    }

    &.icon--size-small {
      height: 8px;
      width: 8px;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Chevron/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/icons/CloseMenu/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .icon--close-menu {
    height: $baseline;
    width: $baseline;

    .stroke {
      stroke: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/icons/CloseMenu/index.tsx">
import React from 'react'
⋮----
export const CloseMenuIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/CodeBlock/index.tsx">
import React from 'react'
⋮----
export const CodeBlockIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Copy/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--copy {
    height: $baseline;
    width: $baseline;

    .stroke {
      fill: none;
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Copy/index.tsx">
import React from 'react'
⋮----
export const CopyIcon: React.FC = ()
⋮----
// <svg className="icon icon--copy" viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg">
//   <rect className="stroke" height="8" width="8" x="6.5" y="10" />
//   <path className="stroke" d="M10 9.98438V6.5H18V14.5H14" />
// </svg>
</file>

<file path="packages/ui/src/icons/Dots/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .dots {
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 2px;
    background-color: var(--theme-elevation-150);
    border-radius: $style-radius-m;
    height: calc(var(--base) * 1.2);
    width: calc(var(--base) * 1.2);

    &:hover {
      background-color: var(--theme-elevation-100);
    }

    &--no-background {
      background-color: transparent;
      width: auto;
      height: auto;

      &:hover {
        background-color: transparent;
      }
    }

    &--horizontal {
      flex-direction: row;
    }

    > div {
      width: 2.5px;
      height: 2.5px;
      border-radius: 100%;
      background-color: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Dots/index.tsx">
import React from 'react'
⋮----
export const Dots: React.FC<
</file>

<file path="packages/ui/src/icons/DragHandle/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--drag-handle {
    height: $baseline;
    width: $baseline;

    .fill {
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
      fill: var(--theme-elevation-800);
    }
  }
}
</file>

<file path="packages/ui/src/icons/DragHandle/index.tsx">
import React from 'react'
⋮----
export const DragHandleIcon: React.FC<
</file>

<file path="packages/ui/src/icons/Edit/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--edit {
    height: $baseline;
    width: $baseline;
    shape-rendering: auto;

    .stroke {
      fill: none;
      stroke: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Edit/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/icons/Line/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--line {
    width: $baseline;
    height: $baseline;

    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Line/index.tsx">
import React from 'react'
⋮----
export const LineIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Link/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--link {
    width: $baseline;
    height: $baseline;

    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Link/index.tsx">
import React from 'react'
⋮----
export const LinkIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Lock/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--lock {
    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Lock/index.tsx">
import React from 'react'
⋮----
export const LockIcon: React.FC<
</file>

<file path="packages/ui/src/icons/LogOut/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .icon--logout {
    height: $baseline;
    width: $baseline;

    .stroke {
      stroke: currentColor;
      stroke-width: 2px;
    }
  }
}
</file>

<file path="packages/ui/src/icons/LogOut/index.tsx">
import React from 'react'
⋮----
export const LogOutIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Menu/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .icon--menu {
    .stroke {
      stroke-width: $style-stroke-width-s;
      stroke: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Menu/index.tsx">
import React from 'react'
⋮----
export const MenuIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/MinimizeMaximize/index.tsx">
type Props = {
  className?: string
  isMinimized?: boolean
}
</file>

<file path="packages/ui/src/icons/More/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--more {
    height: $baseline;
    width: $baseline;

    .fill {
      fill: var(--theme-elevation-800);
      stroke: currentColor;
    }
  }
}
</file>

<file path="packages/ui/src/icons/More/index.tsx">
import React from 'react'
⋮----
export const MoreIcon: React.FC<
</file>

<file path="packages/ui/src/icons/People/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--people {
    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width;
      fill: none;
    }
  }
}
</file>

<file path="packages/ui/src/icons/People/index.tsx">
import React from 'react'
⋮----
export const PeopleIcon: React.FC<
</file>

<file path="packages/ui/src/icons/Plus/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--plus {
    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Plus/index.tsx">
import React from 'react'
⋮----
export const PlusIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Search/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--search {
    height: $baseline;
    width: $baseline;

    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Search/index.tsx">
import React from 'react'
⋮----
export const SearchIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/Sort/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--sort {
    height: $baseline;
    width: $baseline;

    .fill {
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
      fill: var(--theme-elevation-800);
    }
  }
}
</file>

<file path="packages/ui/src/icons/Sort/index.tsx">
import React from 'react'
⋮----
export const SortDownIcon: React.FC<
⋮----
export const SortUpIcon: React.FC<
</file>

<file path="packages/ui/src/icons/Swap/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--swap {
    height: $baseline;
    width: $baseline;

    .stroke {
      fill: none;
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
    }
  }
}
</file>

<file path="packages/ui/src/icons/Swap/index.tsx">
import React from 'react'
⋮----
export const SwapIcon: React.FC = ()
</file>

<file path="packages/ui/src/icons/X/index.scss">
@import '../../scss/styles';

@layer payload-default {
  .icon--x {
    .stroke {
      stroke: currentColor;
      stroke-width: $style-stroke-width-s;
    }
  }
}
</file>

<file path="packages/ui/src/icons/X/index.tsx">
import React from 'react'
</file>

<file path="packages/ui/src/providers/Actions/index.tsx">
import React, { createContext, use, useState } from 'react'
⋮----
type ActionsContextType = {
  Actions: {
    [key: string]: React.ReactNode
  }
  setViewActions: (actions: ActionsContextType['Actions']) => void
}
⋮----
export const useActions = ()
⋮----
export const ActionsProvider: React.FC<{
  readonly Actions?: {
    [key: string]: React.ReactNode
  }
  readonly children: React.ReactNode
}> = (
</file>

<file path="packages/ui/src/providers/Auth/index.tsx">
import type { ClientUser, SanitizedPermissions, User } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { usePathname, useRouter } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
⋮----
import React, { createContext, use, useCallback, useEffect, useState } from 'react'
import { toast } from 'sonner'
⋮----
import { stayLoggedInModalSlug } from '../../elements/StayLoggedIn/index.js'
import { useDebounce } from '../../hooks/useDebounce.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { useConfig } from '../Config/index.js'
import { useRouteTransition } from '../RouteTransition/index.js'
⋮----
export type UserWithToken<T = ClientUser> = {
  exp: number
  token: string
  user: T
}
⋮----
export type AuthContext<T = ClientUser> = {
  fetchFullUser: () => Promise<null | User>
  logOut: () => Promise<boolean>
  permissions?: SanitizedPermissions
  refreshCookie: (forceRefresh?: boolean) => void
  refreshCookieAsync: () => Promise<ClientUser>
  refreshPermissions: () => Promise<void>
  setPermissions: (permissions: SanitizedPermissions) => void
  setUser: (user: null | UserWithToken<T>) => void
  strategy?: string
  token?: string
  tokenExpiration?: number
  user?: null | T
}
⋮----
type Props = {
  children: React.ReactNode
  permissions?: SanitizedPermissions
  user?: ClientUser | null
}
⋮----
export function AuthProvider({
  children,
  permissions: initialPermissions,
  user: initialUser,
}: Props)
⋮----
async function refresh()
⋮----
// On mount, get user and set
⋮----
// When location changes, refresh cookie
⋮----
export const useAuth = <T = ClientUser,>(): AuthContext<T>
</file>

<file path="packages/ui/src/providers/ClientFunction/index.tsx">
import React from 'react'
⋮----
type ModifyClientFunctionContextType = {
  addClientFunction: (args: ModifyFunctionArgs) => void
  removeClientFunction: (args: ModifyFunctionArgs) => void
}
type ClientFunctionsContextType = Record<string, any>
⋮----
type ModifyFunctionArgs = { func: any; key: string }
⋮----
export const ClientFunctionProvider: React.FC<
⋮----
export const useAddClientFunction = (key: string, func: any) =>
⋮----
export const useClientFunctions = () =>
</file>

<file path="packages/ui/src/providers/Config/index.tsx">
/* eslint-disable perfectionist/sort-object-types  */ // Need to disable this rule because the order of the overloads is important
⋮----
import type {
  ClientCollectionConfig,
  ClientConfig,
  ClientGlobalConfig,
  CollectionSlug,
  GlobalSlug,
  UnsanitizedClientConfig,
} from '@convexcms/core'
⋮----
import React, { createContext, use, useCallback, useEffect, useMemo, useState } from 'react'
⋮----
type GetEntityConfigFn = {
  // Overload #1: collectionSlug only
  // @todo remove "{} |" in 4.0, which would be a breaking change
  (args: { collectionSlug: {} | CollectionSlug; globalSlug?: never }): ClientCollectionConfig

  // Overload #2: globalSlug only
  // @todo remove "{} |" in 4.0, which would be a breaking change
  (args: { collectionSlug?: never; globalSlug: {} | GlobalSlug }): ClientGlobalConfig

  // Overload #3: both/none (fall back to union | null)
  (args: {
    collectionSlug?: {} | CollectionSlug
    globalSlug?: {} | GlobalSlug
  }): ClientCollectionConfig | ClientGlobalConfig | null
}
⋮----
// Overload #1: collectionSlug only
// @todo remove "{} |" in 4.0, which would be a breaking change
⋮----
// Overload #2: globalSlug only
// @todo remove "{} |" in 4.0, which would be a breaking change
⋮----
// Overload #3: both/none (fall back to union | null)
⋮----
export type ClientConfigContext = {
  config: ClientConfig
  /**
   * Get a collection or global config by its slug. This is preferred over
   * using `config.collections.find` or `config.globals.find`, because
   * getEntityConfig uses a lookup map for O(1) lookups.
   */
  getEntityConfig: GetEntityConfigFn
  setConfig: (config: ClientConfig) => void
}
⋮----
/**
   * Get a collection or global config by its slug. This is preferred over
   * using `config.collections.find` or `config.globals.find`, because
   * getEntityConfig uses a lookup map for O(1) lookups.
   */
⋮----
function sanitizeClientConfig(
  unSanitizedConfig: ClientConfig | UnsanitizedClientConfig,
): ClientConfig
⋮----
export const ConfigProvider: React.FC<{
  readonly children: React.ReactNode
  readonly config: ClientConfig | UnsanitizedClientConfig
}> = (
⋮----
// Need to update local config state if config from props changes, for HMR.
// That way, config changes will be updated in the UI immediately without needing a refresh.
⋮----
// Build lookup maps for collections and globals so we can do O(1) lookups by slug
⋮----
export const useConfig = (): ClientConfigContext
</file>

<file path="packages/ui/src/providers/DocumentEvents/index.tsx">
import type { DocumentEvent } from '@convexcms/core'
⋮----
import React, { createContext, use, useState } from 'react'
⋮----
export const DocumentEventsProvider: React.FC<
⋮----
export const useDocumentEvents = ()
</file>

<file path="packages/ui/src/providers/DocumentInfo/index.tsx">
import type { ClientUser, DocumentPreferences, SanitizedDocumentPermissions } from '@convexcms/core'
⋮----
import React, { createContext, use, useCallback, useEffect, useMemo, useRef, useState } from 'react'
⋮----
import type { DocumentInfoContext, DocumentInfoProps } from './types.js'
⋮----
import { useAuth } from '../../providers/Auth/index.js'
import { requests } from '../../utilities/api.js'
import { formatDocTitle } from '../../utilities/formatDocTitle/index.js'
import { useConfig } from '../Config/index.js'
import { useLocale, useLocaleLoading } from '../Locale/index.js'
import { usePreferences } from '../Preferences/index.js'
import { useTranslation } from '../Translation/index.js'
import { UploadEditsProvider, useUploadEdits } from '../UploadEdits/index.js'
import { useGetDocPermissions } from './useGetDocPermissions.js'
⋮----
export const useDocumentInfo = (): DocumentInfoContext
⋮----
const DocumentInfo: React.FC<
  {
    readonly children: React.ReactNode
  } & DocumentInfoProps
> = (
⋮----
// eslint-disable-next-line no-console
⋮----
// Check if the document is already locked
⋮----
// Send a patch request to update the _lastEdited info
⋮----
// eslint-disable-next-line no-console
⋮----
console.error(e) // eslint-disable-line no-console
⋮----
// clean on unmount
⋮----
// swallow error
⋮----
export const DocumentInfoProvider: React.FC<
  {
    readonly children: React.ReactNode
  } & DocumentInfoProps
> = (props) =>
</file>

<file path="packages/ui/src/providers/DocumentInfo/types.ts">
import type {
  ClientCollectionConfig,
  ClientGlobalConfig,
  ClientUser,
  Data,
  DocumentPreferences,
  FormState,
  InsideFieldsPreferences,
  SanitizedCollectionConfig,
  SanitizedDocumentPermissions,
  SanitizedGlobalConfig,
  TypedUser,
} from '@convexcms/core'
import type React from 'react'
⋮----
export type DocumentInfoProps = {
  readonly action?: string
  readonly AfterDocument?: React.ReactNode
  readonly AfterFields?: React.ReactNode
  readonly apiURL?: string
  readonly BeforeFields?: React.ReactNode
  readonly collectionSlug?: SanitizedCollectionConfig['slug']
  readonly currentEditor: TypedUser
  readonly disableActions?: boolean
  readonly disableCreate?: boolean
  readonly disableLeaveWithoutSaving?: boolean
  readonly docPermissions?: SanitizedDocumentPermissions
  readonly globalSlug?: SanitizedGlobalConfig['slug']
  readonly hasPublishedDoc: boolean
  readonly hasPublishPermission?: boolean
  readonly hasSavePermission?: boolean
  readonly id?: number | string
  readonly initialData?: Data
  readonly initialState?: FormState
  readonly isEditing?: boolean
  readonly isLocked: boolean
  readonly lastUpdateTime: number
  readonly mostRecentVersionIsAutosaved: boolean
  readonly redirectAfterCreate?: boolean
  readonly redirectAfterDelete?: boolean
  readonly redirectAfterDuplicate?: boolean
  readonly unpublishedVersionCount: number
  readonly Upload?: React.ReactNode
  readonly versionCount: number
}
⋮----
export type DocumentInfoContext = {
  currentEditor?: ClientUser | null | number | string
  docConfig?: ClientCollectionConfig | ClientGlobalConfig
  documentIsLocked?: boolean
  getDocPermissions: (data?: Data) => Promise<void>
  getDocPreferences: () => Promise<DocumentPreferences>
  incrementVersionCount: () => void
  isInitializing: boolean
  preferencesKey?: string
  savedDocumentData?: Data
  setCurrentEditor?: React.Dispatch<React.SetStateAction<ClientUser>>
  setDocFieldPreferences: (
    field: string,
    fieldPreferences: { [key: string]: unknown } & Partial<InsideFieldsPreferences>,
  ) => void
  setDocumentIsLocked?: React.Dispatch<React.SetStateAction<boolean>>
  setDocumentTitle: (title: string) => void
  setHasPublishedDoc: React.Dispatch<React.SetStateAction<boolean>>
  setLastUpdateTime: React.Dispatch<React.SetStateAction<number>>
  setMostRecentVersionIsAutosaved: React.Dispatch<React.SetStateAction<boolean>>
  setUnpublishedVersionCount: React.Dispatch<React.SetStateAction<number>>
  setUploadStatus?: (status: 'failed' | 'idle' | 'uploading') => void
  title: string
  unlockDocument: (docID: number | string, slug: string) => Promise<void>
  unpublishedVersionCount: number
  updateDocumentEditor: (docID: number | string, slug: string, user: ClientUser) => Promise<void>
  updateSavedDocumentData: (data: Data) => void
  uploadStatus?: 'failed' | 'idle' | 'uploading'
  versionCount: number
} & DocumentInfoProps
</file>

<file path="packages/ui/src/providers/DocumentInfo/useGetDocPermissions.tsx">
import type { Data, SanitizedDocumentPermissions, SanitizedPermissions } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { hasSavePermission as getHasSavePermission } from '../../utilities/hasSavePermission.js'
import { isEditing as getIsEditing } from '../../utilities/isEditing.js'
⋮----
export const useGetDocPermissions = ({
  id,
  api,
  collectionSlug,
  globalSlug,
  i18n,
  locale,
  permissions,
  serverURL,
  setDocPermissions,
  setHasPublishPermission,
  setHasSavePermission,
}: {
  api: string
  collectionSlug: string
  globalSlug: string
  i18n: any
  id: string
  locale: string
  permissions: SanitizedPermissions
  serverURL: string
  setDocPermissions: React.Dispatch<React.SetStateAction<SanitizedDocumentPermissions>>
  setHasPublishPermission: React.Dispatch<React.SetStateAction<boolean>>
  setHasSavePermission: React.Dispatch<React.SetStateAction<boolean>>
})
⋮----
// when creating new documents, there is no permissions saved for this document yet
// use the generic entity permissions instead
</file>

<file path="packages/ui/src/providers/EditDepth/index.tsx">
import React, { createContext, use } from 'react'
⋮----
export const EditDepthProvider: React.FC<
⋮----
export const useEditDepth = (): number
</file>

<file path="packages/ui/src/providers/EntityVisibility/index.tsx">
import type { SanitizedCollectionConfig, SanitizedGlobalConfig, VisibleEntities } from '@convexcms/core'
⋮----
import React, { createContext, use, useCallback } from 'react'
⋮----
export type VisibleEntitiesContextType = {
  isEntityVisible: ({
    collectionSlug,
    globalSlug,
  }: {
    collectionSlug?: SanitizedCollectionConfig['slug']
    globalSlug?: SanitizedGlobalConfig['slug']
  }) => boolean
  visibleEntities: VisibleEntities
}
⋮----
export const EntityVisibilityProvider: React.FC<{
  children: React.ReactNode
  visibleEntities?: VisibleEntities
}> = (
⋮----
export const useEntityVisibility = (): VisibleEntitiesContextType
</file>

<file path="packages/ui/src/providers/ListQuery/context.ts">
import { createContext, use } from 'react'
⋮----
import type { IListQueryContext } from './types.js'
⋮----
export const useListQuery = (): IListQueryContext
⋮----
export const useListQueryModified = (): boolean
</file>

<file path="packages/ui/src/providers/ListQuery/index.tsx">
import { useRouter, useSearchParams } from 'next/navigation.js'
import { type ListQuery, type Where } from '@convexcms/core'
import { isNumber, transformColumnsToSearchParams } from '@convexcms/core/shared'
⋮----
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'
⋮----
import type { IListQueryContext, ListQueryProps } from './types.js'
⋮----
import { useListDrawerContext } from '../../elements/ListDrawer/Provider.js'
import { useEffectEvent } from '../../hooks/useEffectEvent.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { parseSearchParams } from '../../utilities/parseSearchParams.js'
import { ListQueryContext, ListQueryModifiedContext } from './context.js'
⋮----
// eslint-disable-next-line @typescript-eslint/require-await
⋮----
// Allow the URL to override the default limit
⋮----
// Allow the URL to override the default sort
⋮----
// Only modify columns if they originated from preferences
// We can assume they did if `listPreferences.columns` is defined
⋮----
// Do not use router.replace here to avoid re-rendering on initial load
⋮----
// If `defaultLimit` or `defaultSort` are updated externally, update the query
// I.e. when HMR runs, these properties may be different
</file>

<file path="packages/ui/src/providers/ListQuery/types.ts">
import type {
  ClientCollectionConfig,
  ColumnPreference,
  ListPreferences,
  ListQuery,
  PaginatedDocs,
  QueryPreset,
  Sort,
  Where,
} from '@convexcms/core'
⋮----
type ContextHandlers = {
  handlePageChange?: (page: number) => Promise<void>
  handlePerPageChange?: (limit: number) => Promise<void>
  handleSearchChange?: (search: string) => Promise<void>
  handleSortChange?: (sort: string) => Promise<void>
  handleWhereChange?: (where: Where) => Promise<void>
}
⋮----
export type OnListQueryChange = (query: ListQuery) => void
⋮----
export type ListQueryProps = {
  readonly children: React.ReactNode
  readonly collectionSlug?: ClientCollectionConfig['slug']
  readonly columns?: ColumnPreference[]
  readonly data: PaginatedDocs
  readonly defaultLimit?: number
  readonly defaultSort?: Sort
  readonly listPreferences?: ListPreferences
  readonly modifySearchParams?: boolean
  readonly onQueryChange?: OnListQueryChange
  readonly orderableFieldName?: string
  /**
   * @deprecated
   */
  readonly preferenceKey?: string
}
⋮----
/**
   * @deprecated
   */
⋮----
export type IListQueryContext = {
  collectionSlug: ClientCollectionConfig['slug']
  data: PaginatedDocs
  defaultLimit?: number
  defaultSort?: Sort
  modified: boolean
  orderableFieldName?: string
  query: ListQuery
  refineListData: (args: ListQuery, setModified?: boolean) => Promise<void>
  setModified: (modified: boolean) => void
} & ContextHandlers
</file>

<file path="packages/ui/src/providers/Locale/index.tsx">
import type { Locale } from '@convexcms/core'
⋮----
import { useSearchParams } from 'next/navigation.js'
import React, { createContext, use, useEffect, useRef, useState } from 'react'
⋮----
import { findLocaleFromCode } from '../../utilities/findLocaleFromCode.js'
import { useAuth } from '../Auth/index.js'
import { useConfig } from '../Config/index.js'
import { usePreferences } from '../Preferences/index.js'
⋮----
const fetchPreferences = async <T extends Record<string, unknown> | string>(
  key: string,
  baseURL: string,
): Promise<
⋮----
export const LocaleProvider: React.FC<{ children?: React.ReactNode; locale?: Locale['code'] }> = ({
  children,
  /**
    The `locale` prop originates from the root layout, which does not have access to search params
    This component uses the `useSearchParams` hook to get the locale from the URL as precedence over this prop
    This prop does not update as the user navigates the site, because the root layout does not re-render
  */
  locale: initialLocaleFromPrefs,
}) =>
⋮----
/**
    The `locale` prop originates from the root layout, which does not have access to search params
    This component uses the `useSearchParams` hook to get the locale from the URL as precedence over this prop
    This prop does not update as the user navigates the site, because the root layout does not re-render
  */
⋮----
// TODO: return null V4
⋮----
/**
     * We need to set `isLoading` back to false once the locale is detected to be different
     * This happens when the user clicks an anchor link which appends the `?locale=` query param
     * This triggers a client-side navigation, which re-renders the page with the new locale
     * In Next.js, local state is persisted during this type of navigation because components are not unmounted
     */
⋮----
/**
     * This effect should only run when `localeFromParams` changes, i.e. when the user clicks an anchor link
     * The root layout, which sends the initial locale from prefs, will not re-render as the user navigates the site
     * For this reason, we need to fetch the locale from prefs if the search params clears the `locale` query param
     */
async function resetLocale()
⋮----
export const useLocaleLoading = ()
⋮----
/**
 * TODO: V4
 * The return type of the `useLocale` hook will change in v4. It will return `null | Locale` instead of `false | {} | Locale`.
 */
export const useLocale = (): Locale
</file>

<file path="packages/ui/src/providers/Operation/index.tsx">
import React, { createContext, use } from 'react'
⋮----
export const OperationProvider: React.FC<
⋮----
export const useOperation = (): Operation | undefined
</file>

<file path="packages/ui/src/providers/Params/index.tsx">
import { useParams as useNextParams } from 'next/navigation.js'
import React, { createContext, use } from 'react'
⋮----
export type Params = ReturnType<typeof useNextParams>
interface IParamsContext extends Params {}
⋮----
/**
 * @deprecated
 * The ParamsProvider is deprecated and will be removed in the next major release. Instead, use the `useParams` hook from `next/navigation` directly. See https://github.com/payloadcms/payload/pull/9581.
 * @example
 * ```tsx
 * import { useParams } from 'next/navigation'
 * ```
 */
export const ParamsProvider: React.FC<
⋮----
/**
 * @deprecated
 * The `useParams` hook is deprecated and will be removed in the next major release. Instead, use the `useParams` hook from `next/navigation` directly. See https://github.com/payloadcms/payload/pull/9581.
 * @example
 * ```tsx
 * import { useParams } from 'next/navigation'
 * ```
 */
export const useParams = (): IParamsContext
</file>

<file path="packages/ui/src/providers/Preferences/index.tsx">
import { dequal } from 'dequal/lite' // lite: no need for Map and Set support
import React, { createContext, use, useCallback, useEffect, useRef } from 'react'
⋮----
import { useTranslation } from '../../providers/Translation/index.js'
import { requests } from '../../utilities/api.js'
import { deepMergeSimple } from '../../utilities/deepMerge.js'
import { useAuth } from '../Auth/index.js'
import { useConfig } from '../Config/index.js'
⋮----
type PreferencesContext = {
  getPreference: <T = any>(key: string) => Promise<T>
  /**
   * @param key - a string identifier for the property being set
   * @param value - preference data to store
   * @param merge - when true will combine the existing preference object batch the change into one request for objects, default = false
   */
  setPreference: <T = any>(key: string, value: T, merge?: boolean) => Promise<void>
}
⋮----
/**
   * @param key - a string identifier for the property being set
   * @param value - preference data to store
   * @param merge - when true will combine the existing preference object batch the change into one request for objects, default = false
   */
⋮----
const requestOptions = (value, language) => (
⋮----
// clear preferences between users
⋮----
// handle value objects where multiple values can be set under one key
⋮----
// merge the value with any existing preference for the key
⋮----
// add the requested changes to a pendingUpdate batch for the key
⋮----
const updatePreference = async () =>
⋮----
// compare the value stored in context before sending to eliminate duplicate requests
⋮----
// preference set in context here to prevent other updatePreference at the same time
⋮----
// reset any changes for this key after sending the request
⋮----
// use timeout to allow multiple changes of different values using the same key in one request
⋮----
export const usePreferences = (): PreferencesContext
</file>

<file path="packages/ui/src/providers/Root/index.tsx">
import type { I18nClient, I18nOptions, Language } from '@convexcms/translations'
import type {
  ClientConfig,
  LanguageOptions,
  Locale,
  SanitizedPermissions,
  ServerFunctionClient,
  User,
} from '@convexcms/core'
⋮----
import { ModalContainer, ModalProvider } from '@faceless-ui/modal'
import { ScrollInfoProvider } from '@faceless-ui/scroll-info'
import React, { Fragment } from 'react'
⋮----
import type { Theme } from '../Theme/index.js'
⋮----
import { LoadingOverlayProvider } from '../../elements/LoadingOverlay/index.js'
import { NavProvider } from '../../elements/Nav/context.js'
import { StayLoggedInModal } from '../../elements/StayLoggedIn/index.js'
import { StepNavProvider } from '../../elements/StepNav/index.js'
import { WindowInfoProvider } from '../../providers/WindowInfo/index.js'
import { AuthProvider } from '../Auth/index.js'
import { ClientFunctionProvider } from '../ClientFunction/index.js'
import { ConfigProvider } from '../Config/index.js'
import { DocumentEventsProvider } from '../DocumentEvents/index.js'
import { LocaleProvider } from '../Locale/index.js'
import { ParamsProvider } from '../Params/index.js'
import { PreferencesProvider } from '../Preferences/index.js'
import { RouteCache } from '../RouteCache/index.js'
import { RouteTransitionProvider } from '../RouteTransition/index.js'
import { SearchParamsProvider } from '../SearchParams/index.js'
import { ServerFunctionsProvider } from '../ServerFunctions/index.js'
import { ThemeProvider } from '../Theme/index.js'
import { ToastContainer } from '../ToastContainer/index.js'
import { TranslationProvider } from '../Translation/index.js'
import { UploadHandlersProvider } from '../UploadHandlers/index.js'
⋮----
type Props = {
  readonly children: React.ReactNode
  readonly config: ClientConfig
  readonly dateFNSKey: Language['dateFNSKey']
  readonly fallbackLang: I18nOptions['fallbackLanguage']
  readonly isNavOpen?: boolean
  readonly languageCode: string
  readonly languageOptions: LanguageOptions
  readonly locale?: Locale['code']
  readonly permissions: SanitizedPermissions
  readonly serverFunction: ServerFunctionClient
  readonly switchLanguageServerAction?: (lang: string) => Promise<void>
  readonly theme: Theme
  readonly translations: I18nClient['translations']
  readonly user: null | User
}
</file>

<file path="packages/ui/src/providers/RouteCache/index.tsx">
import { usePathname, useRouter } from 'next/navigation.js'
import React, { createContext, use, useCallback, useEffect } from 'react'
⋮----
export type RouteCacheContext = {
  clearRouteCache: () => void
}
⋮----
export const RouteCache: React.FC<
⋮----
export const useRouteCache = ()
</file>

<file path="packages/ui/src/providers/RouteTransition/ProgressBar/index.scss">
@layer payload-default {
  .progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 2px;
    z-index: 9999;
    opacity: 1;

    &__progress {
      height: 100%;
      background-color: var(--theme-elevation-1000);
      transition: width ease-in var(--transition-duration);
    }

    &--fade-out {
      opacity: 0;
      transition: opacity linear var(--transition-duration);
      transition-delay: var(--transition-duration);
    }
  }
}
</file>

<file path="packages/ui/src/providers/RouteTransition/ProgressBar/index.tsx">
import React, { useEffect, useRef } from 'react'
⋮----
import { useRouteTransition } from '../index.js'
⋮----
/**
 * Renders a progress bar that shows the progress of a route transition.
 * Place this at the root of your application, inside of the `RouteTransitionProvider`.
 * When a transition is triggered, the progress bar will show the progress of that transition and exit when the transition is complete.
 * @returns A progress bar that shows the progress of a route transition
 * @example
 * import { RouteTransitionProvider, ProgressBar, Link } from '@convexcms/ui'
 * const App = () => (
 * <RouteTransitionProvider>
 *  <ProgressBar />
 *  <Link href="/somewhere">Go Somewhere</Link>
 * </RouteTransitionProvider>
 */
⋮----
// Fast forward to 100% when the transition is complete
// Then fade out the progress bar directly after
⋮----
// Wait for CSS transition to finish before hiding the progress bar
// This includes both the fast-forward to 100% and the subsequent fade-out
⋮----
// @ts-expect-error - TS doesn't like custom CSS properties
</file>

<file path="packages/ui/src/providers/RouteTransition/index.tsx">
import React, { startTransition, useCallback, useEffect, useOptimistic, useRef } from 'react'
⋮----
/**
 * Route transitions are useful in showing immediate visual feedback to the user when navigating between pages. This is especially useful on slow networks when navigating to data heavy or process intensive pages.
 * To use route transitions, place the `RouteTransitionProvider` at the root of your application, outside of the `ProgressBar` component.
 * To trigger a route transition, use the `Link` component from `@payloadcms/ui`,
 * or wrap a callback function with the `startRouteTransition` method.
 * To gain access to the `RouteTransitionContext`, call the `useRouteTransition` hook in your component.
 * @returns A context provider with methods and state for transitioning between routes, including `isTransitioning`, `startRouteTransition`, and `transitionProgress`.
 * @example
 * import { RouteTransitionProvider, ProgressBar, Link } from '@convexcms/ui'
 * const App = () => (
 *  <RouteTransitionProvider>
 *   <ProgressBar />
 *   <Link href="/somewhere">Go Somewhere</Link>
 *  </RouteTransitionProvider>
 * )
 */
export const RouteTransitionProvider: React.FC<RouteTransitionProps> = (
⋮----
// randomly update progress using an exponential curve
// cap the progress to ensure it never fully reaches completion
// accelerate quickly then decelerate slowly
⋮----
const jumpFactor = 0.2 // lower to reduce jumps in progress
const growthFactor = 0.75 // adjust to control acceleration
const slowdownFactor = 0.75 // adjust to control deceleration
⋮----
}, 250) // every n ms, update progress
⋮----
type RouteTransitionProps = {
  children: React.ReactNode
}
⋮----
type StartRouteTransition = (callback?: () => void) => void
⋮----
type RouteTransitionContextValue = {
  isTransitioning: boolean
  startRouteTransition: StartRouteTransition
  transitionProgress: number
}
⋮----
/**
 * Use this hook to access the `RouteTransitionContext` provided by the `RouteTransitionProvider`.
 * To start a transition, fire the `startRouteTransition` method with a provided callback to run while the transition takes place.
 * @returns The `RouteTransitionContext` needed for transitioning between routes, including `isTransitioning`, `startRouteTransition`, and `transitionProgress`.
 * @example
 * 'use client'
 * import React, { useCallback } from 'react'
 * import { useTransition } from '@convexcms/ui'
 * import { useRouter } from 'next/navigation'
 *
 * const MyComponent: React.FC = () => {
 *   const router = useRouter()
 *   const { startRouteTransition } = useRouteTransition()
 *
 *   const redirectSomewhere = useCallback(() => {
 *     startRouteTransition(() => router.push('/somewhere'))
 *   }, [startRouteTransition, router])
 *
 *   // ...
 * }
 */
export const useRouteTransition = ()
</file>

<file path="packages/ui/src/providers/ScrollInfo/index.tsx">

</file>

<file path="packages/ui/src/providers/SearchParams/index.tsx">
import { useSearchParams as useNextSearchParams } from 'next/navigation.js'
⋮----
import React, { createContext, use } from 'react'
⋮----
export type SearchParamsContext = {
  searchParams: qs.ParsedQs
  stringifyParams: ({ params, replace }: { params: qs.ParsedQs; replace?: boolean }) => string
}
⋮----
/**
 * @deprecated
 * The SearchParamsProvider is deprecated and will be removed in the next major release. Instead, use the `useSearchParams` hook from `next/navigation` directly. See https://github.com/payloadcms/payload/pull/9581.
 * @example
 * ```tsx
 * import { useSearchParams } from 'next/navigation'
 * ```
 */
export const SearchParamsProvider: React.FC<
⋮----
/**
 * @deprecated
 * The `useSearchParams` hook is deprecated and will be removed in the next major release. Instead, use the `useSearchParams` hook from `next/navigation` directly. See https://github.com/payloadcms/payload/pull/9581.
 * @example
 * ```tsx
 * import { useSearchParams } from 'next/navigation'
 * ```
 * If you need to parse the `where` query, you can do so with the `parseSearchParams` utility.
 * ```tsx
 * import { parseSearchParams } from '@convexcms/ui'
 * const parsedSearchParams = parseSearchParams(searchParams)
 * ```
 */
export const useSearchParams = (): SearchParamsContext
</file>

<file path="packages/ui/src/providers/Selection/index.tsx">
import type { ClientUser, Where } from '@convexcms/core'
⋮----
import { useSearchParams } from 'next/navigation.js'
⋮----
import React, { createContext, use, useCallback, useEffect, useRef, useState } from 'react'
⋮----
import { parseSearchParams } from '../../utilities/parseSearchParams.js'
import { useLocale } from '../Locale/index.js'
⋮----
export enum SelectAllStatus {
  AllAvailable = 'allAvailable',
  AllInPage = 'allInPage',
  None = 'none',
  Some = 'some',
}
⋮----
type SelectionContext = {
  count: number
  disableBulkDelete?: boolean
  disableBulkEdit?: boolean
  getQueryParams: (additionalParams?: Where) => string
  selectAll: SelectAllStatus
  selected: Map<number | string, boolean>
  setSelection: (id: number | string) => void
  toggleAll: (allAvailable?: boolean) => void
  totalDocs: number
}
⋮----
type Props = {
  readonly children: React.ReactNode
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  readonly docs: any[]
  readonly totalDocs: number
  user: ClientUser
}
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
return // Prevent selection if the document is locked
⋮----
// If previously selected all and now deselecting, adjust status
⋮----
export const useSelection = (): SelectionContext
</file>

<file path="packages/ui/src/providers/ServerFunctions/index.tsx">
import type {
  BuildFormStateArgs,
  BuildTableStateArgs,
  Data,
  DocumentSlots,
  ErrorResult,
  Locale,
  ServerFunctionClient,
} from '@convexcms/core'
⋮----
import React, { createContext, useCallback } from 'react'
⋮----
import type { buildFormStateHandler } from '../../utilities/buildFormState.js'
import type { buildTableStateHandler } from '../../utilities/buildTableState.js'
import type { CopyDataFromLocaleArgs } from '../../utilities/copyDataFromLocale.js'
import type {
  schedulePublishHandler,
  SchedulePublishHandlerArgs,
} from '../../utilities/schedulePublishHandler.js'
⋮----
type GetFormStateClient = (
  args: {
    signal?: AbortSignal
  } & Omit<BuildFormStateArgs, 'clientConfig' | 'req'>,
) => ReturnType<typeof buildFormStateHandler>
⋮----
type SchedulePublishClient = (
  args: {
    signal?: AbortSignal
  } & Omit<SchedulePublishHandlerArgs, 'clientConfig' | 'req'>,
) => ReturnType<typeof schedulePublishHandler>
⋮----
type GetTableStateClient = (
  args: {
    signal?: AbortSignal
  } & Omit<BuildTableStateArgs, 'clientConfig' | 'req'>,
) => ReturnType<typeof buildTableStateHandler>
⋮----
type RenderDocument = (args: {
  collectionSlug: string
  disableActions?: boolean
  docID?: number | string
  drawerSlug?: string
  initialData?: Data
  locale?: Locale
  overrideEntityVisibility?: boolean
  redirectAfterCreate?: boolean
  redirectAfterDelete?: boolean
  redirectAfterDuplicate?: boolean
  signal?: AbortSignal
}) => Promise<
  { data: Data; Document: React.ReactNode } | ({ data: never; Document: never } & ErrorResult)
>
⋮----
type CopyDataFromLocaleClient = (
  args: {
    signal?: AbortSignal
  } & Omit<CopyDataFromLocaleArgs, 'req'>,
) => Promise<{ data: Data }>
⋮----
type GetDocumentSlots = (args: {
  collectionSlug: string
  signal?: AbortSignal
}) => Promise<DocumentSlots>
⋮----
type ServerFunctionsContextType = {
  copyDataFromLocale: CopyDataFromLocaleClient
  getDocumentSlots: GetDocumentSlots
  getFormState: GetFormStateClient
  getTableState: GetTableStateClient
  renderDocument: RenderDocument
  schedulePublish: SchedulePublishClient
  serverFunction: ServerFunctionClient
}
⋮----
export const useServerFunctions = () =>
⋮----
export const ServerFunctionsProvider: React.FC<{
  children: React.ReactNode
  serverFunction: ServerFunctionClient
}> = (
⋮----
})) as Awaited<ReturnType<typeof schedulePublishHandler>> // TODO: infer this type when `strictNullChecks` is enabled
⋮----
console.error(_err) // eslint-disable-line no-console
⋮----
})) as Awaited<ReturnType<typeof buildFormStateHandler>> // TODO: infer this type when `strictNullChecks` is enabled
⋮----
console.error(_err) // eslint-disable-line no-console
⋮----
})) as Awaited<ReturnType<typeof buildTableStateHandler>> // TODO: infer this type when `strictNullChecks` is enabled
⋮----
console.error(_err) // eslint-disable-line no-console
⋮----
// return { state: args.formState }
⋮----
})) as Awaited<ReturnType<typeof renderDocument>> // TODO: infer this type when `strictNullChecks` is enabled
⋮----
console.error(_err) // eslint-disable-line no-console
⋮----
console.error(_err) // eslint-disable-line no-console
</file>

<file path="packages/ui/src/providers/TableColumns/RenderDefaultCell/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .default-cell {
    &__first-cell {
      border: 0;
      background-color: transparent;
      padding: 0;
      cursor: pointer;
      text-decoration: underline;
      text-align: left;
      white-space: nowrap;
    }
  }
}
</file>

<file path="packages/ui/src/providers/TableColumns/RenderDefaultCell/index.tsx">
import type { DefaultCellComponentProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
import { useListDrawerContext } from '../../../elements/ListDrawer/Provider.js'
import { DefaultCell } from '../../../elements/Table/DefaultCell/index.js'
import { useTableColumns } from '../index.js'
⋮----
export const useCellProps = (): DefaultCellComponentProps | null
⋮----
export const RenderDefaultCell: React.FC<{
  clientProps: DefaultCellComponentProps
  columnIndex: number
  enableRowSelections?: boolean
  isLinkedColumn?: boolean
}> = (
</file>

<file path="packages/ui/src/providers/TableColumns/buildColumnState.tsx">
import type { I18nClient } from '@convexcms/translations'
import type {
  ClientCollectionConfig,
  ClientComponentProps,
  ClientField,
  Column,
  DefaultCellComponentProps,
  DefaultServerCellComponentProps,
  Field,
  ListPreferences,
  PaginatedDocs,
  Payload,
  SanitizedCollectionConfig,
  ServerComponentProps,
  StaticLabel,
} from '@convexcms/core'
⋮----
import { MissingEditorProp } from '@convexcms/core'
import {
  fieldIsHiddenOrDisabled,
  fieldIsID,
  fieldIsPresentationalOnly,
  flattenTopLevelFields,
} from '@convexcms/core/shared'
import React from 'react'
⋮----
import type { SortColumnProps } from '../../elements/SortColumn/index.js'
⋮----
import { RenderServerComponent } from '../../elements/RenderServerComponent/index.js'
import {
  DefaultCell,
  RenderCustomComponent,
  RenderDefaultCell,
  SortColumn,
  // eslint-disable-next-line payload/no-imports-from-exports-dir
} from '../../exports/client/index.js'
⋮----
// eslint-disable-next-line payload/no-imports-from-exports-dir
⋮----
import { hasOptionLabelJSXElement } from '../../utilities/hasOptionLabelJSXElement.js'
import { filterFields } from './filterFields.js'
⋮----
type Args = {
  beforeRows?: Column[]
  clientCollectionConfig: ClientCollectionConfig
  collectionConfig: SanitizedCollectionConfig
  columnPreferences: ListPreferences['columns']
  columns?: ListPreferences['columns']
  customCellProps: DefaultCellComponentProps['customCellProps']
  docs: PaginatedDocs['docs']
  enableRowSelections: boolean
  enableRowTypes?: boolean
  i18n: I18nClient
  payload: Payload
  sortColumnProps?: Partial<SortColumnProps>
  useAsTitle: SanitizedCollectionConfig['admin']['useAsTitle']
}
⋮----
export const buildColumnState = (args: Args): Column[] =>
⋮----
// clientFields contains the fake `id` column
⋮----
) as Field[] // TODO: think of a way to avoid this additional flatten
⋮----
// place the `ID` field first, if it exists
// do the same for the `useAsTitle` field with precedence over the `ID` field
// then sort the rest of the fields based on the `defaultColumns` or `columnPreferences`
⋮----
const sortFieldMap = (fieldMap, sortTo)
⋮----
// sort the fields to the order of `defaultColumns` or `columnPreferences`
⋮----
_sortedFieldMap = sortFieldMap(_sortedFieldMap, sortTo) // TODO: think of a way to avoid this additional sort
⋮----
_field.admin.components.Label !== undefined // let it return `null`
⋮----
// TODO: customComponent will be optional in v4
⋮----
throw new MissingEditorProp(_field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
</file>

<file path="packages/ui/src/providers/TableColumns/buildPolymorphicColumnState.tsx">
// Dirty copy of buildColumnState.tsx with some changes to not break things
⋮----
import type { I18nClient } from '@convexcms/translations'
import type {
  ClientField,
  Column,
  DefaultCellComponentProps,
  DefaultServerCellComponentProps,
  Field,
  ListPreferences,
  PaginatedDocs,
  Payload,
  SanitizedCollectionConfig,
  StaticLabel,
} from '@convexcms/core'
⋮----
import { MissingEditorProp } from '@convexcms/core'
import {
  fieldIsHiddenOrDisabled,
  fieldIsID,
  fieldIsPresentationalOnly,
  flattenTopLevelFields,
} from '@convexcms/core/shared'
import React from 'react'
⋮----
import type { SortColumnProps } from '../../elements/SortColumn/index.js'
⋮----
import {
  RenderCustomComponent,
  RenderDefaultCell,
  SortColumn,
  // eslint-disable-next-line payload/no-imports-from-exports-dir
} from '../../exports/client/index.js'
⋮----
// eslint-disable-next-line payload/no-imports-from-exports-dir
⋮----
import { RenderServerComponent } from '../../elements/RenderServerComponent/index.js'
import { filterFields } from './filterFields.js'
⋮----
type Args = {
  beforeRows?: Column[]
  columnPreferences: ListPreferences['columns']
  columns?: ListPreferences['columns']
  customCellProps: DefaultCellComponentProps['customCellProps']
  docs: PaginatedDocs['docs']
  enableRowSelections: boolean
  enableRowTypes?: boolean
  fields: ClientField[]
  i18n: I18nClient
  payload: Payload
  sortColumnProps?: Partial<SortColumnProps>
  useAsTitle: SanitizedCollectionConfig['admin']['useAsTitle']
}
⋮----
export const buildPolymorphicColumnState = (args: Args): Column[] =>
⋮----
// clientFields contains the fake `id` column
⋮----
let _sortedFieldMap = flattenTopLevelFields(filterFields(fields), true) as Field[] // TODO: think of a way to avoid this additional flatten
⋮----
// place the `ID` field first, if it exists
// do the same for the `useAsTitle` field with precedence over the `ID` field
// then sort the rest of the fields based on the `defaultColumns` or `columnPreferences`
⋮----
const sortFieldMap = (fieldMap, sortTo)
⋮----
// sort the fields to the order of `defaultColumns` or `columnPreferences`
⋮----
_sortedFieldMap = sortFieldMap(_sortedFieldMap, sortTo) // TODO: think of a way to avoid this additional sort
⋮----
// const CustomLabelToRender =
//   _field &&
//   'admin' in _field &&
//   'components' in _field.admin &&
//   'Label' in _field.admin.components &&
//   _field.admin.components.Label !== undefined // let it return `null`
//     ? _field.admin.components.Label
//     : undefined
⋮----
// // TODO: customComponent will be optional in v4
// const clientProps: Omit<ClientComponentProps, 'customComponents'> = {
//   field,
// }
⋮----
// const customLabelServerProps: Pick<
//   ServerComponentProps,
//   'clientField' | 'collectionSlug' | 'field' | 'i18n' | 'payload'
// > = {
//   clientField: field,
//   collectionSlug: collectionConfig.slug,
//   field: _field,
//   i18n,
//   payload,
// }
⋮----
throw new MissingEditorProp(_field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
</file>

<file path="packages/ui/src/providers/TableColumns/context.ts">
import { createContext, use } from 'react'
⋮----
import type { ITableColumns } from './types.js'
⋮----
export const useTableColumns = (): ITableColumns
</file>

<file path="packages/ui/src/providers/TableColumns/filterFields.tsx">
import type { ClientField, Field } from '@convexcms/core'
⋮----
import { fieldIsHiddenOrDisabled, fieldIsID } from '@convexcms/core/shared'
⋮----
/**
 * Filters fields that are hidden, disabled, or have `disableListColumn` set to `true`
 * Does so recursively for `tabs` fields.
 */
export const filterFields = <T extends ClientField | Field>(incomingFields: T[]): T[] =>
⋮----
const shouldSkipField = (field: T): boolean
⋮----
// extract top-level `tabs` fields and filter out the same
</file>

<file path="packages/ui/src/providers/TableColumns/getInitialColumns.ts">
import type { ClientField, CollectionConfig, Field, ListPreferences } from '@convexcms/core'
⋮----
import { fieldAffectsData } from '@convexcms/core/shared'
⋮----
const getRemainingColumns = <T extends ClientField[] | Field[]>(
  fields: T,
  useAsTitle: string,
): ListPreferences['columns']
⋮----
/**
 * Returns the initial columns to display in the table based on the following criteria:
 * 1. If `defaultColumns` is set in the collection config, use those columns
 * 2. Otherwise take `useAtTitle, if set, and the next 3 fields that are not hidden or disabled
 */
export const getInitialColumns = <T extends ClientField[] | Field[]>(
  fields: T,
  useAsTitle: CollectionConfig['admin']['useAsTitle'],
  defaultColumns: CollectionConfig['admin']['defaultColumns'],
): ListPreferences['columns'] =>
</file>

<file path="packages/ui/src/providers/TableColumns/index.tsx">
import { type Column } from '@convexcms/core'
import { transformColumnsToSearchParams } from '@convexcms/core/shared'
import React, { startTransition, useCallback, useRef } from 'react'
⋮----
import type { ITableColumns, TableColumnsProviderProps } from './types.js'
⋮----
import { useConfig } from '../../providers/Config/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
import { TableColumnContext } from './context.js'
⋮----
export const TableColumnsProvider: React.FC<TableColumnsProviderProps> = ({
  children,
  collectionSlug,
  columnState: columnStateFromProps,
  LinkedCellOverride,
}) =>
⋮----
// ensure the name does not begin with a `-` which denotes an inactive column
</file>

<file path="packages/ui/src/providers/TableColumns/types.ts">
import type { Column, ListPreferences } from '@convexcms/core'
⋮----
import type { SortColumnProps } from '../../elements/SortColumn/index.js'
⋮----
export interface ITableColumns {
  columns: Column[]
  LinkedCellOverride?: React.ReactNode
  moveColumn: (args: { fromIndex: number; toIndex: number }) => Promise<void>
  resetColumnsState: () => Promise<void>
  setActiveColumns: (columns: string[]) => Promise<void>
  toggleColumn: (column: string) => Promise<void>
}
⋮----
export type TableColumnsProviderProps = {
  readonly children: React.ReactNode
  readonly collectionSlug: string | string[]
  readonly columnState: Column[]
  /**
   * @deprecated
   */
  readonly docs?: any[]
  /**
   * @deprecated
   */
  readonly enableRowSelections?: boolean
  readonly LinkedCellOverride?: React.ReactNode
  /**
   * @deprecated
   */
  readonly listPreferences?: ListPreferences
  /**
   * @deprecated
   */
  readonly preferenceKey?: string
  /**
   * @deprecated
   */
  readonly renderRowTypes?: boolean
  /**
   * @deprecated
   */
  readonly setTable?: (Table: React.ReactNode) => void
  /**
   * @deprecated
   */
  readonly sortColumnProps?: Partial<SortColumnProps>
  /**
   * @deprecated
   */
  readonly tableAppearance?: 'condensed' | 'default'
}
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
⋮----
/**
   * @deprecated
   */
</file>

<file path="packages/ui/src/providers/Theme/index.tsx">
import React, { createContext, use, useCallback, useEffect, useState } from 'react'
⋮----
import { useConfig } from '../Config/index.js'
⋮----
export type Theme = 'dark' | 'light'
⋮----
export type ThemeContext = {
  autoMode: boolean
  setTheme: (theme: Theme) => void
  theme: Theme
}
⋮----
function setCookie(cname, cvalue, exdays)
⋮----
const getTheme = (
  cookieKey,
):
⋮----
export const ThemeProvider: React.FC<{
  children?: React.ReactNode
  theme?: Theme
}> = (
⋮----
// to delete the cookie, we set an expired date
⋮----
export const useTheme = (): ThemeContext
</file>

<file path="packages/ui/src/providers/ToastContainer/icons/Error.tsx">
import React from 'react'
⋮----
export const Error: React.FC = () =>
⋮----
<svg fill="none" height="26" viewBox="0 0 26 26" width="26" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="packages/ui/src/providers/ToastContainer/icons/Info.tsx">
import React from 'react'
⋮----
export const Info: React.FC = () =>
⋮----
<svg fill="none" height="26" viewBox="0 0 26 26" width="26" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="packages/ui/src/providers/ToastContainer/icons/Success.tsx">
import React from 'react'
⋮----
export const Success: React.FC = () =>
⋮----
<svg fill="none" height="26" viewBox="0 0 26 26" width="26" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="packages/ui/src/providers/ToastContainer/icons/Warning.tsx">
import React from 'react'
⋮----
export const Warning: React.FC = () =>
⋮----
<svg fill="none" height="26" viewBox="0 0 26 26" width="26" xmlns="http://www.w3.org/2000/svg">
</file>

<file path="packages/ui/src/providers/ToastContainer/index.tsx">
import React from 'react'
import { Toaster } from 'sonner'
⋮----
import { Error } from './icons/Error.js'
import { Info } from './icons/Info.js'
import { Success } from './icons/Success.js'
import { Warning } from './icons/Warning.js'
⋮----
// @ts-expect-error
</file>

<file path="packages/ui/src/providers/Translation/index.tsx">
import type {
  AcceptedLanguages,
  ClientTranslationKeys,
  ClientTranslationsObject,
  I18nClient,
  I18nOptions,
  Language,
  TFunction,
} from '@convexcms/translations'
import type { Locale } from 'date-fns'
import type { LanguageOptions } from '@convexcms/core'
⋮----
import { importDateFNSLocale, t } from '@convexcms/translations'
import { enUS } from 'date-fns/locale/en-US'
import { useRouter } from 'next/navigation.js'
import React, { createContext, use, useEffect, useState } from 'react'
⋮----
type ContextType<
  TAdditionalTranslations = {},
  TAdditionalClientTranslationKeys extends string = never,
> = {
  i18n: [TAdditionalClientTranslationKeys] extends [never]
    ? I18nClient
    : TAdditionalTranslations extends object
      ? I18nClient<TAdditionalTranslations, TAdditionalClientTranslationKeys>
      : I18nClient<ClientTranslationsObject, TAdditionalClientTranslationKeys>
  languageOptions: LanguageOptions
  switchLanguage?: (lang: AcceptedLanguages) => Promise<void>
  t: TFunction<ClientTranslationKeys | Extract<TAdditionalClientTranslationKeys, string>>
}
⋮----
// Use `any` here to be replaced later with a more specific type when used
⋮----
type Props = {
  children: React.ReactNode
  dateFNSKey: Language['dateFNSKey']
  fallbackLang: I18nOptions['fallbackLanguage']
  language: string
  languageOptions: LanguageOptions
  switchLanguageServerAction: (lang: string) => Promise<void>
  translations: I18nClient['translations']
}
⋮----
export const TranslationProvider: React.FC<Props> = ({
  children,
  dateFNSKey,
  fallbackLang,
  language,
  languageOptions,
  switchLanguageServerAction,
  translations,
}) =>
⋮----
const nextT: ContextType['t'] = (key, vars): string
⋮----
// eslint-disable-next-line no-console
⋮----
const loadDateFNS = async () =>
⋮----
export const useTranslation = <
</file>

<file path="packages/ui/src/providers/UploadEdits/index.tsx">
import type { UploadEdits } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export type UploadEditsProviderProps = {
  children: React.ReactNode
  initialUploadEdits?: UploadEdits
}
export type UploadEditsContext = {
  getUploadEdits: () => UploadEdits
  resetUploadEdits: () => void
  updateUploadEdits: (edits: UploadEdits) => void
  uploadEdits: UploadEdits
}
⋮----
export const UploadEditsProvider = (
⋮----
const resetUploadEdits = () =>
⋮----
const updateUploadEdits = (edits: UploadEdits) =>
⋮----
const getUploadEdits = ()
⋮----
export const useUploadEdits = (): UploadEditsContext
</file>

<file path="packages/ui/src/providers/UploadHandlers/index.tsx">
import type { UploadCollectionSlug } from '@convexcms/core'
⋮----
import React, { useState } from 'react'
⋮----
type UploadHandler = (args: {
  file: File
  updateFilename: (filename: string) => void
}) => Promise<unknown>
⋮----
export type UploadHandlersContext = {
  getUploadHandler: (args: { collectionSlug: UploadCollectionSlug }) => null | UploadHandler
  setUploadHandler: (args: {
    collectionSlug: UploadCollectionSlug
    handler: UploadHandler
  }) => unknown
}
⋮----
export const UploadHandlersProvider = (
⋮----
const getUploadHandler: UploadHandlersContext['getUploadHandler'] = (
⋮----
const setUploadHandler: UploadHandlersContext['setUploadHandler'] = ({
    collectionSlug,
    handler,
}) =>
⋮----
export const useUploadHandlers = (): UploadHandlersContext =>
</file>

<file path="packages/ui/src/providers/WindowInfo/index.tsx">

</file>

<file path="packages/ui/src/scss/app.scss">
@layer payload-default, payload;

@import 'styles';
@import './toasts.scss';
@import './colors.scss';

@layer payload-default {
  :root {
    --base-px: 20;
    --base-body-size: 13;
    --base: calc((var(--base-px) / var(--base-body-size)) * 1rem);

    --breakpoint-xs-width: #{$breakpoint-xs-width};
    --breakpoint-s-width: #{$breakpoint-s-width};
    --breakpoint-m-width: #{$breakpoint-m-width};
    --breakpoint-l-width: #{$breakpoint-l-width};
    --scrollbar-width: 17px;

    --theme-bg: var(--theme-elevation-0);
    --theme-input-bg: var(--theme-elevation-0);
    --theme-text: var(--theme-elevation-800);
    --theme-overlay: rgba(5, 5, 5, 0.5);
    --theme-baseline: #{$baseline-px};
    --theme-baseline-body-size: #{$baseline-body-size};
    --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
      sans-serif;
    --font-serif: 'Georgia', 'Bitstream Charter', 'Charis SIL', Utopia, 'URW Bookman L', serif;
    --font-mono: 'SF Mono', Menlo, Consolas, Monaco, monospace;

    --style-radius-s: #{$style-radius-s};
    --style-radius-m: #{$style-radius-m};
    --style-radius-l: #{$style-radius-l};

    --z-popup: 10;
    --z-nav: 20;
    --z-modal: 30;
    --z-status: 40;

    --accessibility-outline: 2px solid var(--theme-text);
    --accessibility-outline-offset: 2px;

    --gutter-h: #{base(3)};
    --spacing-view-bottom: var(--gutter-h);
    --doc-controls-height: calc(var(--base) * 2.8);
    --app-header-height: calc(var(--base) * 2.8);
    --nav-width: 275px;
    --nav-trans-time: 150ms;

    @include mid-break {
      --gutter-h: #{base(2)};
      --app-header-height: calc(var(--base) * 2.4);
      --doc-controls-height: calc(var(--base) * 2.4);
    }

    @include small-break {
      --gutter-h: #{base(0.8)};
      --spacing-view-bottom: calc(var(--base) * 2);
      --nav-width: 100vw;
    }
  }

  /////////////////////////////
  // GLOBAL STYLES
  /////////////////////////////

  * {
    box-sizing: border-box;
  }

  html {
    @extend %body;
    background: var(--theme-bg);
    -webkit-font-smoothing: antialiased;

    &[data-theme='dark'] {
      --theme-bg: var(--theme-elevation-0);
      --theme-text: var(--theme-elevation-1000);
      --theme-input-bg: var(--theme-elevation-50);
      --theme-overlay: rgba(5, 5, 5, 0.75);
      color-scheme: dark;

      ::selection {
        color: var(--color-base-1000);
      }

      ::-moz-selection {
        color: var(--color-base-1000);
      }
    }

    @include mid-break {
      font-size: 12px;
    }
  }

  html,
  body,
  #app {
    height: 100%;
  }

  body {
    font-family: var(--font-body);
    font-weight: 400;
    color: var(--theme-text);
    margin: 0;
    // this is for the nav to be able to push the document over
    overflow-x: hidden;
  }

  ::selection {
    background: var(--color-success-250);
    color: var(--theme-base-800);
  }

  ::-moz-selection {
    background: var(--color-success-250);
    color: var(--theme-base-800);
  }

  img {
    max-width: 100%;
    height: auto;
    display: block;
  }

  h1 {
    @extend %h1;
  }

  h2 {
    @extend %h2;
  }

  h3 {
    @extend %h3;
  }

  h4 {
    @extend %h4;
  }

  h5 {
    @extend %h5;
  }

  h6 {
    @extend %h6;
  }

  p {
    margin: 0;
  }

  ul,
  ol {
    padding-left: $baseline;
    margin: 0;
  }

  :focus-visible {
    outline: var(--accessibility-outline);
  }

  a {
    color: currentColor;

    &:focus {
      &:not(:focus-visible) {
        opacity: 0.8;
      }
      outline: none;
    }

    &:active {
      opacity: 0.7;
      outline: none;
    }
  }

  svg {
    vertical-align: middle;
  }

  dialog {
    width: 100%;
    border: 0;
    padding: 0;
    color: currentColor;
  }

  .payload__modal-item {
    min-height: 100%;
    background: transparent;
  }

  .payload__modal-container--enterDone {
    overflow: auto;
  }

  .payload__modal-item--enter,
  .payload__modal-item--enterDone {
    z-index: var(--z-modal);
  }

  // @import '~payload-user-css'; TODO: re-enable this
}
</file>

<file path="packages/ui/src/scss/colors.scss">
@layer payload-default {
  :root {
    --color-base-0: rgb(255, 255, 255);
    --color-base-50: rgb(245, 245, 245);
    --color-base-100: rgb(235, 235, 235);
    --color-base-150: rgb(221, 221, 221);
    --color-base-200: rgb(208, 208, 208);
    --color-base-250: rgb(195, 195, 195);
    --color-base-300: rgb(181, 181, 181);
    --color-base-350: rgb(168, 168, 168);
    --color-base-400: rgb(154, 154, 154);
    --color-base-450: rgb(141, 141, 141);
    --color-base-500: rgb(128, 128, 128);
    --color-base-550: rgb(114, 114, 114);
    --color-base-600: rgb(101, 101, 101);
    --color-base-650: rgb(87, 87, 87);
    --color-base-700: rgb(74, 74, 74);
    --color-base-750: rgb(60, 60, 60);
    --color-base-800: rgb(47, 47, 47);
    --color-base-850: rgb(34, 34, 34);
    --color-base-900: rgb(20, 20, 20);
    --color-base-950: rgb(7, 7, 7);
    --color-base-1000: rgb(0, 0, 0);

    --color-success-50: rgb(237, 245, 249);
    --color-success-100: rgb(218, 237, 248);
    --color-success-150: rgb(188, 225, 248);
    --color-success-200: rgb(156, 216, 253);
    --color-success-250: rgb(125, 204, 248);
    --color-success-300: rgb(97, 190, 241);
    --color-success-350: rgb(65, 178, 236);
    --color-success-400: rgb(36, 164, 223);
    --color-success-450: rgb(18, 148, 204);
    --color-success-500: rgb(21, 135, 186);
    --color-success-550: rgb(12, 121, 168);
    --color-success-600: rgb(11, 110, 153);
    --color-success-650: rgb(11, 97, 135);
    --color-success-700: rgb(17, 88, 121);
    --color-success-750: rgb(17, 76, 105);
    --color-success-800: rgb(18, 66, 90);
    --color-success-850: rgb(18, 56, 76);
    --color-success-900: rgb(19, 44, 58);
    --color-success-950: rgb(22, 33, 39);

    --color-error-50: rgb(250, 241, 240);
    --color-error-100: rgb(252, 229, 227);
    --color-error-150: rgb(247, 208, 204);
    --color-error-200: rgb(254, 193, 188);
    --color-error-250: rgb(253, 177, 170);
    --color-error-300: rgb(253, 154, 146);
    --color-error-350: rgb(253, 131, 123);
    --color-error-400: rgb(246, 109, 103);
    --color-error-450: rgb(234, 90, 86);
    --color-error-500: rgb(218, 75, 72);
    --color-error-550: rgb(200, 62, 61);
    --color-error-600: rgb(182, 54, 54);
    --color-error-650: rgb(161, 47, 47);
    --color-error-700: rgb(144, 44, 43);
    --color-error-750: rgb(123, 41, 39);
    --color-error-800: rgb(105, 39, 37);
    --color-error-850: rgb(86, 36, 33);
    --color-error-900: rgb(64, 32, 29);
    --color-error-950: rgb(44, 26, 24);

    --color-warning-50: rgb(249, 242, 237);
    --color-warning-100: rgb(248, 232, 219);
    --color-warning-150: rgb(243, 212, 186);
    --color-warning-200: rgb(243, 200, 162);
    --color-warning-250: rgb(240, 185, 136);
    --color-warning-300: rgb(238, 166, 98);
    --color-warning-350: rgb(234, 148, 58);
    --color-warning-400: rgb(223, 132, 17);
    --color-warning-450: rgb(204, 120, 15);
    --color-warning-500: rgb(185, 108, 13);
    --color-warning-550: rgb(167, 97, 10);
    --color-warning-600: rgb(150, 87, 11);
    --color-warning-650: rgb(134, 78, 11);
    --color-warning-700: rgb(120, 70, 13);
    --color-warning-750: rgb(105, 61, 13);
    --color-warning-800: rgb(90, 55, 19);
    --color-warning-850: rgb(73, 47, 21);
    --color-warning-900: rgb(56, 38, 20);
    --color-warning-950: rgb(38, 29, 21);

    --color-blue-50: rgb(237, 245, 249);
    --color-blue-100: rgb(218, 237, 248);
    --color-blue-150: rgb(188, 225, 248);
    --color-blue-200: rgb(156, 216, 253);
    --color-blue-250: rgb(125, 204, 248);
    --color-blue-300: rgb(97, 190, 241);
    --color-blue-350: rgb(65, 178, 236);
    --color-blue-400: rgb(36, 164, 223);
    --color-blue-450: rgb(18, 148, 204);
    --color-blue-500: rgb(21, 135, 186);
    --color-blue-550: rgb(12, 121, 168);
    --color-blue-600: rgb(11, 110, 153);
    --color-blue-650: rgb(11, 97, 135);
    --color-blue-700: rgb(17, 88, 121);
    --color-blue-750: rgb(17, 76, 105);
    --color-blue-800: rgb(18, 66, 90);
    --color-blue-850: rgb(18, 56, 76);
    --color-blue-900: rgb(19, 44, 58);
    --color-blue-950: rgb(22, 33, 39);

    --theme-border-color: var(--theme-elevation-150);

    --theme-success-50: var(--color-success-50);
    --theme-success-100: var(--color-success-100);
    --theme-success-150: var(--color-success-150);
    --theme-success-200: var(--color-success-200);
    --theme-success-250: var(--color-success-250);
    --theme-success-300: var(--color-success-300);
    --theme-success-350: var(--color-success-350);
    --theme-success-400: var(--color-success-400);
    --theme-success-450: var(--color-success-450);
    --theme-success-500: var(--color-success-500);
    --theme-success-550: var(--color-success-550);
    --theme-success-600: var(--color-success-600);
    --theme-success-650: var(--color-success-650);
    --theme-success-700: var(--color-success-700);
    --theme-success-750: var(--color-success-750);
    --theme-success-800: var(--color-success-800);
    --theme-success-850: var(--color-success-850);
    --theme-success-900: var(--color-success-900);
    --theme-success-950: var(--color-success-950);

    --theme-warning-50: var(--color-warning-50);
    --theme-warning-100: var(--color-warning-100);
    --theme-warning-150: var(--color-warning-150);
    --theme-warning-200: var(--color-warning-200);
    --theme-warning-250: var(--color-warning-250);
    --theme-warning-300: var(--color-warning-300);
    --theme-warning-350: var(--color-warning-350);
    --theme-warning-400: var(--color-warning-400);
    --theme-warning-450: var(--color-warning-450);
    --theme-warning-500: var(--color-warning-500);
    --theme-warning-550: var(--color-warning-550);
    --theme-warning-600: var(--color-warning-600);
    --theme-warning-650: var(--color-warning-650);
    --theme-warning-700: var(--color-warning-700);
    --theme-warning-750: var(--color-warning-750);
    --theme-warning-800: var(--color-warning-800);
    --theme-warning-850: var(--color-warning-850);
    --theme-warning-900: var(--color-warning-900);
    --theme-warning-950: var(--color-warning-950);

    --theme-error-50: var(--color-error-50);
    --theme-error-100: var(--color-error-100);
    --theme-error-150: var(--color-error-150);
    --theme-error-200: var(--color-error-200);
    --theme-error-250: var(--color-error-250);
    --theme-error-300: var(--color-error-300);
    --theme-error-350: var(--color-error-350);
    --theme-error-400: var(--color-error-400);
    --theme-error-450: var(--color-error-450);
    --theme-error-500: var(--color-error-500);
    --theme-error-550: var(--color-error-550);
    --theme-error-600: var(--color-error-600);
    --theme-error-650: var(--color-error-650);
    --theme-error-700: var(--color-error-700);
    --theme-error-750: var(--color-error-750);
    --theme-error-800: var(--color-error-800);
    --theme-error-850: var(--color-error-850);
    --theme-error-900: var(--color-error-900);
    --theme-error-950: var(--color-error-950);

    --theme-elevation-0: var(--color-base-0);
    --theme-elevation-50: var(--color-base-50);
    --theme-elevation-100: var(--color-base-100);
    --theme-elevation-150: var(--color-base-150);
    --theme-elevation-200: var(--color-base-200);
    --theme-elevation-250: var(--color-base-250);
    --theme-elevation-300: var(--color-base-300);
    --theme-elevation-350: var(--color-base-350);
    --theme-elevation-400: var(--color-base-400);
    --theme-elevation-450: var(--color-base-450);
    --theme-elevation-500: var(--color-base-500);
    --theme-elevation-550: var(--color-base-550);
    --theme-elevation-600: var(--color-base-600);
    --theme-elevation-650: var(--color-base-650);
    --theme-elevation-700: var(--color-base-700);
    --theme-elevation-750: var(--color-base-750);
    --theme-elevation-800: var(--color-base-800);
    --theme-elevation-850: var(--color-base-850);
    --theme-elevation-900: var(--color-base-900);
    --theme-elevation-950: var(--color-base-950);
    --theme-elevation-1000: var(--color-base-1000);
  }

  html[data-theme='dark'] {
    --theme-border-color: var(--theme-elevation-150);

    --theme-elevation-0: var(--color-base-900);
    --theme-elevation-50: var(--color-base-850);
    --theme-elevation-100: var(--color-base-800);
    --theme-elevation-150: var(--color-base-750);
    --theme-elevation-200: var(--color-base-700);
    --theme-elevation-250: var(--color-base-650);
    --theme-elevation-300: var(--color-base-600);
    --theme-elevation-350: var(--color-base-550);
    --theme-elevation-400: var(--color-base-450);
    --theme-elevation-450: var(--color-base-400);
    --theme-elevation-550: var(--color-base-350);
    --theme-elevation-600: var(--color-base-300);
    --theme-elevation-650: var(--color-base-250);
    --theme-elevation-700: var(--color-base-200);
    --theme-elevation-750: var(--color-base-150);
    --theme-elevation-800: var(--color-base-100);
    --theme-elevation-850: var(--color-base-50);
    --theme-elevation-900: var(--color-base-0);
    --theme-elevation-950: var(--color-base-0);
    --theme-elevation-1000: var(--color-base-0);

    --theme-success-50: var(--color-success-950);
    --theme-success-100: var(--color-success-900);
    --theme-success-150: var(--color-success-850);
    --theme-success-200: var(--color-success-800);
    --theme-success-250: var(--color-success-750);
    --theme-success-300: var(--color-success-700);
    --theme-success-350: var(--color-success-650);
    --theme-success-400: var(--color-success-600);
    --theme-success-450: var(--color-success-550);
    --theme-success-550: var(--color-success-450);
    --theme-success-600: var(--color-success-400);
    --theme-success-650: var(--color-success-350);
    --theme-success-700: var(--color-success-300);
    --theme-success-750: var(--color-success-250);
    --theme-success-800: var(--color-success-200);
    --theme-success-850: var(--color-success-150);
    --theme-success-900: var(--color-success-100);
    --theme-success-950: var(--color-success-50);

    --theme-warning-50: var(--color-warning-950);
    --theme-warning-100: var(--color-warning-900);
    --theme-warning-150: var(--color-warning-850);
    --theme-warning-200: var(--color-warning-800);
    --theme-warning-250: var(--color-warning-750);
    --theme-warning-300: var(--color-warning-700);
    --theme-warning-350: var(--color-warning-650);
    --theme-warning-400: var(--color-warning-600);
    --theme-warning-450: var(--color-warning-550);
    --theme-warning-550: var(--color-warning-450);
    --theme-warning-600: var(--color-warning-400);
    --theme-warning-650: var(--color-warning-350);
    --theme-warning-700: var(--color-warning-300);
    --theme-warning-750: var(--color-warning-250);
    --theme-warning-800: var(--color-warning-200);
    --theme-warning-850: var(--color-warning-150);
    --theme-warning-900: var(--color-warning-100);
    --theme-warning-950: var(--color-warning-50);

    --theme-error-50: var(--color-error-950);
    --theme-error-100: var(--color-error-900);
    --theme-error-150: var(--color-error-850);
    --theme-error-200: var(--color-error-800);
    --theme-error-250: var(--color-error-750);
    --theme-error-300: var(--color-error-700);
    --theme-error-350: var(--color-error-650);
    --theme-error-400: var(--color-error-600);
    --theme-error-450: var(--color-error-550);
    --theme-error-550: var(--color-error-450);
    --theme-error-600: var(--color-error-400);
    --theme-error-650: var(--color-error-350);
    --theme-error-700: var(--color-error-300);
    --theme-error-750: var(--color-error-250);
    --theme-error-800: var(--color-error-200);
    --theme-error-850: var(--color-error-150);
    --theme-error-900: var(--color-error-100);
    --theme-error-950: var(--color-error-50);
  }
}
</file>

<file path="packages/ui/src/scss/custom.css">
/* Used as a placeholder for when the Payload app does not have custom CSS */
</file>

<file path="packages/ui/src/scss/queries.scss">
////////////////////////////
// MEDIA QUERIES
/////////////////////////////

@mixin extra-small-break {
  @media (max-width: $breakpoint-xs-width) {
    @content;
  }
}

@mixin small-break {
  @media (max-width: $breakpoint-s-width) {
    @content;
  }
}

@mixin mid-break {
  @media (max-width: $breakpoint-m-width) {
    @content;
  }
}

@mixin large-break {
  @media (max-width: $breakpoint-l-width) {
    @content;
  }
}
</file>

<file path="packages/ui/src/scss/resets.scss">
@layer payload-default {
  %btn-reset {
    border: 0;
    background: none;
    box-shadow: none;
    border-radius: 0;
    padding: 0;
    color: currentColor;
  }
}

@mixin btn-reset {
  border: 0;
  background: none;
  box-shadow: none;
  border-radius: 0;
  padding: 0;
  color: currentColor;
}
</file>

<file path="packages/ui/src/scss/styles.scss">
@import 'vars';
@import 'z-index';

//////////////////////////////
// IMPORT OVERRIDES
//////////////////////////////

@import 'type';
@import 'queries';
@import 'resets';
@import 'svg';
</file>

<file path="packages/ui/src/scss/svg.scss">
@mixin color-svg($color) {
  .stroke {
    stroke: $color;
    fill: none;
  }

  .fill {
    fill: $color;
  }
}
</file>

<file path="packages/ui/src/scss/toastify.scss">
@import 'vars';
@import 'queries';

@layer payload-default {
  .Toastify {
    .Toastify__toast-container {
      left: base(5);
      transform: none;
      right: base(5);
      width: auto;
    }

    .Toastify__toast {
      padding: base(0.5);
      border-radius: $style-radius-m;
      font-weight: 600;
    }

    .Toastify__close-button {
      align-self: center;
      opacity: 0.7;

      &:hover {
        opacity: 1;
      }
    }

    .Toastify__toast--success {
      color: var(--color-success-900);
      background: var(--color-success-500);

      .Toastify__progress-bar {
        background-color: var(--color-success-900);
      }
    }

    .Toastify__close-button--success {
      color: var(--color-success-900);
    }

    .Toastify__toast--error {
      background: var(--theme-error-500);
      color: #fff;

      .Toastify__progress-bar {
        background-color: #fff;
      }
    }

    .Toastify__close-button--light {
      color: inherit;
    }

    @include mid-break {
      .Toastify__toast-container {
        left: $baseline;
        right: $baseline;
      }
    }
  }
}
</file>

<file path="packages/ui/src/scss/toasts.scss">
@import './styles.scss';

@layer payload-default {
  .payload-toast-container {
    --offset: calc(var(--gutter-h) / 2);

    padding: 0;
    margin: 0;

    .payload-toast-close-button {
      position: absolute;
      order: 3;
      left: unset;
      inset-inline-end: base(0.8);
      top: 50%;
      transform: translateY(-50%);
      color: var(--theme-elevation-600);
      background: unset;
      border: none;

      svg {
        width: base(0.8);
        height: base(0.8);
      }

      &:hover {
        color: var(--theme-elevation-250);
        background: none;
      }

      [dir='RTL'] & {
        right: unset;
        left: 0.5rem;
      }
    }

    .toast-title {
      line-height: base(1);
      margin-right: base(1);
    }

    .payload-toast-item {
      padding: base(0.8);
      color: var(--theme-elevation-800);
      font-style: normal;
      font-weight: 600;
      display: flex;
      gap: 1rem;
      align-items: center;
      width: 100%;
      border-radius: 4px;
      border: 1px solid var(--theme-border-color);
      background: var(--theme-input-bg);
      box-shadow:
        0px 10px 4px -8px rgba(0, 2, 4, 0.02),
        0px 2px 3px 0px rgba(0, 2, 4, 0.05);

      .toast-content {
        transition: opacity 100ms cubic-bezier(0.55, 0.055, 0.675, 0.19);
        width: 100%;
      }

      &[data-front='false'] {
        .toast-content {
          opacity: 0;
        }
      }

      &[data-expanded='true'] {
        .toast-content {
          opacity: 1;
        }
      }

      .toast-icon {
        width: base(0.8);
        height: base(0.8);
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;

        & > * {
          width: base(1.2);
          height: base(1.2);
        }
      }

      &.toast-warning {
        color: var(--theme-warning-800);
        border-color: var(--theme-warning-250);
        background-color: var(--theme-warning-100);

        .payload-toast-close-button {
          color: var(--theme-warning-600);

          &:hover {
            color: var(--theme-warning-250);
          }
        }
      }

      &.toast-error {
        color: var(--theme-error-800);
        border-color: var(--theme-error-250);
        background-color: var(--theme-error-100);

        .payload-toast-close-button {
          color: var(--theme-error-600);

          &:hover {
            color: var(--theme-error-250);
          }
        }
      }

      &.toast-success {
        color: var(--theme-success-800);
        border-color: var(--theme-success-250);
        background-color: var(--theme-success-100);

        .payload-toast-close-button {
          color: var(--theme-success-600);

          &:hover {
            color: var(--theme-success-250);
          }
        }
      }

      &.toast-info {
        color: var(--theme-elevation-800);
        border-color: var(--theme-elevation-250);
        background-color: var(--theme-elevation-100);

        .payload-toast-close-button {
          color: var(--theme-elevation-600);

          &:hover {
            color: var(--theme-elevation-250);
          }
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/scss/type.scss">
@import 'vars';
@import 'queries';

/////////////////////////////
// HEADINGS
/////////////////////////////

@layer payload-default {
  %h1,
  %h2,
  %h3,
  %h4,
  %h5,
  %h6 {
    font-family: var(--font-body);
    font-weight: 500;
  }

  %h1 {
    margin: 0;
    font-size: base(1.6);
    line-height: base(1.8);

    @include small-break {
      letter-spacing: -0.5px;
      font-size: base(1.25);
    }
  }

  %h2 {
    margin: 0;
    font-size: base(1.3);
    line-height: base(1.6);

    @include small-break {
      font-size: base(0.85);
    }
  }

  %h3 {
    margin: 0;
    font-size: base(1);
    line-height: base(1.2);

    @include small-break {
      font-size: base(0.65);
      line-height: 1.25;
    }
  }

  %h4 {
    margin: 0;
    font-size: base(0.8);
    line-height: base(1);
    letter-spacing: -0.375px;
  }

  %h5 {
    margin: 0;
    font-size: base(0.65);
    line-height: base(0.8);
  }

  %h6 {
    margin: 0;
    font-size: base(0.6);
    line-height: base(0.8);
  }

  %small {
    margin: 0;
    font-size: 12px;
    line-height: 20px;
  }

  /////////////////////////////
  // TYPE STYLES
  /////////////////////////////

  %large-body {
    font-size: base(0.6);
    line-height: base(1);
    letter-spacing: base(0.02);

    @include mid-break {
      font-size: base(0.7);
      line-height: base(1);
    }

    @include small-break {
      font-size: base(0.55);
      line-height: base(0.75);
    }
  }

  %body {
    font-size: $baseline-body-size;
    line-height: $baseline-px;
    font-weight: normal;
    font-family: var(--font-body);
  }

  %code {
    font-size: base(0.4);
    color: var(--theme-elevation-400);

    span {
      color: var(--theme-elevation-800);
    }
  }
}
</file>

<file path="packages/ui/src/scss/vars.scss">
@use 'sass:math';

/////////////////////////////
// BREAKPOINTS
/////////////////////////////

$breakpoint-xs-width: 400px !default;
$breakpoint-s-width: 768px !default;
$breakpoint-m-width: 1024px !default;
$breakpoint-l-width: 1440px !default;

//////////////////////////////
// BASELINE GRID
//////////////////////////////

$baseline-px: 20px !default;
$baseline-body-size: 13px !default;
$baseline: math.div($baseline-px, $baseline-body-size) + rem;

@function base($multiplier) {
  @return ($baseline-px * $multiplier);
}

//////////////////////////////
// COLORS (DEPRECATED. DO NOT USE. PREFER CSS VARIABLES)
//////////////////////////////

$color-dark-gray: #333333 !default;
$color-gray: #9a9a9a !default;
$color-light-gray: #dadada !default;
$color-background-gray: #f3f3f3 !default;
$color-red: #ff6f76 !default;
$color-yellow: #fdffa4 !default;
$color-green: #b2ffd6 !default;
$color-purple: #f3ddf3 !default;

//////////////////////////////
// STYLES
//////////////////////////////

$style-radius-s: 3px !default;
$style-radius-m: 4px !default;
$style-radius-l: 8px !default;
$style-stroke-width: 1px !default;

$style-stroke-width-s: 1px !default;
$style-stroke-width-m: 2px !default;

//////////////////////////////
// MISC
//////////////////////////////

$top-header-offset: calc(base(1) - 1px);
$top-header-offset-m: base(3);
$focus-box-shadow: 0 0 0 $style-stroke-width-m var(--theme-success-500);

//////////////////////////////
// SHADOWS
//////////////////////////////

@mixin shadow-sm {
  box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.1);
}

@mixin shadow-m {
  box-shadow: 0 4px 8px -3px rgba(0, 0, 0, 0.1);
}

@mixin shadow-lg {
  box-shadow: 0 -2px 16px -2px rgba(0, 0, 0, 0.2);
}

@mixin shadow-lg-top {
  box-shadow: 0 2px 16px -2px rgba(0, 0, 0, 0.2);
}

@mixin inputShadow {
  @include shadow-sm;

  &:not(:disabled) {
    &:hover {
      box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.2);
    }
  }
}

@mixin soft-shadow-bottom {
  box-shadow: 0 7px 14px 0px rgb(0 0 0 / 5%);
}

//////////////////////////////
// STYLE MIXINS
//////////////////////////////

@mixin blur-bg($color: var(--theme-bg), $opacity: 0.75) {
  &:before,
  &:after {
    content: ' ';
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  &:before {
    background: $color;
    opacity: $opacity;
  }

  &:after {
    backdrop-filter: blur(8px);
  }
}

@mixin blur-bg-light {
  @include blur-bg(var(--theme-bg), 0.3);
}

@mixin readOnly {
  background: var(--theme-elevation-100);
  color: var(--theme-elevation-400);
  box-shadow: none;

  &:hover {
    border-color: var(--theme-elevation-150);
    box-shadow: none;
  }
}

@mixin formInput() {
  @include inputShadow;
  font-family: var(--font-body);
  width: 100%;
  border: 1px solid var(--theme-elevation-150);
  border-radius: var(--style-radius-s);
  background: var(--theme-input-bg);
  color: var(--theme-elevation-800);
  font-size: 1rem;
  height: base(2);
  line-height: base(1);
  padding: base(0.4) base(0.75);
  -webkit-appearance: none;
  transition-property: border, box-shadow, background-color;
  transition-duration: 100ms, 100ms, 500ms;
  transition-timing-function: cubic-bezier(0, 0.2, 0.2, 1);

  &[data-rtl='true'] {
    direction: rtl;
  }

  &::-webkit-input-placeholder {
    color: var(--theme-elevation-400);
    font-weight: normal;
    font-size: 1rem;
  }

  &::-moz-placeholder {
    color: var(--theme-elevation-400);
    font-weight: normal;
    font-size: 1rem;
  }

  &:hover {
    border-color: var(--theme-elevation-250);
  }

  &:focus,
  &:focus-within,
  &:active {
    border-color: var(--theme-elevation-400);
    outline: 0;
  }

  &:disabled {
    @include readOnly;
  }
}

@mixin lightInputError {
  background-color: var(--theme-error-50);
  border: 1px solid var(--theme-error-500);
}

@mixin darkInputError {
  background-color: var(--theme-error-100);
  border: 1px solid var(--theme-error-400);

  &:hover {
    border-color: var(--theme-error-500);
  }
}
</file>

<file path="packages/ui/src/scss/z-index.scss">
/////////////////////////////
// Z-INDEX CHART (DEPRECATED. DO NOT USE. PREFER CSS VARIABLES)
/////////////////////////////

$z-page: 20;
$z-page-content: 30;
$z-nav: 40;
$z-modal: 50;
$z-status: 60;
</file>

<file path="packages/ui/src/utilities/buildClientFieldSchemaMap/index.ts">
import type { I18n } from '@convexcms/translations'
import type {
  ClientConfig,
  ClientField,
  ClientFieldSchemaMap,
  FieldSchemaMap,
  Payload,
  TextFieldClient,
} from '@convexcms/core'
⋮----
import { traverseFields } from './traverseFields.js'
⋮----
/**
 * Flattens the config fields into a map of field schemas
 */
export const buildClientFieldSchemaMap = (args: {
  collectionSlug?: string
  config: ClientConfig
  globalSlug?: string
  i18n: I18n
  payload: Payload
  schemaMap: FieldSchemaMap
}):
⋮----
// Place these fields _last_ to ensure they do not disrupt field paths in the field schema map
</file>

<file path="packages/ui/src/utilities/buildClientFieldSchemaMap/traverseFields.ts">
import type { I18n } from '@convexcms/translations'
⋮----
import {
  type ClientBlock,
  type ClientConfig,
  type ClientField,
  type ClientFieldSchemaMap,
  createClientFields,
  type Field,
  type FieldSchemaMap,
  type Payload,
} from '@convexcms/core'
import { getFieldPaths, tabHasName } from '@convexcms/core/shared'
⋮----
type Args = {
  clientSchemaMap: ClientFieldSchemaMap
  config: ClientConfig
  fields: ClientField[]
  i18n: I18n<any, any>
  parentIndexPath: string
  parentSchemaPath: string
  payload: Payload
  schemaMap: FieldSchemaMap
}
⋮----
export const traverseFields = ({
  clientSchemaMap,
  config,
  fields,
  i18n,
  parentIndexPath,
  parentSchemaPath,
  payload,
  schemaMap,
}: Args) =>
⋮----
// richText sub-fields are not part of the ClientConfig or the Config.
// They only exist in the field schema map.
// Thus, we need to
// 1. get them from the field schema map
// 2. convert them to client fields
// 3. add them to the client schema map
⋮----
// So these would basically be all fields that are not part of the client config already
⋮----
// Now loop through them, convert each entry to a client field and add it to the client schema map
⋮----
// check if fields is the only key in the subField object
</file>

<file path="packages/ui/src/utilities/buildFieldSchemaMap/index.ts">
import type { I18n } from '@convexcms/translations'
import type { Field, FieldSchemaMap, SanitizedConfig, TextField } from '@convexcms/core'
⋮----
import { confirmPassword, password } from '@convexcms/core/shared'
⋮----
import { traverseFields } from './traverseFields.js'
⋮----
/**
 * Flattens the config fields into a map of field schemas
 */
export const buildFieldSchemaMap = (args: {
  collectionSlug?: string
  config: SanitizedConfig
  globalSlug?: string
  i18n: I18n
}):
⋮----
// Place these fields _last_ to ensure they do not disrupt field paths in the field schema map
</file>

<file path="packages/ui/src/utilities/buildFieldSchemaMap/traverseFields.ts">
import type { I18n } from '@convexcms/translations'
import type { Field, FieldSchemaMap, SanitizedConfig } from '@convexcms/core'
⋮----
import { MissingEditorProp } from '@convexcms/core'
import { getFieldPaths, tabHasName } from '@convexcms/core/shared'
⋮----
type Args = {
  config: SanitizedConfig
  fields: Field[]
  i18n: I18n<any, any>
  parentIndexPath: string
  parentSchemaPath: string
  schemaMap: FieldSchemaMap
}
⋮----
export const traverseFields = ({
  config,
  fields,
  i18n,
  parentIndexPath,
  parentSchemaPath,
  schemaMap,
}: Args) =>
⋮----
// TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks
⋮----
throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
</file>

<file path="packages/ui/src/utilities/formatDocTitle/formatDateTitle.ts">
import type { I18n } from '@convexcms/translations'
⋮----
import { TZDateMini as TZDate } from '@date-fns/tz/date/mini'
import { format, formatDistanceToNow, transpose } from 'date-fns'
⋮----
type FormatDateArgs = {
  date: Date | number | string | undefined
  i18n: I18n<any, any>
  pattern: string
  timezone?: string
}
⋮----
export const formatDate = (
⋮----
// Transpose the date to the selected timezone
⋮----
// Transpose the date to the user's timezone - this is necessary because the react-datepicker component insists on displaying the date in the user's timezone
⋮----
type FormatTimeToNowArgs = {
  date: Date | number | string | undefined
  i18n: I18n<any, any>
}
⋮----
export const formatTimeToNow = (
</file>

<file path="packages/ui/src/utilities/formatDocTitle/formatLexicalDocTitle.ts">
type SerializedLexicalEditor = {
  root: {
    children: Array<{ children?: Array<{ type: string }>; type: string }>
  }
}
⋮----
export function isSerializedLexicalEditor(value: unknown): value is SerializedLexicalEditor
⋮----
export function formatLexicalDocTitle(
  editorState: Array<{ children?: Array<{ type: string }>; type: string }>,
  textContent: string,
): string
</file>

<file path="packages/ui/src/utilities/formatDocTitle/index.ts">
import type { I18n } from '@convexcms/translations'
import type {
  ClientCollectionConfig,
  ClientGlobalConfig,
  SanitizedConfig,
  TypeWithID,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
⋮----
import { formatDate } from './formatDateTitle.js'
import { formatLexicalDocTitle, isSerializedLexicalEditor } from './formatLexicalDocTitle.js'
⋮----
export const formatDocTitle = ({
  collectionConfig,
  data,
  dateFormat: dateFormatFromConfig,
  fallback,
  globalConfig,
  i18n,
}: {
  collectionConfig?: ClientCollectionConfig
  data: TypeWithID
  dateFormat: SanitizedConfig['admin']['dateFormat']
  fallback?: object | string
  globalConfig?: ClientGlobalConfig
  i18n: I18n<any, any>
}): string =>
⋮----
// richtext lexical case. We convert the first child of root to plain text
</file>

<file path="packages/ui/src/utilities/abortAndIgnore.ts">
export function abortAndIgnore(abortController: AbortController)
⋮----
// swallow error
⋮----
/**
 * Use this function when an effect is triggered multiple times over and you want to cancel the previous effect.
 * It will abort the previous effect and create a new AbortController for the next effect.
 * Important: You must also _reset_ the `abortControllerRef` after the effect is done, otherwise the next effect will be aborted immediately.
 * For example, run `abortControllerRef.current = null` in a `finally` block or after an awaited promise.
 * @param abortControllerRef
 * @returns {AbortController}
 */
export function handleAbortRef(
  abortControllerRef: React.RefObject<AbortController>,
): AbortController
⋮----
// swallow error
</file>

<file path="packages/ui/src/utilities/api.ts">
type GetOptions = {
  params?: Record<string, unknown>
} & RequestInit
</file>

<file path="packages/ui/src/utilities/buildFormState.ts">
import type { BuildFormStateArgs, ClientConfig, ClientUser, ErrorResult, FormState } from '@convexcms/core'
⋮----
import { formatErrors } from '@convexcms/core'
import { getSelectMode, reduceFieldsToValues } from '@convexcms/core/shared'
⋮----
import { fieldSchemasToFormState } from '../forms/fieldSchemasToFormState/index.js'
import { renderField } from '../forms/fieldSchemasToFormState/renderField.js'
import { getClientConfig } from './getClientConfig.js'
import { getClientSchemaMap } from './getClientSchemaMap.js'
import { getSchemaMap } from './getSchemaMap.js'
import { handleFormStateLocking } from './handleFormStateLocking.js'
⋮----
export type LockedState = {
  isLocked: boolean
  lastEditedAt: string
  user: ClientUser | number | string
}
⋮----
type BuildFormStateSuccessResult = {
  clientConfig?: ClientConfig
  errors?: never
  indexPath?: string
  lockedState?: LockedState
  state: FormState
}
⋮----
type BuildFormStateErrorResult = {
  lockedState?: never
  state?: never
} & (
  | {
      message: string
    }
  | ErrorResult
)
⋮----
export type BuildFormStateResult = BuildFormStateErrorResult | BuildFormStateSuccessResult
⋮----
export const buildFormStateHandler = async (
  args: BuildFormStateArgs,
): Promise<BuildFormStateResult> =>
⋮----
// If we have a user slug, test it against the functions
⋮----
// Run the admin access function from the config if it exists
⋮----
// Match the user collection to the global admin config
⋮----
// If there are users, we should not allow access because of /create-first-user
⋮----
export const buildFormState = async (
  args: BuildFormStateArgs,
): Promise<BuildFormStateSuccessResult> =>
⋮----
// If there is a form state,
// then we can deduce data from that form state
⋮----
/**
   * When building state for sub schemas we need to adjust:
   * - `fields`
   * - `parentSchemaPath`
   * - `parentPath`
   *
   * Type assertion is fine because we wrap sub schemas in an array
   * so we can safely map over them within `fieldSchemasToFormState`
   */
⋮----
// Maintain form state of auth / upload fields
</file>

<file path="packages/ui/src/utilities/buildTableState.ts">
import type {
  BuildTableStateArgs,
  ClientCollectionConfig,
  ClientConfig,
  Column,
  ErrorResult,
  ListPreferences,
  PaginatedDocs,
  SanitizedCollectionConfig,
  Where,
} from '@convexcms/core'
⋮----
import { APIError, formatErrors } from '@convexcms/core'
import { isNumber } from '@convexcms/core/shared'
⋮----
import { getClientConfig } from './getClientConfig.js'
import { renderFilters, renderTable } from './renderTable.js'
import { upsertPreferences } from './upsertPreferences.js'
⋮----
type BuildTableStateSuccessResult = {
  clientConfig?: ClientConfig
  data: PaginatedDocs
  errors?: never
  preferences: ListPreferences
  renderedFilters: Map<string, React.ReactNode>
  state: Column[]
  Table: React.ReactNode
}
⋮----
type BuildTableStateErrorResult = {
  data?: any
  renderedFilters?: never
  state?: never
  Table?: never
} & (
  | {
      message: string
    }
  | ErrorResult
)
⋮----
export type BuildTableStateResult = BuildTableStateErrorResult | BuildTableStateSuccessResult
⋮----
export const buildTableStateHandler = async (
  args: BuildTableStateArgs,
): Promise<BuildTableStateResult> =>
⋮----
const buildTableState = async (
  args: BuildTableStateArgs,
): Promise<BuildTableStateSuccessResult> =>
⋮----
// If we have a user slug, test it against the functions
⋮----
// Run the admin access function from the config if it exists
⋮----
// Match the user collection to the global admin config
⋮----
// If there are users, we should not allow access because of /create-first-user
⋮----
// lookup docs, if desired, i.e. within `join` field which initialize with `depth: 0`
⋮----
columnPreferences: Array.isArray(collectionSlug) ? listPreferences?.columns : undefined, // TODO, might not be neededcolumns,
</file>

<file path="packages/ui/src/utilities/canUseDOM.ts">

</file>

<file path="packages/ui/src/utilities/combineFieldLabel.tsx">
import type { ClientField } from '@convexcms/core'
⋮----
import { Fragment } from 'react'
⋮----
import { RenderCustomComponent } from '../elements/RenderCustomComponent/index.js'
import { FieldLabel } from '../fields/FieldLabel/index.js'
</file>

<file path="packages/ui/src/utilities/copyDataFromLocale.ts">
import ObjectIdImport from 'bson-objectid'
import {
  type CollectionSlug,
  type Data,
  type Field,
  type FlattenedBlock,
  formatErrors,
  type PayloadRequest,
} from '@convexcms/core'
import { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '@convexcms/core/shared'
⋮----
export type CopyDataFromLocaleArgs = {
  collectionSlug?: CollectionSlug
  docID?: number | string
  fromLocale: string
  globalSlug?: string
  overrideData?: boolean
  req: PayloadRequest
  toLocale: string
}
⋮----
function iterateFields(
  fields: Field[],
  fromLocaleData: Data,
  toLocaleData: Data,
  req: PayloadRequest,
  parentIsLocalized: boolean,
): void
⋮----
// if the field has no value, take the source value
⋮----
// only replace if the target value is null or undefined
⋮----
// if the field has a value - loop over the data from target
⋮----
// Generate new IDs if the field is localized to prevent errors with relational DBs.
⋮----
// if the field has no value, take the source value
⋮----
// only replace if the target value is null or undefined
⋮----
// if the field has a value - loop over the data from target
⋮----
// Generate new IDs if the field is localized to prevent errors with relational DBs.
⋮----
// only replace if the target value is null or undefined
⋮----
function mergeData(
  fromLocaleData: Data,
  toLocaleData: Data,
  fields: Field[],
  req: PayloadRequest,
  parentIsLocalized: boolean,
): Data
⋮----
export const copyDataFromLocaleHandler = async (args: CopyDataFromLocaleArgs) =>
⋮----
export const copyDataFromLocale = async (args: CopyDataFromLocaleArgs) =>
⋮----
// If we have a user slug, test it against the functions
⋮----
// Run the admin access function from the config if it exists
⋮----
// Match the user collection to the global admin config
⋮----
// `select` would allow us to select only the fields we need in the future
⋮----
// `select` would allow us to select only the fields we need in the future
⋮----
// `select` would allow us to select only the fields we need in the future
⋮----
// `select` would allow us to select only the fields we need in the future
</file>

<file path="packages/ui/src/utilities/dateLocales.ts">
import { ar } from 'date-fns/locale/ar'
import { az } from 'date-fns/locale/az'
import { bg } from 'date-fns/locale/bg'
import { cs } from 'date-fns/locale/cs'
import { de } from 'date-fns/locale/de'
import { enUS } from 'date-fns/locale/en-US'
import { es } from 'date-fns/locale/es'
import { faIR } from 'date-fns/locale/fa-IR'
import { fr } from 'date-fns/locale/fr'
import { hr } from 'date-fns/locale/hr'
import { hu } from 'date-fns/locale/hu'
import { it } from 'date-fns/locale/it'
import { ja } from 'date-fns/locale/ja'
import { ko } from 'date-fns/locale/ko'
import { nb } from 'date-fns/locale/nb'
import { nl } from 'date-fns/locale/nl'
import { pl } from 'date-fns/locale/pl'
import { pt } from 'date-fns/locale/pt'
import { ro } from 'date-fns/locale/ro'
import { ru } from 'date-fns/locale/ru'
import { sv } from 'date-fns/locale/sv'
import { th } from 'date-fns/locale/th'
import { tr } from 'date-fns/locale/tr'
import { vi } from 'date-fns/locale/vi'
import { zhCN } from 'date-fns/locale/zh-CN'
import { zhTW } from 'date-fns/locale/zh-TW'
</file>

<file path="packages/ui/src/utilities/deepMerge.ts">
/**
 * Very simple, but fast deepMerge implementation. Only deepMerges objects, not arrays and clones everything.
 * Do not use this if your object contains any complex objects like React Components, or if you would like to combine Arrays.
 * If you only have simple objects and need a fast deepMerge, this is the function for you.
 *
 * obj2 takes precedence over obj1 - thus if obj2 has a key that obj1 also has, obj2's value will be used.
 *
 * @param obj1 base object
 * @param obj2 object to merge "into" obj1
 */
export function deepMergeSimple<T = object>(obj1: object, obj2: object): T
</file>

<file path="packages/ui/src/utilities/filterOutUploadFields.ts">
import type { FieldWithPathClient } from '@convexcms/core'
⋮----
export const filterOutUploadFields = (fields: FieldWithPathClient[]): FieldWithPathClient[] =>
⋮----
// List of reserved upload field names
</file>

<file path="packages/ui/src/utilities/findLocaleFromCode.ts">
import type { Locale, SanitizedLocalizationConfig } from '@convexcms/core'
/*
 return the Locale for given locale code, else return null
*/
export const findLocaleFromCode = (
  localizationConfig: SanitizedLocalizationConfig,
  locale: string,
): Locale | null =>
</file>

<file path="packages/ui/src/utilities/formatAdminURL.ts">
/** Will read the `routes.admin` config and appropriately handle `"/"` admin paths */
</file>

<file path="packages/ui/src/utilities/formatFields.ts">
import type { Field } from '@convexcms/core'
⋮----
import { fieldAffectsData, fieldIsID } from '@convexcms/core/shared'
⋮----
export const formatFields = (fields: Field[], isEditing?: boolean): Field[]
</file>

<file path="packages/ui/src/utilities/generateFieldID.ts">
export const generateFieldID = (path: string, editDepth: number, uuid: string) =>
</file>

<file path="packages/ui/src/utilities/getBestFitFromSizes.ts">
/**
 * Takes image sizes and a target range and returns the url of the image within that range.
 * If no images fit within the range, it selects the next smallest adequate image, the original,
 * or the largest smaller image if no better fit exists.
 *
 * @param sizes The given FileSizes.
 * @param targetSizeMax The ideal image maximum width. Defaults to 180.
 * @param targetSizeMin The ideal image minimum width. Defaults to 40.
 * @param thumbnailURL The thumbnail url set in config. If passed a url, will return early with it.
 * @param url The url of the original file.
 * @param width The width of the original file.
 * @returns A url of the best fit file.
 */
export const getBestFitFromSizes = ({
  sizes,
  targetSizeMax = 180,
  targetSizeMin = 40,
  thumbnailURL,
  url,
  width,
}: {
  sizes?: Record<string, { url?: string; width?: number }>
  targetSizeMax?: number
  targetSizeMin?: number
  thumbnailURL?: string
  url: string
  width?: number
}) =>
</file>

<file path="packages/ui/src/utilities/getClientConfig.ts">
import type { I18nClient, SupportedLanguages } from '@convexcms/translations'
import type { ClientConfig, ImportMap, SanitizedConfig } from '@convexcms/core'
⋮----
import { createClientConfig } from '@convexcms/core'
import { cache } from 'react'
</file>

<file path="packages/ui/src/utilities/getClientSchemaMap.ts">
import type { I18n, I18nClient } from '@convexcms/translations'
import type { ClientConfig, ClientFieldSchemaMap, FieldSchemaMap, Payload } from '@convexcms/core'
⋮----
import { cache } from 'react'
⋮----
import { buildClientFieldSchemaMap } from './buildClientFieldSchemaMap/index.js'
</file>

<file path="packages/ui/src/utilities/getDisplayedFieldValue.ts">
import type { I18nClient } from '@convexcms/translations'
import type { ClientField } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
/**
 * Returns the appropriate display value for a field.
 * - For select and radio fields:
 *   - Returns JSX elements as-is.
 *   - Translates localized label objects based on the current language.
 *   - Returns string labels directly.
 *   - Falls back to the option value if no valid label is found.
 * - For all other field types, returns `cellData` unchanged.
 */
export const getDisplayedFieldValue = (cellData: any, field: ClientField, i18n: I18nClient) =>
⋮----
? selectedOption.label // Return JSX directly
: getTranslation(selectedOption.label, i18n) || selectedOption.value // Use translation or fallback to value
⋮----
return selectedOption // If option is a string, return it directly
⋮----
return cellData // Default fallback if no match found
</file>

<file path="packages/ui/src/utilities/getOffsetTop.ts">
export const getOffsetTop = (element: HTMLElement): number =>
⋮----
// Set our distance placeholder
⋮----
// Loop up the DOM
⋮----
// Return our distance
</file>

<file path="packages/ui/src/utilities/getRequestLanguage.ts">
import type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies.js'
⋮----
type GetRequestLanguageArgs = {
  cookies: Map<string, string> | ReadonlyRequestCookies
  defaultLanguage?: string
  headers: Request['headers']
}
⋮----
export const getRequestLanguage = ({
  cookies,
  defaultLanguage = 'en',
  headers,
}: GetRequestLanguageArgs): string =>
</file>

<file path="packages/ui/src/utilities/getSchemaMap.ts">
import type { I18n, I18nClient } from '@convexcms/translations'
import type { FieldSchemaMap, SanitizedConfig } from '@convexcms/core'
⋮----
import { cache } from 'react'
⋮----
import { buildFieldSchemaMap } from './buildFieldSchemaMap/index.js'
</file>

<file path="packages/ui/src/utilities/getSupportedMonacoLocale.ts">
export const getSupportedMonacoLocale = (locale: string): string =>
</file>

<file path="packages/ui/src/utilities/groupNavItems.ts">
import type { I18nClient } from '@convexcms/translations'
import type {
  SanitizedCollectionConfig,
  SanitizedGlobalConfig,
  SanitizedPermissions,
  StaticLabel,
} from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
⋮----
export enum EntityType {
  collection = 'collections',
  global = 'globals',
}
⋮----
export type EntityToGroup =
  | {
      entity: SanitizedCollectionConfig
      type: EntityType.collection
    }
  | {
      entity: SanitizedGlobalConfig
      type: EntityType.global
    }
⋮----
export type NavGroupType = {
  entities: {
    label: StaticLabel
    slug: string
    type: EntityType
  }[]
  label: string
}
⋮----
export function groupNavItems(
  entities: EntityToGroup[],
  permissions: SanitizedPermissions,
  i18n: I18nClient,
): NavGroupType[]
⋮----
// Skip entities where admin.group is explicitly false
</file>

<file path="packages/ui/src/utilities/handleBackToDashboard.tsx">
import type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'
⋮----
import { formatAdminURL } from '@convexcms/core/shared'
⋮----
type BackToDashboardProps = {
  adminRoute: string
  router: AppRouterInstance
}
⋮----
export const handleBackToDashboard = (
</file>

<file path="packages/ui/src/utilities/handleFormStateLocking.ts">
import type { PayloadRequest, TypedUser } from '@convexcms/core'
⋮----
type Args = {
  collectionSlug?: string
  globalSlug?: string
  id?: number | string
  req: PayloadRequest
  updateLastEdited?: boolean
}
⋮----
type Result = {
  isLocked: boolean
  lastEditedAt: string
  user: TypedUser
}
⋮----
const lockDurationDefault = 300 // Default 5 minutes in seconds
⋮----
export const handleFormStateLocking = async ({
  id,
  collectionSlug,
  globalSlug,
  req,
  updateLastEdited,
}: Args): Promise<Result> =>
⋮----
// Query where the lock is newer than the current time minus the lock duration
⋮----
// Should only update doc if the incoming / current user is also the owner of the locked doc
⋮----
// If NO ACTIVE lock document exists, first delete any expired locks and then create a fresh lock
// Where updatedAt is older than the duration that is specified in the config
</file>

<file path="packages/ui/src/utilities/handleGoBack.tsx">
import type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'
⋮----
import { formatAdminURL } from '@convexcms/core/shared'
⋮----
type GoBackProps = {
  adminRoute: string
  collectionSlug: string
  router: AppRouterInstance
}
⋮----
export const handleGoBack = (
</file>

<file path="packages/ui/src/utilities/handleTakeOver.tsx">
import type { ClientUser } from '@convexcms/core'
⋮----
export const handleTakeOver = (
  id: number | string,
  collectionSlug: string,
  globalSlug: string,
  user: ClientUser | number | string,
  isWithinDoc: boolean,
  updateDocumentEditor: (
    docID: number | string,
    slug: string,
    user: ClientUser | number | string,
  ) => Promise<void>,
  setCurrentEditor: (value: React.SetStateAction<ClientUser | number | string>) => void,
  documentLockStateRef: React.RefObject<{
    hasShownLockedModal: boolean
    isLocked: boolean
    user: ClientUser | number | string
  }>,
  isLockingEnabled: boolean,
  setIsReadOnlyForIncomingUser?: (value: React.SetStateAction<boolean>) => void,
): void =>
⋮----
// Call updateDocumentEditor to update the document's owner to the current user
⋮----
// Update the locked state to reflect the current user as the owner
⋮----
// If this is a takeover within the document, ensure the document is editable
⋮----
// eslint-disable-next-line no-console
</file>

<file path="packages/ui/src/utilities/hasOptionLabelJSXElement.ts">
import type { DefaultCellComponentProps } from '@convexcms/core'
⋮----
import React from 'react'
⋮----
export const hasOptionLabelJSXElement = (cellClientProps: DefaultCellComponentProps) =>
</file>

<file path="packages/ui/src/utilities/hasSavePermission.ts">
import type {
  SanitizedCollectionPermission,
  SanitizedDocumentPermissions,
  SanitizedGlobalPermission,
} from '@convexcms/core'
⋮----
export const hasSavePermission = (args: {
  /*
   * Pass either `collectionSlug` or `globalSlug`
   */
  collectionSlug?: string
  docPermissions: SanitizedDocumentPermissions
  /*
   * Pass either `collectionSlug` or `globalSlug`
   */
  globalSlug?: string
  isEditing: boolean
}) =>
⋮----
/*
   * Pass either `collectionSlug` or `globalSlug`
   */
⋮----
/*
   * Pass either `collectionSlug` or `globalSlug`
   */
</file>

<file path="packages/ui/src/utilities/isClientUserObject.ts">
import type { ClientUser } from '@convexcms/core'
⋮----
export const isClientUserObject = (user): user is ClientUser =>
</file>

<file path="packages/ui/src/utilities/isEditing.ts">
export const isEditing = (
</file>

<file path="packages/ui/src/utilities/isURLAllowed.ts">
import type { AllowList } from '@convexcms/core'
⋮----
export const isURLAllowed = (url: string, allowList: AllowList): boolean =>
⋮----
// Skip undefined or null values
⋮----
// Compare protocol with colon
⋮----
// Convert wildcards to a regex
⋮----
.replace(/\*\*/g, '.*') // Match any path
.replace(/\*/g, '[^/]*') // Match any part of a path segment
⋮----
// Default comparison for all other properties (hostname, port, search)
⋮----
return false // If the URL is invalid, deny by default
</file>

<file path="packages/ui/src/utilities/parseSearchParams.ts">
import type { ReadonlyURLSearchParams } from 'next/navigation.js'
⋮----
/**
 * A utility function to parse URLSearchParams into a ParsedQs object.
 * This function is a wrapper around the `qs` library.
 * In Next.js, the `useSearchParams()` hook from `next/navigation` returns a `URLSearchParams` object.
 * This function can be used to parse that object into a more usable format.
 * @param {ReadonlyURLSearchParams} searchParams - The URLSearchParams object to parse.
 * @returns {qs.ParsedQs} - The parsed query string object.
 */
export function parseSearchParams(searchParams: ReadonlyURLSearchParams): qs.ParsedQs
</file>

<file path="packages/ui/src/utilities/reduceFieldsToValuesWithValidation.ts">
import type { Data, FormState } from '@convexcms/core'
⋮----
import { unflatten as flatleyUnflatten } from '@convexcms/core/shared'
⋮----
type ReturnType = {
  data: Data
  valid: boolean
}
⋮----
/**
 * Reduce flattened form fields (Fields) to just map to the respective values instead of the full FormField object
 *
 * @param unflatten This also unflattens the data if `unflatten` is true. The unflattened data should match the original data structure
 * @param ignoreDisableFormData - if true, will include fields that have `disableFormData` set to true, for example, blocks or arrays fields.
 *
 */
export const reduceFieldsToValuesWithValidation = (
  fields: FormState,
  unflatten?: boolean,
  ignoreDisableFormData?: boolean,
): ReturnType =>
</file>

<file path="packages/ui/src/utilities/removeUndefined.ts">
export function removeUndefined<T extends object>(obj: T): T
</file>

<file path="packages/ui/src/utilities/renderTable.tsx">
import type {
  ClientCollectionConfig,
  ClientConfig,
  ClientField,
  CollectionConfig,
  Field,
  ImportMap,
  ListPreferences,
  PaginatedDocs,
  Payload,
  SanitizedCollectionConfig,
} from '@convexcms/core'
⋮----
import { getTranslation, type I18nClient } from '@convexcms/translations'
import { fieldAffectsData, fieldIsHiddenOrDisabled, flattenTopLevelFields } from '@convexcms/core/shared'
import React from 'react'
⋮----
// eslint-disable-next-line payload/no-imports-from-exports-dir
import type { Column } from '../exports/client/index.js'
⋮----
import { RenderServerComponent } from '../elements/RenderServerComponent/index.js'
import {
  OrderableTable,
  Pill,
  SelectAll,
  SelectRow,
  SortHeader,
  SortRow,
  Table,
  // eslint-disable-next-line payload/no-imports-from-exports-dir
} from '../exports/client/index.js'
⋮----
// eslint-disable-next-line payload/no-imports-from-exports-dir
⋮----
import { buildColumnState } from '../providers/TableColumns/buildColumnState.js'
import { buildPolymorphicColumnState } from '../providers/TableColumns/buildPolymorphicColumnState.js'
import { filterFields } from '../providers/TableColumns/filterFields.js'
import { getInitialColumns } from '../providers/TableColumns/getInitialColumns.js'
⋮----
export const renderFilters = (
  fields: Field[],
  importMap: ImportMap,
): Map<string, React.ReactNode>
⋮----
// Ensure that columns passed as args comply with the field config, i.e. `hidden`, `disableListColumn`, etc.
⋮----
// sortColumnProps,
⋮----
// sortColumnProps,
⋮----
// key is required since Next.js 15.2.0 to prevent React key error
⋮----
// key is required since Next.js 15.2.0 to prevent React key error
</file>

<file path="packages/ui/src/utilities/resolveFilterOptions.ts">
import type { FilterOptions, FilterOptionsProps, ResolvedFilterOptions } from '@convexcms/core'
⋮----
export const resolveFilterOptions = async (
  filterOptions: FilterOptions,
  options: { relationTo: string | string[] } & Omit<FilterOptionsProps, 'relationTo'>,
): Promise<ResolvedFilterOptions> =>
⋮----
// this is an ugly way to prevent results from being returned
</file>

<file path="packages/ui/src/utilities/sanitizeID.ts">
export function sanitizeID(id: number | string): number | string
</file>

<file path="packages/ui/src/utilities/schedulePublishHandler.ts">
import type { PayloadRequest, SchedulePublishTaskInput } from '@convexcms/core'
⋮----
export type SchedulePublishHandlerArgs = {
  date?: Date
  /**
   * The job id to delete to remove a scheduled publish event
   */
  deleteID?: number | string
  req: PayloadRequest
  timezone?: string
} & SchedulePublishTaskInput
⋮----
/**
   * The job id to delete to remove a scheduled publish event
   */
⋮----
export const schedulePublishHandler = async ({
  type,
  date,
  deleteID,
  doc,
  global,
  locale,
  req,
  timezone,
}: SchedulePublishHandlerArgs) =>
⋮----
// Run the admin access function from the config if it exists
⋮----
// Match the user collection to the global admin config
</file>

<file path="packages/ui/src/utilities/scrollToID.ts">
export const scrollToID = (id: string): void =>
</file>

<file path="packages/ui/src/utilities/setsAreEqual.ts">
/**
 * Function to determine whether two sets are equal or not.
 */
export const setsAreEqual = <T>(lhs: Set<T>, rhs: Set<T>) =>
</file>

<file path="packages/ui/src/utilities/upsertPreferences.ts">
import type { DefaultDocumentIDType, Payload, PayloadRequest } from '@convexcms/core'
⋮----
import { dequal } from 'dequal/lite'
import { cache } from 'react'
⋮----
import { removeUndefined } from './removeUndefined.js'
⋮----
/**
 * Will update the given preferences by key, creating a new record if it doesn't already exist, or merging existing preferences with the new value.
 * This is not possible to do with the existing `db.upsert` operation because it stores on the `value` key and does not perform a deep merge beyond the first level.
 * I.e. if you have a preferences record with a `value` key, `db.upsert` will overwrite the existing value. In the future if this supported we should use that instead.
 * @param req - The PayloadRequest object
 * @param key - The key of the preferences to update
 * @param value - The new value to merge with the existing preferences
 */
export const upsertPreferences = async <T extends Record<string, unknown> | string>({
  customMerge,
  key,
  req,
  value: incomingValue,
}: {
  key: string
  req: PayloadRequest
} & (
  | {
      customMerge: (existingValue: T) => T
      value?: never
    }
  | {
      customMerge?: never
      value: T
    }
)): Promise<T> =>
⋮----
// Strings are valid JSON, i.e. `locale` saved as a string to the locale preferences
⋮----
...(typeof existingPrefs.value === 'object' ? existingPrefs?.value : {}), // Shallow merge existing prefs to acquire any missing keys from incoming value
</file>

<file path="packages/ui/src/views/Edit/Auth/APIKey.tsx">
import type { PayloadRequest, TextFieldClient } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { text } from '@convexcms/core/shared'
import React, { useEffect, useMemo, useState } from 'react'
import { v4 as uuidv4 } from 'uuid'
⋮----
import { CopyToClipboard } from '../../../elements/CopyToClipboard/index.js'
import { GenerateConfirmation } from '../../../elements/GenerateConfirmation/index.js'
import { useFormFields } from '../../../forms/Form/context.js'
import { useField } from '../../../forms/useField/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
const validate = (val)
⋮----
const highlightField = () =>
</file>

<file path="packages/ui/src/views/Edit/Auth/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .auth-fields {
    padding: calc(var(--base) * 2);
    background: var(--theme-elevation-50);
    display: flex;
    flex-direction: column;
    gap: var(--base);

    &__controls {
      display: flex;
      align-items: center;
      gap: calc(var(--base) / 2);
      flex-wrap: wrap;
    }

    &__changing-password {
      display: flex;
      flex-direction: column;
      gap: var(--base);
    }

    .btn {
      margin: 0;
    }

    &__api-key-label {
      position: relative;
    }

    @include mid-break {
      padding: var(--base);
      gap: calc(var(--base) / 2);

      &__changing-password {
        gap: calc(var(--base) / 2);
      }
    }
  }

  .field-type.api-key {
    margin-bottom: var(--base);

    input {
      @include formInput;
    }
  }

  @keyframes highlight {
    0% {
      background: var(--theme-success-250);
      border: 1px solid var(--theme-success-500);
    }

    20% {
      background: var(--theme-input-bg);
      border: 1px solid var(--theme-elevation-250);
      color: var(--theme-text);
    }

    80% {
      background: var(--theme-input-bg);
      border: 1px solid var(--theme-elevation-250);
      color: var(--theme-text);
    }

    100% {
      background: var(--theme-elevation-200);
      border: 1px solid transparent;
      color: var(--theme-elevation-400);
    }
  }

  .highlight {
    animation: highlight 10s;
  }
}
</file>

<file path="packages/ui/src/views/Edit/Auth/index.tsx">
import React, { Fragment, useCallback, useEffect, useMemo, useState } from 'react'
import { toast } from 'sonner'
⋮----
import type { Props } from './types.js'
⋮----
import { Button } from '../../../elements/Button/index.js'
import { EmailAndUsernameFields } from '../../../elements/EmailAndUsername/index.js'
import { CheckboxField } from '../../../fields/Checkbox/index.js'
import { ConfirmPasswordField } from '../../../fields/ConfirmPassword/index.js'
import { PasswordField } from '../../../fields/Password/index.js'
import { useFormFields, useFormModified } from '../../../forms/Form/context.js'
import { useAuth } from '../../../providers/Auth/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { APIKey } from './APIKey.js'
</file>

<file path="packages/ui/src/views/Edit/Auth/types.ts">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
export type Props = {
  className?: string
  collectionSlug: SanitizedCollectionConfig['slug']
  disableLocalStrategy?: SanitizedCollectionConfig['auth']['disableLocalStrategy']
  email: string
  loginWithUsername: SanitizedCollectionConfig['auth']['loginWithUsername']
  operation: 'create' | 'update'
  readOnly: boolean
  requirePassword?: boolean
  setValidateBeforeSubmit: (validate: boolean) => void
  useAPIKey?: boolean
  username: string
  verify?: boolean
}
</file>

<file path="packages/ui/src/views/Edit/SetDocumentStepNav/index.tsx">
import type { SanitizedCollectionConfig, SanitizedGlobalConfig } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { formatAdminURL } from '@convexcms/core/shared'
import { useEffect } from 'react'
⋮----
import type { StepNavItem } from '../../../elements/StepNav/index.js'
⋮----
import { useStepNav } from '../../../elements/StepNav/index.js'
import { useConfig } from '../../../providers/Config/index.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useEntityVisibility } from '../../../providers/EntityVisibility/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
⋮----
export const SetDocumentStepNav: React.FC<{
  collectionSlug?: SanitizedCollectionConfig['slug']
  globalLabel?: SanitizedGlobalConfig['label']
  globalSlug?: SanitizedGlobalConfig['slug']
  id?: number | string
  pluralLabel?: SanitizedCollectionConfig['labels']['plural']
  useAsTitle?: SanitizedCollectionConfig['admin']['useAsTitle']
  view?: string
}> = (props) =>
</file>

<file path="packages/ui/src/views/Edit/SetDocumentTitle/index.tsx">
import type { ClientCollectionConfig, ClientConfig, ClientGlobalConfig } from '@convexcms/core'
⋮----
import { useEffect, useRef } from 'react'
⋮----
import { useFormFields } from '../../../forms/Form/context.js'
import { useDocumentInfo } from '../../../providers/DocumentInfo/index.js'
import { useTranslation } from '../../../providers/Translation/index.js'
import { formatDocTitle } from '../../../utilities/formatDocTitle/index.js'
⋮----
export const SetDocumentTitle: React.FC<{
  collectionConfig?: ClientCollectionConfig
  config?: ClientConfig
  fallback: string
  globalConfig?: ClientGlobalConfig
}> = (props) =>
</file>

<file path="packages/ui/src/views/Edit/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .collection-edit {
    width: 100%;

    &__form {
      height: 100%;
    }

    &__auth {
      margin-bottom: base(1.6);
      border-radius: var(--style-radius-s);
    }

    @include small-break {
      &__auth {
        margin-top: 0;
        margin-bottom: var(--base);
      }
    }
  }
}
</file>

<file path="packages/ui/src/views/Edit/index.tsx">
import type { ClientUser, DocumentViewClientProps, FormState } from '@convexcms/core'
⋮----
import { useRouter, useSearchParams } from 'next/navigation.js'
import { formatAdminURL } from '@convexcms/core/shared'
import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react'
⋮----
import type { FormProps } from '../../forms/Form/index.js'
import type { LockedState } from '../../utilities/buildFormState.js'
⋮----
import { DocumentControls } from '../../elements/DocumentControls/index.js'
import { DocumentDrawerHeader } from '../../elements/DocumentDrawer/DrawerHeader/index.js'
import { useDocumentDrawerContext } from '../../elements/DocumentDrawer/Provider.js'
import { DocumentFields } from '../../elements/DocumentFields/index.js'
import { DocumentLocked } from '../../elements/DocumentLocked/index.js'
import { DocumentTakeOver } from '../../elements/DocumentTakeOver/index.js'
import { LeaveWithoutSaving } from '../../elements/LeaveWithoutSaving/index.js'
import { Upload } from '../../elements/Upload/index.js'
import { Form } from '../../forms/Form/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useDocumentEvents } from '../../providers/DocumentEvents/index.js'
import { useDocumentInfo } from '../../providers/DocumentInfo/index.js'
import { useEditDepth } from '../../providers/EditDepth/index.js'
import { OperationProvider } from '../../providers/Operation/index.js'
import { useRouteTransition } from '../../providers/RouteTransition/index.js'
import { useServerFunctions } from '../../providers/ServerFunctions/index.js'
import { useUploadEdits } from '../../providers/UploadEdits/index.js'
import { abortAndIgnore, handleAbortRef } from '../../utilities/abortAndIgnore.js'
import { handleBackToDashboard } from '../../utilities/handleBackToDashboard.js'
import { handleGoBack } from '../../utilities/handleGoBack.js'
import { handleTakeOver } from '../../utilities/handleTakeOver.js'
import { Auth } from './Auth/index.js'
import { SetDocumentStepNav } from './SetDocumentStepNav/index.js'
import { SetDocumentTitle } from './SetDocumentTitle/index.js'
⋮----
// This component receives props only on _pages_
// When rendered within a drawer, props are empty
// This is solely to support custom edit views which get server-rendered
⋮----
const lockDurationDefault = 300 // Default 5 minutes in seconds
⋮----
// If we're editing the doc of the logged-in user,
// Refresh the cookie to get new permissions
⋮----
// Redirect to the same locale if it's been set
⋮----
// Unlock the document after save
⋮----
const updateLastEdited = isLockingEnabled && timeSinceLastUpdate >= 10000 // 10 seconds
⋮----
// Performance optimization: Setting it to false ensure that only fields that have explicit requireRender set in the form state will be rendered (e.g. new array rows).
// We only want to render ALL fields on initial render, not in onChange.
⋮----
// Clean up when the component unmounts or when the document is unlocked
⋮----
// Only retain the lock if the user is still viewing the document
⋮----
// Check if this user is still the current editor
⋮----
onTakeOver=
</file>

<file path="packages/ui/src/views/Edit/types.ts">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
export type IndexProps = {
  collection: SanitizedCollectionConfig
  isEditing?: boolean
}
</file>

<file path="packages/ui/src/views/List/ListHeader/index.scss">
@import '../../../scss/styles.scss';

@layer payload-default {
  .list-header {
    display: flex;
    align-items: flex-end;
    flex-wrap: wrap;
    gap: calc(var(--base) * 0.8);

    h1 {
      margin: 0;
    }
  }

  .list-drawer {
    &__header {
      margin-top: base(2.5);
      width: 100%;

      @include mid-break {
        margin-top: base(1.5);
      }
    }

    &__header-wrap {
      display: flex;
      gap: base(1);
    }

    &__header-content {
      display: flex;
      flex-wrap: wrap;
      flex-grow: 1;
      align-items: flex-start;
      align-items: center;

      button .pill {
        pointer-events: none;
        margin: 0;
        top: 4px;
        margin-left: base(0.5);
      }
    }

    &__header-text {
      margin: 0;
    }

    &__header-close {
      flex-shrink: 0;
    }

    &__toggler {
      background: transparent;
      border: 0;
      padding: 0;
      cursor: pointer;
      color: inherit;
      border-radius: var(--style-radius-s);

      &:focus:not(:focus-visible),
      &:focus-within:not(:focus-visible) {
        outline: none;
      }

      &:focus-visible {
        outline: var(--accessibility-outline);
        outline-offset: var(--accessibility-outline-offset);
      }

      &:disabled {
        pointer-events: none;
      }
    }

    &__header-close {
      border: 0;
      background-color: transparent;
      padding: 0;
      margin: 0;
      cursor: pointer;
      overflow: hidden;
      width: base(1);
      height: base(1);

      svg {
        width: base(2);
        height: base(2);
        position: relative;
        inset-inline-start: base(-0.5);
        top: base(-0.5);

        .stroke {
          stroke-width: 2px;
          vector-effect: non-scaling-stroke;
        }
      }
    }

    &__select-collection-wrap {
      margin-top: base(1);
    }

    &__first-cell {
      border: 0;
      background-color: transparent;
      padding: 0;
      cursor: pointer;
      text-decoration: underline;
      text-align: left;
      white-space: nowrap;
    }

    @include mid-break {
      .collection-list__header {
        margin-bottom: base(0.5);
      }

      &__select-collection-wrap {
        margin-top: calc(var(--base) / 2);
      }

      &__header-content {
        button .pill {
          top: 2px;
        }
      }
    }
  }
}
</file>

<file path="packages/ui/src/views/List/ListHeader/index.tsx">
import type { I18nClient, TFunction } from '@convexcms/translations'
import type { ClientCollectionConfig } from '@convexcms/core'
⋮----
import { useModal } from '@faceless-ui/modal'
import { getTranslation } from '@convexcms/translations'
import React from 'react'
⋮----
import { Button } from '../../../elements/Button/index.js'
import { useListDrawerContext } from '../../../elements/ListDrawer/Provider.js'
import { ListSelection } from '../../../elements/ListSelection/index.js'
import { Pill } from '../../../elements/Pill/index.js'
import { ReactSelect } from '../../../elements/ReactSelect/index.js'
import { FieldLabel } from '../../../fields/FieldLabel/index.js'
import { XIcon } from '../../../icons/X/index.js'
import { useConfig } from '../../../providers/Config/index.js'
⋮----
export type ListHeaderProps = {
  className?: string
  collectionConfig: ClientCollectionConfig
  Description?: React.ReactNode
  disableBulkDelete?: boolean
  disableBulkEdit?: boolean
  hasCreatePermission: boolean
  i18n: I18nClient
  isBulkUploadEnabled: boolean
  newDocumentURL: string
  openBulkUpload: () => void
  smallBreak: boolean
  t: TFunction
}
⋮----
aria-label=
⋮----
label=
⋮----
<FieldLabel label=
</file>

<file path="packages/ui/src/views/List/index.scss">
@import '../../scss/styles.scss';

@layer payload-default {
  .collection-list {
    width: 100%;

    &__wrap {
      padding-bottom: var(--spacing-view-bottom);

      & > *:not(:last-child) {
        margin-bottom: var(--base);
      }
    }

    .list-header {
      a {
        text-decoration: none;
      }

      .btn--withoutPopup,
      .btn--withPopup {
        position: relative;
        margin: 0 0 base(0.2);
      }
    }

    &__sub-header {
      flex-basis: 100%;
    }

    .table {
      table {
        width: 100%;
        overflow: auto;

        [class^='cell'] > p,
        [class^='cell'] > span,
        [class^='cell'] > a {
          line-clamp: 4;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 4;
          overflow: hidden;
          display: -webkit-box;
          max-width: 100vw;
        }

        #heading-_select,
        .cell-_select {
          display: flex;
          min-width: unset;
        }

        #heading-_dragHandle,
        .cell-_dragHandle {
          width: 20px;
          min-width: 0;
        }
      }
    }

    &__no-results {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--base);

      & > * {
        margin: 0;
      }
    }

    &__page-controls {
      width: 100%;
      display: flex;
      align-items: center;
    }

    .paginator {
      margin-bottom: 0;
    }

    &__page-info {
      [dir='ltr'] & {
        margin-right: base(1);
        margin-left: auto;
      }
      [dir='rtl'] & {
        margin-left: base(1);
        margin-right: auto;
      }
    }

    &__list-selection {
      position: fixed;
      bottom: 0;
      z-index: 10;
      padding: base(0.8) 0;
      width: 100%;
      background-color: var(--theme-bg);

      .btn {
        margin: 0 0 0 base(0.4);
      }

      .btn {
        background-color: var(--theme-elevation-100);
        cursor: pointer;
        padding: 0 base(0.4);
        border-radius: $style-radius-s;

        &:hover {
          background-color: var(--theme-elevation-200);
        }
      }
    }

    &__list-selection-actions {
      display: flex;
      gap: base(0.25);
    }

    &__shimmer {
      margin-top: base(1.75);
      width: 100%;
      > div {
        margin-top: 8px;
      }
    }

    @include mid-break {
      margin-top: base(0.25);

      &__wrap {
        padding-top: 0;
        padding-bottom: 0;
      }

      &__header {
        gap: base(0.5);
      }

      &__sub-header {
        margin-top: 0;
      }

      &__search-input {
        margin: 0;
      }

      // on mobile, extend the table all the way to the viewport edges
      // this is to visually indicate overflowing content
      .table {
        display: flex;
        width: calc(100% + calc(var(--gutter-h) * 2));
        max-width: unset;
        left: calc(var(--gutter-h) * -1);
        position: relative;
        padding-left: var(--gutter-h);

        &::after {
          content: '';
          height: 1px;
          padding-right: var(--gutter-h);
        }
      }

      &__page-controls {
        flex-wrap: wrap;
      }

      &__page-info {
        margin-left: 0;
      }

      .paginator {
        width: 100%;
        margin-bottom: $baseline;
      }
    }

    @include small-break {
      margin-bottom: base(2.4);
    }
  }
}
</file>

<file path="packages/ui/src/views/List/index.tsx">
import type { ListViewClientProps } from '@convexcms/core'
⋮----
import { getTranslation } from '@convexcms/translations'
import { useRouter } from 'next/navigation.js'
import { formatFilesize, isNumber } from '@convexcms/core/shared'
import React, { Fragment, useEffect, useState } from 'react'
⋮----
import { useBulkUpload } from '../../elements/BulkUpload/index.js'
import { Button } from '../../elements/Button/index.js'
import { Gutter } from '../../elements/Gutter/index.js'
import { ListControls } from '../../elements/ListControls/index.js'
import { useListDrawerContext } from '../../elements/ListDrawer/Provider.js'
import { ListSelection } from '../../elements/ListSelection/index.js'
import { useModal } from '../../elements/Modal/index.js'
import { Pagination } from '../../elements/Pagination/index.js'
import { PerPage } from '../../elements/PerPage/index.js'
import { RenderCustomComponent } from '../../elements/RenderCustomComponent/index.js'
import { SelectMany } from '../../elements/SelectMany/index.js'
import { useStepNav } from '../../elements/StepNav/index.js'
import { RelationshipProvider } from '../../elements/Table/RelationshipProvider/index.js'
import { ViewDescription } from '../../elements/ViewDescription/index.js'
import { useAuth } from '../../providers/Auth/index.js'
import { useConfig } from '../../providers/Config/index.js'
import { useListQuery } from '../../providers/ListQuery/index.js'
import { SelectionProvider } from '../../providers/Selection/index.js'
import { TableColumnsProvider } from '../../providers/TableColumns/index.js'
import { useTranslation } from '../../providers/Translation/index.js'
import { useWindowInfo } from '../../providers/WindowInfo/index.js'
import { ListHeader } from './ListHeader/index.js'
</file>

<file path="packages/ui/src/views/List/types.ts">
import type { SanitizedCollectionConfig } from '@convexcms/core'
⋮----
export type DefaultListViewProps = {
  collectionSlug: SanitizedCollectionConfig['slug']
  listSearchableFields: SanitizedCollectionConfig['admin']['listSearchableFields']
}
⋮----
export type ListIndexProps = {
  collection: SanitizedCollectionConfig
}
</file>

<file path="packages/ui/.browserslistrc">
> 1%
not dead
</file>

<file path="packages/ui/.prettierignore">
.tmp
**/.git
**/.hg
**/.pnp.*
**/.svn
**/.yarn/**
**/build
**/dist/**
**/node_modules
**/temp
**/docs/**
tsconfig.json
</file>

<file path="packages/ui/.swcrc">
{
  "$schema": "https://json.schemastore.org/swcrc",
  "sourceMaps": true,
  "jsc": {
    "target": "esnext",
    "parser": {
      "syntax": "typescript",
      "tsx": true,
      "dts": true
    },
    "transform": {
      "react": {
        "runtime": "automatic",
        "pragmaFrag": "React.Fragment",
        "throwIfNamespace": true,
        "development": false,
        "useBuiltins": true
      }
    }
  },
  "module": {
    "type": "es6"
  }
}
</file>

<file path="packages/ui/babel.config.cjs">
// Plugin options can be found here: https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/Entrypoint/Options.ts#L38
⋮----
sources: (filename) => {
const isInNodeModules = filename.includes('node_modules')
⋮----
(!filename.endsWith('.tsx') && !filename.endsWith('.jsx') && !filename.endsWith('.js'))
⋮----
// Only compile files with 'use client' directives. We do not want to
// accidentally compile React Server Components
const file = fs.readFileSync(filename, 'utf8')
if (file.includes("'use client'")) {
⋮----
console.log('React compiler - skipping file: ' + filename)
⋮----
api.cache(false)
⋮----
['babel-plugin-react-compiler', ReactCompilerConfig], // must run first!
/* [
         'babel-plugin-transform-remove-imports',
         {
           test: '\\.(scss|css)$',
         },
       ],*/
</file>

<file path="packages/ui/bundle.js">
const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)
⋮----
setup(build) {
build.onLoad({ filter: /.*/ }, async (args) => {
if (args.path.includes('node_modules') || !args.path.includes(dirname)) return
const contents = await fs.promises.readFile(args.path, 'utf8')
const withRemovedImports = contents.replace(/import\s+.*\.scss';?[\r\n\s]*/g, '')
⋮----
// This plugin ensures there is only one "use client" directive at the top of the file
// and removes any existing directives which are not at the top, for example due to banner inserting
// itself before the directive.
⋮----
// Temporarily disable file writing
⋮----
build.onEnd((result) => {
⋮----
result.outputFiles.forEach((file) => {
⋮----
if (!file.path.endsWith('.map')) {
contents = contents.replace(directiveRegex, '') // Remove existing use client directives
contents = directive + '\n' + contents // Prepend our use client directive
⋮----
const filePath = path.join(build.initialOptions.outdir, path.basename(file.path))
⋮----
const dirPath = path.dirname(filePath)
if (!fs.existsSync(dirPath)) {
fs.mkdirSync(dirPath, { recursive: true })
⋮----
// Write the modified contents to file manually instead of using esbuild's write option
fs.writeFileSync(filePath, contents, 'utf8')
⋮----
console.error('No output files are available to process in useClientPlugin.')
⋮----
async function build() {
// Bundle only the .scss files into a single css file
await esbuild.build({
⋮----
plugins: [sassPlugin({ css: 'external' })],
⋮----
fs.renameSync('dist-styles/index.css', 'dist/styles.css')
fs.rmdirSync('dist-styles', { recursive: true })
⋮----
console.error(`Error while renaming index.css and dist-styles: ${err}`)
⋮----
console.log('styles.css bundled successfully')
// Bundle `client.ts`
const resultClient = await esbuild.build({
⋮----
//outfile: 'index.js',
// IMPORTANT: splitting the client bundle means that the `use client` directive will be lost for every chunk
⋮----
write: true, // required for useClientPlugin
⋮----
`, // react-datepicker fails due to require("react") statements making it to the browser, which is not supported.
// This is a workaround to get it to work, without having to mark react-dateopicker as external
// See https://stackoverflow.com/questions/68423950/when-using-esbuild-with-external-react-i-get-dynamic-require-of-react-is-not-s
⋮----
//'side-channel',
⋮----
//packages: 'external',
⋮----
tsconfig: path.resolve(dirname, './tsconfig.json'),
⋮----
useClientPlugin, // required for banner to work
/*commonjs({
          ignore: ['date-fns', '@floating-ui/react'],
        }),*/
⋮----
console.log('client.ts bundled successfully')
⋮----
const resultShared = await esbuild.build({
⋮----
plugins: [removeCSSImports, commonjs()],
⋮----
console.log('shared.ts bundled successfully')
⋮----
fs.writeFileSync('meta_client.json', JSON.stringify(resultClient.metafile))
fs.writeFileSync('meta_shared.json', JSON.stringify(resultShared.metafile))
⋮----
await build()
</file>

<file path="packages/ui/eslint.config.js">
/** @typedef {import('eslint').Linter.Config} Config */
⋮----
/** @type {Config[]} */
</file>

<file path="packages/ui/LICENSE.md">
MIT License

Copyright (c) 2018-2025 Payload CMS, Inc. <info@payloadcms.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="packages/ui/package.json">
{
  "name": "@payloadcms/ui",
  "version": "3.34.0",
  "homepage": "https://payloadcms.com",
  "repository": {
    "type": "git",
    "url": "https://github.com/payloadcms/payload.git",
    "directory": "packages/ui"
  },
  "license": "MIT",
  "author": "Payload <dev@payloadcms.com> (https://payloadcms.com)",
  "maintainers": [
    {
      "name": '@convexcms/core',
      "email": "info@payloadcms.com",
      "url": "https://payloadcms.com"
    }
  ],
  "sideEffects": false,
  "type": "module",
  "exports": {
    ".": {
      "import": "./src/exports/client/index.ts",
      "types": "./src/exports/client/index.ts",
      "default": "./src/exports/client/index.ts"
    },
    "./shared": {
      "import": "./src/exports/shared/index.ts",
      "types": "./src/exports/shared/index.ts",
      "default": "./src/exports/shared/index.ts"
    },
    "./scss": {
      "import": "./src/scss/styles.scss",
      "default": "./src/scss/styles.scss"
    },
    "./elements/RenderServerComponent": {
      "import": "./src/elements/RenderServerComponent/index.tsx",
      "types": "./src/elements/RenderServerComponent/index.tsx",
      "default": "./src/elements/RenderServerComponent/index.tsx"
    },
    "./rsc": {
      "import": "./src/exports/rsc/index.ts",
      "types": "./src/exports/rsc/index.ts",
      "default": "./src/exports/rsc/index.ts"
    },
    "./utilities/buildFormState": {
      "import": "./src/utilities/buildFormState.ts",
      "types": "./src/utilities/buildFormState.ts",
      "default": "./src/utilities/buildFormState.ts"
    },
    "./utilities/buildTableState": {
      "import": "./src/utilities/buildTableState.ts",
      "types": "./src/utilities/buildTableState.ts",
      "default": "./src/utilities/buildTableState.ts"
    },
    "./utilities/getClientSchemaMap": {
      "import": "./src/utilities/getClientSchemaMap.ts",
      "types": "./src/utilities/getClientSchemaMap.ts",
      "default": "./src/utilities/getClientSchemaMap.ts"
    },
    "./utilities/getSchemaMap": {
      "import": "./src/utilities/getSchemaMap.ts",
      "types": "./src/utilities/getSchemaMap.ts",
      "default": "./src/utilities/getSchemaMap.ts"
    },
    "./utilities/schedulePublishHandler": {
      "import": "./src/utilities/schedulePublishHandler.ts",
      "types": "./src/utilities/schedulePublishHandler.ts",
      "default": "./src/utilities/schedulePublishHandler.ts"
    },
    "./utilities/getClientConfig": {
      "import": "./src/utilities/getClientConfig.ts",
      "types": "./src/utilities/getClientConfig.ts",
      "default": "./src/utilities/getClientConfig.ts"
    },
    "./utilities/buildFieldSchemaMap/traverseFields": {
      "import": "./src/utilities/buildFieldSchemaMap/traverseFields.ts",
      "types": "./src/utilities/buildFieldSchemaMap/traverseFields.ts",
      "default": "./src/utilities/buildFieldSchemaMap/traverseFields.ts"
    },
    "./forms/fieldSchemasToFormState": {
      "import": "./src/forms/fieldSchemasToFormState/index.tsx",
      "types": "./src/forms/fieldSchemasToFormState/index.tsx",
      "default": "./src/forms/fieldSchemasToFormState/index.tsx"
    },
    "./forms/renderField": {
      "import": "./src/forms/fieldSchemasToFormState/renderField.tsx",
      "types": "./src/forms/fieldSchemasToFormState/renderField.tsx",
      "default": "./src/forms/fieldSchemasToFormState/renderField.tsx"
    },
    "./scss/app.scss": "./src/scss/app.scss",
    "./assets": {
      "import": "./src/assets/index.ts",
      "types": "./src/assets/index.ts",
      "default": "./src/assets/index.ts"
    }
  },
  "main": "./src/exports/client/index.ts",
  "types": "./src/exports/client/index.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "pnpm build:reactcompiler",
    "build:babel": "rm -rf dist_optimized && babel dist --out-dir dist_optimized --source-maps --extensions .ts,.js,.tsx,.jsx,.cjs,.mjs && rm -rf dist && mv dist_optimized dist",
    "build:esbuild": "node bundle.js && rm -rf dist/exports/client && mv dist/exports/client_optimized dist/exports/client",
    "build:reactcompiler": "rm -rf dist && rm -rf tsconfig.tsbuildinfo && pnpm build:swc && pnpm build:babel && pnpm copyfiles && pnpm build:esbuild && pnpm build:types",
    "build:remove-artifact": "rm dist/prod/index.js",
    "build:swc": "swc ./src -d dist --config-file .swcrc --strip-leading-paths",
    "build:types": "tsc --emitDeclarationOnly --outDir dist",
    "build:without_reactcompiler": "rm -rf dist && rm -rf tsconfig.tsbuildinfo && pnpm copyfiles && pnpm build:types && pnpm build:swc",
    "clean": "rimraf -g {dist,*.tsbuildinfo}",
    "copyfiles": "copyfiles -u 1 \"src/**/*.{html,css,scss,ttf,woff,woff2,eot,svg,jpg,png,json}\" dist/",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "prepublishOnly": "pnpm clean && pnpm turbo build"
  },
  "dependencies": {
    "@date-fns/tz": "1.2.0",
    "@dnd-kit/core": "6.0.8",
    "@dnd-kit/sortable": "7.0.2",
    "@faceless-ui/modal": "3.0.0-beta.2",
    "@faceless-ui/scroll-info": "2.0.0",
    "@faceless-ui/window-info": "3.0.1",
    "@monaco-editor/react": "4.7.0",
    "@payloadcms/translations": "workspace:*",
    "bson-objectid": "2.0.4",
    "date-fns": "4.1.0",
    "dequal": "2.0.3",
    "md5": "2.3.0",
    "object-to-formdata": "4.5.1",
    "qs-esm": "7.0.2",
    "react-datepicker": "7.6.0",
    "react-image-crop": "10.1.8",
    "react-select": "5.9.0",
    "scheduler": "0.25.0",
    "sonner": "^1.7.2",
    "ts-essentials": "10.0.3",
    "use-context-selector": "2.0.0",
    "uuid": "10.0.0"
  },
  "devDependencies": {
    "@babel/cli": "7.26.4",
    "@babel/core": "7.26.7",
    "@babel/preset-env": "7.26.7",
    "@babel/preset-react": "7.26.3",
    "@babel/preset-typescript": "7.26.0",
    "@hyrious/esbuild-plugin-commonjs": "^0.2.4",
    "@payloadcms/eslint-config": "workspace:*",
    "@types/react": "19.1.0",
    "@types/react-dom": "19.1.2",
    "@types/uuid": "10.0.0",
    "babel-plugin-react-compiler": "19.0.0-beta-e993439-20250405",
    "esbuild": "0.24.2",
    "esbuild-sass-plugin": "3.3.1",
    "eslint-plugin-react-compiler": "19.0.0-beta-e993439-20250405",
    '@convexcms/core': "workspace:*"
  },
  "peerDependencies": {
    "next": "^15.2.3",
    '@convexcms/core': "workspace:*",
    "react": "^19.0.0 || ^19.0.0-rc-65a56d0e-20241020",
    "react-dom": "^19.0.0 || ^19.0.0-rc-65a56d0e-20241020"
  },
  "engines": {
    "node": "^18.20.2 || >=20.9.0"
  },
  "publishConfig": {
    "exports": {
      ".": {
        "import": "./dist/exports/client/index.js",
        "types": "./dist/exports/client/index.d.ts",
        "default": "./dist/exports/client/index.js"
      },
      "./shared": {
        "import": "./dist/exports/shared/index.js",
        "types": "./dist/exports/shared/index.d.ts",
        "default": "./dist/exports/shared/index.js"
      },
      "./css": {
        "import": "./dist/styles.css",
        "default": "./dist/styles.css"
      },
      "./scss": {
        "import": "./dist/scss/styles.scss",
        "default": "./dist/scss/styles.scss"
      },
      "./rsc": {
        "import": "./dist/exports/rsc/index.js",
        "types": "./dist/exports/rsc/index.d.ts",
        "default": "./dist/exports/rsc/index.js"
      },
      "./scss/app.scss": "./dist/scss/app.scss",
      "./styles.css": "./dist/styles.css",
      "./assets": {
        "import": "./dist/assets/index.js",
        "types": "./dist/assets/index.d.ts",
        "default": "./dist/assets/index.js"
      },
      "./elements/RenderServerComponent": {
        "import": "./dist/elements/RenderServerComponent/index.js",
        "types": "./dist/elements/RenderServerComponent/index.d.ts",
        "default": "./dist/elements/RenderServerComponent/index.js"
      },
      "./elements/*": {
        "import": "./dist/elements/*/index.js",
        "types": "./dist/elements/*/index.d.ts",
        "default": "./dist/elements/*/index.js"
      },
      "./fields/*": {
        "import": "./dist/fields/*/index.js",
        "types": "./dist/fields/*/index.d.ts",
        "default": "./dist/fields/*/index.js"
      },
      "./forms/fieldSchemasToFormState": {
        "import": "./dist/forms/fieldSchemasToFormState/index.js",
        "types": "./dist/forms/fieldSchemasToFormState/index.d.ts",
        "default": "./dist/forms/fieldSchemasToFormState/index.js"
      },
      "./forms/renderField": {
        "import": "./dist/forms/fieldSchemasToFormState/renderField.js",
        "types": "./dist/forms/fieldSchemasToFormState/renderField.d.ts",
        "default": "./dist/forms/fieldSchemasToFormState/renderField.js"
      },
      "./forms/*": {
        "import": "./dist/forms/*/index.js",
        "types": "./dist/forms/*/index.d.ts",
        "default": "./dist/forms/*/index.js"
      },
      "./graphics/*": {
        "import": "./dist/graphics/*/index.js",
        "types": "./dist/graphics/*/index.d.ts",
        "default": "./dist/graphics/*/index.js"
      },
      "./hooks/*": {
        "import": "./dist/hooks/*.js",
        "types": "./dist/hooks/*.d.ts",
        "default": "./dist/hooks/*.js"
      },
      "./icons/*": {
        "import": "./dist/icons/*/index.js",
        "types": "./dist/icons/*/index.d.ts",
        "default": "./dist/icons/*/index.js"
      },
      "./providers/*": {
        "import": "./dist/providers/*/index.js",
        "types": "./dist/providers/*/index.d.ts",
        "default": "./dist/providers/*/index.js"
      },
      "./utilities/*": {
        "import": "./dist/utilities/*.js",
        "types": "./dist/utilities/*.d.ts",
        "default": "./dist/utilities/*.js"
      }
    },
    "main": "./dist/exports/client/index.js",
    "types": "./dist/exports/client/index.d.ts"
  }
}
</file>

<file path="packages/ui/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    /* TODO: remove the following lines */
    "strict": false,
  },
  "references": [{ "path": "../payload" }, { "path": "../translations" }]
}
</file>

</files>
</file>

<file path="docs/repomix-output-t3-oss-create-t3-turbo.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  DISCUSSION_TEMPLATE/
    ideas.yml
  ISSUE_TEMPLATE/
    bug_report.yml
    config.yml
  workflows/
    ci.yml
  FUNDING.yml
  renovate.json
apps/
  auth-proxy/
    routes/
      r/
        [...auth].ts
    .env.example
    eslint.config.js
    package.json
    README.md
    tsconfig.json
    turbo.json
  expo/
    .expo-shared/
      assets.json
    src/
      app/
        post/
          [id].tsx
        _layout.tsx
        index.tsx
      utils/
        api.tsx
        auth.ts
        base-url.ts
        session-store.ts
      styles.css
    .prettierignore
    app.config.ts
    babel.config.js
    eas.json
    eslint.config.mjs
    index.ts
    metro.config.js
    nativewind-env.d.ts
    package.json
    tailwind.config.ts
    tsconfig.json
    turbo.json
  nextjs/
    public/
      t3-icon.svg
    src/
      app/
        _components/
          auth-showcase.tsx
          posts.tsx
        api/
          auth/
            [...nextauth]/
              route.ts
          trpc/
            [trpc]/
              route.ts
        globals.css
        layout.tsx
        page.tsx
      trpc/
        query-client.ts
        react.tsx
        server.tsx
      env.ts
      middleware.ts
    eslint.config.js
    next.config.js
    package.json
    postcss.config.cjs
    README.md
    tailwind.config.ts
    tsconfig.json
    turbo.json
packages/
  api/
    src/
      router/
        auth.ts
        post.ts
      index.ts
      root.ts
      trpc.ts
    eslint.config.js
    package.json
    tsconfig.json
  auth/
    src/
      config.ts
      index.rsc.ts
      index.ts
    env.ts
    eslint.config.js
    package.json
    tsconfig.json
  db/
    src/
      client.ts
      index.ts
      schema.ts
    drizzle.config.ts
    eslint.config.js
    package.json
    tsconfig.json
  ui/
    src/
      button.tsx
      dropdown-menu.tsx
      form.tsx
      index.ts
      input.tsx
      label.tsx
      theme.tsx
      toast.tsx
    components.json
    eslint.config.js
    package.json
    tsconfig.json
  validators/
    src/
      index.ts
    eslint.config.js
    package.json
    tsconfig.json
tooling/
  eslint/
    base.js
    nextjs.js
    package.json
    react.js
    tsconfig.json
    types.d.ts
  github/
    setup/
      action.yml
    package.json
  prettier/
    index.js
    package.json
    tsconfig.json
  tailwind/
    base.ts
    eslint.config.js
    native.ts
    package.json
    tsconfig.json
    web.ts
  typescript/
    base.json
    internal-package.json
    package.json
turbo/
  generators/
    templates/
      eslint.config.js.hbs
      package.json.hbs
      tsconfig.json.hbs
    config.ts
.env.example
.gitignore
.npmrc
.nvmrc
LICENSE
package.json
pnpm-workspace.yaml
README.md
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/DISCUSSION_TEMPLATE/ideas.yml">
body:
  - type: markdown
    attributes:
      value: |
        Thank you for taking the time to file a feature request. Please fill out this form as completely as possible.
  - type: textarea
    attributes:
      label: Describe the feature you'd like to request
      description: Please describe the feature as clear and concise as possible. Remember to add context as to why you believe this feature is needed.
    validations:
      required: true
  - type: textarea
    attributes:
      label: Describe the solution you'd like to see
      description: Please describe the solution you would like to see. Adding example usage is a good way to provide context.
    validations:
      required: true
  - type: textarea
    attributes:
      label: Additional information
      description: Add any other information related to the feature here. If your feature request is related to any issues or discussions, link them here.
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.yml">
name: 🐞 Bug Report
description: Create a bug report to help us improve
title: "bug: "
labels: ["🐞❔ unconfirmed bug"]
body:
  - type: textarea
    attributes:
      label: Provide environment information
      description: |
        Run this command in your project root and paste the results in a code block:
        ```bash
        npx envinfo --system --binaries
        ```
    validations:
      required: true
  - type: textarea
    attributes:
      label: Describe the bug
      description: A clear and concise description of the bug, as well as what you expected to happen when encountering it.
    validations:
      required: true
  - type: input
    attributes:
      label: Link to reproduction
      description: Please provide a link to a reproduction of the bug. Issues without a reproduction repo may be ignored.
    validations:
      required: true
  - type: textarea
    attributes:
      label: To reproduce
      description: Describe how to reproduce your bug. Steps, code snippets, reproduction repos etc.
    validations:
      required: true
  - type: textarea
    attributes:
      label: Additional information
      description: Add any other information related to the bug here, screenshots if applicable.
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
contact_links:
  - name: Ask a question
    url: https://github.com/t3-oss/create-t3-turbo/discussions
    about: Ask questions and discuss with other community members
  - name: Feature request
    url: https://github.com/t3-oss/create-t3-turbo/discussions/new?category=ideas
    about: Feature requests should be opened as discussions
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  pull_request:
    branches: ["*"]
  push:
    branches: ["main"]
  merge_group:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

# You can leverage Vercel Remote Caching with Turbo to speed up your builds
# @link https://turborepo.org/docs/core-concepts/remote-caching#remote-caching-on-vercel-builds
env:
  FORCE_COLOR: 3
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup
        uses: ./tooling/github/setup

      - name: Copy env
        shell: bash
        run: cp .env.example .env

      - name: Lint
        run: pnpm lint && pnpm lint:ws

  format:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup
        uses: ./tooling/github/setup

      - name: Format
        run: pnpm format

  typecheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup
        uses: ./tooling/github/setup

      - name: Typecheck
        run: pnpm typecheck
</file>

<file path=".github/FUNDING.yml">
# These are supported funding model platforms

github: juliusmarminge
</file>

<file path=".github/renovate.json">
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:base"],
  "packageRules": [
    {
      "matchPackagePatterns": ["^@acme/"],
      "enabled": false
    }
  ],
  "updateInternalDeps": true,
  "rangeStrategy": "bump",
  "automerge": true,
  "npm": {
    "fileMatch": ["(^|/)package\\.json$", "(^|/)package\\.json\\.hbs$"]
  }
}
</file>

<file path="apps/auth-proxy/routes/r/[...auth].ts">
import { Auth } from "@auth/core";
import Discord from "@auth/core/providers/discord";
import { eventHandler, toWebRequest } from "h3";

export default eventHandler(async (event) =>
  Auth(toWebRequest(event), {
    basePath: "/r",
    secret: process.env.AUTH_SECRET,
    trustHost: !!process.env.VERCEL,
    redirectProxyUrl: process.env.AUTH_REDIRECT_PROXY_URL,
    providers: [
      Discord({
        clientId: process.env.AUTH_DISCORD_ID,
        clientSecret: process.env.AUTH_DISCORD_SECRET,
      }),
    ],
  }),
);
</file>

<file path="apps/auth-proxy/.env.example">
AUTH_SECRET=""
AUTH_DISCORD_ID=""
AUTH_DISCORD_SECRET=""
AUTH_REDIRECT_PROXY_URL=""

NITRO_PRESET="vercel_edge"
</file>

<file path="apps/auth-proxy/eslint.config.js">
import baseConfig from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: [".nitro/**", ".output/**"],
  },
  ...baseConfig,
];
</file>

<file path="apps/auth-proxy/package.json">
{
  "name": "@acme/auth-proxy",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nitro build",
    "clean": "git clean -xdf .cache .nitro .output .turbo .vercel node_modules",
    "lint": "eslint",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@auth/core": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tailwind-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@types/node": "^22.13.11",
    "eslint": "catalog:",
    "h3": "^1.14.0",
    "nitropack": "^2.10.4",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="apps/auth-proxy/README.md">
# Auth Proxy

This is a simple proxy server that enables OAuth authentication for preview environments and Expo apps.

## Setup

Deploy it somewhere (Vercel is a one-click, zero-config option) and set the following environment variables:

- `AUTH_DISCORD_ID` - The Discord OAuth client ID
- `AUTH_DISCORD_SECRET` - The Discord OAuth client secret
- `AUTH_REDIRECT_PROXY_URL` - The URL of this proxy server (e.g. )
- `AUTH_SECRET` - Your secret

Make sure the `AUTH_SECRET` and `AUTH_REDIRECT_PROXY_URL` match the values set for the main application's deployment for preview environments, and that you're using the same OAuth credentials for the proxy and the application's preview environment.
`AUTH_REDIRECT_PROXY_URL` should only be set for the main application's preview environment. Do not set it for the production environment.
The lines below shows what values should match eachother in both deployments.

> [!NOTE]
>
> For using the proxy for local development set the `AUTH_REDIRECT_PROXY_URL` in the `.env` file as well.

![Environment variables setup](https://github.com/t3-oss/create-t3-turbo/assets/51714798/5fadd3f5-f705-459a-82ab-559a3df881d0)

For providers that require an origin and a redirect URL, set them to `{AUTH_REDIRECT_PROXY_URL}` and `{AUTH_REDIRECT_PROXY_URL}/r/callback/{provider}` accordingly.

![Google credentials setup](https://github.com/ahkhanjani/create-t3-turbo/assets/72540492/eaa88685-6fc2-4c23-b7ac-737eb172fa0e)
</file>

<file path="apps/auth-proxy/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "include": ["routes"]
}
</file>

<file path="apps/auth-proxy/turbo.json">
{
  "$schema": "https://turborepo.org/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".nitro/**", ".output/**", ".vercel/**"]
    },
    "dev": {
      "persistent": true
    }
  }
}
</file>

<file path="apps/expo/.expo-shared/assets.json">
{
  "12bb71342c6255bbf50437ec8f4441c083f47cdb74bd89160c15e4f43e52a1cb": true,
  "40b842e832070c58deac6aa9e08fa459302ee3f9da492c7e77d93d2fbf4a56fd": true
}
</file>

<file path="apps/expo/src/app/post/[id].tsx">
import { SafeAreaView, Text, View } from "react-native";
import { Stack, useGlobalSearchParams } from "expo-router";
import { useQuery } from "@tanstack/react-query";

import { trpc } from "~/utils/api";

export default function Post() {
  const { id } = useGlobalSearchParams();
  if (!id || typeof id !== "string") throw new Error("unreachable");
  const { data } = useQuery(trpc.post.byId.queryOptions({ id }));

  if (!data) return null;

  return (
    <SafeAreaView className="bg-background">
      <Stack.Screen options={{ title: data.title }} />
      <View className="h-full w-full p-4">
        <Text className="py-2 text-3xl font-bold text-primary">
          {data.title}
        </Text>
        <Text className="py-4 text-foreground">{data.content}</Text>
      </View>
    </SafeAreaView>
  );
}
</file>

<file path="apps/expo/src/app/_layout.tsx">
import { Stack } from "expo-router";
import { StatusBar } from "expo-status-bar";
import { useColorScheme } from "nativewind";

import { queryClient } from "~/utils/api";

import "../styles.css";

import { QueryClientProvider } from "@tanstack/react-query";

// This is the main layout of the app
// It wraps your pages with the providers they need
export default function RootLayout() {
  const { colorScheme } = useColorScheme();
  return (
    <QueryClientProvider client={queryClient}>
      {/*
          The Stack component displays the current page.
          It also allows you to configure your screens 
        */}
      <Stack
        screenOptions={{
          headerStyle: {
            backgroundColor: "#f472b6",
          },
          contentStyle: {
            backgroundColor: colorScheme == "dark" ? "#09090B" : "#FFFFFF",
          },
        }}
      />
      <StatusBar />
    </QueryClientProvider>
  );
}
</file>

<file path="apps/expo/src/app/index.tsx">
import React, { useState } from "react";
import { Button, Pressable, Text, TextInput, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { Link, Stack } from "expo-router";
import { FlashList } from "@shopify/flash-list";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import type { RouterOutputs } from "~/utils/api";
import { trpc } from "~/utils/api";
import { useSignIn, useSignOut, useUser } from "~/utils/auth";

function PostCard(props: {
  post: RouterOutputs["post"]["all"][number];
  onDelete: () => void;
}) {
  return (
    <View className="flex flex-row rounded-lg bg-muted p-4">
      <View className="flex-grow">
        <Link
          asChild
          href={{
            pathname: "/post/[id]",
            params: { id: props.post.id },
          }}
        >
          <Pressable className="">
            <Text className="text-xl font-semibold text-primary">
              {props.post.title}
            </Text>
            <Text className="mt-2 text-foreground">{props.post.content}</Text>
          </Pressable>
        </Link>
      </View>
      <Pressable onPress={props.onDelete}>
        <Text className="font-bold uppercase text-primary">Delete</Text>
      </Pressable>
    </View>
  );
}

function CreatePost() {
  const queryClient = useQueryClient();

  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");

  const { mutate, error } = useMutation(
    trpc.post.create.mutationOptions({
      async onSuccess() {
        setTitle("");
        setContent("");
        await queryClient.invalidateQueries(trpc.post.all.queryFilter());
      },
    }),
  );

  return (
    <View className="mt-4 flex gap-2">
      <TextInput
        className="items-center rounded-md border border-input bg-background px-3 text-lg leading-[1.25] text-foreground"
        value={title}
        onChangeText={setTitle}
        placeholder="Title"
      />
      {error?.data?.zodError?.fieldErrors.title && (
        <Text className="mb-2 text-destructive">
          {error.data.zodError.fieldErrors.title}
        </Text>
      )}
      <TextInput
        className="items-center rounded-md border border-input bg-background px-3 text-lg leading-[1.25] text-foreground"
        value={content}
        onChangeText={setContent}
        placeholder="Content"
      />
      {error?.data?.zodError?.fieldErrors.content && (
        <Text className="mb-2 text-destructive">
          {error.data.zodError.fieldErrors.content}
        </Text>
      )}
      <Pressable
        className="flex items-center rounded bg-primary p-2"
        onPress={() => {
          mutate({
            title,
            content,
          });
        }}
      >
        <Text className="text-foreground">Create</Text>
      </Pressable>
      {error?.data?.code === "UNAUTHORIZED" && (
        <Text className="mt-2 text-destructive">
          You need to be logged in to create a post
        </Text>
      )}
    </View>
  );
}

function MobileAuth() {
  const user = useUser();
  const signIn = useSignIn();
  const signOut = useSignOut();

  return (
    <>
      <Text className="pb-2 text-center text-xl font-semibold text-white">
        {user?.name ?? "Not logged in"}
      </Text>
      <Button
        onPress={() => (user ? signOut() : signIn())}
        title={user ? "Sign Out" : "Sign In With Discord"}
        color={"#5B65E9"}
      />
    </>
  );
}

export default function Index() {
  const queryClient = useQueryClient();

  const postQuery = useQuery(trpc.post.all.queryOptions());

  const deletePostMutation = useMutation(
    trpc.post.delete.mutationOptions({
      onSettled: () =>
        queryClient.invalidateQueries(trpc.post.all.queryFilter()),
    }),
  );

  return (
    <SafeAreaView className="bg-background">
      {/* Changes page title visible on the header */}
      <Stack.Screen options={{ title: "Home Page" }} />
      <View className="h-full w-full bg-background p-4">
        <Text className="pb-2 text-center text-5xl font-bold text-foreground">
          Create <Text className="text-primary">T3</Text> Turbo
        </Text>

        <MobileAuth />

        <View className="py-2">
          <Text className="font-semibold italic text-primary">
            Press on a post
          </Text>
        </View>

        <FlashList
          data={postQuery.data}
          estimatedItemSize={20}
          ItemSeparatorComponent={() => <View className="h-2" />}
          renderItem={(p) => (
            <PostCard
              post={p.item}
              onDelete={() => deletePostMutation.mutate(p.item.id)}
            />
          )}
        />

        <CreatePost />
      </View>
    </SafeAreaView>
  );
}
</file>

<file path="apps/expo/src/utils/api.tsx">
import { QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink, loggerLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import superjson from "superjson";

import type { AppRouter } from "@acme/api";

import { getBaseUrl } from "./base-url";
import { getToken } from "./session-store";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ...
    },
  },
});

/**
 * A set of typesafe hooks for consuming your API.
 */
export const trpc = createTRPCOptionsProxy<AppRouter>({
  client: createTRPCClient({
    links: [
      loggerLink({
        enabled: (opts) =>
          process.env.NODE_ENV === "development" ||
          (opts.direction === "down" && opts.result instanceof Error),
        colorMode: "ansi",
      }),
      httpBatchLink({
        transformer: superjson,
        url: `${getBaseUrl()}/api/trpc`,
        headers() {
          const headers = new Map<string, string>();
          headers.set("x-trpc-source", "expo-react");

          const token = getToken();
          if (token) headers.set("Authorization", `Bearer ${token}`);

          return Object.fromEntries(headers);
        },
      }),
    ],
  }),
  queryClient,
});

export { type RouterInputs, type RouterOutputs } from "@acme/api";
</file>

<file path="apps/expo/src/utils/auth.ts">
import * as Linking from "expo-linking";
import { useRouter } from "expo-router";
import * as Browser from "expo-web-browser";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import { trpc } from "./api";
import { getBaseUrl } from "./base-url";
import { deleteToken, setToken } from "./session-store";

export const signIn = async () => {
  const signInUrl = `${getBaseUrl()}/api/auth/signin`;
  const redirectTo = Linking.createURL("/login");
  const result = await Browser.openAuthSessionAsync(
    `${signInUrl}?expo-redirect=${encodeURIComponent(redirectTo)}`,
    redirectTo,
  );

  if (result.type !== "success") return false;
  const url = Linking.parse(result.url);
  const sessionToken = String(url.queryParams?.session_token);
  if (!sessionToken) throw new Error("No session token found");

  setToken(sessionToken);

  return true;
};

export const useUser = () => {
  const { data: session } = useQuery(trpc.auth.getSession.queryOptions());
  return session?.user ?? null;
};

export const useSignIn = () => {
  const queryClient = useQueryClient();
  const router = useRouter();

  return async () => {
    const success = await signIn();
    if (!success) return;

    await queryClient.invalidateQueries(trpc.pathFilter());
    router.replace("/");
  };
};

export const useSignOut = () => {
  const queryClient = useQueryClient();
  const signOut = useMutation(trpc.auth.signOut.mutationOptions());
  const router = useRouter();

  return async () => {
    const res = await signOut.mutateAsync();
    if (!res.success) return;
    await deleteToken();
    await queryClient.invalidateQueries(trpc.pathFilter());
    router.replace("/");
  };
};
</file>

<file path="apps/expo/src/utils/base-url.ts">
import Constants from "expo-constants";

/**
 * Extend this function when going to production by
 * setting the baseUrl to your production API URL.
 */
export const getBaseUrl = () => {
  /**
   * Gets the IP address of your host-machine. If it cannot automatically find it,
   * you'll have to manually set it. NOTE: Port 3000 should work for most but confirm
   * you don't have anything else running on it, or you'd have to change it.
   *
   * **NOTE**: This is only for development. In production, you'll want to set the
   * baseUrl to your production API URL.
   */
  const debuggerHost = Constants.expoConfig?.hostUri;
  const localhost = debuggerHost?.split(":")[0];

  if (!localhost) {
    // return "https://turbo.t3.gg";
    throw new Error(
      "Failed to get localhost. Please point to your production server.",
    );
  }
  return `http://${localhost}:3000`;
};
</file>

<file path="apps/expo/src/utils/session-store.ts">
import * as SecureStore from "expo-secure-store";

const key = "session_token";
export const getToken = () => SecureStore.getItem(key);
export const deleteToken = () => SecureStore.deleteItemAsync(key);
export const setToken = (v: string) => SecureStore.setItem(key, v);
</file>

<file path="apps/expo/src/styles.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 240 10% 3.9%;
  --card: 0 0% 100%;
  --card-foreground: 240 10% 3.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 240 10% 3.9%;
  --primary: 327 66% 69%;
  --primary-foreground: 337 65.5% 17.1%;
  --secondary: 240 4.8% 95.9%;
  --secondary-foreground: 240 5.9% 10%;
  --muted: 240 4.8% 95.9%;
  --muted-foreground: 240 3.8% 46.1%;
  --accent: 240 4.8% 95.9%;
  --accent-foreground: 240 5.9% 10%;
  --destructive: 0 72.22% 50.59%;
  --destructive-foreground: 0 0% 98%;
  --border: 240 5.9% 90%;
  --input: 240 5.9% 90%;
  --ring: 240 5% 64.9%;
  --radius: 0.5rem;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 327 66% 69%;
    --primary-foreground: 337 65.5% 17.1%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
  }
}
</file>

<file path="apps/expo/.prettierignore">
nativewind-env.d.ts
</file>

<file path="apps/expo/app.config.ts">
import type { ConfigContext, ExpoConfig } from "expo/config";

export default ({ config }: ConfigContext): ExpoConfig => ({
  ...config,
  name: "expo",
  slug: "expo",
  scheme: "expo",
  version: "0.1.0",
  orientation: "portrait",
  icon: "./assets/icon-light.png",
  userInterfaceStyle: "automatic",
  updates: {
    fallbackToCacheTimeout: 0,
  },
  assetBundlePatterns: ["**/*"],
  ios: {
    bundleIdentifier: "your.bundle.identifier",
    supportsTablet: true,
    icon: {
      light: "./assets/icon-light.png",
      dark: "./assets/icon-dark.png",
      // tinted: "",
    },
  },
  android: {
    package: "your.bundle.identifier",
    adaptiveIcon: {
      foregroundImage: "./assets/icon-light.png",
      backgroundColor: "#1F104A",
    },
  },
  // extra: {
  //   eas: {
  //     projectId: "your-eas-project-id",
  //   },
  // },
  experiments: {
    tsconfigPaths: true,
    typedRoutes: true,
  },
  plugins: [
    "expo-router",
    "expo-secure-store",
    "expo-web-browser",
    [
      "expo-splash-screen",
      {
        backgroundColor: "#E4E4E7",
        image: "./assets/icon-light.png",
        dark: {
          backgroundColor: "#18181B",
          image: "./assets/icon-dark.png",
        },
      },
    ],
  ],
});
</file>

<file path="apps/expo/babel.config.js">
/** @type {import("@babel/core").ConfigFunction} */
module.exports = (api) => {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
    plugins: ["react-native-reanimated/plugin"],
  };
};
</file>

<file path="apps/expo/eas.json">
{
  "cli": {
    "version": ">= 4.1.2",
    "appVersionSource": "remote"
  },
  "build": {
    "base": {
      "node": "22.12.0",
      "pnpm": "9.15.4",
      "ios": {
        "resourceClass": "m-medium"
      }
    },
    "development": {
      "extends": "base",
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "extends": "base",
      "distribution": "internal",
      "ios": {
        "simulator": true
      }
    },
    "production": {
      "extends": "base"
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="apps/expo/eslint.config.mjs">
import baseConfig from "@acme/eslint-config/base";
import reactConfig from "@acme/eslint-config/react";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: [".expo/**", "expo-plugins/**"],
  },
  ...baseConfig,
  ...reactConfig,
];
</file>

<file path="apps/expo/index.ts">
import "expo-router/entry";
</file>

<file path="apps/expo/metro.config.js">
// Learn more: https://docs.expo.dev/guides/monorepos/
const { getDefaultConfig } = require("expo/metro-config");
const { FileStore } = require("metro-cache");
const { withNativeWind } = require("nativewind/metro");

const path = require("node:path");

const config = withTurborepoManagedCache(
  withNativeWind(getDefaultConfig(__dirname), {
    input: "./src/styles.css",
    configPath: "./tailwind.config.ts",
  }),
);

// XXX: Resolve our exports in workspace packages
// https://github.com/expo/expo/issues/26926
config.resolver.unstable_enablePackageExports = true;

module.exports = config;

/**
 * Move the Metro cache to the `.cache/metro` folder.
 * If you have any environment variables, you can configure Turborepo to invalidate it when needed.
 *
 * @see https://turbo.build/repo/docs/reference/configuration#env
 * @param {import('expo/metro-config').MetroConfig} config
 * @returns {import('expo/metro-config').MetroConfig}
 */
function withTurborepoManagedCache(config) {
  config.cacheStores = [
    new FileStore({ root: path.join(__dirname, ".cache/metro") }),
  ];
  return config;
}
</file>

<file path="apps/expo/nativewind-env.d.ts">
/// <reference types="nativewind/types" />

// NOTE: This file should not be edited and should be committed with your source code. It is generated by NativeWind.
</file>

<file path="apps/expo/package.json">
{
  "name": "@acme/expo",
  "version": "0.1.0",
  "private": true,
  "main": "index.ts",
  "scripts": {
    "clean": "git clean -xdf .cache .expo .turbo android ios node_modules",
    "dev": "expo start",
    "dev:android": "expo start --android",
    "dev:ios": "expo start --ios",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "format": "prettier --check . --ignore-path ../../.gitignore --ignore-path .prettierignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@expo/metro-config": "^0.19.12",
    "@shopify/flash-list": "1.7.6",
    "@tanstack/react-query": "catalog:",
    "@trpc/client": "catalog:",
    "@trpc/server": "catalog:",
    "@trpc/tanstack-react-query": "catalog:",
    "expo": "53.0.0-canary-20250304-f08e984",
    "expo-constants": "18.0.0-canary-20250304-f08e984",
    "expo-dev-client": "5.0.13-canary-20250304-f08e984",
    "expo-linking": "7.1.0-canary-20250304-f08e984",
    "expo-router": "4.0.18-canary-20250304-f08e984",
    "expo-secure-store": "14.0.2-canary-20250304-f08e984",
    "expo-splash-screen": "0.29.23-canary-20250304-f08e984",
    "expo-status-bar": "2.0.2-canary-20250304-f08e984",
    "expo-web-browser": "14.1.0-canary-20250304-f08e984",
    "nativewind": "~4.1.23",
    "react": "catalog:react19",
    "react-dom": "catalog:react19",
    "react-native": "0.78.0",
    "react-native-css-interop": "~0.1.22",
    "react-native-gesture-handler": "~2.24.0",
    "react-native-reanimated": "~3.17.1",
    "react-native-safe-area-context": "~5.2.0-beta.0",
    "react-native-screens": "~4.9.1",
    "superjson": "2.2.2"
  },
  "devDependencies": {
    "@acme/api": "workspace:*",
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tailwind-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@babel/core": "^7.26.10",
    "@babel/preset-env": "^7.26.9",
    "@babel/runtime": "^7.26.10",
    "@types/babel__core": "^7.20.5",
    "@types/react": "catalog:react19",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "tailwindcss": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="apps/expo/tailwind.config.ts">
import type { Config } from "tailwindcss";
// @ts-expect-error - no types
import nativewind from "nativewind/preset";

import baseConfig from "@acme/tailwind-config/native";

export default {
  content: ["./src/**/*.{ts,tsx}"],
  presets: [baseConfig, nativewind],
} satisfies Config;
</file>

<file path="apps/expo/tsconfig.json">
{
  "extends": ["@acme/tsconfig/base.json"],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    },
    "jsx": "react-native",
    "checkJs": false,
    "moduleSuffixes": [".ios", ".android", ".native", ""]
  },
  "include": [
    "src",
    "*.ts",
    "*.js",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "nativewind-env.d.ts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/expo/turbo.json">
{
  "$schema": "https://turborepo.org/schema.json",
  "extends": ["//"],
  "tasks": {
    "dev": {
      "persistent": true,
      "interactive": true
    }
  }
}
</file>

<file path="apps/nextjs/public/t3-icon.svg">
<svg width="258" height="198" viewBox="0 0 258 198" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_1_12)">
<path d="M165.269 24.0976L188.481 -0.000411987H0V24.0976H165.269Z" fill="black"/>
<path d="M163.515 95.3516L253.556 2.71059H220.74L145.151 79.7886L163.515 95.3516Z" fill="black"/>
<path d="M233.192 130.446C233.192 154.103 214.014 173.282 190.357 173.282C171.249 173.282 155.047 160.766 149.534 143.467L146.159 132.876L126.863 152.171L128.626 156.364C138.749 180.449 162.568 197.382 190.357 197.382C227.325 197.382 257.293 167.414 257.293 130.446C257.293 105.965 243.933 84.7676 224.49 73.1186L219.929 70.3856L202.261 88.2806L210.322 92.5356C223.937 99.7236 233.192 114.009 233.192 130.446Z" fill="black"/>
<path d="M87.797 191.697V44.6736H63.699V191.697H87.797Z" fill="black"/>
</g>
<defs>
<clipPath id="clip0_1_12">
<rect width="258" height="198" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="apps/nextjs/src/app/_components/auth-showcase.tsx">
import { auth, signIn, signOut } from "@acme/auth";
import { Button } from "@acme/ui/button";

export async function AuthShowcase() {
  const session = await auth();

  if (!session) {
    return (
      <form>
        <Button
          size="lg"
          formAction={async () => {
            "use server";
            await signIn("discord");
          }}
        >
          Sign in with Discord
        </Button>
      </form>
    );
  }

  return (
    <div className="flex flex-col items-center justify-center gap-4">
      <p className="text-center text-2xl">
        <span>Logged in as {session.user.name}</span>
      </p>

      <form>
        <Button
          size="lg"
          formAction={async () => {
            "use server";
            await signOut();
          }}
        >
          Sign out
        </Button>
      </form>
    </div>
  );
}
</file>

<file path="apps/nextjs/src/app/_components/posts.tsx">
"use client";

import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";

import type { RouterOutputs } from "@acme/api";
import { CreatePostSchema } from "@acme/db/schema";
import { cn } from "@acme/ui";
import { Button } from "@acme/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
  useForm,
} from "@acme/ui/form";
import { Input } from "@acme/ui/input";
import { toast } from "@acme/ui/toast";

import { useTRPC } from "~/trpc/react";

export function CreatePostForm() {
  const trpc = useTRPC();
  const form = useForm({
    schema: CreatePostSchema,
    defaultValues: {
      content: "",
      title: "",
    },
  });

  const queryClient = useQueryClient();
  const createPost = useMutation(
    trpc.post.create.mutationOptions({
      onSuccess: async () => {
        form.reset();
        await queryClient.invalidateQueries(trpc.post.pathFilter());
      },
      onError: (err) => {
        toast.error(
          err.data?.code === "UNAUTHORIZED"
            ? "You must be logged in to post"
            : "Failed to create post",
        );
      },
    }),
  );

  return (
    <Form {...form}>
      <form
        className="flex w-full max-w-2xl flex-col gap-4"
        onSubmit={form.handleSubmit((data) => {
          createPost.mutate(data);
        })}
      >
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Input {...field} placeholder="Title" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="content"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Input {...field} placeholder="Content" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button>Create</Button>
      </form>
    </Form>
  );
}

export function PostList() {
  const trpc = useTRPC();
  const { data: posts } = useSuspenseQuery(trpc.post.all.queryOptions());

  if (posts.length === 0) {
    return (
      <div className="relative flex w-full flex-col gap-4">
        <PostCardSkeleton pulse={false} />
        <PostCardSkeleton pulse={false} />
        <PostCardSkeleton pulse={false} />

        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/10">
          <p className="text-2xl font-bold text-white">No posts yet</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex w-full flex-col gap-4">
      {posts.map((p) => {
        return <PostCard key={p.id} post={p} />;
      })}
    </div>
  );
}

export function PostCard(props: {
  post: RouterOutputs["post"]["all"][number];
}) {
  const trpc = useTRPC();
  const queryClient = useQueryClient();
  const deletePost = useMutation(
    trpc.post.delete.mutationOptions({
      onSuccess: async () => {
        await queryClient.invalidateQueries(trpc.post.pathFilter());
      },
      onError: (err) => {
        toast.error(
          err.data?.code === "UNAUTHORIZED"
            ? "You must be logged in to delete a post"
            : "Failed to delete post",
        );
      },
    }),
  );

  return (
    <div className="flex flex-row rounded-lg bg-muted p-4">
      <div className="flex-grow">
        <h2 className="text-2xl font-bold text-primary">{props.post.title}</h2>
        <p className="mt-2 text-sm">{props.post.content}</p>
      </div>
      <div>
        <Button
          variant="ghost"
          className="cursor-pointer text-sm font-bold uppercase text-primary hover:bg-transparent hover:text-white"
          onClick={() => deletePost.mutate(props.post.id)}
        >
          Delete
        </Button>
      </div>
    </div>
  );
}

export function PostCardSkeleton(props: { pulse?: boolean }) {
  const { pulse = true } = props;
  return (
    <div className="flex flex-row rounded-lg bg-muted p-4">
      <div className="flex-grow">
        <h2
          className={cn(
            "w-1/4 rounded bg-primary text-2xl font-bold",
            pulse && "animate-pulse",
          )}
        >
          &nbsp;
        </h2>
        <p
          className={cn(
            "mt-2 w-1/3 rounded bg-current text-sm",
            pulse && "animate-pulse",
          )}
        >
          &nbsp;
        </p>
      </div>
    </div>
  );
}
</file>

<file path="apps/nextjs/src/app/api/auth/[...nextauth]/route.ts">
import { cookies } from "next/headers";
import { NextRequest, NextResponse } from "next/server";

import { handlers, isSecureContext } from "@acme/auth";

const EXPO_COOKIE_NAME = "__acme-expo-redirect-state";
const AUTH_COOKIE_PATTERN = /authjs\.session-token=([^;]+)/;

/**
 * Noop in production.
 *
 * In development, rewrite the request URL to use localhost instead of host IP address
 * so that Expo Auth works without getting trapped by Next.js CSRF protection.
 * @param req The request to modify
 * @returns The modified request.
 */
function rewriteRequestUrlInDevelopment(req: NextRequest) {
  if (isSecureContext) return req;

  const host = req.headers.get("host");
  const newURL = new URL(req.url);
  newURL.host = host ?? req.nextUrl.host;
  return new NextRequest(newURL, req);
}

async function handleExpoSigninCallback(req: NextRequest, redirectURL: string) {
  (await cookies()).delete(EXPO_COOKIE_NAME);

  // Run original handler, then extract the session token from the response
  // Send it back via a query param in the Expo deep link. The Expo app
  // will then get that and set it in the session storage.
  const authResponse = await handlers.POST(req);
  const setCookie = authResponse.headers
    .getSetCookie()
    .find((cookie) => AUTH_COOKIE_PATTERN.test(cookie));
  const match = setCookie?.match(AUTH_COOKIE_PATTERN)?.[1];

  if (!match)
    throw new Error(
      "Unable to find session cookie: " +
        JSON.stringify(authResponse.headers.getSetCookie()),
    );

  const url = new URL(redirectURL);
  url.searchParams.set("session_token", match);

  return NextResponse.redirect(url);
}

export const POST = async (
  _req: NextRequest,
  props: { params: Promise<{ nextauth: string[] }> },
) => {
  // First step must be to correct the request URL.
  const req = rewriteRequestUrlInDevelopment(_req);

  const nextauthAction = (await props.params).nextauth[0];
  const isExpoCallback = (await cookies()).get(EXPO_COOKIE_NAME);

  // callback handler required separately in the POST handler
  // since Apple sends a POST request instead of a GET
  if (nextauthAction === "callback" && !!isExpoCallback) {
    return handleExpoSigninCallback(req, isExpoCallback.value);
  }

  return handlers.POST(req);
};

export const GET = async (
  _req: NextRequest,
  props: { params: Promise<{ nextauth: string[] }> },
) => {
  // First step must be to correct the request URL.
  const req = rewriteRequestUrlInDevelopment(_req);

  const nextauthAction = (await props.params).nextauth[0];
  const isExpoSignIn = req.nextUrl.searchParams.get("expo-redirect");
  const isExpoCallback = (await cookies()).get(EXPO_COOKIE_NAME);

  if (nextauthAction === "signin" && !!isExpoSignIn) {
    // set a cookie we can read in the callback
    // to know to send the user back to expo
    (await cookies()).set({
      name: EXPO_COOKIE_NAME,
      value: isExpoSignIn,
      maxAge: 60 * 10, // 10 min
      path: "/",
    });
  }

  if (nextauthAction === "callback" && !!isExpoCallback) {
    return handleExpoSigninCallback(req, isExpoCallback.value);
  }

  // Every other request just calls the default handler
  return handlers.GET(req);
};
</file>

<file path="apps/nextjs/src/app/api/trpc/[trpc]/route.ts">
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";

import { appRouter, createTRPCContext } from "@acme/api";
import { auth } from "@acme/auth";

/**
 * Configure basic CORS headers
 * You should extend this to match your needs
 */
const setCorsHeaders = (res: Response) => {
  res.headers.set("Access-Control-Allow-Origin", "*");
  res.headers.set("Access-Control-Request-Method", "*");
  res.headers.set("Access-Control-Allow-Methods", "OPTIONS, GET, POST");
  res.headers.set("Access-Control-Allow-Headers", "*");
};

export const OPTIONS = () => {
  const response = new Response(null, {
    status: 204,
  });
  setCorsHeaders(response);
  return response;
};

const handler = auth(async (req) => {
  const response = await fetchRequestHandler({
    endpoint: "/api/trpc",
    router: appRouter,
    req,
    createContext: () =>
      createTRPCContext({
        session: req.auth,
        headers: req.headers,
      }),
    onError({ error, path }) {
      console.error(`>>> tRPC Error on '${path}'`, error);
    },
  });

  setCorsHeaders(response);
  return response;
});

export { handler as GET, handler as POST };
</file>

<file path="apps/nextjs/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 327 66% 69%;
    --primary-foreground: 337 65.5% 17.1%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 72.22% 50.59%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5% 64.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 327 66% 69%;
    --primary-foreground: 337 65.5% 17.1%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
  }
}
</file>

<file path="apps/nextjs/src/app/layout.tsx">
import type { Metadata, Viewport } from "next";
import { GeistMono } from "geist/font/mono";
import { GeistSans } from "geist/font/sans";

import { cn } from "@acme/ui";
import { ThemeProvider, ThemeToggle } from "@acme/ui/theme";
import { Toaster } from "@acme/ui/toast";

import { TRPCReactProvider } from "~/trpc/react";

import "~/app/globals.css";

import { env } from "~/env";

export const metadata: Metadata = {
  metadataBase: new URL(
    env.VERCEL_ENV === "production"
      ? "https://turbo.t3.gg"
      : "http://localhost:3000",
  ),
  title: "Create T3 Turbo",
  description: "Simple monorepo with shared backend for web & mobile apps",
  openGraph: {
    title: "Create T3 Turbo",
    description: "Simple monorepo with shared backend for web & mobile apps",
    url: "https://create-t3-turbo.vercel.app",
    siteName: "Create T3 Turbo",
  },
  twitter: {
    card: "summary_large_image",
    site: "@jullerino",
    creator: "@jullerino",
  },
};

export const viewport: Viewport = {
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "white" },
    { media: "(prefers-color-scheme: dark)", color: "black" },
  ],
};

export default function RootLayout(props: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={cn(
          "min-h-screen bg-background font-sans text-foreground antialiased",
          GeistSans.variable,
          GeistMono.variable,
        )}
      >
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
          <TRPCReactProvider>{props.children}</TRPCReactProvider>
          <div className="absolute bottom-4 right-4">
            <ThemeToggle />
          </div>
          <Toaster />
        </ThemeProvider>
      </body>
    </html>
  );
}
</file>

<file path="apps/nextjs/src/app/page.tsx">
import { Suspense } from "react";

import { HydrateClient, prefetch, trpc } from "~/trpc/server";
import { AuthShowcase } from "./_components/auth-showcase";
import {
  CreatePostForm,
  PostCardSkeleton,
  PostList,
} from "./_components/posts";

export default function HomePage() {
  prefetch(trpc.post.all.queryOptions());

  return (
    <HydrateClient>
      <main className="container h-screen py-16">
        <div className="flex flex-col items-center justify-center gap-4">
          <h1 className="text-5xl font-extrabold tracking-tight sm:text-[5rem]">
            Create <span className="text-primary">T3</span> Turbo
          </h1>
          <AuthShowcase />

          <CreatePostForm />
          <div className="w-full max-w-2xl overflow-y-scroll">
            <Suspense
              fallback={
                <div className="flex w-full flex-col gap-4">
                  <PostCardSkeleton />
                  <PostCardSkeleton />
                  <PostCardSkeleton />
                </div>
              }
            >
              <PostList />
            </Suspense>
          </div>
        </div>
      </main>
    </HydrateClient>
  );
}
</file>

<file path="apps/nextjs/src/trpc/query-client.ts">
import {
  defaultShouldDehydrateQuery,
  QueryClient,
} from "@tanstack/react-query";
import SuperJSON from "superjson";

export const createQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 30 * 1000,
      },
      dehydrate: {
        serializeData: SuperJSON.serialize,
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
        shouldRedactErrors: () => {
          // We should not catch Next.js server errors
          // as that's how Next.js detects dynamic pages
          // so we cannot redact them.
          // Next.js also automatically redacts errors for us
          // with better digests.
          return false;
        },
      },
      hydrate: {
        deserializeData: SuperJSON.deserialize,
      },
    },
  });
</file>

<file path="apps/nextjs/src/trpc/react.tsx">
"use client";

import type { QueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { QueryClientProvider } from "@tanstack/react-query";
import {
  createTRPCClient,
  httpBatchStreamLink,
  loggerLink,
} from "@trpc/client";
import { createTRPCContext } from "@trpc/tanstack-react-query";
import SuperJSON from "superjson";

import type { AppRouter } from "@acme/api";

import { env } from "~/env";
import { createQueryClient } from "./query-client";

let clientQueryClientSingleton: QueryClient | undefined = undefined;
const getQueryClient = () => {
  if (typeof window === "undefined") {
    // Server: always make a new query client
    return createQueryClient();
  } else {
    // Browser: use singleton pattern to keep the same query client
    return (clientQueryClientSingleton ??= createQueryClient());
  }
};

export const { useTRPC, TRPCProvider } = createTRPCContext<AppRouter>();

export function TRPCReactProvider(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  const [trpcClient] = useState(() =>
    createTRPCClient<AppRouter>({
      links: [
        loggerLink({
          enabled: (op) =>
            env.NODE_ENV === "development" ||
            (op.direction === "down" && op.result instanceof Error),
        }),
        httpBatchStreamLink({
          transformer: SuperJSON,
          url: getBaseUrl() + "/api/trpc",
          headers() {
            const headers = new Headers();
            headers.set("x-trpc-source", "nextjs-react");
            return headers;
          },
        }),
      ],
    }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
        {props.children}
      </TRPCProvider>
    </QueryClientProvider>
  );
}

const getBaseUrl = () => {
  if (typeof window !== "undefined") return window.location.origin;
  if (env.VERCEL_URL) return `https://${env.VERCEL_URL}`;
  // eslint-disable-next-line no-restricted-properties
  return `http://localhost:${process.env.PORT ?? 3000}`;
};
</file>

<file path="apps/nextjs/src/trpc/server.tsx">
import type { TRPCQueryOptions } from "@trpc/tanstack-react-query";
import { cache } from "react";
import { headers } from "next/headers";
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";

import type { AppRouter } from "@acme/api";
import { appRouter, createTRPCContext } from "@acme/api";
import { auth } from "@acme/auth";

import { createQueryClient } from "./query-client";

/**
 * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when
 * handling a tRPC call from a React Server Component.
 */
const createContext = cache(async () => {
  const heads = new Headers(await headers());
  heads.set("x-trpc-source", "rsc");

  return createTRPCContext({
    session: await auth(),
    headers: heads,
  });
});

const getQueryClient = cache(createQueryClient);

export const trpc = createTRPCOptionsProxy<AppRouter>({
  router: appRouter,
  ctx: createContext,
  queryClient: getQueryClient,
});

export function HydrateClient(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient();
  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      {props.children}
    </HydrationBoundary>
  );
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(
  queryOptions: T,
) {
  const queryClient = getQueryClient();
  if (queryOptions.queryKey[1]?.type === "infinite") {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
    void queryClient.prefetchInfiniteQuery(queryOptions as any);
  } else {
    void queryClient.prefetchQuery(queryOptions);
  }
}
</file>

<file path="apps/nextjs/src/env.ts">
import { createEnv } from "@t3-oss/env-nextjs";
import { vercel } from "@t3-oss/env-nextjs/presets-zod";
import { z } from "zod";

import { env as authEnv } from "@acme/auth/env";

export const env = createEnv({
  extends: [authEnv, vercel()],
  shared: {
    NODE_ENV: z
      .enum(["development", "production", "test"])
      .default("development"),
  },
  /**
   * Specify your server-side environment variables schema here.
   * This way you can ensure the app isn't built with invalid env vars.
   */
  server: {
    POSTGRES_URL: z.string().url(),
  },

  /**
   * Specify your client-side environment variables schema here.
   * For them to be exposed to the client, prefix them with `NEXT_PUBLIC_`.
   */
  client: {
    // NEXT_PUBLIC_CLIENTVAR: z.string(),
  },
  /**
   * Destructure all variables from `process.env` to make sure they aren't tree-shaken away.
   */
  experimental__runtimeEnv: {
    NODE_ENV: process.env.NODE_ENV,

    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,
  },
  skipValidation:
    !!process.env.CI || process.env.npm_lifecycle_event === "lint",
});
</file>

<file path="apps/nextjs/src/middleware.ts">
export { auth as middleware } from "@acme/auth";

// Or like this if you need to do something here.
// export default auth((req) => {
//   console.log(req.auth) //  { session: { user: { ... } } }
// })

// Read more: https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};
</file>

<file path="apps/nextjs/eslint.config.js">
import baseConfig, { restrictEnvAccess } from "@acme/eslint-config/base";
import nextjsConfig from "@acme/eslint-config/nextjs";
import reactConfig from "@acme/eslint-config/react";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: [".next/**"],
  },
  ...baseConfig,
  ...reactConfig,
  ...nextjsConfig,
  ...restrictEnvAccess,
];
</file>

<file path="apps/nextjs/next.config.js">
import { fileURLToPath } from "url";
import createJiti from "jiti";

// Import env files to validate at build time. Use jiti so we can load .ts files in here.
createJiti(fileURLToPath(import.meta.url))("./src/env");

/** @type {import("next").NextConfig} */
const config = {
  /** Enables hot reloading for local packages without a build step */
  transpilePackages: [
    "@acme/api",
    "@acme/auth",
    "@acme/db",
    "@acme/ui",
    "@acme/validators",
  ],

  /** We already do linting and typechecking as separate tasks in CI */
  eslint: { ignoreDuringBuilds: true },
  typescript: { ignoreBuildErrors: true },
};

export default config;
</file>

<file path="apps/nextjs/package.json">
{
  "name": "@acme/nextjs",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "pnpm with-env next build",
    "clean": "git clean -xdf .cache .next .turbo node_modules",
    "dev": "pnpm with-env next dev --turbopack",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "start": "pnpm with-env next start",
    "typecheck": "tsc --noEmit",
    "with-env": "dotenv -e ../../.env --"
  },
  "dependencies": {
    "@acme/api": "workspace:*",
    "@acme/auth": "workspace:*",
    "@acme/db": "workspace:*",
    "@acme/ui": "workspace:*",
    "@acme/validators": "workspace:*",
    "@t3-oss/env-nextjs": "^0.12.0",
    "@tanstack/react-query": "catalog:",
    "@trpc/client": "catalog:",
    "@trpc/server": "catalog:",
    "@trpc/tanstack-react-query": "catalog:",
    "geist": "^1.3.1",
    "next": "^15.2.3",
    "react": "catalog:react19",
    "react-dom": "catalog:react19",
    "superjson": "2.2.2",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tailwind-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@types/node": "^22.13.11",
    "@types/react": "catalog:react19",
    "@types/react-dom": "catalog:react19",
    "dotenv-cli": "^8.0.0",
    "eslint": "catalog:",
    "jiti": "^1.21.7",
    "prettier": "catalog:",
    "tailwindcss": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="apps/nextjs/postcss.config.cjs">
module.exports = {
  plugins: {
    tailwindcss: {},
  },
};
</file>

<file path="apps/nextjs/README.md">
# Create T3 App

This is a [T3 Stack](https://create.t3.gg/) project bootstrapped with `create-t3-app`.

## What's next? How do I make an app with this?

We try to keep this project as simple as possible, so you can start with just the scaffolding we set up for you, and add additional things later when they become necessary.

If you are not familiar with the different technologies used in this project, please refer to the respective docs. If you still are in the wind, please join our [Discord](https://t3.gg/discord) and ask for help.

- [Next.js](https://nextjs.org)
- [NextAuth.js](https://next-auth.js.org)
- [Drizzle](https://orm.drizzle.team)
- [Tailwind CSS](https://tailwindcss.com)
- [tRPC](https://trpc.io)

## Learn More

To learn more about the [T3 Stack](https://create.t3.gg/), take a look at the following resources:

- [Documentation](https://create.t3.gg/)
- [Learn the T3 Stack](https://create.t3.gg/en/faq#what-learning-resources-are-currently-available) — Check out these awesome tutorials

You can check out the [create-t3-app GitHub repository](https://github.com/t3-oss/create-t3-app) — your feedback and contributions are welcome!

## How do I deploy this?

Follow our deployment guides for [Vercel](https://create.t3.gg/en/deployment/vercel) and [Docker](https://create.t3.gg/en/deployment/docker) for more information.
</file>

<file path="apps/nextjs/tailwind.config.ts">
import type { Config } from "tailwindcss";
import { fontFamily } from "tailwindcss/defaultTheme";

import baseConfig from "@acme/tailwind-config/web";

export default {
  // We need to append the path to the UI package to the content array so that
  // those classes are included correctly.
  content: [...baseConfig.content, "../../packages/ui/src/*.{ts,tsx}"],
  presets: [baseConfig],
  theme: {
    extend: {
      fontFamily: {
        sans: ["var(--font-geist-sans)", ...fontFamily.sans],
        mono: ["var(--font-geist-mono)", ...fontFamily.mono],
      },
    },
  },
} satisfies Config;
</file>

<file path="apps/nextjs/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "compilerOptions": {
    "lib": ["ES2022", "dom", "dom.iterable"],
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    },
    "plugins": [{ "name": "next" }],
    "module": "esnext"
  },
  "include": [".", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/nextjs/turbo.json">
{
  "$schema": "https://turborepo.org/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".next/**", "!.next/cache/**", "next-env.d.ts"]
    },
    "dev": {
      "persistent": true
    }
  }
}
</file>

<file path="packages/api/src/router/auth.ts">
import type { TRPCRouterRecord } from "@trpc/server";

import { invalidateSessionToken } from "@acme/auth";

import { protectedProcedure, publicProcedure } from "../trpc";

export const authRouter = {
  getSession: publicProcedure.query(({ ctx }) => {
    return ctx.session;
  }),
  getSecretMessage: protectedProcedure.query(() => {
    return "you can see this secret message!";
  }),
  signOut: protectedProcedure.mutation(async (opts) => {
    if (!opts.ctx.token) {
      return { success: false };
    }
    await invalidateSessionToken(opts.ctx.token);
    return { success: true };
  }),
} satisfies TRPCRouterRecord;
</file>

<file path="packages/api/src/router/post.ts">
import type { TRPCRouterRecord } from "@trpc/server";
import { z } from "zod";

import { desc, eq } from "@acme/db";
import { CreatePostSchema, Post } from "@acme/db/schema";

import { protectedProcedure, publicProcedure } from "../trpc";

export const postRouter = {
  all: publicProcedure.query(({ ctx }) => {
    // return ctx.db.select().from(schema.post).orderBy(desc(schema.post.id));
    return ctx.db.query.Post.findMany({
      orderBy: desc(Post.id),
      limit: 10,
    });
  }),

  byId: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(({ ctx, input }) => {
      // return ctx.db
      //   .select()
      //   .from(schema.post)
      //   .where(eq(schema.post.id, input.id));

      return ctx.db.query.Post.findFirst({
        where: eq(Post.id, input.id),
      });
    }),

  create: protectedProcedure
    .input(CreatePostSchema)
    .mutation(({ ctx, input }) => {
      return ctx.db.insert(Post).values(input);
    }),

  delete: protectedProcedure.input(z.string()).mutation(({ ctx, input }) => {
    return ctx.db.delete(Post).where(eq(Post.id, input));
  }),
} satisfies TRPCRouterRecord;
</file>

<file path="packages/api/src/index.ts">
import type { inferRouterInputs, inferRouterOutputs } from "@trpc/server";

import type { AppRouter } from "./root";
import { appRouter } from "./root";
import { createCallerFactory, createTRPCContext } from "./trpc";

/**
 * Create a server-side caller for the tRPC API
 * @example
 * const trpc = createCaller(createContext);
 * const res = await trpc.post.all();
 *       ^? Post[]
 */
const createCaller = createCallerFactory(appRouter);

/**
 * Inference helpers for input types
 * @example
 * type PostByIdInput = RouterInputs['post']['byId']
 *      ^? { id: number }
 **/
type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helpers for output types
 * @example
 * type AllPostsOutput = RouterOutputs['post']['all']
 *      ^? Post[]
 **/
type RouterOutputs = inferRouterOutputs<AppRouter>;

export { createTRPCContext, appRouter, createCaller };
export type { AppRouter, RouterInputs, RouterOutputs };
</file>

<file path="packages/api/src/root.ts">
import { authRouter } from "./router/auth";
import { postRouter } from "./router/post";
import { createTRPCRouter } from "./trpc";

export const appRouter = createTRPCRouter({
  auth: authRouter,
  post: postRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;
</file>

<file path="packages/api/src/trpc.ts">
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1)
 * 2. You want to create a new middleware or type of procedure (see Part 3)
 *
 * tl;dr - this is where all the tRPC server stuff is created and plugged in.
 * The pieces you will need to use are documented accordingly near the end
 */
import { initTRPC, TRPCError } from "@trpc/server";
import superjson from "superjson";
import { ZodError } from "zod";

import type { Session } from "@acme/auth";
import { auth, validateToken } from "@acme/auth";
import { db } from "@acme/db/client";

/**
 * Isomorphic Session getter for API requests
 * - Expo requests will have a session token in the Authorization header
 * - Next.js requests will have a session token in cookies
 */
const isomorphicGetSession = async (headers: Headers) => {
  const authToken = headers.get("Authorization") ?? null;
  if (authToken) return validateToken(authToken);
  return auth();
};

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 *
 * This helper generates the "internals" for a tRPC context. The API handler and RSC clients each
 * wrap this and provides the required context.
 *
 * @see https://trpc.io/docs/server/context
 */
export const createTRPCContext = async (opts: {
  headers: Headers;
  session: Session | null;
}) => {
  const authToken = opts.headers.get("Authorization") ?? null;
  const session = await isomorphicGetSession(opts.headers);

  const source = opts.headers.get("x-trpc-source") ?? "unknown";
  console.log(">>> tRPC Request from", source, "by", session?.user);

  return {
    session,
    db,
    token: authToken,
  };
};

/**
 * 2. INITIALIZATION
 *
 * This is where the trpc api is initialized, connecting the context and
 * transformer
 */
const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter: ({ shape, error }) => ({
    ...shape,
    data: {
      ...shape.data,
      zodError: error.cause instanceof ZodError ? error.cause.flatten() : null,
    },
  }),
});

/**
 * Create a server-side caller
 * @see https://trpc.io/docs/server/server-side-calls
 */
export const createCallerFactory = t.createCallerFactory;

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these
 * a lot in the /src/server/api/routers folder
 */

/**
 * This is how you create new routers and subrouters in your tRPC API
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Middleware for timing procedure execution and adding an articifial delay in development.
 *
 * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating
 * network latency that would occur in production but not in local development.
 */
const timingMiddleware = t.middleware(async ({ next, path }) => {
  const start = Date.now();

  if (t._config.isDev) {
    // artificial delay in dev 100-500ms
    const waitMs = Math.floor(Math.random() * 400) + 100;
    await new Promise((resolve) => setTimeout(resolve, waitMs));
  }

  const result = await next();

  const end = Date.now();
  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);

  return result;
});

/**
 * Public (unauthed) procedure
 *
 * This is the base piece you use to build new queries and mutations on your
 * tRPC API. It does not guarantee that a user querying is authorized, but you
 * can still access user session data if they are logged in
 */
export const publicProcedure = t.procedure.use(timingMiddleware);

/**
 * Protected (authenticated) procedure
 *
 * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies
 * the session is valid and guarantees `ctx.session.user` is not null.
 *
 * @see https://trpc.io/docs/procedures
 */
export const protectedProcedure = t.procedure
  .use(timingMiddleware)
  .use(({ ctx, next }) => {
    if (!ctx.session?.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }
    return next({
      ctx: {
        // infers the `session` as non-nullable
        session: { ...ctx.session, user: ctx.session.user },
      },
    });
  });
</file>

<file path="packages/api/eslint.config.js">
import baseConfig from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: ["dist/**"],
  },
  ...baseConfig,
];
</file>

<file path="packages/api/package.json">
{
  "name": "@acme/api",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./src/index.ts"
    }
  },
  "license": "MIT",
  "scripts": {
    "build": "tsc",
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "dev": "tsc",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit --emitDeclarationOnly false"
  },
  "dependencies": {
    "@acme/auth": "workspace:*",
    "@acme/db": "workspace:*",
    "@acme/validators": "workspace:*",
    "@trpc/server": "catalog:",
    "superjson": "2.2.2",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="packages/api/tsconfig.json">
{
  "extends": "@acme/tsconfig/internal-package.json",
  "include": ["src"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/auth/src/config.ts">
import type {
  DefaultSession,
  NextAuthConfig,
  Session as NextAuthSession,
} from "next-auth";
import { skipCSRFCheck } from "@auth/core";
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import Discord from "next-auth/providers/discord";

import { db } from "@acme/db/client";
import { Account, Session, User } from "@acme/db/schema";

import { env } from "../env";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
    } & DefaultSession["user"];
  }
}

const adapter = DrizzleAdapter(db, {
  usersTable: User,
  accountsTable: Account,
  sessionsTable: Session,
});

export const isSecureContext = env.NODE_ENV !== "development";

export const authConfig = {
  adapter,
  // In development, we need to skip checks to allow Expo to work
  ...(!isSecureContext
    ? {
        skipCSRFCheck: skipCSRFCheck,
        trustHost: true,
      }
    : {}),
  secret: env.AUTH_SECRET,
  providers: [Discord],
  callbacks: {
    session: (opts) => {
      if (!("user" in opts))
        throw new Error("unreachable with session strategy");

      return {
        ...opts.session,
        user: {
          ...opts.session.user,
          id: opts.user.id,
        },
      };
    },
  },
} satisfies NextAuthConfig;

export const validateToken = async (
  token: string,
): Promise<NextAuthSession | null> => {
  const sessionToken = token.slice("Bearer ".length);
  const session = await adapter.getSessionAndUser?.(sessionToken);
  return session
    ? {
        user: {
          ...session.user,
        },
        expires: session.session.expires.toISOString(),
      }
    : null;
};

export const invalidateSessionToken = async (token: string) => {
  const sessionToken = token.slice("Bearer ".length);
  await adapter.deleteSession?.(sessionToken);
};
</file>

<file path="packages/auth/src/index.rsc.ts">
import { cache } from "react";
import NextAuth from "next-auth";

import { authConfig } from "./config";

export type { Session } from "next-auth";

const { handlers, auth: defaultAuth, signIn, signOut } = NextAuth(authConfig);

/**
 * This is the main way to get session data for your RSCs.
 * This will de-duplicate all calls to next-auth's default `auth()` function and only call it once per request
 */
const auth = cache(defaultAuth);

export { handlers, auth, signIn, signOut };

export {
  invalidateSessionToken,
  validateToken,
  isSecureContext,
} from "./config";
</file>

<file path="packages/auth/src/index.ts">
import NextAuth from "next-auth";

import { authConfig } from "./config";

export type { Session } from "next-auth";

const { handlers, auth, signIn, signOut } = NextAuth(authConfig);

export { handlers, auth, signIn, signOut };

export {
  invalidateSessionToken,
  validateToken,
  isSecureContext,
} from "./config";
</file>

<file path="packages/auth/env.ts">
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    AUTH_DISCORD_ID: z.string().min(1),
    AUTH_DISCORD_SECRET: z.string().min(1),
    AUTH_SECRET:
      process.env.NODE_ENV === "production"
        ? z.string().min(1)
        : z.string().min(1).optional(),
    NODE_ENV: z.enum(["development", "production"]).optional(),
  },
  client: {},
  experimental__runtimeEnv: {},
  skipValidation:
    !!process.env.CI || process.env.npm_lifecycle_event === "lint",
});
</file>

<file path="packages/auth/eslint.config.js">
import baseConfig, { restrictEnvAccess } from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: [],
  },
  ...baseConfig,
  ...restrictEnvAccess,
];
</file>

<file path="packages/auth/package.json">
{
  "name": "@acme/auth",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "react-server": "./src/index.rsc.ts",
      "default": "./src/index.ts"
    },
    "./env": "./env.ts"
  },
  "license": "MIT",
  "scripts": {
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@acme/db": "workspace:*",
    "@auth/core": "catalog:",
    "@auth/drizzle-adapter": "catalog:",
    "@t3-oss/env-nextjs": "^0.12.0",
    "next": "^15.2.3",
    "next-auth": "catalog:",
    "react": "catalog:react19",
    "react-dom": "catalog:react19",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@types/react": "catalog:react19",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="packages/auth/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "include": ["src", "*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/db/src/client.ts">
import { sql } from "@vercel/postgres";
import { drizzle } from "drizzle-orm/vercel-postgres";

import * as schema from "./schema";

export const db = drizzle({
  client: sql,
  schema,
  casing: "snake_case",
});
</file>

<file path="packages/db/src/index.ts">
export * from "drizzle-orm/sql";
export { alias } from "drizzle-orm/pg-core";
</file>

<file path="packages/db/src/schema.ts">
import { relations, sql } from "drizzle-orm";
import { pgTable, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const Post = pgTable("post", (t) => ({
  id: t.uuid().notNull().primaryKey().defaultRandom(),
  title: t.varchar({ length: 256 }).notNull(),
  content: t.text().notNull(),
  createdAt: t.timestamp().defaultNow().notNull(),
  updatedAt: t
    .timestamp({ mode: "date", withTimezone: true })
    .$onUpdateFn(() => sql`now()`),
}));

export const CreatePostSchema = createInsertSchema(Post, {
  title: z.string().max(256),
  content: z.string().max(256),
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const User = pgTable("user", (t) => ({
  id: t.uuid().notNull().primaryKey().defaultRandom(),
  name: t.varchar({ length: 255 }),
  email: t.varchar({ length: 255 }).notNull(),
  emailVerified: t.timestamp({ mode: "date", withTimezone: true }),
  image: t.varchar({ length: 255 }),
}));

export const UserRelations = relations(User, ({ many }) => ({
  accounts: many(Account),
}));

export const Account = pgTable(
  "account",
  (t) => ({
    userId: t
      .uuid()
      .notNull()
      .references(() => User.id, { onDelete: "cascade" }),
    type: t
      .varchar({ length: 255 })
      .$type<"email" | "oauth" | "oidc" | "webauthn">()
      .notNull(),
    provider: t.varchar({ length: 255 }).notNull(),
    providerAccountId: t.varchar({ length: 255 }).notNull(),
    refresh_token: t.varchar({ length: 255 }),
    access_token: t.text(),
    expires_at: t.integer(),
    token_type: t.varchar({ length: 255 }),
    scope: t.varchar({ length: 255 }),
    id_token: t.text(),
    session_state: t.varchar({ length: 255 }),
  }),
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  }),
);

export const AccountRelations = relations(Account, ({ one }) => ({
  user: one(User, { fields: [Account.userId], references: [User.id] }),
}));

export const Session = pgTable("session", (t) => ({
  sessionToken: t.varchar({ length: 255 }).notNull().primaryKey(),
  userId: t
    .uuid()
    .notNull()
    .references(() => User.id, { onDelete: "cascade" }),
  expires: t.timestamp({ mode: "date", withTimezone: true }).notNull(),
}));

export const SessionRelations = relations(Session, ({ one }) => ({
  user: one(User, { fields: [Session.userId], references: [User.id] }),
}));
</file>

<file path="packages/db/drizzle.config.ts">
import type { Config } from "drizzle-kit";

if (!process.env.POSTGRES_URL) {
  throw new Error("Missing POSTGRES_URL");
}

const nonPoolingUrl = process.env.POSTGRES_URL.replace(":6543", ":5432");

export default {
  schema: "./src/schema.ts",
  dialect: "postgresql",
  dbCredentials: { url: nonPoolingUrl },
  casing: "snake_case",
} satisfies Config;
</file>

<file path="packages/db/eslint.config.js">
import baseConfig from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: ["dist/**"],
  },
  ...baseConfig,
];
</file>

<file path="packages/db/package.json">
{
  "name": "@acme/db",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./src/index.ts"
    },
    "./client": {
      "types": "./dist/client.d.ts",
      "default": "./src/client.ts"
    },
    "./schema": {
      "types": "./dist/schema.d.ts",
      "default": "./src/schema.ts"
    }
  },
  "license": "MIT",
  "scripts": {
    "build": "tsc",
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "dev": "tsc",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "push": "pnpm with-env drizzle-kit push",
    "studio": "pnpm with-env drizzle-kit studio",
    "typecheck": "tsc --noEmit --emitDeclarationOnly false",
    "with-env": "dotenv -e ../../.env --"
  },
  "dependencies": {
    "@vercel/postgres": "^0.10.0",
    "drizzle-orm": "^0.41.0",
    "drizzle-zod": "^0.7.0",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "dotenv-cli": "^8.0.0",
    "drizzle-kit": "^0.30.5",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="packages/db/tsconfig.json">
{
  "extends": "@acme/tsconfig/internal-package.json",
  "include": ["src"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/ui/src/button.tsx">
import type { VariantProps } from "class-variance-authority";
import * as React from "react";
import { cva } from "class-variance-authority";
import { Slot } from "radix-ui";

import { cn } from "@acme/ui";

export const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        primary:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        sm: "h-8 rounded-md px-3 text-xs",
        md: "h-9 px-4 py-2",
        lg: "h-10 rounded-md px-8",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
    },
  },
);

interface ButtonProps
  extends React.ComponentProps<"button">,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

export function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: ButtonProps) {
  const Comp = asChild ? Slot.Slot : "button";
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/src/dropdown-menu.tsx">
"use client";

import * as React from "react";
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons";
import { DropdownMenu as DropdownMenuPrimitive } from "radix-ui";

import { cn } from "@acme/ui";

export const DropdownMenu = DropdownMenuPrimitive.Root;
export const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;
export const DropdownMenuGroup = DropdownMenuPrimitive.Group;
export const DropdownMenuPortal = DropdownMenuPrimitive.Portal;
export const DropdownMenuSub = DropdownMenuPrimitive.Sub;
export const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

export function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      className={cn(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        inset && "pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

export function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  );
}

export function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
          "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

export function DropdownMenuItem({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Item
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        inset && "pl-8",
        className,
      )}
      {...props}
    />
  );
}

export function DropdownMenuCheckboxItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className,
      )}
      {...props}
    >
      <span className="absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

export function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className,
      )}
      {...props}
    >
      <span className="absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <DotFilledIcon className="size-4 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

export function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      className={cn(
        "px-2 py-1.5 text-sm font-semibold",
        inset && "pl-8",
        className,
      )}
      {...props}
    />
  );
}

export function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      className={cn("-mx-1 my-1 h-px bg-muted", className)}
      {...props}
    />
  );
}

export function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/src/form.tsx">
"use client";

import type {
  ControllerProps,
  FieldPath,
  FieldValues,
  UseFormProps,
} from "react-hook-form";
import type { ZodType, ZodTypeDef } from "zod";
import * as React from "react";
import { standardSchemaResolver } from "@hookform/resolvers/standard-schema";
import { Slot } from "radix-ui";
import {
  useForm as __useForm,
  Controller,
  useFormContext,
} from "react-hook-form";

import { cn } from "@acme/ui";

import { Label } from "./label";

export { FormProvider as Form, useFieldArray } from "react-hook-form";

export function useForm<
  TOut extends FieldValues,
  TDef extends ZodTypeDef,
  TIn extends FieldValues,
>(
  props: Omit<UseFormProps<TIn>, "resolver"> & {
    schema: ZodType<TOut, TDef, TIn>;
  },
) {
  const form = __useForm<TIn, unknown, TOut>({
    ...props,
    resolver: standardSchemaResolver(props.schema, undefined),
  });

  return form;
}

interface FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> {
  name: TName;
}

const FormFieldContext = React.createContext<FormFieldContextValue | null>(
  null,
);

export function FormField<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({ ...props }: ControllerProps<TFieldValues, TName>) {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
}

export function useFormField() {
  const { getFieldState, formState } = useFormContext();

  const fieldContext = React.use(FormFieldContext);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const fieldState = getFieldState(fieldContext.name, formState);

  const itemContext = React.use(FormItemContext);
  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
}

interface FormItemContextValue {
  id: string;
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

export function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
}

export function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof Label>) {
  const { error, formItemId } = useFormField();

  return (
    <Label
      htmlFor={formItemId}
      className={cn(error && "text-destructive", className)}
      {...props}
    />
  );
}

export function FormControl({
  ...props
}: React.ComponentProps<typeof Slot.Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot.Slot
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
}

export function FormDescription({
  className,
  ...props
}: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField();

  return (
    <p
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  );
}

export function FormMessage({
  className,
  children,
  ...props
}: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error.message) : children;

  if (!body) {
    return;
  }

  return (
    <p
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
}
</file>

<file path="packages/ui/src/index.ts">
import { cx } from "class-variance-authority";
import { twMerge } from "tailwind-merge";

const cn = (...inputs: Parameters<typeof cx>) => twMerge(cx(inputs));

export { cn };
</file>

<file path="packages/ui/src/input.tsx">
import type { ComponentProps } from "react";

import { cn } from "@acme/ui";

export function Input({ className, ...props }: ComponentProps<"input">) {
  return (
    <input
      className={cn(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/src/label.tsx">
import * as React from "react";
import { Label as LabelPrimitive } from "radix-ui";

import { cn } from "@acme/ui";

export function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      className={cn(
        "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        className,
      )}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/src/theme.tsx">
"use client";

import { MoonIcon, SunIcon } from "@radix-ui/react-icons";
import { useTheme } from "next-themes";

import { Button } from "./button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "./dropdown-menu";

export { ThemeProvider } from "next-themes";

export function ThemeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <SunIcon className="size-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <MoonIcon className="absolute size-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="packages/ui/src/toast.tsx">
"use client";

import type { ToasterProps } from "sonner";
import { useTheme } from "next-themes";
import { Toaster as Sonner } from "sonner";

export { toast } from "sonner";

export function Toaster({ ...props }: ToasterProps) {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
}
</file>

<file path="packages/ui/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "../../tooling/tailwind/web.ts",
    "css": "unused.css",
    "baseColor": "zinc",
    "cssVariables": true
  },
  "aliases": {
    "utils": "@acme/ui",
    "components": "src/",
    "ui": "src/"
  }
}
</file>

<file path="packages/ui/eslint.config.js">
import baseConfig from "@acme/eslint-config/base";
import reactConfig from "@acme/eslint-config/react";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: ["dist/**"],
  },
  ...baseConfig,
  ...reactConfig,
];
</file>

<file path="packages/ui/package.json">
{
  "name": "@acme/ui",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": "./src/index.ts",
    "./button": "./src/button.tsx",
    "./dropdown-menu": "./src/dropdown-menu.tsx",
    "./form": "./src/form.tsx",
    "./input": "./src/input.tsx",
    "./label": "./src/label.tsx",
    "./theme": "./src/theme.tsx",
    "./toast": "./src/toast.tsx"
  },
  "license": "MIT",
  "scripts": {
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit --emitDeclarationOnly false",
    "ui-add": "pnpm dlx shadcn@latest add && prettier src --write --list-different"
  },
  "dependencies": {
    "@hookform/resolvers": "^4.1.3",
    "@radix-ui/react-icons": "^1.3.2",
    "class-variance-authority": "^0.7.1",
    "next-themes": "^0.4.6",
    "radix-ui": "^1.1.3",
    "react-hook-form": "^7.54.2",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.2"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tailwind-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@types/react": "catalog:react19",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "react": "catalog:react19",
    "typescript": "catalog:",
    "zod": "catalog:"
  },
  "peerDependencies": {
    "react": "catalog:react19",
    "zod": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="packages/ui/tsconfig.json">
{
  "extends": "@acme/tsconfig/internal-package.json",
  "compilerOptions": {
    "lib": ["ES2022", "dom", "dom.iterable"],
    "jsx": "preserve",
    "rootDir": "."
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/validators/src/index.ts">
import { z } from "zod";

export const unused = z.string().describe(
  `This lib is currently not used as we use drizzle-zod for simple schemas
   But as your application grows and you need other validators to share
   with back and frontend, you can put them in here
  `,
);
</file>

<file path="packages/validators/eslint.config.js">
import baseConfig from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: ["dist/**"],
  },
  ...baseConfig,
];
</file>

<file path="packages/validators/package.json">
{
  "name": "@acme/validators",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./src/index.ts"
    }
  },
  "license": "MIT",
  "scripts": {
    "build": "tsc",
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "dev": "tsc",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit --emitDeclarationOnly false"
  },
  "dependencies": {
    "zod": "catalog:"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="packages/validators/tsconfig.json">
{
  "extends": "@acme/tsconfig/internal-package.json",
  "include": ["src"],
  "exclude": ["node_modules"]
}
</file>

<file path="tooling/eslint/base.js">
/// <reference types="./types.d.ts" />

import * as path from "node:path";
import { includeIgnoreFile } from "@eslint/compat";
import eslint from "@eslint/js";
import importPlugin from "eslint-plugin-import";
import turboPlugin from "eslint-plugin-turbo";
import tseslint from "typescript-eslint";

/**
 * All packages that leverage t3-env should use this rule
 */
export const restrictEnvAccess = tseslint.config(
  { ignores: ["**/env.ts"] },
  {
    files: ["**/*.js", "**/*.ts", "**/*.tsx"],
    rules: {
      "no-restricted-properties": [
        "error",
        {
          object: "process",
          property: "env",
          message:
            "Use `import { env } from '~/env'` instead to ensure validated types.",
        },
      ],
      "no-restricted-imports": [
        "error",
        {
          name: "process",
          importNames: ["env"],
          message:
            "Use `import { env } from '~/env'` instead to ensure validated types.",
        },
      ],
    },
  },
);

export default tseslint.config(
  // Ignore files not tracked by VCS and any config files
  includeIgnoreFile(path.join(import.meta.dirname, "../../.gitignore")),
  { ignores: ["**/*.config.*"] },
  {
    files: ["**/*.js", "**/*.ts", "**/*.tsx"],
    plugins: {
      import: importPlugin,
      turbo: turboPlugin,
    },
    extends: [
      eslint.configs.recommended,
      ...tseslint.configs.recommended,
      ...tseslint.configs.recommendedTypeChecked,
      ...tseslint.configs.stylisticTypeChecked,
    ],
    rules: {
      ...turboPlugin.configs.recommended.rules,
      "@typescript-eslint/no-unused-vars": [
        "error",
        { argsIgnorePattern: "^_", varsIgnorePattern: "^_" },
      ],
      "@typescript-eslint/consistent-type-imports": [
        "warn",
        { prefer: "type-imports", fixStyle: "separate-type-imports" },
      ],
      "@typescript-eslint/no-misused-promises": [
        2,
        { checksVoidReturn: { attributes: false } },
      ],
      "@typescript-eslint/no-unnecessary-condition": [
        "error",
        {
          allowConstantLoopConditions: true,
        },
      ],
      "@typescript-eslint/no-non-null-assertion": "error",
      "import/consistent-type-specifier-style": ["error", "prefer-top-level"],
    },
  },
  {
    linterOptions: { reportUnusedDisableDirectives: true },
    languageOptions: { parserOptions: { projectService: true } },
  },
);
</file>

<file path="tooling/eslint/nextjs.js">
import nextPlugin from "@next/eslint-plugin-next";

/** @type {Awaited<import('typescript-eslint').Config>} */
export default [
  {
    files: ["**/*.ts", "**/*.tsx"],
    plugins: {
      "@next/next": nextPlugin,
    },
    rules: {
      ...nextPlugin.configs.recommended.rules,
      ...nextPlugin.configs["core-web-vitals"].rules,
      // TypeError: context.getAncestors is not a function
      "@next/next/no-duplicate-head": "off",
    },
  },
];
</file>

<file path="tooling/eslint/package.json">
{
  "name": "@acme/eslint-config",
  "private": true,
  "version": "0.3.0",
  "type": "module",
  "exports": {
    "./base": "./base.js",
    "./nextjs": "./nextjs.js",
    "./react": "./react.js"
  },
  "scripts": {
    "clean": "git clean -xdf .cache .turbo node_modules",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@eslint/compat": "^1.2.7",
    "@next/eslint-plugin-next": "^15.2.3",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-react": "^7.37.4",
    "eslint-plugin-react-compiler": "beta",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-turbo": "^2.4.4",
    "typescript-eslint": "^8.27.0"
  },
  "devDependencies": {
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="tooling/eslint/react.js">
import reactPlugin from "eslint-plugin-react";
import compilerPlugin from "eslint-plugin-react-compiler";
import hooksPlugin from "eslint-plugin-react-hooks";

/** @type {Awaited<import('typescript-eslint').Config>} */
export default [
  {
    files: ["**/*.ts", "**/*.tsx"],
    plugins: {
      react: reactPlugin,
      "react-compiler": compilerPlugin,
      "react-hooks": hooksPlugin,
    },
    rules: {
      ...reactPlugin.configs["jsx-runtime"].rules,
      ...hooksPlugin.configs.recommended.rules,
      "react-compiler/react-compiler": "error",
    },
    languageOptions: {
      globals: {
        React: "writable",
      },
    },
  },
];
</file>

<file path="tooling/eslint/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "include": ["."],
  "exclude": ["node_modules"]
}
</file>

<file path="tooling/eslint/types.d.ts">
/**
 * Since the ecosystem hasn't fully migrated to ESLint's new FlatConfig system yet,
 * we "need" to type some of the plugins manually :(
 */

declare module "eslint-plugin-import" {
  import type { Linter, Rule } from "eslint";

  export const configs: {
    recommended: { rules: Linter.RulesRecord };
  };
  export const rules: Record<string, Rule.RuleModule>;
}

declare module "eslint-plugin-react" {
  import type { Linter, Rule } from "eslint";

  export const configs: {
    recommended: { rules: Linter.RulesRecord };
    all: { rules: Linter.RulesRecord };
    "jsx-runtime": { rules: Linter.RulesRecord };
  };
  export const rules: Record<string, Rule.RuleModule>;
}

declare module "eslint-plugin-react-compiler" {}

declare module "eslint-plugin-react-hooks" {
  import type { Linter, Rule } from "eslint";

  export const configs: {
    recommended: {
      rules: {
        "rules-of-hooks": Linter.RuleEntry;
        "exhaustive-deps": Linter.RuleEntry;
      };
    };
  };
  export const rules: Record<string, Rule.RuleModule>;
}

declare module "@next/eslint-plugin-next" {
  import type { Linter, Rule } from "eslint";

  export const configs: {
    recommended: { rules: Linter.RulesRecord };
    "core-web-vitals": { rules: Linter.RulesRecord };
  };
  export const rules: Record<string, Rule.RuleModule>;
}
</file>

<file path="tooling/github/setup/action.yml">
name: "Setup and install"
description: "Common setup steps for Actions"

runs:
  using: composite
  steps:
    - uses: pnpm/action-setup@v4
    - uses: actions/setup-node@v4
      with:
        node-version-file: ".nvmrc"
        cache: "pnpm"

    - shell: bash
      run: pnpm add -g turbo

    - shell: bash
      run: pnpm install
</file>

<file path="tooling/github/package.json">
{
  "name": "@acme/github"
}
</file>

<file path="tooling/prettier/index.js">
import { fileURLToPath } from "node:url";

/** @typedef {import("prettier").Config} PrettierConfig */
/** @typedef {import("prettier-plugin-tailwindcss").PluginOptions} TailwindConfig */
/** @typedef {import("@ianvs/prettier-plugin-sort-imports").PluginConfig} SortImportsConfig */

/** @type { PrettierConfig | SortImportsConfig | TailwindConfig } */
const config = {
  plugins: [
    "@ianvs/prettier-plugin-sort-imports",
    "prettier-plugin-tailwindcss",
  ],
  tailwindConfig: fileURLToPath(
    new URL("../../tooling/tailwind/web.ts", import.meta.url),
  ),
  tailwindFunctions: ["cn", "cva"],
  importOrder: [
    "<TYPES>",
    "^(react/(.*)$)|^(react$)|^(react-native(.*)$)",
    "^(next/(.*)$)|^(next$)",
    "^(expo(.*)$)|^(expo$)",
    "<THIRD_PARTY_MODULES>",
    "",
    "<TYPES>^@acme",
    "^@acme/(.*)$",
    "",
    "<TYPES>^[.|..|~]",
    "^~/",
    "^[../]",
    "^[./]",
  ],
  importOrderParserPlugins: ["typescript", "jsx", "decorators-legacy"],
  importOrderTypeScriptVersion: "4.4.0",
  overrides: [
    {
      files: "*.json.hbs",
      options: {
        parser: "json",
      },
    },
    {
      files: "*.js.hbs",
      options: {
        parser: "babel",
      },
    },
  ],
};

export default config;
</file>

<file path="tooling/prettier/package.json">
{
  "name": "@acme/prettier-config",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": "./index.js"
  },
  "scripts": {
    "clean": "git clean -xdf .cache .turbo node_modules",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@ianvs/prettier-plugin-sort-imports": "^4.4.1",
    "prettier": "catalog:",
    "prettier-plugin-tailwindcss": "^0.6.11"
  },
  "devDependencies": {
    "@acme/tsconfig": "workspace:*",
    "@types/node": "^22.13.11",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="tooling/prettier/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "include": ["."],
  "exclude": ["node_modules"]
}
</file>

<file path="tooling/tailwind/base.ts">
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["src/**/*.{ts,tsx}"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderColor: {
        DEFAULT: "hsl(var(--border))",
      },
    },
  },
} satisfies Config;
</file>

<file path="tooling/tailwind/eslint.config.js">
// FIXME: This kinda stinks...
/// <reference types="../../tooling/eslint/types.d.ts" />

import baseConfig from "@acme/eslint-config/base";

export default [...baseConfig];
</file>

<file path="tooling/tailwind/native.ts">
import type { Config } from "tailwindcss";

import base from "./base";

export default {
  content: base.content,
  presets: [base],
  theme: {},
} satisfies Config;
</file>

<file path="tooling/tailwind/package.json">
{
  "name": "@acme/tailwind-config",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "exports": {
    "./native": "./native.ts",
    "./web": "./web.ts"
  },
  "license": "MIT",
  "scripts": {
    "clean": "git clean -xdf .cache .turbo node_modules",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "postcss": "^8.5.3",
    "tailwindcss": "catalog:",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "@types/node": "^22.13.11",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="tooling/tailwind/tsconfig.json">
{
  "extends": "@acme/tsconfig/base.json",
  "include": ["."],
  "exclude": ["node_modules"]
}
</file>

<file path="tooling/tailwind/web.ts">
import type { Config } from "tailwindcss";
import animate from "tailwindcss-animate";

import base from "./base";

export default {
  content: base.content,
  presets: [base],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [animate],
} satisfies Config;
</file>

<file path="tooling/typescript/base.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    /** Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "lib": ["ES2022"],
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,

    /** Keep TSC performant in monorepos */
    "incremental": true,
    "disableSourceOfProjectReferenceRedirect": true,
    "tsBuildInfoFile": "${configDir}/.cache/tsbuildinfo.json",

    /** Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,

    /** Transpile using Bundler (not tsc) */
    "module": "Preserve",
    "moduleResolution": "Bundler",
    "noEmit": true
  },
  "exclude": ["node_modules", "build", "dist", ".next", ".expo"]
}
</file>

<file path="tooling/typescript/internal-package.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "./base.json",
  "compilerOptions": {
    /** Emit types for internal packages to speed up editor performance. */
    "declaration": true,
    "declarationMap": true,
    "emitDeclarationOnly": true,
    "noEmit": false,
    "outDir": "${configDir}/dist"
  }
}
</file>

<file path="tooling/typescript/package.json">
{
  "name": "@acme/tsconfig",
  "private": true,
  "version": "0.1.0",
  "files": [
    "*.json"
  ]
}
</file>

<file path="turbo/generators/templates/eslint.config.js.hbs">
import baseConfig from "@acme/eslint-config/base";

/** @type {import('typescript-eslint').Config} */
export default [
  {
    ignores: [],
  },
  ...baseConfig,
];
</file>

<file path="turbo/generators/templates/package.json.hbs">
{
  "name": "@acme/{{ name }}",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": "./src/index.ts"
  },
  "license": "MIT",
  "scripts": {
    "build": "tsc",
    "clean": "git clean -xdf .cache .turbo dist node_modules",
    "dev": "tsc",
    "format": "prettier --check . --ignore-path ../../.gitignore",
    "lint": "eslint",
    "typecheck": "tsc --noEmit --emitDeclarationOnly false"
  },
  "devDependencies": {
    "@acme/eslint-config": "workspace:*",
    "@acme/prettier-config": "workspace:*",
    "@acme/tsconfig": "workspace:*",
    "eslint": "catalog:",
    "prettier": "catalog:",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="turbo/generators/templates/tsconfig.json.hbs">
{
  "extends": "@acme/tsconfig/internal-package.json",
  "compilerOptions": {},
  "include": ["*.ts", "src"],
  "exclude": ["node_modules"]
}
</file>

<file path="turbo/generators/config.ts">
import { execSync } from "node:child_process";
import type { PlopTypes } from "@turbo/gen";

interface PackageJson {
  name: string;
  scripts: Record<string, string>;
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
}

export default function generator(plop: PlopTypes.NodePlopAPI): void {
  plop.setGenerator("init", {
    description: "Generate a new package for the Acme Monorepo",
    prompts: [
      {
        type: "input",
        name: "name",
        message:
          "What is the name of the package? (You can skip the `@acme/` prefix)",
      },
      {
        type: "input",
        name: "deps",
        message:
          "Enter a space separated list of dependencies you would like to install",
      },
    ],
    actions: [
      (answers) => {
        if ("name" in answers && typeof answers.name === "string") {
          if (answers.name.startsWith("@acme/")) {
            answers.name = answers.name.replace("@acme/", "");
          }
        }
        return "Config sanitized";
      },
      {
        type: "add",
        path: "packages/{{ name }}/eslint.config.js",
        templateFile: "templates/eslint.config.js.hbs",
      },
      {
        type: "add",
        path: "packages/{{ name }}/package.json",
        templateFile: "templates/package.json.hbs",
      },
      {
        type: "add",
        path: "packages/{{ name }}/tsconfig.json",
        templateFile: "templates/tsconfig.json.hbs",
      },
      {
        type: "add",
        path: "packages/{{ name }}/src/index.ts",
        template: "export const name = '{{ name }}';",
      },
      {
        type: "modify",
        path: "packages/{{ name }}/package.json",
        async transform(content, answers) {
          if ("deps" in answers && typeof answers.deps === "string") {
            const pkg = JSON.parse(content) as PackageJson;
            for (const dep of answers.deps.split(" ").filter(Boolean)) {
              const version = await fetch(
                `https://registry.npmjs.org/-/package/${dep}/dist-tags`,
              )
                .then((res) => res.json())
                .then((json) => json.latest);
              if (!pkg.dependencies) pkg.dependencies = {};
              pkg.dependencies[dep] = `^${version}`;
            }
            return JSON.stringify(pkg, null, 2);
          }
          return content;
        },
      },
      async (answers) => {
        /**
         * Install deps and format everything
         */
        if ("name" in answers && typeof answers.name === "string") {
          // execSync("pnpm dlx sherif@latest --fix", {
          //   stdio: "inherit",
          // });
          execSync("pnpm i", { stdio: "inherit" });
          execSync(
            `pnpm prettier --write packages/${answers.name}/** --list-different`,
          );
          return "Package scaffolded";
        }
        return "Package not scaffolded";
      },
    ],
  });
}
</file>

<file path=".env.example">
# Since .env is gitignored, you can use .env.example to build a new `.env` file when you clone the repo.
# Keep this file up-to-date when you add new variables to \`.env\`.

# This file will be committed to version control, so make sure not to have any secrets in it.
# If you are cloning this repo, create a copy of this file named `.env` and populate it with your secrets.

# The database URL is used to connect to your Supabase database.
POSTGRES_URL="postgres://postgres.[USERNAME]:[PASSWORD]@aws-0-eu-central-1.pooler.supabase.com:6543/postgres?workaround=supabase-pooler.vercel"


# You can generate the secret via 'openssl rand -base64 32' on Unix
# @see https://next-auth.js.org/configuration/options#secret
AUTH_SECRET='supersecret'

# Preconfigured Discord OAuth provider, works out-of-the-box
# @see https://next-auth.js.org/providers/discord
AUTH_DISCORD_ID=''
AUTH_DISCORD_SECRET=''

# In case you're using the Auth Proxy (apps/auth-proxy)
# AUTH_REDIRECT_PROXY_URL='https://auth.your-server.com/r'
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
next-env.d.ts

# nitro
.nitro/
.output/

# expo
.expo/
expo-env.d.ts
apps/expo/.gitignore
apps/expo/ios
apps/expo/android

# production
build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env
.env*.local

# vercel
.vercel

# typescript
dist/
.cache

# turbo
.turbo
</file>

<file path=".npmrc">
node-linker=hoisted
link-workspace-packages=true
</file>

<file path=".nvmrc">
22.14
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2023 Julius Marminge

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "create-t3-turbo",
  "private": true,
  "engines": {
    "node": ">=22.14.0",
    "pnpm": ">=9.6.0"
  },
  "packageManager": "pnpm@10.6.3",
  "scripts": {
    "build": "turbo run build",
    "clean": "git clean -xdf node_modules",
    "clean:workspaces": "turbo run clean",
    "db:push": "turbo -F @acme/db push",
    "db:studio": "turbo -F @acme/db studio",
    "dev": "turbo watch dev --continue",
    "dev:next": "turbo watch dev -F @acme/nextjs...",
    "format": "turbo run format --continue -- --cache --cache-location .cache/.prettiercache",
    "format:fix": "turbo run format --continue -- --write --cache --cache-location .cache/.prettiercache",
    "lint": "turbo run lint --continue -- --cache --cache-location .cache/.eslintcache",
    "lint:fix": "turbo run lint --continue -- --fix --cache --cache-location .cache/.eslintcache",
    "lint:ws": "pnpm dlx sherif@latest",
    "postinstall": "pnpm lint:ws",
    "typecheck": "turbo run typecheck",
    "ui-add": "turbo run ui-add"
  },
  "devDependencies": {
    "@acme/prettier-config": "workspace:*",
    "@turbo/gen": "^2.4.4",
    "prettier": "catalog:",
    "turbo": "^2.4.4",
    "typescript": "catalog:"
  },
  "prettier": "@acme/prettier-config"
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - apps/*
  - packages/*
  - tooling/*

catalog:
  # Auth
  "@auth/core": 0.37.2
  "@auth/drizzle-adapter": ~1.7.4
  "next-auth": 5.0.0-beta.25

  # Dev tooling
  eslint: ^9.23.0
  prettier: ^3.5.3
  tailwindcss: ^3.4.15
  typescript: ^5.8.2

  # Misc
  zod: ^3.24.2

  # Tanstack & tRPC
  "@tanstack/react-query": ^5.69.0
  "@trpc/client": ^11.0.0
  "@trpc/tanstack-react-query": ^11.0.0
  "@trpc/server": ^11.0.0

catalogs:
  react19:
    react: 19.0.0
    react-dom: 19.0.0
    "@types/react": ^19.0.12
    "@types/react-dom": ^19.0.4
</file>

<file path="README.md">
# create-t3-turbo

> [!NOTE]
>
> NextAuth setup now works for Expo app!

> [!NOTE]
>
> OAuth deployments are now working for preview deployments. Read [deployment guide](https://github.com/t3-oss/create-t3-turbo#auth-proxy) and [check out the source](./apps/auth-proxy) to learn more!

## Installation

> [!NOTE]
>
> Make sure to follow the system requirements specified in [`package.json#engines`](./package.json#L4) before proceeding.

There are two ways of initializing an app using the `create-t3-turbo` starter. You can either use this repository as a template:

![use-as-template](https://github.com/t3-oss/create-t3-turbo/assets/51714798/bb6c2e5d-d8b6-416e-aeb3-b3e50e2ca994)

or use Turbo's CLI to init your project (use PNPM as package manager):

```bash
npx create-turbo@latest -e https://github.com/t3-oss/create-t3-turbo
```

## About

Ever wondered how to migrate your T3 application into a monorepo? Stop right here! This is the perfect starter repo to get you running with the perfect stack!

It uses [Turborepo](https://turborepo.org) and contains:

```text
.github
  └─ workflows
        └─ CI with pnpm cache setup
.vscode
  └─ Recommended extensions and settings for VSCode users
apps
  ├─ auth-proxy
  |   ├─ Nitro server to proxy OAuth requests in preview deployments
  |   └─ Uses Auth.js Core
  ├─ expo
  |   ├─ Expo SDK 53 (EXPERIMENTAL)
  |   |   > [!WARNING]
  |   |   > Using Expo SDK 53 (canary) to unblock Next.js 15 / React 19 support.
  |   |   > This is experimental and might not work as expected.
  |   ├─ React Native using React 19
  |   ├─ Navigation using Expo Router
  |   ├─ Tailwind using NativeWind
  |   └─ Typesafe API calls using tRPC
  └─ next.js
      ├─ Next.js 15
      ├─ React 19
      ├─ Tailwind CSS
      └─ E2E Typesafe API Server & Client
packages
  ├─ api
  |   └─ tRPC v11 router definition
  ├─ auth
  |   └─ Authentication using next-auth.
  ├─ db
  |   └─ Typesafe db calls using Drizzle & Supabase
  └─ ui
      └─ Start of a UI package for the webapp using shadcn-ui
tooling
  ├─ eslint
  |   └─ shared, fine-grained, eslint presets
  ├─ prettier
  |   └─ shared prettier configuration
  ├─ tailwind
  |   └─ shared tailwind configuration
  └─ typescript
      └─ shared tsconfig you can extend from
```

> In this template, we use `@acme` as a placeholder for package names. As a user, you might want to replace it with your own organization or project name. You can use find-and-replace to change all the instances of `@acme` to something like `@my-company` or `@project-name`.

## Quick Start

> **Note**
> The [db](./packages/db) package is preconfigured to use Supabase and is **edge-bound** with the [Vercel Postgres](https://github.com/vercel/storage/tree/main/packages/postgres) driver. If you're using something else, make the necessary modifications to the [schema](./packages/db/src/schema.ts) as well as the [client](./packages/db/src/index.ts) and the [drizzle config](./packages/db/drizzle.config.ts). If you want to switch to non-edge database driver, remove `export const runtime = "edge";` [from all pages and api routes](https://github.com/t3-oss/create-t3-turbo/issues/634#issuecomment-1730240214).

To get it running, follow the steps below:

### 1. Setup dependencies

```bash
# Install dependencies
pnpm i

# Configure environment variables
# There is an `.env.example` in the root directory you can use for reference
cp .env.example .env

# Push the Drizzle schema to the database
pnpm db:push
```

### 2. Configure Expo `dev`-script

#### Use iOS Simulator

1. Make sure you have XCode and XCommand Line Tools installed [as shown on expo docs](https://docs.expo.dev/workflow/ios-simulator).

   > **NOTE:** If you just installed XCode, or if you have updated it, you need to open the simulator manually once. Run `npx expo start` from `apps/expo`, and then enter `I` to launch Expo Go. After the manual launch, you can run `pnpm dev` in the root directory.

   ```diff
   +  "dev": "expo start --ios",
   ```

2. Run `pnpm dev` at the project root folder.

#### Use Android Emulator

1. Install Android Studio tools [as shown on expo docs](https://docs.expo.dev/workflow/android-studio-emulator).

2. Change the `dev` script at `apps/expo/package.json` to open the Android emulator.

   ```diff
   +  "dev": "expo start --android",
   ```

3. Run `pnpm dev` at the project root folder.

### 3. Configuring Next-Auth to work with Expo

In order to get Next-Auth to work with Expo, you must either:

#### Deploy the Auth Proxy (RECOMMENDED)

In [apps/auth-proxy](./apps/auth-proxy) you can find a Nitro server that proxies OAuth requests. By deploying this and setting the `AUTH_REDIRECT_PROXY_URL` environment variable to the URL of this proxy, you can get OAuth working in preview deployments and development for Expo apps. See more deployment instructions in the [auth proxy README](./apps/auth-proxy/README.md).

By using the proxy server, the Next.js apps will forward any auth requests to the proxy server, which will handle the OAuth flow and then redirect back to the Next.js app. This makes it easy to get OAuth working since you'll have a stable URL that is publically accessible and doesn't change for every deployment and doesn't rely on what port the app is running on. So if port 3000 is taken and your Next.js app starts at port 3001 instead, your auth should still work without having to reconfigure the OAuth provider.

#### Add your local IP to your OAuth provider

You can alternatively add your local IP (e.g. `192.168.x.y:$PORT`) to your OAuth provider. This may not be as reliable as your local IP may change when you change networks. Some OAuth providers may also only support a single callback URL for each app making this approach unviable for some providers (e.g. GitHub).

### 4a. When it's time to add a new UI component

Run the `ui-add` script to add a new UI component using the interactive `shadcn/ui` CLI:

```bash
pnpm ui-add
```

When the component(s) has been installed, you should be good to go and start using it in your app.

### 4b. When it's time to add a new package

To add a new package, simply run `pnpm turbo gen init` in the monorepo root. This will prompt you for a package name as well as if you want to install any dependencies to the new package (of course you can also do this yourself later).

The generator sets up the `package.json`, `tsconfig.json` and a `index.ts`, as well as configures all the necessary configurations for tooling around your package such as formatting, linting and typechecking. When the package is created, you're ready to go build out the package.

## FAQ

### Does the starter include Solito?

No. Solito will not be included in this repo. It is a great tool if you want to share code between your Next.js and Expo app. However, the main purpose of this repo is not the integration between Next.js and Expo — it's the code splitting of your T3 App into a monorepo. The Expo app is just a bonus example of how you can utilize the monorepo with multiple apps but can just as well be any app such as Vite, Electron, etc.

Integrating Solito into this repo isn't hard, and there are a few [official templates](https://github.com/nandorojo/solito/tree/master/example-monorepos) by the creators of Solito that you can use as a reference.

### Does this pattern leak backend code to my client applications?

No, it does not. The `api` package should only be a production dependency in the Next.js application where it's served. The Expo app, and all other apps you may add in the future, should only add the `api` package as a dev dependency. This lets you have full typesafety in your client applications, while keeping your backend code safe.

If you need to share runtime code between the client and server, such as input validation schemas, you can create a separate `shared` package for this and import it on both sides.

## Deployment

### Next.js

#### Prerequisites

> **Note**
> Please note that the Next.js application with tRPC must be deployed in order for the Expo app to communicate with the server in a production environment.

#### Deploy to Vercel

Let's deploy the Next.js application to [Vercel](https://vercel.com). If you've never deployed a Turborepo app there, don't worry, the steps are quite straightforward. You can also read the [official Turborepo guide](https://vercel.com/docs/concepts/monorepos/turborepo) on deploying to Vercel.

1. Create a new project on Vercel, select the `apps/nextjs` folder as the root directory. Vercel's zero-config system should handle all configurations for you.

2. Add your `DATABASE_URL` environment variable.

3. Done! Your app should successfully deploy. Assign your domain and use that instead of `localhost` for the `url` in the Expo app so that your Expo app can communicate with your backend when you are not in development.

### Auth Proxy

The auth proxy is a Nitro server that proxies OAuth requests in preview deployments. This is required for the Next.js app to be able to authenticate users in preview deployments. The auth proxy is not used for OAuth requests in production deployments. To get it running, it's easiest to use Vercel Edge functions. See the [Nitro docs](https://nitro.unjs.io/deploy/providers/vercel#vercel-edge-functions) for how to deploy Nitro to Vercel.

Then, there are some environment variables you need to set in order to get OAuth working:

- For the Next.js app, set `AUTH_REDIRECT_PROXY_URL` to the URL of the auth proxy.
- For the auth proxy server, set `AUTH_REDIRECT_PROXY_URL` to the same as above, as well as `AUTH_DISCORD_ID`, `AUTH_DISCORD_SECRET` (or the equivalent for your OAuth provider(s)). Lastly, set `AUTH_SECRET` **to the same value as in the Next.js app** for preview environments.

Read more about the setup in [the auth proxy README](./apps/auth-proxy/README.md).

### Expo

Deploying your Expo application works slightly differently compared to Next.js on the web. Instead of "deploying" your app online, you need to submit production builds of your app to app stores, like [Apple App Store](https://www.apple.com/app-store) and [Google Play](https://play.google.com/store/apps). You can read the full [guide to distributing your app](https://docs.expo.dev/distribution/introduction), including best practices, in the Expo docs.

1. Make sure to modify the `getBaseUrl` function to point to your backend's production URL:

   <https://github.com/t3-oss/create-t3-turbo/blob/656965aff7db271e5e080242c4a3ce4dad5d25f8/apps/expo/src/utils/api.tsx#L20-L37>

2. Let's start by setting up [EAS Build](https://docs.expo.dev/build/introduction), which is short for Expo Application Services. The build service helps you create builds of your app, without requiring a full native development setup. The commands below are a summary of [Creating your first build](https://docs.expo.dev/build/setup).

   ```bash
   # Install the EAS CLI
   pnpm add -g eas-cli

   # Log in with your Expo account
   eas login

   # Configure your Expo app
   cd apps/expo
   eas build:configure
   ```

3. After the initial setup, you can create your first build. You can build for Android and iOS platforms and use different [`eas.json` build profiles](https://docs.expo.dev/build-reference/eas-json) to create production builds or development, or test builds. Let's make a production build for iOS.

   ```bash
   eas build --platform ios --profile production
   ```

   > If you don't specify the `--profile` flag, EAS uses the `production` profile by default.

4. Now that you have your first production build, you can submit this to the stores. [EAS Submit](https://docs.expo.dev/submit/introduction) can help you send the build to the stores.

   ```bash
   eas submit --platform ios --latest
   ```

   > You can also combine build and submit in a single command, using `eas build ... --auto-submit`.

5. Before you can get your app in the hands of your users, you'll have to provide additional information to the app stores. This includes screenshots, app information, privacy policies, etc. _While still in preview_, [EAS Metadata](https://docs.expo.dev/eas/metadata) can help you with most of this information.

6. Once everything is approved, your users can finally enjoy your app. Let's say you spotted a small typo; you'll have to create a new build, submit it to the stores, and wait for approval before you can resolve this issue. In these cases, you can use EAS Update to quickly send a small bugfix to your users without going through this long process. Let's start by setting up EAS Update.

   The steps below summarize the [Getting started with EAS Update](https://docs.expo.dev/eas-update/getting-started/#configure-your-project) guide.

   ```bash
   # Add the `expo-updates` library to your Expo app
   cd apps/expo
   pnpm expo install expo-updates

   # Configure EAS Update
   eas update:configure
   ```

7. Before we can send out updates to your app, you have to create a new build and submit it to the app stores. For every change that includes native APIs, you have to rebuild the app and submit the update to the app stores. See steps 2 and 3.

8. Now that everything is ready for updates, let's create a new update for `production` builds. With the `--auto` flag, EAS Update uses your current git branch name and commit message for this update. See [How EAS Update works](https://docs.expo.dev/eas-update/how-eas-update-works/#publishing-an-update) for more information.

   ```bash
   cd apps/expo
   eas update --auto
   ```

   > Your OTA (Over The Air) updates must always follow the app store's rules. You can't change your app's primary functionality without getting app store approval. But this is a fast way to update your app for minor changes and bug fixes.

9. Done! Now that you have created your production build, submitted it to the stores, and installed EAS Update, you are ready for anything!

## References

The stack originates from [create-t3-app](https://github.com/t3-oss/create-t3-app).

A [blog post](https://jumr.dev/blog/t3-turbo) where I wrote how to migrate a T3 app into this.
</file>

<file path="turbo.json">
{
  "$schema": "https://turborepo.org/schema.json",
  "ui": "tui",
  "tasks": {
    "topo": {
      "dependsOn": ["^topo"]
    },
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".cache/tsbuildinfo.json", "dist/**"]
    },
    "dev": {
      "dependsOn": ["^dev"],
      "cache": false,
      "persistent": false
    },
    "format": {
      "outputs": [".cache/.prettiercache"],
      "outputLogs": "new-only"
    },
    "lint": {
      "dependsOn": ["^topo", "^build"],
      "outputs": [".cache/.eslintcache"]
    },
    "typecheck": {
      "dependsOn": ["^topo", "^build"],
      "outputs": [".cache/tsbuildinfo.json"]
    },
    "clean": {
      "cache": false
    },
    "//#clean": {
      "cache": false
    },
    "push": {
      "cache": false,
      "interactive": true
    },
    "studio": {
      "cache": false,
      "persistent": true
    },
    "ui-add": {
      "cache": false,
      "interactive": true
    }
  },
  "globalEnv": [
    "POSTGRES_URL",
    "AUTH_DISCORD_ID",
    "AUTH_DISCORD_SECRET",
    "AUTH_REDIRECT_PROXY_URL",
    "AUTH_SECRET",
    "PORT"
  ],
  "globalPassThroughEnv": [
    "NODE_ENV",
    "CI",
    "VERCEL",
    "VERCEL_ENV",
    "VERCEL_URL",
    "npm_lifecycle_event"
  ]
}
</file>

</files>
</file>

<file path="lib/frontend/getFrontendViewComponent.ts">
import type { AdminConfig } from "@/convexadmin/types";
import { GenericCollectionListPage } from "@/components/frontend/views/GenericCollectionListPage"; // Import the generic view
import { PlaceholderView } from "@/components/frontend/views/PlaceholderView"; // Import a default/placeholder view
import React from "react";

interface GetFrontendViewArgs {
  config: AdminConfig;
  segments: string[];
  searchParams: { [key: string]: string | string[] };
}

interface GetFrontendViewResult {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ViewComponent: React.ComponentType<any>; // The component to render
  props: Record<string, unknown>; // Props to pass to the component
}

// TODO: Implement the actual logic to map segments to frontend views
export const getFrontendViewComponent = (
  args: GetFrontendViewArgs,
): GetFrontendViewResult => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { config, segments, searchParams } = args;
  console.log("Frontend Segments:", segments);
  console.log("Frontend Search Params:", searchParams);

  // --- Routing Logic --- //

  // Check if it's a known collection list view path (e.g., /posts, /todos)
  if (segments.length === 1 && config.collections[segments[0]]) {
    const collectionSlug = segments[0];
    const collectionConfig = config.collections[collectionSlug]; // Get the specific config

    if (!collectionConfig) {
      // Should not happen if config.collections[segments[0]] exists, but good practice
      console.error(
        `Config not found for slug: ${collectionSlug} in getFrontendViewComponent`,
      );
      return {
        ViewComponent: PlaceholderView,
        props: {
          segments,
          searchParams,
          message: `Configuration error for ${collectionSlug}.`,
        },
      };
    }

    return {
      ViewComponent: GenericCollectionListPage,
      props: { collectionSlug, collectionConfig }, // Pass specific config as prop
    };
  }

  // --- Add more routes here --- //
  // Example: Check if it's a known collection detail view?
  // if (segments.length === 2 && config.collections[segments[0]]) {
  //   // const slug = segments[1];
  //   // return { ViewComponent: CollectionDetailView, props: { collectionSlug: segments[0], documentSlug: slug, ... } };
  // }

  // Default/Fallback View
  return {
    ViewComponent: PlaceholderView,
    props: {
      segments,
      searchParams,
      message: "No specific view mapped for this path.",
    },
  };
};
</file>

<file path="public/.generated/admin-config.json">
{
  "collections": {
    "todos": {
      "label": "Todos",
      "pluralLabel": "Todos",
      "fields": {
        "text": {
          "label": "Text",
          "type": "string"
        },
        "isCompleted": {
          "label": "Is Completed",
          "type": "boolean"
        },
        "createdAt": {
          "label": "Created At",
          "type": "number"
        },
        "updatedAt": {
          "label": "Updated At",
          "type": "number"
        }
      }
    }
  }
}
</file>

<file path="public/convex.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 367 370" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(1,0,0,1,-129.225,-127.948)">
        <g id="Layer-1" serif:id="Layer 1" transform="matrix(4.16667,0,0,4.16667,0,0)">
            <g transform="matrix(1,0,0,1,86.6099,107.074)">
                <path d="M0,-6.544C13.098,-7.973 25.449,-14.834 32.255,-26.287C29.037,2.033 -2.48,19.936 -28.196,8.94C-30.569,7.925 -32.605,6.254 -34.008,4.088C-39.789,-4.83 -41.69,-16.18 -38.963,-26.48C-31.158,-13.247 -15.3,-5.131 0,-6.544" style="fill:rgb(245,176,26);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(1,0,0,1,47.1708,74.7779)">
                <path d="M0,-2.489C-5.312,9.568 -5.545,23.695 0.971,35.316C-21.946,18.37 -21.692,-17.876 0.689,-34.65C2.754,-36.197 5.219,-37.124 7.797,-37.257C18.41,-37.805 29.19,-33.775 36.747,-26.264C21.384,-26.121 6.427,-16.446 0,-2.489" style="fill:rgb(141,37,118);fill-rule:nonzero;"/>
            </g>
            <g transform="matrix(1,0,0,1,91.325,66.4152)">
                <path d="M0,-14.199C-7.749,-24.821 -19.884,-32.044 -33.173,-32.264C-7.482,-43.726 24.112,-25.143 27.557,2.322C27.877,4.876 27.458,7.469 26.305,9.769C21.503,19.345 12.602,26.776 2.203,29.527C9.838,15.64 8.889,-1.328 0,-14.199" style="fill:rgb(238,52,47);fill-rule:nonzero;"/>
            </g>
        </g>
    </g>
</svg>
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# Ignored for the template, you probably want to remove it:
package-lock.json

# clerk configuration (can include secrets)
/.clerk/

# Payload Source Packages (Keep locally, ignore in Git)
docs/payloadpackages/
</file>

<file path=".prettierrc">
{}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/convexadmin/components",
    "utils": "@/convexadmin/lib/utils",
    "ui": "@/convexadmin/components/ui",
    "lib": "@/convexadmin/lib",
    "hooks": "@/convexadmin/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="middleware.ts">
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isProtectedRoute = createRouteMatcher(["/server"]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) await auth.protect();
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "convex-nextjs-clerk",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "generate:admin": "tsx convexadmin/scripts/generate-admin.ts",
    "dev": "pnpm generate:admin && next dev",
    "dev:frontend": "next dev",
    "dev:backend": "convex dev",
    "predev": "convex dev --until-success && convex dashboard",
    "build": "pnpm generate:admin && next build",
    "start": "next start",
    "lint": "next lint",
    "convex": "convex"
  },
  "dependencies": {
    "@clerk/clerk-react": "^5.25.0",
    "@clerk/nextjs": "^6.12.6",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@hookform/resolvers": "^5.0.1",
    "@measured/puck": "^0.18.3",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-table": "^8.21.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "convex": "^1.23.0",
    "date-fns": "^4.1.0",
    "embla-carousel-react": "^8.6.0",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.488.0",
    "next": "15.2.3",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.55.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.2.0",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@faceless-ui/window-info": "^3.0.1",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.2.3",
    "npm-run-all": "^4.1.5",
    "prettier": "^3.5.3",
    "qs-esm": "^7.0.2",
    "tailwindcss": "^4",
    "ts-morph": "^25.0.1",
    "tsx": "^4.19.3",
    "typescript": "^5",
    "zod": "^3.24.3"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
# Welcome to your Convex + Next.js + Clerk app

This is a [Convex](https://convex.dev/) project created with [`npm create convex`](https://www.npmjs.com/package/create-convex).

After the initial setup (<2 minutes) you'll have a working full-stack app using:

- Convex as your backend (database, server logic)
- [React](https://react.dev/) as your frontend (web page interactivity)
- [Next.js](https://nextjs.org/) for optimized web hosting and page routing
- [Tailwind](https://tailwindcss.com/) for building great looking accessible UI
- [Clerk](https://clerk.com/) for authentication

## Get started

If you just cloned this codebase and didn't use `npm create convex`, run:

```
npm install
npm run dev
```

If you're reading this README on GitHub and want to use this template, run:

```
npm create convex@latest -- -t nextjs-clerk
```

Then:

1. Open your app. There should be a "Claim your application" button from Clerk in the bottom right of your app.
2. Follow the steps to claim your application and link it to this app.
3. Follow step 3 in the [Convex Clerk onboarding guide](https://docs.convex.dev/auth/clerk#get-started) to create a Convex JWT template.
4. Uncomment the Clerk provider in `convex/auth.config.ts`
5. Paste the Issuer URL as `CLERK_JWT_ISSUER_DOMAIN` to your dev deployment environment variable settings on the Convex dashboard (see [docs](https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances))

If you want to sync Clerk user data via webhooks, check out this [example repo](https://github.com/thomasballinger/convex-clerk-users-table/).

## Learn more

To learn more about developing your project with Convex, check out:

- The [Tour of Convex](https://docs.convex.dev/get-started) for a thorough introduction to Convex principles.
- The rest of [Convex docs](https://docs.convex.dev/) to learn about all Convex features.
- [Stack](https://stack.convex.dev/) for in-depth articles on advanced topics.

## Join the community

Join thousands of developers building full-stack apps with Convex:

- Join the [Convex Discord community](https://convex.dev/community) to get help in real-time.
- Follow [Convex on GitHub](https://github.com/get-convex/), star and contribute to the open-source implementation of Convex.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
