{"version":3,"file":"addFieldStatePromise.js","names":["getBlockSelect","deepCopyObjectSimple","fieldAffectsData","fieldHasSubFields","fieldIsHiddenOrDisabled","fieldIsID","fieldIsLocalized","getFieldPaths","tabHasName","ObjectIdImport","resolveFilterOptions","iterateFields","ObjectId","default","addFieldStatePromise","args","id","addErrorPathToParent","addErrorPathToParentArg","anyParentLocalized","blockData","clientFieldSchemaMap","collectionSlug","data","field","fieldSchemaMap","filter","forceFullValue","fullData","includeSchema","indexPath","mockRSCs","omitParents","operation","parentPath","parentPermissions","parentSchemaPath","passesCondition","path","preferences","previousFormState","renderAllFields","renderFieldFn","req","schemaPath","select","selectMode","skipConditionChecks","skipValidation","state","console","warn","lastRenderedPath","fieldPermissions","fieldState","fieldSchema","name","hasPermission","read","access","siblingData","validate","validationResult","jsonError","type","JSON","parse","e","event","previousValue","initialValue","err","payload","logger","error","msg","errorPath","errorPaths","includes","push","valid","errorMessage","arrayValue","Array","isArray","arraySelect","promises","rows","reduce","acc","row","i","toHexString","idKey","value","fields","find","localized","parentIndexPath","parentPassesCondition","permissions","undefined","previousRows","previousRow","prevRow","newRow","isLoading","collapsedRowIDsFromPrefs","collapsed","admin","initCollapsed","length","Promise","all","disableFormData","blocksValue","rowMetadata","blockTypeToMatch","blockType","block","blocks","blockReferences","slug","Error","blockSelect","blockSelectMode","blockField","fieldKey","blockNameKey","blockName","collapsedRowIDs","groupSelect","filterOptions","relationTo","relation","query","user","hasMany","relationshipValue","map","relationship","tabs","tab","tabIndex","isNamedTab","tabSelect","tabIndexPath","tabPath","tabSchemaPath","index","childPermissions","tabPermissions","pathSegments","split","tabPassesCondition","condition","fieldConfig","get","endsWith","formState","previousFieldState"],"sources":["../../../src/forms/fieldSchemasToFormState/addFieldStatePromise.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientFieldSchemaMap,\n  Data,\n  DocumentPreferences,\n  Field,\n  FieldSchemaMap,\n  FieldState,\n  FlattenedBlock,\n  FormState,\n  FormStateWithoutComponents,\n  PayloadRequest,\n  Row,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SelectMode,\n  SelectType,\n  Validate,\n} from \"@convexcms/core\";\nimport { getBlockSelect } from \"@convexcms/core\";\nimport {\n  deepCopyObjectSimple,\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsHiddenOrDisabled,\n  fieldIsID,\n  fieldIsLocalized,\n  getFieldPaths,\n  tabHasName,\n} from \"@convexcms/core/shared\";\nimport ObjectIdImport from \"bson-objectid\";\n\nimport type { RenderFieldMethod } from \"./types.js\";\nimport { resolveFilterOptions } from \"../../utilities/resolveFilterOptions.js\";\nimport { iterateFields } from \"./iterateFields.js\";\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default;\n\nexport type AddFieldStatePromiseArgs = {\n  addErrorPathToParent: (fieldPath: string) => void;\n  /**\n   * if all parents are localized, then the field is localized\n   */\n  anyParentLocalized?: boolean;\n  /**\n   * Data of the nearest parent block, or undefined\n   */\n  blockData: Data | undefined;\n  clientFieldSchemaMap?: ClientFieldSchemaMap;\n  collectionSlug?: string;\n  data: Data;\n  field: Field;\n  fieldIndex: number;\n  fieldSchemaMap: FieldSchemaMap;\n  /**\n   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.\n   */\n  filter?: (args: AddFieldStatePromiseArgs) => boolean;\n  /**\n   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false\n   */\n  forceFullValue?: boolean;\n  fullData: Data;\n  id: number | string;\n  /**\n   * Whether the field schema should be included in the state\n   */\n  includeSchema?: boolean;\n  indexPath: string;\n  mockRSCs?: BuildFormStateArgs[\"mockRSCs\"];\n  /**\n   * Whether to omit parent fields in the state. @default false\n   */\n  omitParents?: boolean;\n  operation: \"create\" | \"update\";\n  parentIndexPath: string;\n  parentPath: string;\n  parentPermissions: SanitizedFieldsPermissions;\n  parentSchemaPath: string;\n  passesCondition: boolean;\n  path: string;\n  preferences: DocumentPreferences;\n  previousFormState: FormState;\n  renderAllFields: boolean;\n  renderFieldFn: RenderFieldMethod;\n  /**\n   * Req is used for validation and defaultValue calculation. If you don't need validation,\n   * just create your own req and pass in the locale and the user\n   */\n  req: PayloadRequest;\n  schemaPath: string;\n  select?: SelectType;\n  selectMode?: SelectMode;\n  /**\n   * Whether to skip checking the field's condition. @default false\n   */\n  skipConditionChecks?: boolean;\n  /**\n   * Whether to skip validating the field. @default false\n   */\n  skipValidation?: boolean;\n  state: FormStateWithoutComponents;\n};\n\n/**\n * Flattens the fields schema and fields data.\n * The output is the field path (e.g. array.0.name) mapped to a FormField object.\n */\nexport const addFieldStatePromise = async (\n  args: AddFieldStatePromiseArgs,\n): Promise<void> => {\n  const {\n    id,\n    addErrorPathToParent: addErrorPathToParentArg,\n    anyParentLocalized = false,\n    blockData,\n    clientFieldSchemaMap,\n    collectionSlug,\n    data,\n    field,\n    fieldSchemaMap,\n    filter,\n    forceFullValue = false,\n    fullData,\n    includeSchema = false,\n    indexPath,\n    mockRSCs,\n    omitParents = false,\n    operation,\n    parentPath,\n    parentPermissions,\n    parentSchemaPath,\n    passesCondition,\n    path,\n    preferences,\n    previousFormState,\n    renderAllFields,\n    renderFieldFn,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipConditionChecks = false,\n    skipValidation = false,\n    state,\n  } = args;\n\n  if (!args.clientFieldSchemaMap && args.renderFieldFn) {\n    console.warn(\n      \"clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance\",\n    );\n  }\n\n  const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath;\n\n  let fieldPermissions: SanitizedFieldPermissions = true;\n\n  const fieldState: FieldState = {};\n\n  if (lastRenderedPath) {\n    fieldState.lastRenderedPath = lastRenderedPath;\n  }\n\n  if (passesCondition === false) {\n    fieldState.passesCondition = false;\n  }\n\n  if (includeSchema) {\n    fieldState.fieldSchema = field;\n  }\n\n  if (fieldAffectsData(field) && !fieldIsHiddenOrDisabled(field)) {\n    fieldPermissions =\n      parentPermissions === true\n        ? parentPermissions\n        : deepCopyObjectSimple(parentPermissions?.[field.name]);\n\n    let hasPermission: boolean =\n      fieldPermissions === true || deepCopyObjectSimple(fieldPermissions?.read);\n\n    if (typeof field?.access?.read === \"function\") {\n      hasPermission = await field.access.read({\n        id,\n        blockData,\n        data: fullData,\n        req,\n        siblingData: data,\n      });\n    } else {\n      hasPermission = true;\n    }\n\n    if (!hasPermission) {\n      return;\n    }\n\n    const validate: Validate = field.validate;\n\n    let validationResult: string | true = true;\n\n    if (typeof validate === \"function\" && !skipValidation && passesCondition) {\n      let jsonError;\n\n      if (field.type === \"json\" && typeof data[field.name] === \"string\") {\n        try {\n          JSON.parse(data[field.name]);\n        } catch (e) {\n          jsonError = e;\n        }\n      }\n\n      try {\n        validationResult = await validate(data?.[field.name], {\n          ...field,\n          id,\n          blockData,\n          collectionSlug,\n          data: fullData,\n          event: \"onChange\",\n          // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d\n          // @ts-expect-error-next-line\n          jsonError,\n          operation,\n          preferences,\n          previousValue: previousFormState?.[path]?.initialValue,\n          req,\n          siblingData: data,\n        });\n      } catch (err) {\n        validationResult = `Error validating field at path: ${path}`;\n\n        req.payload.logger.error({\n          err,\n          msg: validationResult,\n        });\n      }\n    }\n\n    const addErrorPathToParent = (errorPath: string) => {\n      if (typeof addErrorPathToParentArg === \"function\") {\n        addErrorPathToParentArg(errorPath);\n      }\n\n      if (!fieldState.errorPaths) {\n        fieldState.errorPaths = [];\n      }\n\n      if (!fieldState.errorPaths.includes(errorPath)) {\n        fieldState.errorPaths.push(errorPath);\n        fieldState.valid = false;\n      }\n    };\n\n    if (typeof validationResult === \"string\") {\n      fieldState.errorMessage = validationResult;\n      fieldState.valid = false;\n      addErrorPathToParent(path);\n    }\n\n    switch (field.type) {\n      case \"array\": {\n        const arrayValue = Array.isArray(data[field.name])\n          ? data[field.name]\n          : [];\n\n        const arraySelect = select?.[field.name];\n\n        const { promises, rows } = arrayValue.reduce(\n          (acc, row, i: number) => {\n            const parentPath = path + \".\" + i;\n            row.id = row?.id || new ObjectId().toHexString();\n\n            if (!omitParents && (!filter || filter(args))) {\n              const idKey = parentPath + \".id\";\n\n              state[idKey] = {\n                initialValue: row.id,\n                value: row.id,\n              };\n\n              if (includeSchema) {\n                state[idKey].fieldSchema = field.fields.find((field) =>\n                  fieldIsID(field),\n                );\n              }\n            }\n\n            acc.promises.push(\n              iterateFields({\n                id,\n                addErrorPathToParent,\n                anyParentLocalized: field.localized || anyParentLocalized,\n                blockData,\n                clientFieldSchemaMap,\n                collectionSlug,\n                data: row,\n                fields: field.fields,\n                fieldSchemaMap,\n                filter,\n                forceFullValue,\n                fullData,\n                includeSchema,\n                mockRSCs,\n                omitParents,\n                operation,\n                parentIndexPath: \"\",\n                parentPassesCondition: passesCondition,\n                parentPath,\n                parentSchemaPath: schemaPath,\n                permissions:\n                  fieldPermissions === true\n                    ? fieldPermissions\n                    : fieldPermissions?.fields || {},\n                preferences,\n                previousFormState,\n                renderAllFields,\n                renderFieldFn,\n                req,\n                select:\n                  typeof arraySelect === \"object\" ? arraySelect : undefined,\n                selectMode,\n                skipConditionChecks,\n                skipValidation,\n                state,\n              }),\n            );\n\n            if (!acc.rows) {\n              acc.rows = [];\n            }\n\n            const previousRows = previousFormState?.[path]?.rows || [];\n\n            // First, check if `previousFormState` has a matching row\n            const previousRow: Row = previousRows.find(\n              (prevRow) => prevRow.id === row.id,\n            );\n\n            const newRow: Row = {\n              id: row.id,\n              isLoading: false,\n            };\n\n            if (previousRow?.lastRenderedPath) {\n              newRow.lastRenderedPath = previousRow.lastRenderedPath;\n            }\n\n            acc.rows.push(newRow);\n\n            const collapsedRowIDsFromPrefs =\n              preferences?.fields?.[path]?.collapsed;\n\n            const collapsed = (() => {\n              if (previousRow) {\n                return previousRow.collapsed ?? false;\n              }\n\n              // If previousFormState is undefined, check preferences\n              if (collapsedRowIDsFromPrefs !== undefined) {\n                return collapsedRowIDsFromPrefs.includes(row.id); // Check if collapsed in preferences\n              }\n\n              // If neither exists, fallback to `field.admin.initCollapsed`\n              return field.admin.initCollapsed;\n            })();\n\n            if (collapsed) {\n              acc.rows[acc.rows.length - 1].collapsed = collapsed;\n            }\n\n            return acc;\n          },\n          {\n            promises: [],\n            rows: undefined,\n          },\n        );\n\n        // Wait for all promises and update fields with the results\n        await Promise.all(promises);\n\n        if (rows) {\n          fieldState.rows = rows;\n        }\n\n        // Add values to field state\n        if (data[field.name] !== null) {\n          fieldState.value = forceFullValue ? arrayValue : arrayValue.length;\n          fieldState.initialValue = forceFullValue\n            ? arrayValue\n            : arrayValue.length;\n\n          if (arrayValue.length > 0) {\n            fieldState.disableFormData = true;\n          }\n        }\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState;\n        }\n\n        break;\n      }\n\n      case \"blocks\": {\n        const blocksValue = Array.isArray(data[field.name])\n          ? data[field.name]\n          : [];\n\n        const { promises, rowMetadata } = blocksValue.reduce(\n          (acc, row, i: number) => {\n            const blockTypeToMatch: string = row.blockType;\n\n            const block =\n              req.payload.blocks[blockTypeToMatch] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (blockType) =>\n                  typeof blockType !== \"string\" &&\n                  blockType.slug === blockTypeToMatch,\n              ) as FlattenedBlock | undefined);\n\n            if (!block) {\n              throw new Error(\n                `Block with type \"${row.blockType}\" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`,\n              );\n            }\n\n            const { blockSelect, blockSelectMode } = getBlockSelect({\n              block,\n              select: select?.[field.name],\n              selectMode,\n            });\n\n            const parentPath = path + \".\" + i;\n\n            if (block) {\n              row.id = row?.id || new ObjectId().toHexString();\n\n              if (!omitParents && (!filter || filter(args))) {\n                // Handle block `id` field\n                const idKey = parentPath + \".id\";\n\n                state[idKey] = {\n                  initialValue: row.id,\n                  value: row.id,\n                };\n\n                if (includeSchema) {\n                  state[idKey].fieldSchema = includeSchema\n                    ? block.fields.find((blockField) => fieldIsID(blockField))\n                    : undefined;\n                }\n\n                // Handle `blockType` field\n                const fieldKey = parentPath + \".blockType\";\n\n                state[fieldKey] = {\n                  initialValue: row.blockType,\n                  value: row.blockType,\n                };\n\n                if (includeSchema) {\n                  state[fieldKey].fieldSchema = block.fields.find(\n                    (blockField) =>\n                      \"name\" in blockField && blockField.name === \"blockType\",\n                  );\n                }\n\n                // Handle `blockName` field\n                const blockNameKey = parentPath + \".blockName\";\n\n                state[blockNameKey] = {};\n\n                if (row.blockName) {\n                  state[blockNameKey].initialValue = row.blockName;\n                  state[blockNameKey].value = row.blockName;\n                }\n\n                if (includeSchema) {\n                  state[blockNameKey].fieldSchema = block.fields.find(\n                    (blockField) =>\n                      \"name\" in blockField && blockField.name === \"blockName\",\n                  );\n                }\n              }\n\n              acc.promises.push(\n                iterateFields({\n                  id,\n                  addErrorPathToParent,\n                  anyParentLocalized: field.localized || anyParentLocalized,\n                  blockData: row,\n                  clientFieldSchemaMap,\n                  collectionSlug,\n                  data: row,\n                  fields: block.fields,\n                  fieldSchemaMap,\n                  filter,\n                  forceFullValue,\n                  fullData,\n                  includeSchema,\n                  mockRSCs,\n                  omitParents,\n                  operation,\n                  parentIndexPath: \"\",\n                  parentPassesCondition: passesCondition,\n                  parentPath,\n                  parentSchemaPath: schemaPath + \".\" + block.slug,\n                  permissions:\n                    fieldPermissions === true\n                      ? fieldPermissions\n                      : parentPermissions?.[field.name]?.blocks?.[\n                            block.slug\n                          ] === true\n                        ? true\n                        : parentPermissions?.[field.name]?.blocks?.[block.slug]\n                            ?.fields || {},\n                  preferences,\n                  previousFormState,\n                  renderAllFields,\n                  renderFieldFn,\n                  req,\n                  select:\n                    typeof blockSelect === \"object\" ? blockSelect : undefined,\n                  selectMode: blockSelectMode,\n                  skipConditionChecks,\n                  skipValidation,\n                  state,\n                }),\n              );\n\n              const previousRows = previousFormState?.[path]?.rows || [];\n\n              // First, check if `previousFormState` has a matching row\n              const previousRow: Row = previousRows.find(\n                (prevRow) => prevRow.id === row.id,\n              );\n\n              const newRow: Row = {\n                id: row.id,\n                blockType: row.blockType,\n                isLoading: false,\n              };\n\n              if (previousRow?.lastRenderedPath) {\n                newRow.lastRenderedPath = previousRow.lastRenderedPath;\n              }\n\n              acc.rowMetadata.push(newRow);\n\n              const collapsedRowIDs = preferences?.fields?.[path]?.collapsed;\n\n              const collapsed =\n                collapsedRowIDs === undefined\n                  ? field.admin.initCollapsed\n                  : collapsedRowIDs.includes(row.id);\n\n              if (collapsed) {\n                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed =\n                  collapsed;\n              }\n            }\n\n            return acc;\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        );\n\n        await Promise.all(promises);\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null;\n          fieldState.initialValue = null;\n        } else {\n          fieldState.value = forceFullValue ? blocksValue : blocksValue.length;\n          fieldState.initialValue = forceFullValue\n            ? blocksValue\n            : blocksValue.length;\n\n          if (blocksValue.length > 0) {\n            fieldState.disableFormData = true;\n          }\n        }\n\n        fieldState.rows = rowMetadata;\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState;\n        }\n\n        break;\n      }\n\n      case \"group\": {\n        if (!filter || filter(args)) {\n          fieldState.disableFormData = true;\n          state[path] = fieldState;\n        }\n\n        const groupSelect = select?.[field.name];\n\n        await iterateFields({\n          id,\n          addErrorPathToParent,\n          anyParentLocalized: field.localized || anyParentLocalized,\n          blockData,\n          clientFieldSchemaMap,\n          collectionSlug,\n          data: data?.[field.name] || {},\n          fields: field.fields,\n          fieldSchemaMap,\n          filter,\n          forceFullValue,\n          fullData,\n          includeSchema,\n          mockRSCs,\n          omitParents,\n          operation,\n          parentIndexPath: \"\",\n          parentPassesCondition: passesCondition,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          permissions:\n            typeof fieldPermissions === \"boolean\"\n              ? fieldPermissions\n              : fieldPermissions?.fields,\n          preferences,\n          previousFormState,\n          renderAllFields,\n          renderFieldFn,\n          req,\n          select: typeof groupSelect === \"object\" ? groupSelect : undefined,\n          selectMode,\n          skipConditionChecks,\n          skipValidation,\n          state,\n        });\n\n        break;\n      }\n      case \"relationship\":\n      case \"upload\": {\n        if (field.filterOptions) {\n          if (typeof field.filterOptions === \"object\") {\n            if (typeof field.relationTo === \"string\") {\n              fieldState.filterOptions = {\n                [field.relationTo]: field.filterOptions,\n              };\n            } else {\n              fieldState.filterOptions = field.relationTo.reduce(\n                (acc, relation) => {\n                  acc[relation] = field.filterOptions;\n                  return acc;\n                },\n                {},\n              );\n            }\n          }\n\n          if (typeof field.filterOptions === \"function\") {\n            const query = await resolveFilterOptions(field.filterOptions, {\n              id,\n              blockData,\n              data: fullData,\n              relationTo: field.relationTo,\n              req,\n              siblingData: data,\n              user: req.user,\n            });\n\n            fieldState.filterOptions = query;\n          }\n        }\n\n        if (field.hasMany) {\n          const relationshipValue = Array.isArray(data[field.name])\n            ? data[field.name].map((relationship) => {\n                if (Array.isArray(field.relationTo)) {\n                  return {\n                    relationTo: relationship.relationTo,\n                    value:\n                      relationship.value &&\n                      typeof relationship.value === \"object\"\n                        ? relationship.value?.id\n                        : relationship.value,\n                  };\n                }\n                if (typeof relationship === \"object\" && relationship !== null) {\n                  return relationship.id;\n                }\n                return relationship;\n              })\n            : undefined;\n\n          fieldState.value = relationshipValue;\n          fieldState.initialValue = relationshipValue;\n        } else if (Array.isArray(field.relationTo)) {\n          if (\n            data[field.name] &&\n            typeof data[field.name] === \"object\" &&\n            \"relationTo\" in data[field.name] &&\n            \"value\" in data[field.name]\n          ) {\n            const value =\n              typeof data[field.name]?.value === \"object\" &&\n              data[field.name]?.value &&\n              \"id\" in data[field.name].value\n                ? data[field.name].value.id\n                : data[field.name].value;\n            const relationshipValue = {\n              relationTo: data[field.name]?.relationTo,\n              value,\n            };\n            fieldState.value = relationshipValue;\n            fieldState.initialValue = relationshipValue;\n          }\n        } else {\n          const relationshipValue =\n            data[field.name] &&\n            typeof data[field.name] === \"object\" &&\n            \"id\" in data[field.name]\n              ? data[field.name].id\n              : data[field.name];\n          fieldState.value = relationshipValue;\n          fieldState.initialValue = relationshipValue;\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState;\n        }\n\n        break;\n      }\n\n      default: {\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name];\n          fieldState.initialValue = data[field.name];\n        }\n\n        // Add field to state\n        if (!filter || filter(args)) {\n          state[path] = fieldState;\n        }\n\n        break;\n      }\n    }\n  } else if (fieldHasSubFields(field) && !fieldAffectsData(field)) {\n    // Handle field types that do not use names (row, etc)\n\n    if (!filter || filter(args)) {\n      state[path] = {\n        disableFormData: true,\n      };\n\n      if (passesCondition === false) {\n        state[path].passesCondition = false;\n      }\n    }\n\n    await iterateFields({\n      id,\n      mockRSCs,\n      select,\n      selectMode,\n      // passthrough parent functionality\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data,\n      fields: field.fields,\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: passesCondition,\n      parentPath,\n      parentSchemaPath,\n      permissions: parentPermissions, // TODO: Verify this is correct\n      preferences,\n      previousFormState,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    });\n  } else if (field.type === \"tabs\") {\n    const promises = field.tabs.map((tab, tabIndex) => {\n      const isNamedTab = tabHasName(tab);\n      let tabSelect: SelectType | undefined;\n\n      const {\n        indexPath: tabIndexPath,\n        path: tabPath,\n        schemaPath: tabSchemaPath,\n      } = getFieldPaths({\n        field: {\n          ...tab,\n          type: \"tab\",\n        },\n        index: tabIndex,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath,\n      });\n\n      let childPermissions: SanitizedFieldsPermissions = undefined;\n\n      if (isNamedTab) {\n        if (parentPermissions === true) {\n          childPermissions = true;\n        } else {\n          const tabPermissions = parentPermissions?.[tab.name];\n          if (tabPermissions === true) {\n            childPermissions = true;\n          } else {\n            childPermissions = tabPermissions?.fields;\n          }\n        }\n\n        if (typeof select?.[tab.name] === \"object\") {\n          tabSelect = select?.[tab.name] as SelectType;\n        }\n      } else {\n        childPermissions = parentPermissions;\n        tabSelect = select;\n      }\n\n      const pathSegments = path ? path.split(\".\") : [];\n\n      // If passesCondition is false then this should always result to false\n      // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result\n      let tabPassesCondition = passesCondition;\n\n      if (passesCondition && typeof tab.admin?.condition === \"function\") {\n        tabPassesCondition = tab.admin.condition(fullData, data, {\n          blockData,\n          path: pathSegments,\n          user: req.user,\n        });\n      }\n\n      if (tab?.id) {\n        state[tab.id] = {\n          passesCondition: tabPassesCondition,\n        };\n      }\n\n      return iterateFields({\n        id,\n        addErrorPathToParent: addErrorPathToParentArg,\n        anyParentLocalized: tab.localized || anyParentLocalized,\n        blockData,\n        clientFieldSchemaMap,\n        collectionSlug,\n        data: isNamedTab ? data?.[tab.name] || {} : data,\n        fields: tab.fields,\n        fieldSchemaMap,\n        filter,\n        forceFullValue,\n        fullData,\n        includeSchema,\n        mockRSCs,\n        omitParents,\n        operation,\n        parentIndexPath: isNamedTab ? \"\" : tabIndexPath,\n        parentPassesCondition: tabPassesCondition,\n        parentPath: isNamedTab ? tabPath : parentPath,\n        parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,\n        permissions: childPermissions,\n        preferences,\n        previousFormState,\n        renderAllFields,\n        renderFieldFn,\n        req,\n        select: tabSelect,\n        selectMode,\n        skipConditionChecks,\n        skipValidation,\n        state,\n      });\n    });\n\n    await Promise.all(promises);\n  } else if (field.type === \"ui\") {\n    if (!filter || filter(args)) {\n      state[path] = fieldState;\n      state[path].disableFormData = true;\n    }\n  }\n\n  if (renderFieldFn && !fieldIsHiddenOrDisabled(field)) {\n    const fieldState = state[path];\n\n    const fieldConfig = fieldSchemaMap.get(schemaPath);\n\n    if (!fieldConfig && !mockRSCs) {\n      if (schemaPath.endsWith(\".blockType\")) {\n        return;\n      } else {\n        throw new Error(`Field config not found for ${schemaPath}`);\n      }\n    }\n\n    if (!fieldState) {\n      // Some fields (ie `Tab`) do not live in form state\n      // therefore we cannot attach customComponents to them\n      return;\n    }\n\n    renderFieldFn({\n      id,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: fullData,\n      fieldConfig: fieldConfig as Field,\n      fieldSchemaMap,\n      fieldState,\n      formState: state,\n      indexPath,\n      lastRenderedPath,\n      mockRSCs,\n      operation,\n      parentPath,\n      parentSchemaPath,\n      path,\n      permissions: fieldPermissions,\n      preferences,\n      previousFieldState: previousFormState?.[path],\n      renderAllFields,\n      req,\n      schemaPath,\n      siblingData: data,\n    });\n  }\n};\n"],"mappings":"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","ignoreList":[]}