{"version":3,"file":"mergeServerFormState.js","names":["dequal","mergeErrorPaths","mergeServerFormState","acceptValues","existingState","incomingState","changed","newState","serverPropsToAccept","push","path","newFieldState","Object","entries","fieldChanged","errorPathsResult","errorPaths","result","filterOptions","Array","isArray","rows","forEach","row","matchedExistingRowIndex","findIndex","existingRow","id","propFromServer","serverPropsToIgnore","includes","filter","prop","length","valid","passesCondition","field"],"sources":["../../../src/forms/Form/mergeServerFormState.ts"],"sourcesContent":["\"use client\";\n\nimport type { FieldState, FormState } from \"@convexcms/core\";\nimport { dequal } from \"dequal/lite\"; // lite: no need for Map and Set support\n\nimport { mergeErrorPaths } from \"./mergeErrorPaths.js\";\n\ntype Args = {\n  acceptValues?: boolean;\n  existingState: FormState;\n  incomingState: FormState;\n};\n\n/**\n * Merges certain properties from the server state into the client state. These do not include values,\n * as we do not want to update them on the client like that, which would cause flickering.\n *\n * We want to use this to update the error state, and other properties that are not user input, as the error state\n * is the thing we want to keep in sync with the server (where it's calculated) on the client.\n */\nexport const mergeServerFormState = ({\n  acceptValues,\n  existingState,\n  incomingState,\n}: Args): { changed: boolean; newState: FormState } => {\n  let changed = false;\n\n  const newState = {};\n\n  if (existingState) {\n    const serverPropsToAccept: Array<keyof FieldState> = [\n      \"passesCondition\",\n      \"valid\",\n      \"errorMessage\",\n      \"errorPaths\",\n      \"customComponents\",\n    ];\n\n    if (acceptValues) {\n      serverPropsToAccept.push(\"value\");\n      serverPropsToAccept.push(\"initialValue\");\n    }\n\n    for (const [path, newFieldState] of Object.entries(existingState)) {\n      if (!incomingState[path]) {\n        continue;\n      }\n\n      let fieldChanged = false;\n\n      /**\n       * Handle error paths\n       */\n      const errorPathsResult = mergeErrorPaths(\n        newFieldState.errorPaths,\n        incomingState[path].errorPaths as unknown as string[],\n      );\n\n      if (errorPathsResult.result) {\n        if (errorPathsResult.changed) {\n          changed = errorPathsResult.changed;\n        }\n        newFieldState.errorPaths = errorPathsResult.result;\n      }\n\n      /**\n       * Handle filterOptions\n       */\n      if (incomingState[path]?.filterOptions || newFieldState.filterOptions) {\n        if (\n          !dequal(\n            incomingState[path]?.filterOptions,\n            newFieldState.filterOptions,\n          )\n        ) {\n          changed = true;\n          fieldChanged = true;\n          newFieldState.filterOptions = incomingState[path].filterOptions;\n        }\n      }\n\n      /**\n       * Need to intelligently merge the rows array to ensure changes to local state are not lost while the request was pending\n       * For example, the server response could come back with a row which has been deleted on the client\n       * Loop over the incoming rows, if it exists in client side form state, merge in any new properties from the server\n       */\n      if (Array.isArray(incomingState[path].rows)) {\n        incomingState[path].rows.forEach((row) => {\n          const matchedExistingRowIndex = newFieldState.rows.findIndex(\n            (existingRow) => existingRow.id === row.id,\n          );\n\n          if (matchedExistingRowIndex > -1) {\n            newFieldState.rows[matchedExistingRowIndex] = {\n              ...newFieldState.rows[matchedExistingRowIndex],\n              ...row,\n            };\n          }\n        });\n      }\n\n      /**\n       * Handle adding all the remaining props that should be updated in the local form state from the server form state\n       */\n      serverPropsToAccept.forEach((propFromServer) => {\n        if (\n          !dequal(\n            incomingState[path]?.[propFromServer],\n            newFieldState[propFromServer],\n          )\n        ) {\n          changed = true;\n          fieldChanged = true;\n\n          if (newFieldState?.serverPropsToIgnore?.includes(propFromServer)) {\n            // Remove the ignored prop for the next request\n            newFieldState.serverPropsToIgnore =\n              newFieldState.serverPropsToIgnore.filter(\n                (prop) => prop !== propFromServer,\n              );\n\n            // if no keys left, remove the entire object\n            if (!newFieldState.serverPropsToIgnore.length) {\n              delete newFieldState.serverPropsToIgnore;\n            }\n\n            return;\n          }\n\n          if (!(propFromServer in incomingState[path])) {\n            // Regarding excluding the customComponents prop from being deleted: the incoming state might not have been rendered, as rendering components for every form onchange is expensive.\n            // Thus, we simply re-use the initial render state\n            if (propFromServer !== \"customComponents\") {\n              delete newFieldState[propFromServer];\n            }\n          } else {\n            newFieldState[propFromServer as any] =\n              incomingState[path][propFromServer];\n          }\n        }\n      });\n\n      if (newFieldState.valid !== false) {\n        newFieldState.valid = true;\n      }\n\n      if (newFieldState.passesCondition !== false) {\n        newFieldState.passesCondition = true;\n      }\n\n      // Conditions don't work if we don't memcopy the new state, as the object references would otherwise be the same\n      newState[path] = fieldChanged ? { ...newFieldState } : newFieldState;\n    }\n\n    // Now loop over values that are part of incoming state but not part of existing state, and add them to the new state.\n    // This can happen if a new array row was added. In our local state, we simply add out stubbed `array` and `array.[index].id` entries to the local form state.\n    // However, all other array sub-fields are not added to the local state - those will be added by the server and may be incoming here.\n    for (const [path, field] of Object.entries(incomingState)) {\n      if (!existingState[path]) {\n        changed = true;\n        newState[path] = field;\n      }\n    }\n  }\n\n  return { changed, newState };\n};\n"],"mappings":"AAAA;;AAGA,SAASA,MAAM,QAAQ,cAAc,CAAC;AAEtC,SAASC,eAAe,QAAQ;AAQhC;;;;;;;AAOA,OAAO,MAAMC,oBAAA,GAAuBA,CAAC;EACnCC,YAAY;EACZC,aAAa;EACbC;AAAa,CACR;EACL,IAAIC,OAAA,GAAU;EAEd,MAAMC,QAAA,GAAW,CAAC;EAElB,IAAIH,aAAA,EAAe;IACjB,MAAMI,mBAAA,GAA+C,CACnD,mBACA,SACA,gBACA,cACA,mBACD;IAED,IAAIL,YAAA,EAAc;MAChBK,mBAAA,CAAoBC,IAAI,CAAC;MACzBD,mBAAA,CAAoBC,IAAI,CAAC;IAC3B;IAEA,KAAK,MAAM,CAACC,IAAA,EAAMC,aAAA,CAAc,IAAIC,MAAA,CAAOC,OAAO,CAACT,aAAA,GAAgB;MACjE,IAAI,CAACC,aAAa,CAACK,IAAA,CAAK,EAAE;QACxB;MACF;MAEA,IAAII,YAAA,GAAe;MAEnB;;;MAGA,MAAMC,gBAAA,GAAmBd,eAAA,CACvBU,aAAA,CAAcK,UAAU,EACxBX,aAAa,CAACK,IAAA,CAAK,CAACM,UAAU;MAGhC,IAAID,gBAAA,CAAiBE,MAAM,EAAE;QAC3B,IAAIF,gBAAA,CAAiBT,OAAO,EAAE;UAC5BA,OAAA,GAAUS,gBAAA,CAAiBT,OAAO;QACpC;QACAK,aAAA,CAAcK,UAAU,GAAGD,gBAAA,CAAiBE,MAAM;MACpD;MAEA;;;MAGA,IAAIZ,aAAa,CAACK,IAAA,CAAK,EAAEQ,aAAA,IAAiBP,aAAA,CAAcO,aAAa,EAAE;QACrE,IACE,CAAClB,MAAA,CACCK,aAAa,CAACK,IAAA,CAAK,EAAEQ,aAAA,EACrBP,aAAA,CAAcO,aAAa,GAE7B;UACAZ,OAAA,GAAU;UACVQ,YAAA,GAAe;UACfH,aAAA,CAAcO,aAAa,GAAGb,aAAa,CAACK,IAAA,CAAK,CAACQ,aAAa;QACjE;MACF;MAEA;;;;;MAKA,IAAIC,KAAA,CAAMC,OAAO,CAACf,aAAa,CAACK,IAAA,CAAK,CAACW,IAAI,GAAG;QAC3ChB,aAAa,CAACK,IAAA,CAAK,CAACW,IAAI,CAACC,OAAO,CAAEC,GAAA;UAChC,MAAMC,uBAAA,GAA0Bb,aAAA,CAAcU,IAAI,CAACI,SAAS,CACzDC,WAAA,IAAgBA,WAAA,CAAYC,EAAE,KAAKJ,GAAA,CAAII,EAAE;UAG5C,IAAIH,uBAAA,GAA0B,CAAC,GAAG;YAChCb,aAAA,CAAcU,IAAI,CAACG,uBAAA,CAAwB,GAAG;cAC5C,GAAGb,aAAA,CAAcU,IAAI,CAACG,uBAAA,CAAwB;cAC9C,GAAGD;YACL;UACF;QACF;MACF;MAEA;;;MAGAf,mBAAA,CAAoBc,OAAO,CAAEM,cAAA;QAC3B,IACE,CAAC5B,MAAA,CACCK,aAAa,CAACK,IAAA,CAAK,GAAGkB,cAAA,CAAe,EACrCjB,aAAa,CAACiB,cAAA,CAAe,GAE/B;UACAtB,OAAA,GAAU;UACVQ,YAAA,GAAe;UAEf,IAAIH,aAAA,EAAekB,mBAAA,EAAqBC,QAAA,CAASF,cAAA,GAAiB;YAChE;YACAjB,aAAA,CAAckB,mBAAmB,GAC/BlB,aAAA,CAAckB,mBAAmB,CAACE,MAAM,CACrCC,IAAA,IAASA,IAAA,KAASJ,cAAA;YAGvB;YACA,IAAI,CAACjB,aAAA,CAAckB,mBAAmB,CAACI,MAAM,EAAE;cAC7C,OAAOtB,aAAA,CAAckB,mBAAmB;YAC1C;YAEA;UACF;UAEA,IAAI,EAAED,cAAA,IAAkBvB,aAAa,CAACK,IAAA,CAAK,CAAD,EAAI;YAC5C;YACA;YACA,IAAIkB,cAAA,KAAmB,oBAAoB;cACzC,OAAOjB,aAAa,CAACiB,cAAA,CAAe;YACtC;UACF,OAAO;YACLjB,aAAa,CAACiB,cAAA,CAAsB,GAClCvB,aAAa,CAACK,IAAA,CAAK,CAACkB,cAAA,CAAe;UACvC;QACF;MACF;MAEA,IAAIjB,aAAA,CAAcuB,KAAK,KAAK,OAAO;QACjCvB,aAAA,CAAcuB,KAAK,GAAG;MACxB;MAEA,IAAIvB,aAAA,CAAcwB,eAAe,KAAK,OAAO;QAC3CxB,aAAA,CAAcwB,eAAe,GAAG;MAClC;MAEA;MACA5B,QAAQ,CAACG,IAAA,CAAK,GAAGI,YAAA,GAAe;QAAE,GAAGH;MAAc,IAAIA,aAAA;IACzD;IAEA;IACA;IACA;IACA,KAAK,MAAM,CAACD,IAAA,EAAM0B,KAAA,CAAM,IAAIxB,MAAA,CAAOC,OAAO,CAACR,aAAA,GAAgB;MACzD,IAAI,CAACD,aAAa,CAACM,IAAA,CAAK,EAAE;QACxBJ,OAAA,GAAU;QACVC,QAAQ,CAACG,IAAA,CAAK,GAAG0B,KAAA;MACnB;IACF;EACF;EAEA,OAAO;IAAE9B,OAAA;IAASC;EAAS;AAC7B","ignoreList":[]}