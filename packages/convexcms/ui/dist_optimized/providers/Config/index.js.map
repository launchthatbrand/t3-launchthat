{"version":3,"file":"index.js","names":["React","createContext","use","useCallback","useEffect","useMemo","useState","RootConfigContext","undefined","sanitizeClientConfig","unSanitizedConfig","blocks","length","blocksMap","sanitizedConfig","block","slug","ConfigProvider","children","config","configFromProps","setConfig","collectionsBySlug","globalsBySlug","collection","collections","global","globals","getEntityConfig","args","collectionSlug","globalSlug","_jsx","value","useConfig"],"sources":["../../../src/providers/Config/index.tsx"],"sourcesContent":["/* eslint-disable perfectionist/sort-object-types  */ // Need to disable this rule because the order of the overloads is important\n\"use client\";\n\nimport type {\n  ClientCollectionConfig,\n  ClientConfig,\n  ClientGlobalConfig,\n  CollectionSlug,\n  GlobalSlug,\n  UnsanitizedClientConfig,\n} from \"@convexcms/core\";\nimport React, {\n  createContext,\n  use,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\n\ntype GetEntityConfigFn = {\n  // Overload #1: collectionSlug only\n  // @todo remove \"{} |\" in 4.0, which would be a breaking change\n  (args: {\n    collectionSlug: {} | CollectionSlug;\n    globalSlug?: never;\n  }): ClientCollectionConfig;\n\n  // Overload #2: globalSlug only\n  // @todo remove \"{} |\" in 4.0, which would be a breaking change\n  (args: {\n    collectionSlug?: never;\n    globalSlug: {} | GlobalSlug;\n  }): ClientGlobalConfig;\n\n  // Overload #3: both/none (fall back to union | null)\n  (args: {\n    collectionSlug?: {} | CollectionSlug;\n    globalSlug?: {} | GlobalSlug;\n  }): ClientCollectionConfig | ClientGlobalConfig | null;\n};\n\nexport type ClientConfigContext = {\n  config: ClientConfig;\n  /**\n   * Get a collection or global config by its slug. This is preferred over\n   * using `config.collections.find` or `config.globals.find`, because\n   * getEntityConfig uses a lookup map for O(1) lookups.\n   */\n  getEntityConfig: GetEntityConfigFn;\n  setConfig: (config: ClientConfig) => void;\n};\n\nconst RootConfigContext = createContext<ClientConfigContext | undefined>(\n  undefined,\n);\n\nfunction sanitizeClientConfig(\n  unSanitizedConfig: ClientConfig | UnsanitizedClientConfig,\n): ClientConfig {\n  if (\n    !unSanitizedConfig?.blocks?.length ||\n    (unSanitizedConfig as ClientConfig).blocksMap\n  ) {\n    (unSanitizedConfig as ClientConfig).blocksMap = {};\n    return unSanitizedConfig as ClientConfig;\n  }\n  const sanitizedConfig: ClientConfig = {\n    ...unSanitizedConfig,\n  } as ClientConfig;\n\n  sanitizedConfig.blocksMap = {};\n\n  for (const block of unSanitizedConfig.blocks) {\n    sanitizedConfig.blocksMap[block.slug] = block;\n  }\n\n  return sanitizedConfig;\n}\n\nexport const ConfigProvider: React.FC<{\n  readonly children: React.ReactNode;\n  readonly config: ClientConfig | UnsanitizedClientConfig;\n}> = ({ children, config: configFromProps }) => {\n  const [config, setConfig] = useState<ClientConfig>(() =>\n    sanitizeClientConfig(configFromProps),\n  );\n\n  // Need to update local config state if config from props changes, for HMR.\n  // That way, config changes will be updated in the UI immediately without needing a refresh.\n  useEffect(() => {\n    setConfig(sanitizeClientConfig(configFromProps));\n  }, [configFromProps]);\n\n  // Build lookup maps for collections and globals so we can do O(1) lookups by slug\n  const { collectionsBySlug, globalsBySlug } = useMemo(() => {\n    const collectionsBySlug: Record<string, ClientCollectionConfig> = {};\n    const globalsBySlug: Record<string, ClientGlobalConfig> = {};\n\n    for (const collection of config.collections) {\n      collectionsBySlug[collection.slug] = collection;\n    }\n    for (const global of config.globals) {\n      globalsBySlug[global.slug] = global;\n    }\n\n    return { collectionsBySlug, globalsBySlug };\n  }, [config]);\n\n  const getEntityConfig = useCallback<GetEntityConfigFn>(\n    (args) => {\n      if (\"collectionSlug\" in args) {\n        return collectionsBySlug[args.collectionSlug] ?? null;\n      }\n      if (\"globalSlug\" in args) {\n        return globalsBySlug[args.globalSlug] ?? null;\n      }\n      return null as any;\n    },\n    [collectionsBySlug, globalsBySlug],\n  );\n\n  return (\n    <RootConfigContext value={{ config, getEntityConfig, setConfig }}>\n      {children}\n    </RootConfigContext>\n  );\n};\n\nexport const useConfig = (): ClientConfigContext => use(RootConfigContext);\n"],"mappings":"AAAA,sDAAsD;AACtD;;;AAUA,OAAOA,KAAA,IACLC,aAAa,EACbC,GAAG,EACHC,WAAW,EACXC,SAAS,EACTC,OAAO,EACPC,QAAQ,QACH;AAmCP,MAAMC,iBAAA,gBAAoBN,aAAA,CACxBO,SAAA;AAGF,SAASC,qBACPC,iBAAyD;EAEzD,IACE,CAACA,iBAAA,EAAmBC,MAAA,EAAQC,MAAA,IAC5BF,iBAAC,CAAmCG,SAAS,EAC7C;IACCH,iBAAA,CAAmCG,SAAS,GAAG,CAAC;IACjD,OAAOH,iBAAA;EACT;EACA,MAAMI,eAAA,GAAgC;IACpC,GAAGJ;EACL;EAEAI,eAAA,CAAgBD,SAAS,GAAG,CAAC;EAE7B,KAAK,MAAME,KAAA,IAASL,iBAAA,CAAkBC,MAAM,EAAE;IAC5CG,eAAA,CAAgBD,SAAS,CAACE,KAAA,CAAMC,IAAI,CAAC,GAAGD,KAAA;EAC1C;EAEA,OAAOD,eAAA;AACT;AAEA,OAAO,MAAMG,cAAA,GAGRA,CAAC;EAAEC,QAAQ;EAAEC,MAAA,EAAQC;AAAe,CAAE;EACzC,MAAM,CAACD,MAAA,EAAQE,SAAA,CAAU,GAAGf,QAAA,CAAuB,MACjDG,oBAAA,CAAqBW,eAAA;EAGvB;EACA;EACAhB,SAAA,CAAU;IACRiB,SAAA,CAAUZ,oBAAA,CAAqBW,eAAA;EACjC,GAAG,CAACA,eAAA,CAAgB;EAEpB;EACA,MAAM;IAAEE,iBAAiB;IAAEC;EAAa,CAAE,GAAGlB,OAAA,CAAQ;IACnD,MAAMiB,iBAAA,GAA4D,CAAC;IACnE,MAAMC,aAAA,GAAoD,CAAC;IAE3D,KAAK,MAAMC,UAAA,IAAcL,MAAA,CAAOM,WAAW,EAAE;MAC3CH,iBAAiB,CAACE,UAAA,CAAWR,IAAI,CAAC,GAAGQ,UAAA;IACvC;IACA,KAAK,MAAME,MAAA,IAAUP,MAAA,CAAOQ,OAAO,EAAE;MACnCJ,aAAa,CAACG,MAAA,CAAOV,IAAI,CAAC,GAAGU,MAAA;IAC/B;IAEA,OAAO;MAAEJ,iBAAA;MAAmBC;IAAc;EAC5C,GAAG,CAACJ,MAAA,CAAO;EAEX,MAAMS,eAAA,GAAkBzB,WAAA,CACrB0B,IAAA;IACC,IAAI,oBAAoBA,IAAA,EAAM;MAC5B,OAAOP,iBAAiB,CAACO,IAAA,CAAKC,cAAc,CAAC,IAAI;IACnD;IACA,IAAI,gBAAgBD,IAAA,EAAM;MACxB,OAAON,aAAa,CAACM,IAAA,CAAKE,UAAU,CAAC,IAAI;IAC3C;IACA,OAAO;EACT,GACA,CAACT,iBAAA,EAAmBC,aAAA,CAAc;EAGpC,oBACES,IAAA,CAACzB,iBAAA;IAAkB0B,KAAA,EAAO;MAAEd,MAAA;MAAQS,eAAA;MAAiBP;IAAU;cAC5DH;;AAGP;AAEA,OAAO,MAAMgB,SAAA,GAAYA,CAAA,KAA2BhC,GAAA,CAAIK,iBAAA","ignoreList":[]}