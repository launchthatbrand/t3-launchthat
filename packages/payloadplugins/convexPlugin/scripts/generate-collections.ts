#!/usr/bin/env node

import * as fs from "fs";
import * as path from "path";

// Import generator functions
import {
  formatConfigToTypeScript,
  generatePayloadCollection,
} from "../src/generators/payload";

import { Command } from "commander";
// Import parser types (needed for casting parsed JSON)
import type { ParsedTable } from "../src/utilities/schema-parser/types";
import { fileURLToPath } from "url";

const program = new Command();

// Get the directory name using import.meta.url for ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

program
  .name("generate-payload-collections")
  .description(
    "Generates Payload collection TS files from a parsed Convex schema JSON file.",
  )
  .requiredOption(
    "-i, --input <path>",
    "Path to the input parsed-schema.json file",
  )
  .requiredOption(
    "-o, --output-dir <path>",
    "Path to the output directory for Payload collection files",
  )
  .action(async (options) => {
    // Determine workspace root based on script location
    const workspaceRoot = path.resolve(__dirname, "../../../../");
    const inputPath = path.resolve(workspaceRoot, options.input);
    const baseOutputDir = path.resolve(workspaceRoot, options.outputDir); // Main _generated dir

    // Define specific output dirs for collections and globals
    const collectionsOutputDir = path.join(baseOutputDir, "collections");
    const globalsOutputDir = path.join(baseOutputDir, "globals"); // For future use

    console.log(`Input JSON:  ${inputPath}`);
    console.log(`Base Output Dir: ${baseOutputDir}`);
    console.log(`Collections Output Dir: ${collectionsOutputDir}`);

    // Validate input path
    if (!fs.existsSync(inputPath)) {
      console.error(`Error: Input JSON file not found at ${inputPath}`);
      process.exit(1);
    }

    // Ensure output directories exist (collections and globals)
    [collectionsOutputDir, globalsOutputDir].forEach((dir) => {
      if (!fs.existsSync(dir)) {
        try {
          fs.mkdirSync(dir, { recursive: true });
          console.log(`Created output directory: ${dir}`);
        } catch (error) {
          console.error(`Error creating output directory ${dir}:`, error);
          process.exit(1);
        }
      }
    });

    // Read and parse the input JSON
    let parsedTables: ParsedTable[] = [];
    try {
      const jsonContent = fs.readFileSync(inputPath, "utf-8");
      parsedTables = JSON.parse(jsonContent) as ParsedTable[]; // Cast to expected type
      if (!Array.isArray(parsedTables)) {
        throw new Error("Input JSON is not an array.");
      }
      console.log(`Read ${parsedTables.length} table definition(s) from JSON.`);
    } catch (error) {
      console.error(
        `Error reading or parsing input JSON file ${inputPath}:`,
        error,
      );
      process.exit(1);
    }

    // --- Generate Collections ---
    let collectionSuccessCount = 0;
    let collectionErrorCount = 0;
    const generatedCollectionNames: string[] = []; // Store names for index file

    for (const tableData of parsedTables) {
      // TODO: Add logic here later to differentiate between tables intended as collections vs globals
      // For now, assume all tables are collections.
      try {
        console.log(`Generating collection for: ${tableData.name}`);
        const collectionConfigObject = generatePayloadCollection(tableData);
        const tsContent = formatConfigToTypeScript(collectionConfigObject);

        const collectionName = tableData.name
          .split(/[-_]/)
          .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
          .join("");
        // Write to collections subdir
        const outputFilePath = path.join(
          collectionsOutputDir,
          `${collectionName}.ts`,
        );

        fs.writeFileSync(outputFilePath, tsContent, "utf-8");
        console.log(`  Successfully wrote collection file: ${outputFilePath}`);
        generatedCollectionNames.push(collectionName);
        collectionSuccessCount++;
      } catch (error) {
        console.error(
          `  Error generating collection for table '${tableData.name}':`,
          error,
        );
        collectionErrorCount++;
      }
    }

    // Generate and write collections index.ts file
    let collectionsIndexWritten = false;
    if (generatedCollectionNames.length > 0) {
      // Write to collections subdir
      const indexFilePath = path.join(collectionsOutputDir, "index.ts");
      let indexContent = `// Generated by convex-payload-plugin (Collections Index)\n\n`;
      generatedCollectionNames.forEach((name) => {
        indexContent += `import { ${name} } from './${name}';\n`;
      });
      indexContent += `\n`;
      indexContent += `export const getConvexCollections = (): any[] => {\n`; // Return type any[] for now
      indexContent += `  return [\n`;
      generatedCollectionNames.forEach((name) => {
        indexContent += `    ${name},\n`;
      });
      indexContent += `  ];\n`;
      indexContent += `};\n`;

      try {
        fs.writeFileSync(indexFilePath, indexContent, "utf-8");
        console.log(
          `  Successfully wrote collections index file: ${indexFilePath}`,
        );
        collectionsIndexWritten = true;
      } catch (error) {
        console.error(
          `  Error writing collections index file ${indexFilePath}:`,
          error,
        );
        collectionErrorCount++; // Count index file writing error
      }
    } else {
      console.log(
        "No collections were generated, skipping collections index file creation.",
      );
    }

    // --- Generate Globals (Placeholder) ---
    // TODO: Implement globals parsing and generation
    let globalSuccessCount = 0;
    let globalErrorCount = 0;
    let globalsIndexWritten = false;
    // const generatedGlobalNames: string[] = [];
    // ... logic to generate globals and their index ...
    const generatedGlobalNames: string[] = []; // Temp empty array
    console.log("(Skipping globals generation - not implemented yet)");

    // --- Generate Top-Level Index ---
    let topLevelIndexWritten = false;
    const topLevelIndexFilePath = path.join(baseOutputDir, "index.ts");
    let topLevelIndexContent = `// Generated by convex-payload-plugin (Top-Level Index)\n\n`;
    if (collectionsIndexWritten) {
      topLevelIndexContent += `export { getConvexCollections } from './collections';\n`;
    }
    if (globalsIndexWritten) {
      // Placeholder for when globals are implemented
      // topLevelIndexContent += `export { getConvexGlobals } from './globals';\n`;
    } else {
      topLevelIndexContent += `// export { getConvexGlobals } from './globals'; // (Globals not generated)\n`;
    }

    try {
      fs.writeFileSync(topLevelIndexFilePath, topLevelIndexContent, "utf-8");
      console.log(
        `  Successfully wrote top-level index file: ${topLevelIndexFilePath}`,
      );
      topLevelIndexWritten = true;
    } catch (error) {
      console.error(
        `  Error writing top-level index file ${topLevelIndexFilePath}:`,
        error,
      );
      // Decide if this error should increment collection or global count, or have its own?
      collectionErrorCount++;
    }

    // Final Summary
    const totalSuccess = collectionSuccessCount + globalSuccessCount;
    const totalErrors = collectionErrorCount + globalErrorCount;
    let summary = `\nGeneration complete.\n`;
    summary += `Collections: ${collectionSuccessCount} generated`;
    if (collectionsIndexWritten) summary += ` (+ index)`;
    if (collectionErrorCount > 0) summary += `, ${collectionErrorCount} errors`;
    summary += `\n`;
    summary += `Globals: ${globalSuccessCount} generated`;
    if (globalsIndexWritten) summary += ` (+ index)`;
    if (globalErrorCount > 0) summary += `, ${globalErrorCount} errors`;
    summary += `\n`;
    if (topLevelIndexWritten) summary += `Top-level index generated.\n`;
    if (totalErrors > 0) summary += `Total errors: ${totalErrors}.\n`;

    console.log(summary);

    if (totalErrors > 0) {
      process.exit(1);
    }
  });

program.parse(process.argv);
