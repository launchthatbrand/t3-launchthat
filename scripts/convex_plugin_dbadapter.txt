# Product Requirements Document: Payload CMS + Convex Integration via Plugin & DB Adapter

## 1. Introduction

This document outlines the requirements for a deep integration between Payload CMS and the Convex backend. The goal is to leverage Payload's powerful admin UI, configuration system, and features (access control, hooks, components) while using Convex as the primary, real-time database. This will be achieved through a custom Payload plugin (`convexPlugin`) and a custom Payload database adapter (`convexDbAdapter`).

## 2. Goals

-   Develop a Payload plugin (`convexPlugin`) responsible for schema generation and client-side UI overrides.
-   Develop a Payload database adapter (`convexDbAdapter`) to handle all data operations via Convex, replacing default adapters like Postgres/Mongo.
-   Enable real-time data display in Payload's native `ListView` component for all collections by overriding client-side data fetching.
-   Establish `payload.config.ts` as the primary configuration source for developers, defining collection structure, fields, Payload-specific hooks, UI components, and access control.
-   Utilize `convex/schema.ts` as the definitive schema definition *for the Convex backend*, generated by `convexPlugin` based on the Payload config.
-   Ensure standard Payload features (validation, hooks, access control) function correctly within this architecture.

## 3. Architecture

-   **Payload Config (`payload.config.ts`):**
    -   The central configuration file where developers define collections (slug, fields) and Payload-specific behaviors (hooks, `admin.components`, `access` functions, field validation, etc.).
    -   Specifies the `convexDbAdapter` as the active database adapter.
-   **Convex Plugin (`packages/payloadplugins/convexPlugin`):**
    -   Installed and configured in `payload.config.ts`.
    -   Contains an `onInit` hook that reads the collection/field structure from the loaded Payload config.
    -   Generates/updates the `convex/schema.ts` file based on the parsed structure.
    -   Provides the necessary component overrides, specifically for `admin.components.providers.ListQuery`, to inject the real-time client-side data fetching mechanism.
-   **Convex Schema (`convex/schema.ts`):**
    -   Located in the standard `convex/` directory.
    -   Its content is entirely generated and managed by the `convexPlugin`. Developers should not edit this file directly.
    -   Defines Convex tables, fields (`v.*`), and indexes based on the structure defined in `payload.config.ts`.
    -   This file is the source of truth *for the Convex backend* and is synchronized using Convex CLI tools (`convex dev` or `convex push`).
-   **Convex DB Adapter (`packages/payloadplugins/convexDbAdapter`):**
    -   Implements Payload's `DatabaseAdapter` interface.
    -   Receives all database operation requests from Payload core (e.g., `find`, `create`, `update`, `delete`).
    *   Translates Payload operations, query parameters (including `where` clauses), and data structures into appropriate Convex client calls (`convexClient.query`, `convexClient.mutation`).
    *   Handles data mapping between Payload and Convex formats (e.g., `id` vs `_id`).
-   **Client-Side Real-time Override (`convexPlugin` or dedicated UI package):**
    *   A custom React hook (e.g., `useConvexRealtimeListQuery`) that:
        *   Manages list view state (filters, sorting, pagination), potentially syncing with URL query parameters.
        *   Translates this state into arguments for a Convex query function.
        *   Uses Convex's `useQuery` hook for real-time data subscription (potentially leveraging `@convex-dev/react-query`).
        *   Transforms the data returned by Convex into the structure expected by Payload's `ListView` (`{ docs, totalDocs, ... }`).
        *   Provides state update handlers (e.g., `setSort`, `setPage`, `setWhere`).
    *   A custom React context provider (`ConvexListQueryProvider`) that utilizes the hook above.
    *   The `convexPlugin` uses `admin.components.providers.ListQuery` in `payload.config.ts` to replace the default provider with `ConvexListQueryProvider`.

## 4. Workflow

-   **Development:**
    1.  Developers define and modify collections, fields, hooks, UI components, etc., primarily within `payload.config.ts`.
    2.  The project's development script (e.g., `pnpm dev`) must be configured to run `pnpm convex dev` concurrently with the Payload development server (`payload dev`).
    3.  On Payload server start, the `convexPlugin`'s `onInit` hook runs, regenerating `convex/schema.ts`.
    4.  The running `pnpm convex dev` process detects the change to `schema.ts` and automatically pushes the schema update to the Convex development backend.
    5.  Developers **must monitor the terminal output of both** the Payload server (for `onInit` errors) and the `convex dev` process (for schema push errors).
-   **Production/Deployment:**
    1.  The build process for the application should ensure the final `convex/schema.ts` is generated (either via a build script running the plugin's generation logic or ensuring it happens reliably at server start).
    2.  The deployment script **must explicitly include a step to run `pnpm convex push`** after the `convex/schema.ts` file is finalized and *before* the application server starts accepting traffic, ensuring the production Convex backend schema is synchronized.

## 5. Functional Requirements

-   Collections defined in `payload.config.ts` are fully manageable via the Payload Admin UI and API.
-   All data persistence must use the configured Convex deployment via the `convexDbAdapter`. No data should be stored in other databases like Postgres/Mongo unless explicitly configured outside this system.
-   The standard `ListView` in the Payload Admin UI must display data fetched directly from Convex in real-time. Updates made to Convex data (via Payload or other means) should reflect automatically in the open `ListView` without manual refresh.
-   Payload features defined in `payload.config.ts` (field hooks, collection hooks, access control functions, field validation, conditional logic, UI components) must function correctly.
-   The system must handle standard Payload field types and translate them appropriately to Convex schema types (`v.*`) and back.
-   Basic relationship field functionality should be supported by the adapter.

## 6. Key Challenges & Considerations

-   **Query Translation:** Implementing robust translation logic within the `convexDbAdapter` to map Payload's `where` query syntax (including operators like `equals`, `in`, `not_in`, `like`, `contains`, nested conditions, etc.) to effective Convex query function arguments. This might require developers to define specific query functions in Convex for complex filtering scenarios not directly mappable.
-   **Relationship Population:** Designing how the `convexDbAdapter` handles population of relationship fields across tables/documents in Convex.
-   **Client Hook Complexity:** Ensuring the `useConvexRealtimeListQuery` hook correctly handles all aspects of list state (filtering, sorting, pagination) synchronization, translates them accurately for Convex `useQuery`, and maps results back reliably. Calculating pagination metadata (`totalDocs`, `totalPages`) might require additional logic or dedicated Convex queries.
-   **Performance:** Optimizing Convex queries generated by the adapter and used by the client hook for efficiency.
-   **Error Handling:** Ensuring clear error reporting from both the adapter (server-side) and the client-side hook. Handling potential inconsistencies if a schema push fails in `convex dev` after Payload has started.
-   **Documentation:** Providing comprehensive documentation for developers covering the architecture, setup (especially the concurrent dev script), deployment process (`convex push`), and any limitations (e.g., query translation differences).

## 7. Out of Scope (Initial Version)

-   Full 1:1 feature parity for every complex Payload query operator if direct translation isn't feasible.
-   Advanced features like Payload's Versions or Drafts (unless Convex equivalents are leveraged).
-   Complex transaction management across multiple adapter operations (Convex mutations are transactional, but orchestrating multiple Payload operations might require care).




