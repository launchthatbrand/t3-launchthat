{
  "feature-admin-task-manager": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Convex Backend Schema",
        "description": "Define the Convex schema for the tasks table with all required fields according to the PRD specifications.",
        "details": "Create a new Convex schema file that defines the tasks table with the following fields:\n- id (Convex id, auto-generated)\n- title (string, required)\n- description (string, optional)\n- dueDate (date, optional)\n- isRecurring (boolean, optional)\n- recurrenceRule (string, optional)\n- status (enum: 'pending', 'completed', 'cancelled'; default: 'pending')\n- createdAt (date, auto-generated)\n- updatedAt (date, auto-generated)\n\nExample schema implementation:\n```typescript\nimport { defineSchema, defineTable } from 'convex/server';\nimport { v } from 'convex/values';\n\nexport default defineSchema({\n  tasks: defineTable({\n    title: v.string(),\n    description: v.optional(v.string()),\n    dueDate: v.optional(v.number()), // Unix timestamp\n    isRecurring: v.optional(v.boolean()),\n    recurrenceRule: v.optional(v.string()),\n    status: v.union(v.literal('pending'), v.literal('completed'), v.literal('cancelled')),\n    createdAt: v.number(), // Unix timestamp\n    updatedAt: v.number(), // Unix timestamp\n  })\n});\n```",
        "testStrategy": "Verify schema definition by running Convex dev server and checking that the schema is correctly applied. Test creating a sample task entry to ensure all fields are properly defined and constraints are enforced.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Convex CRUD API",
        "description": "Create Convex queries and mutations for all task CRUD operations as specified in the PRD.",
        "details": "Implement the following Convex functions:\n\n1. Query to get all tasks:\n```typescript\nexport const getTasks = query(async ({ db }) => {\n  return await db.query('tasks').collect();\n});\n```\n\n2. Query to get a single task by ID:\n```typescript\nexport const getTask = query(async ({ db }, { id }: { id: Id<'tasks'> }) => {\n  return await db.get(id);\n});\n```\n\n3. Mutation to create a task:\n```typescript\nexport const createTask = mutation(async (\n  { db },\n  {\n    title,\n    description,\n    dueDate,\n    isRecurring,\n    recurrenceRule,\n    status = 'pending',\n  }: {\n    title: string;\n    description?: string;\n    dueDate?: number;\n    isRecurring?: boolean;\n    recurrenceRule?: string;\n    status?: 'pending' | 'completed' | 'cancelled';\n  }\n) => {\n  const now = Date.now();\n  return await db.insert('tasks', {\n    title,\n    description,\n    dueDate,\n    isRecurring,\n    recurrenceRule,\n    status,\n    createdAt: now,\n    updatedAt: now,\n  });\n});\n```\n\n4. Mutation to update a task:\n```typescript\nexport const updateTask = mutation(async (\n  { db },\n  {\n    id,\n    title,\n    description,\n    dueDate,\n    isRecurring,\n    recurrenceRule,\n    status,\n  }: {\n    id: Id<'tasks'>;\n    title?: string;\n    description?: string;\n    dueDate?: number;\n    isRecurring?: boolean;\n    recurrenceRule?: string;\n    status?: 'pending' | 'completed' | 'cancelled';\n  }\n) => {\n  const task = await db.get(id);\n  if (!task) throw new Error('Task not found');\n  \n  const updates: Partial<typeof task> = { updatedAt: Date.now() };\n  if (title !== undefined) updates.title = title;\n  if (description !== undefined) updates.description = description;\n  if (dueDate !== undefined) updates.dueDate = dueDate;\n  if (isRecurring !== undefined) updates.isRecurring = isRecurring;\n  if (recurrenceRule !== undefined) updates.recurrenceRule = recurrenceRule;\n  if (status !== undefined) updates.status = status;\n  \n  await db.patch(id, updates);\n  return id;\n});\n```\n\n5. Mutation to delete a task:\n```typescript\nexport const deleteTask = mutation(async ({ db }, { id }: { id: Id<'tasks'> }) => {\n  await db.delete(id);\n  return id;\n});\n```",
        "testStrategy": "Test each CRUD operation individually:\n1. Create a task and verify all fields are saved correctly\n2. Retrieve tasks and verify data integrity\n3. Update a task and confirm changes are persisted\n4. Delete a task and verify it's removed from the database\n5. Test edge cases like invalid inputs and error handling",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create Task List/Table UI Component",
        "description": "Implement a table or list view that displays all tasks with sorting capabilities by date and status.",
        "details": "Create a React component using Shadcn UI components for the task list/table view:\n\n```tsx\nimport { useQuery } from 'convex/react';\nimport { api } from '../convex/_generated/api';\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { Button } from '@/components/ui/button';\nimport { useState } from 'react';\n\nexport function TaskTable() {\n  const tasks = useQuery(api.tasks.getTasks);\n  const [sortField, setSortField] = useState<'dueDate' | 'status'>('dueDate');\n  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');\n  \n  const sortedTasks = tasks ? [...tasks].sort((a, b) => {\n    if (sortField === 'dueDate') {\n      if (!a.dueDate) return sortDirection === 'asc' ? 1 : -1;\n      if (!b.dueDate) return sortDirection === 'asc' ? -1 : 1;\n      return sortDirection === 'asc' \n        ? a.dueDate - b.dueDate \n        : b.dueDate - a.dueDate;\n    } else {\n      return sortDirection === 'asc' \n        ? a.status.localeCompare(b.status) \n        : b.status.localeCompare(a.status);\n    }\n  }) : [];\n  \n  const toggleSort = (field: 'dueDate' | 'status') => {\n    if (sortField === field) {\n      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortField(field);\n      setSortDirection('asc');\n    }\n  };\n  \n  if (!tasks) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <Table>\n        <TableHeader>\n          <TableRow>\n            <TableHead>Title</TableHead>\n            <TableHead onClick={() => toggleSort('dueDate')} className=\"cursor-pointer\">\n              Due Date {sortField === 'dueDate' && (sortDirection === 'asc' ? '↑' : '↓')}\n            </TableHead>\n            <TableHead onClick={() => toggleSort('status')} className=\"cursor-pointer\">\n              Status {sortField === 'status' && (sortDirection === 'asc' ? '↑' : '↓')}\n            </TableHead>\n            <TableHead>Recurring</TableHead>\n            <TableHead>Actions</TableHead>\n          </TableRow>\n        </TableHeader>\n        <TableBody>\n          {sortedTasks.map((task) => (\n            <TableRow key={task._id}>\n              <TableCell>{task.title}</TableCell>\n              <TableCell>{task.dueDate ? new Date(task.dueDate).toLocaleDateString() : 'No date'}</TableCell>\n              <TableCell>\n                <span className={`status-${task.status}`}>{task.status}</span>\n              </TableCell>\n              <TableCell>{task.isRecurring ? 'Yes' : 'No'}</TableCell>\n              <TableCell>\n                <Button variant=\"outline\" size=\"sm\" onClick={() => handleEdit(task._id)}>Edit</Button>\n                <Button variant=\"destructive\" size=\"sm\" onClick={() => handleDelete(task._id)}>Delete</Button>\n              </TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </div>\n  );\n}\n```\n\nImplement the handleEdit and handleDelete functions to open the edit modal and confirm deletion respectively.",
        "testStrategy": "Test the table component by:\n1. Verifying it correctly displays task data\n2. Testing sorting functionality by date and status\n3. Confirming edit and delete buttons trigger the correct actions\n4. Testing responsive behavior on different screen sizes\n5. Checking accessibility with keyboard navigation and screen readers",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Task Form with Validation",
        "description": "Create a form component for creating and editing tasks with React Hook Form and zod validation.",
        "details": "Create a reusable task form component using React Hook Form with zod validation:\n\n```tsx\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport * as z from 'zod';\nimport { Button } from '@/components/ui/button';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { DatePicker } from '@/components/ui/date-picker';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\n\nconst taskFormSchema = z.object({\n  title: z.string().min(1, 'Title is required'),\n  description: z.string().optional(),\n  dueDate: z.date().optional(),\n  isRecurring: z.boolean().default(false),\n  recurrenceRule: z.string().optional(),\n  status: z.enum(['pending', 'completed', 'cancelled']).default('pending'),\n});\n\ntype TaskFormValues = z.infer<typeof taskFormSchema>;\n\ninterface TaskFormProps {\n  defaultValues?: Partial<TaskFormValues>;\n  onSubmit: (data: TaskFormValues) => void;\n  isEditing?: boolean;\n}\n\nexport function TaskForm({ defaultValues, onSubmit, isEditing = false }: TaskFormProps) {\n  const form = useForm<TaskFormValues>({\n    resolver: zodResolver(taskFormSchema),\n    defaultValues: {\n      title: '',\n      description: '',\n      isRecurring: false,\n      status: 'pending',\n      ...defaultValues,\n    },\n  });\n\n  const { watch, setValue } = form;\n  const isRecurring = watch('isRecurring');\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        <FormField\n          control={form.control}\n          name=\"title\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Title</FormLabel>\n              <FormControl>\n                <Input {...field} />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        \n        <FormField\n          control={form.control}\n          name=\"description\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Description</FormLabel>\n              <FormControl>\n                <Textarea {...field} />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        \n        <FormField\n          control={form.control}\n          name=\"dueDate\"\n          render={({ field }) => (\n            <FormItem>\n              <FormLabel>Due Date</FormLabel>\n              <FormControl>\n                <DatePicker \n                  date={field.value} \n                  setDate={(date) => field.onChange(date)} \n                />\n              </FormControl>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        \n        <FormField\n          control={form.control}\n          name=\"isRecurring\"\n          render={({ field }) => (\n            <FormItem className=\"flex items-center space-x-2\">\n              <FormControl>\n                <Checkbox \n                  checked={field.value} \n                  onCheckedChange={field.onChange} \n                />\n              </FormControl>\n              <FormLabel>Recurring Task</FormLabel>\n              <FormMessage />\n            </FormItem>\n          )}\n        />\n        \n        {isRecurring && (\n          <FormField\n            control={form.control}\n            name=\"recurrenceRule\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Recurrence Pattern</FormLabel>\n                <FormControl>\n                  <Select \n                    value={field.value} \n                    onValueChange={field.onChange}\n                  >\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select pattern\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"FREQ=DAILY\">Daily</SelectItem>\n                      <SelectItem value=\"FREQ=WEEKLY\">Weekly</SelectItem>\n                      <SelectItem value=\"FREQ=MONTHLY\">Monthly</SelectItem>\n                      <SelectItem value=\"custom\">Custom RRULE</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </FormControl>\n                <FormDescription>\n                  Select a recurrence pattern for this task\n                </FormDescription>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        )}\n        \n        {isEditing && (\n          <FormField\n            control={form.control}\n            name=\"status\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Status</FormLabel>\n                <FormControl>\n                  <Select \n                    value={field.value} \n                    onValueChange={field.onChange}\n                  >\n                    <SelectTrigger>\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"pending\">Pending</SelectItem>\n                      <SelectItem value=\"completed\">Completed</SelectItem>\n                      <SelectItem value=\"cancelled\">Cancelled</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n        )}\n        \n        <Button type=\"submit\">{isEditing ? 'Update Task' : 'Create Task'}</Button>\n      </form>\n    </Form>\n  );\n}\n```",
        "testStrategy": "Test the form component by:\n1. Validating required fields (title)\n2. Testing form submission with various input combinations\n3. Verifying conditional fields (recurrence rule only shows when isRecurring is true)\n4. Testing form validation error messages\n5. Verifying the form works correctly in both create and edit modes\n6. Testing accessibility of form controls",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Task Modal Components",
        "description": "Implement modal/drawer components for creating, editing, and confirming deletion of tasks.",
        "details": "Create three modal components using Shadcn UI's Dialog component:\n\n1. Create/Edit Task Modal:\n```tsx\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { TaskForm } from './TaskForm';\nimport { useMutation } from 'convex/react';\nimport { api } from '../convex/_generated/api';\nimport { Id } from '../convex/_generated/dataModel';\n\ninterface TaskModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  task?: any; // The task to edit, if editing\n}\n\nexport function TaskModal({ isOpen, onClose, task }: TaskModalProps) {\n  const createTask = useMutation(api.tasks.createTask);\n  const updateTask = useMutation(api.tasks.updateTask);\n  \n  const handleSubmit = async (data: any) => {\n    try {\n      if (task) {\n        // Editing existing task\n        await updateTask({\n          id: task._id as Id<'tasks'>,\n          ...data,\n          dueDate: data.dueDate ? data.dueDate.getTime() : undefined,\n        });\n      } else {\n        // Creating new task\n        await createTask({\n          ...data,\n          dueDate: data.dueDate ? data.dueDate.getTime() : undefined,\n        });\n      }\n      onClose();\n    } catch (error) {\n      console.error('Error saving task:', error);\n    }\n  };\n  \n  const defaultValues = task\n    ? {\n        ...task,\n        dueDate: task.dueDate ? new Date(task.dueDate) : undefined,\n      }\n    : undefined;\n  \n  return (\n    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>\n      <DialogContent>\n        <DialogHeader>\n          <DialogTitle>{task ? 'Edit Task' : 'Create New Task'}</DialogTitle>\n        </DialogHeader>\n        <TaskForm \n          defaultValues={defaultValues} \n          onSubmit={handleSubmit} \n          isEditing={!!task} \n        />\n      </DialogContent>\n    </Dialog>\n  );\n}\n```\n\n2. Delete Confirmation Modal:\n```tsx\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport { useMutation } from 'convex/react';\nimport { api } from '../convex/_generated/api';\nimport { Id } from '../convex/_generated/dataModel';\n\ninterface DeleteTaskDialogProps {\n  isOpen: boolean;\n  onClose: () => void;\n  taskId: Id<'tasks'> | null;\n}\n\nexport function DeleteTaskDialog({ isOpen, onClose, taskId }: DeleteTaskDialogProps) {\n  const deleteTask = useMutation(api.tasks.deleteTask);\n  \n  const handleDelete = async () => {\n    if (!taskId) return;\n    try {\n      await deleteTask({ id: taskId });\n      onClose();\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  };\n  \n  return (\n    <AlertDialog open={isOpen} onOpenChange={(open) => !open && onClose()}>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>Are you sure?</AlertDialogTitle>\n          <AlertDialogDescription>\n            This action cannot be undone. This will permanently delete the task.\n          </AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel>Cancel</AlertDialogCancel>\n          <AlertDialogAction onClick={handleDelete}>Delete</AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  );\n}\n```",
        "testStrategy": "Test the modal components by:\n1. Verifying they open and close correctly\n2. Testing form submission in the create/edit modal\n3. Confirming the delete confirmation works as expected\n4. Testing that the modals correctly handle the task data for editing\n5. Verifying error handling for failed operations\n6. Testing accessibility of the modals (keyboard navigation, focus trapping)",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Recurrence Rule Logic",
        "description": "Create utility functions to handle recurring tasks, including RRULE parsing and expansion for calendar display.",
        "details": "Implement utility functions to handle recurring tasks using the rrule.js library:\n\n```typescript\nimport { RRule, RRuleSet, rrulestr } from 'rrule';\n\n// Convert a simple recurrence pattern to an RRULE string\nexport function patternToRRule(pattern: string, startDate: Date): string {\n  const options: Partial<RRule.Options> = {\n    dtstart: startDate,\n  };\n  \n  switch (pattern) {\n    case 'daily':\n      options.freq = RRule.DAILY;\n      break;\n    case 'weekly':\n      options.freq = RRule.WEEKLY;\n      break;\n    case 'monthly':\n      options.freq = RRule.MONTHLY;\n      break;\n    default:\n      // If it's already a valid RRULE string, return it\n      if (pattern.startsWith('FREQ=')) {\n        return pattern;\n      }\n      // Default to daily if unknown pattern\n      options.freq = RRule.DAILY;\n  }\n  \n  return new RRule(options).toString();\n}\n\n// Expand a recurring task into individual occurrences for a date range\nexport function expandRecurringTask(task: any, start: Date, end: Date): any[] {\n  if (!task.isRecurring || !task.recurrenceRule || !task.dueDate) {\n    return [task];\n  }\n  \n  const startDate = new Date(task.dueDate);\n  let rrule;\n  \n  try {\n    // Try to parse the recurrence rule\n    if (task.recurrenceRule.startsWith('FREQ=')) {\n      rrule = rrulestr(task.recurrenceRule, { dtstart: startDate });\n    } else {\n      rrule = new RRule({\n        ...getRRuleOptions(task.recurrenceRule),\n        dtstart: startDate\n      });\n    }\n    \n    // Get all occurrences in the date range\n    const occurrences = rrule.between(start, end, true);\n    \n    // Create a task instance for each occurrence\n    return occurrences.map((date, index) => ({\n      ...task,\n      _id: `${task._id}_${index}`, // Create a unique ID for each occurrence\n      dueDate: date.getTime(),\n      isRecurrenceInstance: true,\n      originalTaskId: task._id,\n    }));\n  } catch (error) {\n    console.error('Error parsing recurrence rule:', error);\n    return [task];\n  }\n}\n\n// Helper to convert simple patterns to RRule options\nfunction getRRuleOptions(pattern: string): Partial<RRule.Options> {\n  switch (pattern) {\n    case 'daily':\n      return { freq: RRule.DAILY };\n    case 'weekly':\n      return { freq: RRule.WEEKLY };\n    case 'monthly':\n      return { freq: RRule.MONTHLY };\n    default:\n      return { freq: RRule.DAILY };\n  }\n}\n\n// Get all task occurrences for calendar view\nexport function getCalendarTasks(tasks: any[], start: Date, end: Date): any[] {\n  const regularTasks = tasks.filter(task => \n    !task.isRecurring && task.dueDate && \n    new Date(task.dueDate) >= start && \n    new Date(task.dueDate) <= end\n  );\n  \n  const recurringTasksExpanded = tasks\n    .filter(task => task.isRecurring && task.dueDate)\n    .flatMap(task => expandRecurringTask(task, start, end));\n  \n  return [...regularTasks, ...recurringTasksExpanded];\n}\n```",
        "testStrategy": "Test the recurrence utilities by:\n1. Verifying pattern to RRULE conversion for different patterns\n2. Testing expansion of recurring tasks with various recurrence rules\n3. Confirming date calculations are correct\n4. Testing edge cases like invalid recurrence rules\n5. Verifying the calendar task aggregation function works correctly\n6. Testing with different date ranges and recurrence patterns",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Calendar View Integration",
        "description": "Integrate with the existing campaign calendar component to display tasks with due dates on the calendar.",
        "details": "Create a calendar view component that integrates with the existing campaign calendar:\n\n```tsx\nimport { useQuery } from 'convex/react';\nimport { api } from '../convex/_generated/api';\nimport { CampaignCalendar } from '@/components/campaign/CampaignCalendar';\nimport { useState, useMemo } from 'react';\nimport { getCalendarTasks } from '../utils/recurrence';\n\nexport function TaskCalendar() {\n  const tasks = useQuery(api.tasks.getTasks);\n  const [dateRange, setDateRange] = useState({\n    start: new Date(new Date().setDate(1)), // First day of current month\n    end: new Date(new Date().setMonth(new Date().getMonth() + 1, 0)), // Last day of current month\n  });\n  const [filters, setFilters] = useState({\n    status: 'all', // 'all', 'pending', 'completed', 'cancelled'\n    showRecurring: true,\n  });\n  \n  // Transform tasks for calendar display\n  const calendarEvents = useMemo(() => {\n    if (!tasks) return [];\n    \n    // Filter tasks based on status\n    let filteredTasks = tasks;\n    if (filters.status !== 'all') {\n      filteredTasks = filteredTasks.filter(task => task.status === filters.status);\n    }\n    \n    // Filter out recurring tasks if not showing them\n    if (!filters.showRecurring) {\n      filteredTasks = filteredTasks.filter(task => !task.isRecurring);\n    }\n    \n    // Expand recurring tasks and format for calendar\n    const calendarTasks = getCalendarTasks(filteredTasks, dateRange.start, dateRange.end);\n    \n    // Convert to calendar event format\n    return calendarTasks.map(task => ({\n      id: task._id,\n      title: task.title,\n      start: new Date(task.dueDate),\n      end: new Date(task.dueDate),\n      allDay: true,\n      status: task.status,\n      isRecurring: task.isRecurring,\n      originalData: task,\n    }));\n  }, [tasks, dateRange, filters]);\n  \n  const handleEventClick = (event: any) => {\n    // Open task edit modal with the clicked task\n    const taskId = event.originalData.originalTaskId || event.id;\n    // Call function to open edit modal with taskId\n  };\n  \n  const handleRangeChange = (start: Date, end: Date) => {\n    setDateRange({ start, end });\n  };\n  \n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex gap-4\">\n        <select\n          value={filters.status}\n          onChange={(e) => setFilters({ ...filters, status: e.target.value })}\n          className=\"border rounded p-2\"\n        >\n          <option value=\"all\">All Statuses</option>\n          <option value=\"pending\">Pending</option>\n          <option value=\"completed\">Completed</option>\n          <option value=\"cancelled\">Cancelled</option>\n        </select>\n        \n        <label className=\"flex items-center gap-2\">\n          <input\n            type=\"checkbox\"\n            checked={filters.showRecurring}\n            onChange={(e) => setFilters({ ...filters, showRecurring: e.target.checked })}\n          />\n          Show Recurring Tasks\n        </label>\n      </div>\n      \n      <CampaignCalendar\n        events={calendarEvents}\n        onEventClick={handleEventClick}\n        onRangeChange={handleRangeChange}\n      />\n    </div>\n  );\n}\n```\n\nNote: This implementation assumes the existence of a `CampaignCalendar` component that accepts `events`, `onEventClick`, and `onRangeChange` props. You'll need to adapt this to match the actual API of your campaign calendar component.",
        "testStrategy": "Test the calendar integration by:\n1. Verifying tasks appear correctly on the calendar\n2. Testing that recurring tasks expand properly across multiple dates\n3. Confirming filters work as expected\n4. Testing event click handling opens the correct task\n5. Verifying date range changes update the displayed tasks\n6. Testing with various task configurations (recurring/non-recurring, different statuses)",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Main Task Management Page",
        "description": "Implement the main task management page that combines the task table, form modals, and calendar view.",
        "details": "Create the main task management page that integrates all components:\n\n```tsx\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { TaskTable } from '@/components/TaskTable';\nimport { TaskCalendar } from '@/components/TaskCalendar';\nimport { TaskModal } from '@/components/TaskModal';\nimport { DeleteTaskDialog } from '@/components/DeleteTaskDialog';\nimport { Id } from '../convex/_generated/dataModel';\n\nexport default function TaskManagementPage() {\n  const [activeTab, setActiveTab] = useState('list');\n  const [taskModalOpen, setTaskModalOpen] = useState(false);\n  const [currentTask, setCurrentTask] = useState<any | null>(null);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [taskToDelete, setTaskToDelete] = useState<Id<'tasks'> | null>(null);\n  \n  const handleCreateTask = () => {\n    setCurrentTask(null);\n    setTaskModalOpen(true);\n  };\n  \n  const handleEditTask = (task: any) => {\n    setCurrentTask(task);\n    setTaskModalOpen(true);\n  };\n  \n  const handleDeleteTask = (taskId: Id<'tasks'>) => {\n    setTaskToDelete(taskId);\n    setDeleteDialogOpen(true);\n  };\n  \n  return (\n    <div className=\"container mx-auto py-6 space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-3xl font-bold\">Task Management</h1>\n        <Button onClick={handleCreateTask}>Create Task</Button>\n      </div>\n      \n      <Tabs value={activeTab} onValueChange={setActiveTab}>\n        <TabsList>\n          <TabsTrigger value=\"list\">List View</TabsTrigger>\n          <TabsTrigger value=\"calendar\">Calendar View</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"list\" className=\"mt-4\">\n          <TaskTable onEdit={handleEditTask} onDelete={handleDeleteTask} />\n        </TabsContent>\n        \n        <TabsContent value=\"calendar\" className=\"mt-4\">\n          <TaskCalendar onTaskClick={handleEditTask} />\n        </TabsContent>\n      </Tabs>\n      \n      <TaskModal \n        isOpen={taskModalOpen} \n        onClose={() => setTaskModalOpen(false)} \n        task={currentTask} \n      />\n      \n      <DeleteTaskDialog \n        isOpen={deleteDialogOpen} \n        onClose={() => setDeleteDialogOpen(false)} \n        taskId={taskToDelete} \n      />\n    </div>\n  );\n}\n```",
        "testStrategy": "Test the main page by:\n1. Verifying all components render correctly\n2. Testing tab switching between list and calendar views\n3. Confirming create, edit, and delete workflows function properly\n4. Testing integration between components (e.g., editing a task from calendar view)\n5. Verifying responsive design on different screen sizes\n6. Testing accessibility of the entire page",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Filtering and Sorting",
        "description": "Add filtering and sorting capabilities to both the task list and calendar views.",
        "details": "Enhance the task list and calendar components with filtering and sorting:\n\n1. Add filtering to TaskTable component:\n```tsx\n// Add to TaskTable component\nconst [filters, setFilters] = useState({\n  status: 'all',\n  hasDate: 'all', // 'all', 'withDate', 'withoutDate'\n  isRecurring: 'all', // 'all', 'recurring', 'nonRecurring'\n});\n\nconst filteredTasks = tasks ? tasks.filter(task => {\n  // Filter by status\n  if (filters.status !== 'all' && task.status !== filters.status) {\n    return false;\n  }\n  \n  // Filter by date\n  if (filters.hasDate === 'withDate' && !task.dueDate) {\n    return false;\n  }\n  if (filters.hasDate === 'withoutDate' && task.dueDate) {\n    return false;\n  }\n  \n  // Filter by recurring\n  if (filters.isRecurring === 'recurring' && !task.isRecurring) {\n    return false;\n  }\n  if (filters.isRecurring === 'nonRecurring' && task.isRecurring) {\n    return false;\n  }\n  \n  return true;\n}) : [];\n\n// Add filter controls to the UI\nconst FilterControls = () => (\n  <div className=\"flex flex-wrap gap-4 mb-4\">\n    <div>\n      <label className=\"block text-sm font-medium mb-1\">Status</label>\n      <select\n        value={filters.status}\n        onChange={(e) => setFilters({ ...filters, status: e.target.value })}\n        className=\"border rounded p-2\"\n      >\n        <option value=\"all\">All Statuses</option>\n        <option value=\"pending\">Pending</option>\n        <option value=\"completed\">Completed</option>\n        <option value=\"cancelled\">Cancelled</option>\n      </select>\n    </div>\n    \n    <div>\n      <label className=\"block text-sm font-medium mb-1\">Due Date</label>\n      <select\n        value={filters.hasDate}\n        onChange={(e) => setFilters({ ...filters, hasDate: e.target.value })}\n        className=\"border rounded p-2\"\n      >\n        <option value=\"all\">All Tasks</option>\n        <option value=\"withDate\">With Due Date</option>\n        <option value=\"withoutDate\">Without Due Date</option>\n      </select>\n    </div>\n    \n    <div>\n      <label className=\"block text-sm font-medium mb-1\">Recurrence</label>\n      <select\n        value={filters.isRecurring}\n        onChange={(e) => setFilters({ ...filters, isRecurring: e.target.value })}\n        className=\"border rounded p-2\"\n      >\n        <option value=\"all\">All Tasks</option>\n        <option value=\"recurring\">Recurring Only</option>\n        <option value=\"nonRecurring\">Non-recurring Only</option>\n      </select>\n    </div>\n  </div>\n);\n```\n\n2. Enhance calendar filtering:\n```tsx\n// Add to TaskCalendar component\nconst [filters, setFilters] = useState({\n  status: 'all',\n  showRecurring: true,\n  showCompleted: true,\n});\n\n// Update the filter controls\nconst FilterControls = () => (\n  <div className=\"flex flex-wrap gap-4 mb-4\">\n    <div>\n      <label className=\"block text-sm font-medium mb-1\">Status</label>\n      <select\n        value={filters.status}\n        onChange={(e) => setFilters({ ...filters, status: e.target.value })}\n        className=\"border rounded p-2\"\n      >\n        <option value=\"all\">All Statuses</option>\n        <option value=\"pending\">Pending</option>\n        <option value=\"completed\">Completed</option>\n        <option value=\"cancelled\">Cancelled</option>\n      </select>\n    </div>\n    \n    <label className=\"flex items-center gap-2\">\n      <input\n        type=\"checkbox\"\n        checked={filters.showRecurring}\n        onChange={(e) => setFilters({ ...filters, showRecurring: e.target.checked })}\n      />\n      Show Recurring Tasks\n    </label>\n    \n    <label className=\"flex items-center gap-2\">\n      <input\n        type=\"checkbox\"\n        checked={filters.showCompleted}\n        onChange={(e) => setFilters({ ...filters, showCompleted: e.target.checked })}\n      />\n      Show Completed Tasks\n    </label>\n  </div>\n);\n\n// Update the filtering logic in the useMemo\nlet filteredTasks = tasks;\nif (filters.status !== 'all') {\n  filteredTasks = filteredTasks.filter(task => task.status === filters.status);\n} else if (!filters.showCompleted) {\n  filteredTasks = filteredTasks.filter(task => task.status !== 'completed');\n}\n\nif (!filters.showRecurring) {\n  filteredTasks = filteredTasks.filter(task => !task.isRecurring);\n}\n```",
        "testStrategy": "Test the filtering and sorting functionality by:\n1. Verifying all filter controls work correctly\n2. Testing combinations of filters to ensure they work together\n3. Confirming sorting in the task table works for all columns\n4. Testing that filters persist when switching between views\n5. Verifying filter state is correctly reflected in the UI\n6. Testing edge cases like filtering with no matching results",
        "priority": "low",
        "dependencies": [
          3,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Accessibility and Responsive Design",
        "description": "Ensure the task management system is fully accessible and responsive across different screen sizes.",
        "details": "Implement accessibility and responsive design improvements:\n\n1. Accessibility enhancements:\n```tsx\n// Add to all interactive components\n// Example for a button:\n<Button \n  onClick={handleAction}\n  aria-label=\"Create new task\"\n>\n  Create Task\n</Button>\n\n// Add proper labels to form fields\n<FormLabel htmlFor=\"task-title\">Title</FormLabel>\n<Input id=\"task-title\" {...field} />\n\n// Add ARIA attributes to custom components\n<div role=\"grid\" aria-label=\"Task list\">\n  {/* Task table content */}\n</div>\n\n// Add keyboard navigation to custom components\n// Example for task table rows:\nconst handleKeyDown = (e: React.KeyboardEvent, taskId: string) => {\n  if (e.key === 'Enter' || e.key === ' ') {\n    e.preventDefault();\n    handleEdit(taskId);\n  }\n};\n\n<TableRow \n  key={task._id}\n  tabIndex={0}\n  onKeyDown={(e) => handleKeyDown(e, task._id)}\n  role=\"row\"\n>\n  {/* Row content */}\n</TableRow>\n```\n\n2. Responsive design improvements:\n```tsx\n// Make the task table responsive\n<div className=\"overflow-x-auto\">\n  <Table>\n    {/* Table content */}\n  </Table>\n</div>\n\n// Make the filter controls responsive\n<div className=\"flex flex-wrap gap-4 mb-4\">\n  {/* Filter controls */}\n</div>\n\n// Use responsive utility classes for the main layout\n<div className=\"container mx-auto px-4 py-6 space-y-6\">\n  <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\">\n    <h1 className=\"text-2xl sm:text-3xl font-bold\">Task Management</h1>\n    <Button onClick={handleCreateTask}>Create Task</Button>\n  </div>\n  \n  {/* Rest of the content */}\n</div>\n\n// Make the task form responsive in the modal\n<DialogContent className=\"sm:max-w-md md:max-w-lg\">\n  {/* Form content */}\n</DialogContent>\n```\n\n3. Add focus management for modals:\n```tsx\n// In the TaskModal component\nimport { useRef, useEffect } from 'react';\n\nconst initialFocusRef = useRef<HTMLInputElement>(null);\n\nuseEffect(() => {\n  if (isOpen && initialFocusRef.current) {\n    initialFocusRef.current.focus();\n  }\n}, [isOpen]);\n\n// In the form\n<Input ref={initialFocusRef} {...field} />\n```\n\n4. Add responsive calendar view:\n```tsx\n// In the TaskCalendar component\nimport { useMediaQuery } from '@/hooks/useMediaQuery';\n\nconst isMobile = useMediaQuery('(max-width: 640px)');\n\n// Pass view type to calendar based on screen size\n<CampaignCalendar\n  events={calendarEvents}\n  onEventClick={handleEventClick}\n  onRangeChange={handleRangeChange}\n  defaultView={isMobile ? 'day' : 'month'}\n/>\n```",
        "testStrategy": "Test accessibility and responsive design by:\n1. Running automated accessibility tests (e.g., using axe-core)\n2. Testing keyboard navigation throughout the application\n3. Verifying screen reader compatibility\n4. Testing on various screen sizes (mobile, tablet, desktop)\n5. Verifying that all interactive elements are properly sized for touch input\n6. Testing focus management in modals and dialogs\n7. Verifying color contrast meets WCAG standards",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-11T13:44:11.799Z",
      "updated": "2025-07-11T13:58:11.687Z",
      "description": "Tasks for feature-admin-task-manager context"
    }
  }
}