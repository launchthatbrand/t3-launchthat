"use client";

import React, { Suspense, useRef } from "react";
import { OrbitControls, Stars, Trail, useGLTF } from "@react-three/drei";
import { Canvas, useFrame } from "@react-three/fiber";
import { Bloom, EffectComposer } from "@react-three/postprocessing";
import * as THREE_NS from "three";

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: overlaps (https://sketchfab.com/overlaps)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/models/91964c1ce1a34c3985b6257441efa500
title: Space exploration [WLP series #8]
*/
const RocketModel: React.FC<{ url: string }> = ({ url }) => {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
  const { nodes } = useGLTF(url) as any;
  const groupRef = useRef<THREE_NS.Group>(null);

  // Continuous spinning animation
   
  useFrame((state, delta) => {
    if (groupRef.current) {
      groupRef.current.rotation.z += delta * 0.3;
    }
  });

  return (
    <group
      ref={groupRef}
      rotation={[-Math.PI / 2, 0, 0]}
      position={[12, -3, 0]}
      scale={5}
    >
      <group rotation={[Math.PI / 13.5, -Math.PI / 5.8, Math.PI / 5.6]}>
        <mesh
          receiveShadow
          castShadow
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
          geometry={nodes.planet002?.geometry}
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
          material={nodes.planet002?.material}
        />
        <mesh
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
          geometry={nodes.planet003?.geometry}
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
          material={nodes.planet003?.material}
        />
      </group>
    </group>
  );
};

// Preload the model
useGLTF.preload("/scene.glb");

// Shooting Star Component with Trail
interface ShootingStarProps {
  offset?: number;
  startX?: number;
  startY?: number;
  startZ?: number;
}

const ShootingStar: React.FC<ShootingStarProps> = ({
  offset = 0,
  startX = 0,
  startY = 0,
  startZ = 0,
}) => {
  const ref = useRef<THREE_NS.Mesh>(null);

   
  useFrame((state) => {
    if (!ref.current) return;
     
    const elapsed = state.clock.getElapsedTime() + offset;
    const t = (elapsed * 0.15) % 4; // Slower: Loop every 4 seconds

    // Linear diagonal motion from top-left to bottom-right
    const progress = Math.min(t, 1); // Clamp to 0-1
    ref.current.position.set(
      startX - progress * 30, // Longer travel distance
      startY - progress * 25, // Longer travel distance
      startZ - progress * 15, // Longer travel distance
    );

    // Fade out when resetting
    if ("opacity" in ref.current.material) {
      (ref.current.material as THREE_NS.MeshBasicMaterial).opacity =
        t > 1 ? 0 : 1;
    }
  });

  return (
    <Trail
      width={3}
      length={8}
      color={new THREE_NS.Color(2, 1, 10)}
      attenuation={(t) => t * t}
    >
      <mesh ref={ref}>
        <sphereGeometry args={[0.2]} />
        <meshBasicMaterial color={[10, 1, 10]} toneMapped={false} transparent />
      </mesh>
    </Trail>
  );
};

// Multiple Shooting Stars
const ShootingStars: React.FC<{ count?: number }> = ({ count = 6 }) => {
  const stars = React.useMemo(() => {
    const validCount = count || 6;
    return Array.from({ length: validCount }, (_, i) => ({
      offset: i * 1.5, // More staggered start times
      startX: -25 + Math.random() * 30, // Much wider spread (-15 to +15)
      startY: 10 + Math.random() * 15, // Higher starting points (20 to 35)
      startZ: -20 + Math.random() * 40, // Much deeper spread (-20 to +20)
    }));
  }, [count]);

  return (
    <>
      {stars.map((star, i) => (
        <ShootingStar
          key={i}
          offset={star.offset}
          startX={star.startX}
          startY={star.startY}
          startZ={star.startZ}
        />
      ))}
    </>
  );
};

const TrackingSpotlight: React.FC<{
  target: THREE_NS.Vector3;
}> = ({ target }) => {
  const spotlightRef = useRef<THREE_NS.SpotLight>(null);
  const targetRef = useRef<THREE_NS.Object3D>(new THREE_NS.Object3D());

   
  useFrame(() => {
    const light = spotlightRef.current;
    const tgt = targetRef.current;
    if (!light) return;
    tgt.position.lerp(target, 0.25);
    tgt.updateMatrixWorld();
    light.target = tgt;
    light.target.updateMatrixWorld();
  });

  return (
    <>
      {/* World-space spotlight (not parented to the camera). */}
      <spotLight
        ref={spotlightRef}
        castShadow
        intensity={2.25 * Math.PI}
        decay={0}
        angle={0.25}
        penumbra={1}
        position={[-25, 20, -15]}
        shadow-mapSize={[1024, 1024]}
        shadow-bias={-0.0001}
      />
      {/* Ensure the spotlight target is part of the scene graph */}
      <primitive object={targetRef.current} />
    </>
  );
};

export const RocketScene: React.FC = () => {
  const rocketTarget = React.useMemo(() => new THREE_NS.Vector3(12, -3, 0), []);
  const controlsRef = useRef<unknown>(null);

  // Make sure OrbitControls orbits the rocket, not the world origin.
  React.useEffect(() => {
    const controls = controlsRef.current as {
      target?: THREE_NS.Vector3;
      update?: () => void;
    } | null;

    if (!controls?.target) return;
    controls.target.copy(rocketTarget);
    controls.update?.();
  }, [rocketTarget]);

  return (
    <div className="absolute inset-0 h-full w-full">
      <Canvas
        dpr={[1.5, 2]}
        linear
        shadows
        className="!absolute !inset-0 block !h-full !w-full"
        style={{
          width: "100%",
          height: "100%",
          position: "absolute",
          inset: 0,
        }}
        camera={{ position: [0, 0, 16], fov: 75 }}
        gl={{
          antialias: true,
          toneMapping: THREE_NS.ACESFilmicToneMapping,
          toneMappingExposure: 1.2,
        }}
      >
        {/* Background color */}
        <color attach="background" args={["#272730"]} />

        {/* Fog for depth */}
        <fog attach="fog" args={["#272730", 16, 30]} />

        {/* Lighting */}
        <ambientLight intensity={0.75 * Math.PI} />

        {/* Spotlight highlighting the rocket */}
        <TrackingSpotlight target={rocketTarget} />

        {/* Camera controls - reduced auto-rotate speed */}
        <OrbitControls
          ref={controlsRef}
          autoRotate
          autoRotateSpeed={0.1}
          enablePan={false}
          enableZoom={false}
          maxPolarAngle={Math.PI / 2}
          minPolarAngle={Math.PI / 2}
        />

        {/* 3D Model */}
        <Suspense
          fallback={
            <mesh position={[12, -3, 0]}>
              <sphereGeometry args={[2, 32, 32]} />
              <meshStandardMaterial color="#4444ff" wireframe />
            </mesh>
          }
        >
          <RocketModel url="/scene.glb" />
        </Suspense>

        {/* Stars background */}
        <Stars radius={500} depth={50} count={1000} factor={10} />

        {/* Shooting stars */}
        <ShootingStars count={6} />

        {/* Post-processing effects */}
        <Suspense fallback={null}>
          <EffectComposer>
            <Bloom mipmapBlur luminanceThreshold={1} intensity={1.5} />
          </EffectComposer>
        </Suspense>
      </Canvas>
    </div>
  );
};
