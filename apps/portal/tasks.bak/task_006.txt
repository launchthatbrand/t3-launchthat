# Task ID: 6
# Title: Implement Role-Based Access Control
# Status: done
# Dependencies: 5
# Priority: high
# Description: Create a system for role-based access control to distinguish between admin and regular users using Clerk authentication.
# Details:
Extend the Convex user schema to include role information (admin/user). Create Convex functions to fetch the user role based on the authenticated user ID (obtained from Clerk's useAuth hook). Implement middleware or wrapper components in Next.js to protect admin routes, checking the user's role via the Convex function after verifying authentication with Clerk. Create a higher-order component or hook for role-based conditional rendering based on Clerk auth state and Convex role data. Set up initial admin user creation in Convex (associating with a Clerk user).

# Test Strategy:
Test access control by attempting to access admin routes logged in as different Clerk users with varying roles defined in Convex. Verify admin-only components are only visible to admin users. Test role-checking functions with various user roles.

# Subtasks:
## 1. Extend Convex User Schema with Role Information [done]
### Dependencies: None
### Description: Modify the existing Convex user schema to include role information that distinguishes between admin and regular users.
### Details:
1. Update the Convex schema definition to add a 'role' field to the user table/document with type string and default value 'user'.
2. Define an enum or constants for available roles ('admin', 'user').
3. Ensure the schema validates that role values can only be one of the predefined options.
4. Run schema migration if necessary.
5. Test by manually creating test users with different roles in the Convex dashboard.
6. Document the updated schema structure.

<info added on 2025-04-25T18:38:03.346Z>
Based on the exploration findings, the subtask appears to be already implemented. Here's the additional information to add:

The `role` field is already properly implemented in the Convex user schema. Instead of modifying the schema, we should focus on:

1. Verifying the existing implementation works as expected by:
   - Creating test users with different roles through the Convex dashboard
   - Confirming role validation is enforced when attempting to set invalid values

2. Adding utility functions to:
   ```typescript
   // Add to usersSchema.ts or a new auth.ts file
   export const isAdmin = (user: Doc<"users">) => user.role === 'admin';
   export const isUser = (user: Doc<"users">) => user.role === 'user';
   
   // Function to check permissions in protected routes
   export async function requireAdmin(ctx: MutationCtx) {
     const identity = await ctx.auth.getUserIdentity();
     if (!identity) throw new Error("Unauthenticated");
     
     const user = await ctx.db.get(ctx.db.query("users").filter(q => 
       q.eq(q.field("tokenIdentifier"), identity.tokenIdentifier)
     ).first());
     
     if (!user || user.role !== 'admin') {
       throw new Error("Unauthorized: Admin access required");
     }
     
     return user;
   }
   ```

3. Document that the schema already includes role information and how to use the utility functions for role-based access control.
</info added on 2025-04-25T18:38:03.346Z>

## 2. Create Convex Functions for Role Management [done]
### Dependencies: 6.1
### Description: Implement Convex functions to fetch, verify, and manage user roles based on authenticated user IDs from Clerk.
### Details:
1. Create a `getUserRole` function that accepts a Clerk user ID and returns the corresponding role from Convex.
2. Implement a `hasRole` function that checks if a user has a specific role (e.g., isAdmin).
3. Create an admin-only function to update user roles (for future admin panel use).
4. Add proper authentication checks using Clerk's identity in these functions.
5. Test each function using the Convex dev tools.
6. Create utility functions to map between Clerk user IDs and Convex user IDs if needed.

<info added on 2025-04-25T18:38:37.250Z>
Here's additional implementation information for the role management functions:

```typescript
// apps/wsa/convex/roles.ts
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { getUserIdentity } from "./users";

// Define role types for better type safety
export type UserRole = "admin" | "member" | "guest";

// Query to get a user's role
export const getUserRole = query({
  args: {},
  handler: async (ctx) => {
    const identity = await getUserIdentity(ctx);
    if (!identity) return null;
    
    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => 
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .first();
    
    return user?.role as UserRole | null;
  },
});

// Check if user has a specific role
export const hasRole = query({
  args: { role: v.string() },
  handler: async (ctx, args) => {
    try {
      const userRole = await getUserRole(ctx, {});
      return userRole === args.role;
    } catch (error) {
      return false;
    }
  },
});

// Admin-only function to update user roles
export const updateUserRole = mutation({
  args: { 
    userId: v.id("users"),
    newRole: v.string() 
  },
  handler: async (ctx, args) => {
    // Verify the caller is an admin
    const isAdmin = await hasRole(ctx, { role: "admin" });
    if (!isAdmin) {
      throw new Error("Unauthorized: Admin access required");
    }
    
    // Update the user's role
    return await ctx.db.patch(args.userId, { 
      role: args.newRole as UserRole 
    });
  },
});

// Helper function for role-based access control in other functions
export const requireRole = async (ctx, requiredRole: UserRole) => {
  const hasRequiredRole = await hasRole(ctx, { role: requiredRole });
  if (!hasRequiredRole) {
    throw new Error(`Unauthorized: ${requiredRole} access required`);
  }
  return true;
};
```

Include error handling with specific error messages and implement a reusable `requireRole` helper that can be used in other functions to enforce role-based access control. The type definition for `UserRole` ensures type safety throughout the application.
</info added on 2025-04-25T18:38:37.250Z>

## 3. Implement Next.js Middleware for Route Protection [done]
### Dependencies: 6.2
### Description: Create middleware in Next.js to protect admin routes by verifying user roles after authentication.
### Details:
1. Create a middleware.ts file in the Next.js app root that intercepts requests to admin routes.
2. Use Clerk's middleware to verify authentication status.
3. For authenticated users, call the Convex `hasRole` function to check if the user has admin privileges.
4. Redirect unauthorized users to an appropriate page (login or unauthorized page).
5. Configure middleware to only run on admin routes using the matcher configuration.
6. Test by attempting to access admin routes with different user roles.
7. Add appropriate error handling and loading states.

## 4. Create Role-Based Conditional Rendering Components [done]
### Dependencies: 6.2
### Description: Implement higher-order components or hooks for conditionally rendering UI elements based on user roles.
### Details:
1. Create a `useUserRole` hook that combines Clerk's `useAuth` with Convex's role data.
2. Implement a `<RequireRole>` component that conditionally renders children based on the user's role.
3. Create an `<AdminOnly>` component that only renders content for admin users.
4. Add appropriate loading states and fallback UI for when role information is being fetched.
5. Test components with different user roles to ensure proper rendering behavior.
6. Document usage examples for the team.

## 5. Set Up Initial Admin User Creation [done]
### Dependencies: 6.1, 6.2
### Description: Implement a mechanism to create and designate the initial admin user in the system.
### Details:
1. Create a Convex mutation function to set a user as admin.
2. Implement a secure admin initialization process (options include environment variables, initial setup page with secure token, or CLI tool).
3. Create a one-time setup endpoint or script that can only be triggered during initial deployment.
4. Add validation to prevent creating multiple initial admins.
5. Document the admin setup process for deployment.
6. Test the complete flow from user creation in Clerk to admin designation in Convex.
7. Add logging for admin user creation events.

