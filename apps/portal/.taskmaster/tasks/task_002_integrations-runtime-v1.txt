# Task ID: 2
# Title: Implement Typed Registries for Actions, Triggers, and Nodes
# Status: done
# Dependencies: None
# Priority: high
# Description: Create strongly-typed registries with Zod schemas for actions, triggers, and nodes to ensure runtime validation and type safety.
# Details:
1. Create base registry interfaces:

```typescript
// Action Registry
interface ActionDefinition<TConfig, TInput, TOutput> {
  type: string;
  metadata: {
    name: string;
    description: string;
    category?: string;
  };
  configSchema: z.ZodSchema<TConfig>;
  inputSchema: z.ZodSchema<TInput>;
  outputSchema: z.ZodSchema<TOutput>;
  execute: (ctx: ActionContext, input: TInput, config: TConfig) => Promise<ActionResult<TOutput>>;
}

interface ActionResult<T> {
  kind: "success" | "retryable_error" | "fatal_error";
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}

// Trigger Registry
interface TriggerDefinition<TConfig, TPayload> {
  key: string;
  metadata: {
    name: string;
    description: string;
    category?: string;
  };
  configSchema: z.ZodSchema<TConfig>;
  fire: (ctx: TriggerContext, payload: TPayload, config: TConfig) => Promise<TriggerResult>;
}

interface TriggerResult {
  correlationId: string;
  idempotencyKey?: string;
  payload: Record<string, unknown>;
}

// Node Registry
interface NodeDefinition<TConfig> {
  type: string;
  metadata: {
    name: string;
    description: string;
    category?: string;
  };
  configSchema: z.ZodSchema<TConfig>;
  execute: (ctx: NodeContext, input: NodeIO, config: TConfig) => Promise<NodeIO>;
  migrate?: (oldConfig: unknown) => TConfig;
}

interface NodeIO {
  correlationId: string;
  data: Record<string, unknown>;
  metadata?: Record<string, unknown>;
}
```

2. Implement registry factories and registration methods:

```typescript
// Example for action registry
export const actionRegistry = {
  actions: new Map<string, ActionDefinition<any, any, any>>(),
  register<TConfig, TInput, TOutput>(action: ActionDefinition<TConfig, TInput, TOutput>) {
    if (this.actions.has(action.type)) {
      throw new Error(`Action type '${action.type}' is already registered`);
    }
    this.actions.set(action.type, action);
    return action;
  },
  get(type: string) {
    const action = this.actions.get(type);
    if (!action) {
      throw new Error(`Action type '${type}' not found in registry`);
    }
    return action;
  },
  getAll() {
    return Array.from(this.actions.values());
  }
};
```

3. Create similar registry implementations for triggers and nodes

4. Add validation helpers that use the schemas to validate inputs/configs at runtime

# Test Strategy:
1. Unit tests for registry registration and retrieval
2. Test validation of inputs against schemas
3. Test error handling when retrieving non-existent registry items
4. Test registration of duplicate items (should throw errors)
5. Integration tests with sample actions/triggers/nodes to verify end-to-end validation
