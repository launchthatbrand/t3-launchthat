# Task ID: 10
# Title: Integrate and Test the Complete System
# Status: done
# Dependencies: 1, 2, 3, 4, 5, 6, 7, 8, 9
# Priority: high
# Description: Connect all components, implement the runtime execution flow, and create comprehensive tests for the entire system.
# Details:
1. Implement the main scenario execution flow:

```typescript
export const executeScenario = internalAction({
  args: {
    scenarioId: v.id("scenarios"),
    runId: v.id("runs"),
    payload: v.any(),
    correlationId: v.string()
  },
  handler: async (ctx, args) => {
    // Get the scenario
    const scenario = await ctx.runQuery(internal.scenarios.getById, { id: args.scenarioId });
    if (!scenario) {
      throw new Error(`Scenario ${args.scenarioId} not found`);
    }
    
    // Get all nodes for this scenario
    const nodes = await ctx.runQuery(internal.nodes.getByScenarioId, { scenarioId: args.scenarioId });
    
    // Get all edges to determine execution flow
    const edges = await ctx.runQuery(internal.scenarioEdges.getByScenarioId, { scenarioId: args.scenarioId });
    
    // Update run with scenario info
    await ctx.runMutation(internal.runs.update, {
      id: args.runId,
      scenarioId: args.scenarioId,
      scenarioVersion: scenario.version,
      status: "running"
    });
    
    // Sort nodes in execution order
    const sortedNodes = topologicalSort(nodes, edges);
    
    // Execute each node in order
    const nodeOutputs = new Map();
    
    // Start with trigger output
    nodeOutputs.set("trigger", {
      correlationId: args.correlationId,
      data: args.payload
    });
    
    let success = true;
    let lastError = null;
    
    for (const [index, node] of sortedNodes.entries()) {
      // Get node definition
      const nodeDefinition = nodeRegistry.get(node.type);
      
      // Get input for this node based on incoming edges
      const inputNodeIds = edges
        .filter(edge => edge.targetNodeId === node._id)
        .map(edge => edge.sourceNodeId);
      
      // For simplicity, we'll just use the output of the first input node
      // In a real implementation, you'd need to handle multiple inputs and named handles
      const inputNodeId = inputNodeIds[0] || "trigger";
      const input = nodeOutputs.get(inputNodeId) || { correlationId: args.correlationId, data: {} };
      
      try {
        // Execute the node with retry logic
        const result = await executeWithRetry(
          ctx,
          args.runId,
          node._id,
          index + 1, // step number
          async () => {
            try {
              // Validate node config
              nodeDefinition.configSchema.parse(node.config);
              
              // Execute the node
              return await nodeDefinition.execute(ctx, input, node.config);
            } catch (error) {
              return {
                kind: "retryable_error",
                error: {
                  code: "EXECUTION_ERROR",
                  message: error.message || String(error)
                }
              };
            }
          }
        );
        
        if (result.kind === "success") {
          // Store the output for use by downstream nodes
          nodeOutputs.set(node._id, {
            correlationId: args.correlationId,
            data: result.data
          });
        } else {
          // Node execution failed
          success = false;
          lastError = result.error;
          break;
        }
      } catch (error) {
        // Unexpected error during execution
        success = false;
        lastError = {
          code: "UNEXPECTED_ERROR",
          message: error.message || String(error)
        };
        break;
      }
    }
    
    // Update run status based on execution result
    await ctx.runMutation(internal.runs.update, {
      id: args.runId,
      status: success ? "succeeded" : "failed",
      finishedAt: Date.now(),
      error: success ? undefined : lastError
    });
    
    return {
      success,
      runId: args.runId,
      error: lastError
    };
  },
});
```

2. Implement the main webhook handler that ties everything together:

```typescript
export const handleWebhook = httpAction(async (ctx, request) => {
  // Parse request
  const url = new URL(request.url);
  const appKey = url.pathname.split("/").pop(); // Assuming URL format like /webhook/:appKey
  
  if (!appKey) {
    return new Response(JSON.stringify({ error: "Missing app key" }), {
      status: 400,
      headers: { "Content-Type": "application/json" }
    });
  }
  
  // Get app by key
  const app = await ctx.runQuery(internal.apps.getByKey, { key: appKey });
  if (!app) {
    return new Response(JSON.stringify({ error: "Invalid app key" }), {
      status: 404,
      headers: { "Content-Type": "application/json" }
    });
  }
  
  // Parse body
  let body;
  try {
    const contentType = request.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
      body = await request.json();
    } else {
      body = await request.text();
    }
  } catch (error) {
    return new Response(JSON.stringify({ error: "Invalid request body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" }
    });
  }
  
  // Convert headers to a plain object
  const headers = {};
  for (const [key, value] of request.headers.entries()) {
    headers[key.toLowerCase()] = value;
  }
  
  // Process the webhook
  try {
    const result = await ctx.runAction(internal.webhooks.processWebhook, {
      appId: app._id,
      triggerKey: "webhook",
      payload: {
        method: request.method,
        headers,
        body,
        url: request.url
      },
      headers,
      connectionId: app.defaultConnectionId
    });
    
    if (!result.success) {
      return new Response(JSON.stringify({ error: result.error }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    
    return new Response(JSON.stringify({
      success: true,
      runId: result.runId,
      idempotent: result.idempotent
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message || String(error) }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
});
```

3. Create a comprehensive test suite:

```typescript
// Example test for the entire flow
describe("Integration Tests", () => {
  beforeEach(async () => {
    // Set up test data
    // Create test app, connection, scenario, nodes, etc.
  });
  
  test("End-to-end webhook trigger to action execution", async () => {
    // Create a test scenario with webhook trigger
    const appId = await ctx.runMutation(internal.apps.create, {
      name: "Test App",
      key: "test-app-" + Math.random().toString(36).substring(2, 7)
    });
    
    const connectionId = await ctx.runMutation(internal.connections.create, {
      appId,
      name: "Test Connection",
      status: "active",
      metadata: {},
      secrets: {
        credentials: {
          webhookSecret: "test-secret"
        }
      }
    });
    
    // Update app with default connection
    await ctx.runMutation(internal.apps.update, {
      id: appId,
      defaultConnectionId: connectionId
    });
    
    // Create a scenario
    const scenarioId = await ctx.runMutation(internal.scenarios.create, {
      name: "Test Scenario",
      enabled: true,
      draftConfig: {
        triggerKey: "webhook",
        triggerConfig: {}
      },
      publishedConfig: {
        triggerKey: "webhook",
        triggerConfig: {}
      },
      version: 1
    });
    
    // Create a test action node
    const nodeId = await ctx.runMutation(internal.nodes.create, {
      scenarioId,
      type: "logger",
      name: "Log Message",
      config: {
        message: "Hello from test"
      },
      rfType: "default",
      rfPosition: { x: 100, y: 100 }
    });
    
    // Create an edge from trigger to node
    await ctx.runMutation(internal.scenarioEdges.create, {
      scenarioId,
      sourceNodeId: "trigger", // Special ID for the trigger
      targetNodeId: nodeId
    });
    
    // Simulate a webhook request
    const payload = {
      test: true,
      message: "Test webhook payload"
    };
    
    // Create HMAC signature
    const hmac = createHmac("sha256", "test-secret");
    hmac.update(JSON.stringify(payload));
    const signature = hmac.digest("hex");
    
    // Send webhook request
    const response = await fetch(`/api/webhook/${app.key}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Signature": signature
      },
      body: JSON.stringify(payload)
    });
    
    expect(response.status).toBe(200);
    const responseData = await response.json();
    expect(responseData.success).toBe(true);
    
    // Verify run was created and completed successfully
    const run = await ctx.runQuery(internal.runs.getById, { id: responseData.runId });
    expect(run).not.toBeNull();
    expect(run.status).toBe("succeeded");
    
    // Verify logs were created
    const logs = await ctx.runQuery(internal.logs.getByRunId, { runId: run._id });
    expect(logs.length).toBeGreaterThan(0);
    expect(logs.some(log => log.nodeId === nodeId)).toBe(true);
  });
  
  test("Scenario with error handling and retries", async () => {
    // Similar setup but with a node that fails and tests retry logic
  });
  
  test("Dry run execution", async () => {
    // Test the dry run functionality
  });
  
  test("Scenario versioning and publishing", async () => {
    // Test draft/publish workflow
  });
});
```

4. Create a system health check endpoint:

```typescript
export const healthCheck = httpAction(async (ctx) => {
  try {
    // Check database connectivity
    const dbCheck = await ctx.runQuery(internal.system.ping, {});
    
    // Check registry initialization
    const registryCheck = {
      actions: actionRegistry.getAll().length,
      triggers: triggerRegistry.getAll().length,
      nodes: nodeRegistry.getAll().length
    };
    
    // Get system stats
    const stats = await ctx.runQuery(internal.system.getStats, {});
    
    return new Response(JSON.stringify({
      status: "healthy",
      version: "1.0.0",
      timestamp: Date.now(),
      checks: {
        database: dbCheck.success,
        registry: registryCheck
      },
      stats
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      status: "unhealthy",
      error: error.message || String(error),
      timestamp: Date.now()
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
});
```

# Test Strategy:
1. End-to-end integration tests for the complete system
2. Test webhook handling with various payloads and signature validation
3. Test scenario execution with different node types and configurations
4. Test error handling and recovery at the system level
5. Performance tests with multiple concurrent webhook requests
6. Test idempotency with duplicate webhook calls
7. Test system health check endpoint
8. Load testing to verify system stability under high load
