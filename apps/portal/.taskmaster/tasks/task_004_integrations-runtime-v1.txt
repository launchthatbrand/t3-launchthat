# Task ID: 4
# Title: Implement Runtime Reliability with Idempotency and Retries
# Status: done
# Dependencies: 1
# Priority: high
# Description: Build a reliable runtime with idempotency guarantees, retry policies with exponential backoff, and a consistent error taxonomy.
# Details:
1. Implement idempotency handling:

```typescript
async function ensureIdempotent(ctx: ActionContext, correlationId: string, idempotencyKey?: string) {
  // Check if a run with this correlationId already exists
  const existingRun = await ctx.runQuery(internal.runs.getByCorrelationId, { correlationId });
  
  if (existingRun) {
    // Return the existing run to prevent duplicate execution
    return { isNew: false, runId: existingRun._id };
  }
  
  // Create a new run
  const runId = await ctx.runMutation(internal.runs.create, {
    correlationId,
    idempotencyKey,
    // other run details
  });
  
  return { isNew: true, runId };
}
```

2. Implement retry mechanism with exponential backoff:

```typescript
interface RetryConfig {
  maxAttempts: number;
  initialDelayMs: number;
  maxDelayMs: number;
  backoffFactor: number;
}

async function executeWithRetry<T>(
  ctx: ActionContext,
  runId: Id<"runs">,
  nodeId: Id<"nodes"> | null,
  step: number,
  fn: () => Promise<ActionResult<T>>,
  config: RetryConfig = {
    maxAttempts: 3,
    initialDelayMs: 1000,
    maxDelayMs: 60000,
    backoffFactor: 2
  }
): Promise<ActionResult<T>> {
  let attempt = 1;
  let lastError: ActionResult<T> | null = null;
  
  while (attempt <= config.maxAttempts) {
    const startTime = Date.now();
    try {
      const result = await fn();
      
      // Log the attempt
      await ctx.runMutation(internal.logs.create, {
        runId,
        nodeId,
        step,
        status: result.kind,
        attempt,
        startedAt: startTime,
        durationMs: Date.now() - startTime,
        errorCode: result.error?.code,
        errorMessage: result.error?.message,
        data: result.kind === "success" ? result.data : undefined
      });
      
      // If success or fatal error, return immediately
      if (result.kind !== "retryable_error") {
        return result;
      }
      
      // Store the error for potential final return
      lastError = result;
      
    } catch (error) {
      // Unexpected errors are logged and treated as retryable
      await ctx.runMutation(internal.logs.create, {
        runId,
        nodeId,
        step,
        status: "retryable_error",
        attempt,
        startedAt: startTime,
        durationMs: Date.now() - startTime,
        errorCode: "UNEXPECTED_ERROR",
        errorMessage: error.message || String(error)
      });
      
      lastError = {
        kind: "retryable_error",
        error: {
          code: "UNEXPECTED_ERROR",
          message: error.message || String(error)
        }
      };
    }
    
    // Calculate backoff delay
    const delayMs = Math.min(
      config.initialDelayMs * Math.pow(config.backoffFactor, attempt - 1),
      config.maxDelayMs
    );
    
    // Wait before retry
    await new Promise(resolve => setTimeout(resolve, delayMs));
    
    attempt++;
  }
  
  // Max attempts reached, log as fatal error
  await ctx.runMutation(internal.logs.create, {
    runId,
    nodeId,
    step,
    status: "fatal_error",
    attempt,
    startedAt: Date.now(),
    durationMs: 0,
    errorCode: "MAX_RETRIES_EXCEEDED",
    errorMessage: `Failed after ${config.maxAttempts} attempts: ${lastError?.error?.message || "Unknown error"}`,
    data: undefined
  });
  
  // Convert the last retryable error to fatal
  return {
    kind: "fatal_error",
    error: {
      code: "MAX_RETRIES_EXCEEDED",
      message: `Failed after ${config.maxAttempts} attempts: ${lastError?.error?.message || "Unknown error"}`
    }
  };
}
```

3. Define a consistent error taxonomy:

```typescript
// Error codes enum
export enum ErrorCode {
  // Authentication errors
  INVALID_CREDENTIALS = "INVALID_CREDENTIALS",
  TOKEN_EXPIRED = "TOKEN_EXPIRED",
  UNAUTHORIZED = "UNAUTHORIZED",
  
  // Rate limiting
  RATE_LIMITED = "RATE_LIMITED",
  QUOTA_EXCEEDED = "QUOTA_EXCEEDED",
  
  // Validation errors
  INVALID_INPUT = "INVALID_INPUT",
  INVALID_CONFIG = "INVALID_CONFIG",
  
  // External service errors
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
  TIMEOUT = "TIMEOUT",
  
  // Execution errors
  EXECUTION_FAILED = "EXECUTION_FAILED",
  MAX_RETRIES_EXCEEDED = "MAX_RETRIES_EXCEEDED",
  
  // Unexpected errors
  UNEXPECTED_ERROR = "UNEXPECTED_ERROR"
}

// Helper to create error results
export function createError<T>(code: ErrorCode, message: string, retryable = true): ActionResult<T> {
  return {
    kind: retryable ? "retryable_error" : "fatal_error",
    error: {
      code,
      message
    }
  };
}
```

4. Implement dead-letter handling for failed runs:

```typescript
async function markRunAsFailed(ctx: ActionContext, runId: Id<"runs">, error: { code: string; message: string }) {
  await ctx.runMutation(internal.runs.update, {
    id: runId,
    status: "failed",
    finishedAt: Date.now(),
    error
  });
  
  // Optional: Send notification or trigger alert for failed run
}
```

# Test Strategy:
1. Unit tests for idempotency handling with duplicate correlation IDs
2. Test retry mechanism with mocked functions that fail a set number of times
3. Verify exponential backoff timing (using jest.useFakeTimers)
4. Test error taxonomy and consistent error handling
5. Integration tests for end-to-end retry scenarios
6. Test dead-letter handling for permanently failed runs
7. Performance tests to ensure retry overhead is acceptable

# Subtasks:
## 1. Implement idempotency handling [done]
### Dependencies: None
### Description: Create a function to ensure idempotent execution of actions using correlation IDs
### Details:
Create a new file 'src/runtime/idempotency.ts'. Implement the 'ensureIdempotent' function as described in the task details. This function should check for existing runs with the given correlation ID and either return the existing run or create a new one. Update the 'internal.runs' table schema if necessary to support correlation IDs.
<info added on 2025-08-15T19:25:40.512Z>
Fixed TypeScript error in the `ActionContext` interface by extending it from Convex's `ActionCtx`. Modified `apps/portal/convex/integrations/lib/registries.ts` to properly inherit all Convex action context methods while maintaining the custom `correlationId` property. This resolved the "Property 'runMutation' does not exist on type 'ActionContext'" error, allowing the `ensureIdempotent` function to access necessary Convex methods like `runMutation` and `runQuery`. The fix was validated with `pnpm typecheck` and confirms the idempotency implementation now correctly handles race conditions by using atomic mutations.
</info added on 2025-08-15T19:25:40.512Z>

## 2. Implement retry mechanism with exponential backoff [done]
### Dependencies: 4.1
### Description: Create a function to execute actions with retry logic and exponential backoff
### Details:
Create a new file 'src/runtime/retry.ts'. Implement the 'executeWithRetry' function as described in the task details. This function should handle retries with configurable attempts, delays, and backoff factors. Integrate with the logging system to record attempt details.

## 3. Define consistent error taxonomy [done]
### Dependencies: None
### Description: Create an error code enum and helper functions for standardized error handling
### Details:
Create a new file 'src/runtime/errors.ts'. Define the 'ErrorCode' enum and 'createError' helper function as described in the task details. Ensure all parts of the system use this consistent error taxonomy.

## 4. Implement dead-letter handling for failed runs [done]
### Dependencies: 4.2, 4.3
### Description: Create a function to mark runs as failed and handle unrecoverable errors
### Details:
In 'src/runtime/errorHandling.ts', implement the 'markRunAsFailed' function as described in the task details. This should update the run status in the 'internal.runs' table and potentially trigger notifications or alerts for failed runs.

## 5. Integrate reliability features into action execution [done]
### Dependencies: 4.1, 4.2, 4.3, 4.4
### Description: Update the main action execution flow to incorporate idempotency, retries, and error handling
### Details:
In 'src/runtime/actionExecution.ts', update the main action execution function to use the newly implemented reliability features. This should include checking for idempotency, wrapping execution in the retry mechanism, and using the standardized error taxonomy. Ensure proper logging and error handling throughout the execution flow.

