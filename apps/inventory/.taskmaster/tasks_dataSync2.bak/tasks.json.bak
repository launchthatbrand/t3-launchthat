{
  "tasks": [
    {
      "id": 1,
      "title": "Design Core Rules Engine Framework",
      "description": "Create the abstract rules engine framework that defines the core interfaces, types, and utilities for a generic rules system independent of integration type.",
      "details": "Implement the following components:\n\n1. Define TypeScript interfaces for core concepts:\n```typescript\ninterface Rule {\n  id: string;\n  name: string;\n  description?: string;\n  enabled: boolean;\n  triggerType: string;\n  triggerConfig: Record<string, any>;\n  conditions: Condition[];\n  actions: Action[];\n  integrationId: string;\n  metadata?: Record<string, any>;\n}\n\ninterface Trigger {\n  type: string;\n  evaluate(context: RuleExecutionContext): Promise<boolean>;\n}\n\ninterface Condition {\n  type: string;\n  config: Record<string, any>;\n  evaluate(context: RuleExecutionContext): Promise<boolean>;\n}\n\ninterface Action {\n  type: string;\n  config: Record<string, any>;\n  execute(context: RuleExecutionContext): Promise<ActionResult>;\n}\n\ninterface RuleExecutionContext {\n  rule: Rule;\n  triggerData: any;\n  integrationData: any;\n  timestamp: Date;\n  logger: RuleLogger;\n}\n\ninterface ActionResult {\n  success: boolean;\n  message?: string;\n  data?: any;\n}\n```\n\n2. Create a provider pattern for registering integration-specific implementations:\n```typescript\nclass RuleEngineRegistry {\n  private triggers: Map<string, Map<string, TriggerFactory>>;\n  private conditions: Map<string, Map<string, ConditionFactory>>;\n  private actions: Map<string, Map<string, ActionFactory>>;\n\n  registerIntegration(integrationId: string): void;\n  registerTrigger(integrationId: string, type: string, factory: TriggerFactory): void;\n  registerCondition(integrationId: string, type: string, factory: ConditionFactory): void;\n  registerAction(integrationId: string, type: string, factory: ActionFactory): void;\n  \n  getTrigger(integrationId: string, type: string): TriggerFactory | undefined;\n  getCondition(integrationId: string, type: string): ConditionFactory | undefined;\n  getAction(integrationId: string, type: string): ActionFactory | undefined;\n}\n```\n\n3. Implement the core rule execution engine:\n```typescript\nclass RuleEngine {\n  constructor(private registry: RuleEngineRegistry) {}\n\n  async evaluateRule(rule: Rule, triggerData: any, integrationData: any): Promise<RuleEvaluationResult>;\n  async executeRule(rule: Rule, triggerData: any, integrationData: any): Promise<RuleExecutionResult>;\n}\n```\n\n4. Create a logging and monitoring system:\n```typescript\ninterface RuleLogger {\n  info(message: string, data?: any): void;\n  warn(message: string, data?: any): void;\n  error(message: string, error: Error, data?: any): void;\n  startTimer(label: string): void;\n  endTimer(label: string): number;\n}\n\nclass RuleExecutionLogger implements RuleLogger {\n  // Implementation details\n}\n```\n\n5. Set up Convex schema for storing rules in a generic format that supports multiple integration types.",
      "testStrategy": "1. Write unit tests for each core interface implementation\n2. Create mock implementations of triggers, conditions, and actions for testing\n3. Test the rule engine with various rule configurations\n4. Verify the provider pattern works correctly with different integration types\n5. Test logging and monitoring functionality\n6. Ensure type safety throughout the system",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Core TypeScript Interfaces",
          "description": "Define and implement the core TypeScript interfaces for the rules engine framework",
          "dependencies": [],
          "details": "Create TypeScript interfaces for Rule, Trigger, Condition, Action, RuleExecutionContext, and ActionResult. Ensure all properties and methods are correctly typed and documented.",
          "status": "pending",
          "testStrategy": "Write unit tests to validate interface implementations and type checking"
        },
        {
          "id": 2,
          "title": "Develop RuleEngineRegistry Class",
          "description": "Create the RuleEngineRegistry class to manage integration-specific implementations",
          "dependencies": [
            1
          ],
          "details": "Implement the RuleEngineRegistry class with methods for registering and retrieving triggers, conditions, and actions for different integrations. Use Maps for efficient storage and retrieval.",
          "status": "pending",
          "testStrategy": "Create unit tests for registration and retrieval methods, including edge cases"
        },
        {
          "id": 3,
          "title": "Implement Core RuleEngine Class",
          "description": "Develop the main RuleEngine class for rule evaluation and execution",
          "dependencies": [
            1,
            2
          ],
          "details": "Create the RuleEngine class with methods for evaluating and executing rules. Implement logic to use the RuleEngineRegistry for retrieving integration-specific components.",
          "status": "pending",
          "testStrategy": "Develop integration tests simulating rule evaluation and execution scenarios"
        },
        {
          "id": 4,
          "title": "Create Logging and Monitoring System",
          "description": "Implement the RuleLogger interface and RuleExecutionLogger class",
          "dependencies": [
            1
          ],
          "details": "Develop the RuleLogger interface and RuleExecutionLogger class with methods for logging different levels of information and timing rule execution. Ensure compatibility with various logging backends.",
          "status": "pending",
          "testStrategy": "Write unit tests for logging methods and timer functionality"
        },
        {
          "id": 5,
          "title": "Design Convex Schema for Rule Storage",
          "description": "Create a Convex schema for storing rules in a format supporting multiple integration types",
          "dependencies": [
            1
          ],
          "details": "Design and implement a Convex schema that can store rules with their associated triggers, conditions, and actions. Ensure the schema is flexible enough to accommodate different integration types and future extensions.",
          "status": "pending",
          "testStrategy": "Develop schema validation tests and sample queries to verify data integrity and retrieval efficiency"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Integration Registry System",
      "description": "Create a registry system that allows different integration types to register their specific rule components (triggers, conditions, actions) with the core rules engine.",
      "details": "1. Create an integration registry class that manages available integrations:\n```typescript\ninterface IntegrationDefinition {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  triggers: TriggerDefinition[];\n  conditions: ConditionDefinition[];\n  actions: ActionDefinition[];\n}\n\ninterface TriggerDefinition {\n  type: string;\n  name: string;\n  description: string;\n  configSchema: JSONSchema7; // JSON Schema for configuration\n  factory: TriggerFactory;\n}\n\n// Similar interfaces for ConditionDefinition and ActionDefinition\n\nclass IntegrationRegistry {\n  private integrations: Map<string, IntegrationDefinition>;\n  \n  registerIntegration(integration: IntegrationDefinition): void;\n  getIntegration(id: string): IntegrationDefinition | undefined;\n  getAllIntegrations(): IntegrationDefinition[];\n  \n  // Methods to get available triggers, conditions, and actions for an integration\n  getAvailableTriggers(integrationId: string): TriggerDefinition[];\n  getAvailableConditions(integrationId: string): ConditionDefinition[];\n  getAvailableActions(integrationId: string): ActionDefinition[];\n}\n```\n\n2. Implement a plugin architecture for loading integration definitions:\n```typescript\ninterface IntegrationPlugin {\n  getDefinition(): IntegrationDefinition;\n  initialize(): Promise<void>;\n}\n\nclass IntegrationPluginLoader {\n  async loadPlugin(plugin: IntegrationPlugin): Promise<void> {\n    await plugin.initialize();\n    const definition = plugin.getDefinition();\n    // Register with the registry\n  }\n}\n```\n\n3. Create Convex functions to manage integrations:\n```typescript\n// Define Convex schema for integrations\nexport const integrations = defineTable({\n  id: v.string(),\n  name: v.string(),\n  description: v.string(),\n  version: v.string(),\n  enabled: v.boolean(),\n  config: v.any(),\n});\n\n// Convex mutation to register a new integration\nexport const registerIntegration = mutation({\n  args: { /* ... */ },\n  handler: async (ctx, args) => {\n    // Implementation\n  },\n});\n```\n\n4. Implement integration-specific configuration storage and retrieval:\n```typescript\ninterface IntegrationConfig {\n  // Common configuration fields\n  enabled: boolean;\n  // Integration-specific configuration stored as JSON\n  settings: Record<string, any>;\n}\n\nclass IntegrationConfigManager {\n  async getConfig(integrationId: string): Promise<IntegrationConfig>;\n  async updateConfig(integrationId: string, config: Partial<IntegrationConfig>): Promise<void>;\n}\n```\n\n5. Create a mechanism for integrations to register their components with the core rule engine registry created in Task 1.",
      "testStrategy": "1. Write unit tests for the integration registry functionality\n2. Test registration and retrieval of integration definitions\n3. Create mock integration plugins for testing\n4. Verify that integration-specific components are correctly registered with the rule engine\n5. Test configuration management for different integration types\n6. Ensure proper error handling for invalid or missing integrations",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Design Generic Rules Schema",
      "description": "Design and implement a new database schema with generic tables for rules, rule executions, and rule logs that can support multiple integration types.",
      "details": "1. Define Convex schema for the generic rules system:\n\n```typescript\n// Rules table - generic structure for all integration types\nexport const rules = defineTable({\n  id: v.string(),\n  name: v.string(),\n  description: v.optional(v.string()),\n  enabled: v.boolean(),\n  integrationId: v.string(), // References the integration type\n  triggerType: v.string(),\n  triggerConfig: v.any(), // JSON configuration for the trigger\n  conditions: v.array(v.object({\n    id: v.string(),\n    type: v.string(),\n    config: v.any(), // JSON configuration for the condition\n  })),\n  actions: v.array(v.object({\n    id: v.string(),\n    type: v.string(),\n    config: v.any(), // JSON configuration for the action\n  })),\n  metadata: v.optional(v.any()), // Integration-specific metadata\n  createdAt: v.number(),\n  updatedAt: v.number(),\n});\n\n// Rule executions table - tracks each execution of a rule\nexport const ruleExecutions = defineTable({\n  ruleId: v.string(),\n  integrationId: v.string(),\n  triggered: v.boolean(), // Whether the trigger condition was met\n  conditionsMet: v.boolean(), // Whether all conditions were satisfied\n  successful: v.boolean(), // Whether all actions executed successfully\n  startTime: v.number(),\n  endTime: v.number(),\n  triggerData: v.any(), // Data that triggered the rule\n  resultData: v.optional(v.any()), // Results of the rule execution\n  error: v.optional(v.string()), // Error message if execution failed\n});\n\n// Rule execution logs - detailed logs for debugging\nexport const ruleExecutionLogs = defineTable({\n  executionId: v.string(),\n  timestamp: v.number(),\n  level: v.string(), // 'info', 'warn', 'error'\n  message: v.string(),\n  data: v.optional(v.any()), // Additional context data\n  component: v.string(), // 'trigger', 'condition', 'action'\n  componentId: v.optional(v.string()), // ID of the specific component\n});\n```\n\n2. Create indexes for efficient querying:\n\n```typescript\nrules.index('by_integration', ['integrationId']);\nruleExecutions.index('by_rule', ['ruleId']);\nruleExecutions.index('by_integration', ['integrationId']);\nruleExecutionLogs.index('by_execution', ['executionId']);\n```\n\n3. Implement Convex functions for rule management:\n\n```typescript\n// Create a new rule\nexport const createRule = mutation({\n  args: {\n    name: v.string(),\n    description: v.optional(v.string()),\n    integrationId: v.string(),\n    triggerType: v.string(),\n    triggerConfig: v.any(),\n    conditions: v.array(v.object({\n      type: v.string(),\n      config: v.any(),\n    })),\n    actions: v.array(v.object({\n      type: v.string(),\n      config: v.any(),\n    })),\n    metadata: v.optional(v.any()),\n  },\n  handler: async (ctx, args) => {\n    // Implementation\n  },\n});\n\n// Similar functions for updateRule, deleteRule, enableRule, disableRule\n```\n\n4. Create query functions for retrieving rules:\n\n```typescript\n// Get rules for a specific integration\nexport const getRulesByIntegration = query({\n  args: { integrationId: v.string() },\n  handler: async (ctx, args) => {\n    return await ctx.db\n      .query('rules')\n      .withIndex('by_integration', q => q.eq('integrationId', args.integrationId))\n      .collect();\n  },\n});\n\n// Get rule execution history\nexport const getRuleExecutions = query({\n  args: { ruleId: v.string(), limit: v.optional(v.number()) },\n  handler: async (ctx, args) => {\n    // Implementation\n  },\n});\n```\n\n5. Design migration utilities to transition from the existing Monday-specific schema to the new generic schema:\n\n```typescript\nexport const migrateMondayRules = mutation({\n  handler: async (ctx) => {\n    // Fetch existing Monday rules\n    const mondayRules = await ctx.db.query('mondayRules').collect();\n    \n    // Convert each rule to the new format and insert\n    for (const rule of mondayRules) {\n      // Conversion logic\n      await ctx.db.insert('rules', {\n        // Mapped fields\n      });\n    }\n    \n    // Mark migration as complete\n    await ctx.db.insert('migrations', {\n      name: 'monday-rules-to-generic',\n      completedAt: Date.now(),\n    });\n  },\n});\n```",
      "testStrategy": "1. Create unit tests for schema validation\n2. Test CRUD operations on the new schema\n3. Verify indexes are working correctly with performance tests\n4. Test migration utilities with sample data\n5. Ensure backward compatibility with existing data\n6. Verify that integration-specific metadata is properly stored and retrieved\n7. Test query performance for common rule management operations",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Refactor Monday Rules Engine",
      "description": "Adapt the existing Monday-specific rules engine to use the new abstract framework while preserving all existing functionality.",
      "details": "1. Create a Monday integration plugin that implements the IntegrationPlugin interface:\n\n```typescript\nclass MondayIntegrationPlugin implements IntegrationPlugin {\n  getDefinition(): IntegrationDefinition {\n    return {\n      id: 'monday',\n      name: 'Monday.com',\n      description: 'Integration with Monday.com boards and items',\n      version: '1.0.0',\n      triggers: this.getTriggerDefinitions(),\n      conditions: this.getConditionDefinitions(),\n      actions: this.getActionDefinitions(),\n    };\n  }\n  \n  private getTriggerDefinitions(): TriggerDefinition[] {\n    return [\n      {\n        type: 'item_created',\n        name: 'Item Created',\n        description: 'Triggered when a new item is created in a board',\n        configSchema: {\n          type: 'object',\n          properties: {\n            boardId: { type: 'string', title: 'Board ID' },\n          },\n          required: ['boardId'],\n        },\n        factory: (config) => new MondayItemCreatedTrigger(config),\n      },\n      // Define other Monday triggers (item_updated, status_changed, etc.)\n    ];\n  }\n  \n  // Similar methods for conditions and actions\n  \n  async initialize(): Promise<void> {\n    // Set up any necessary Monday API connections or listeners\n  }\n}\n```\n\n2. Implement Monday-specific triggers that extend the abstract framework:\n\n```typescript\nclass MondayItemCreatedTrigger implements Trigger {\n  type = 'item_created';\n  \n  constructor(private config: { boardId: string }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData } = context;\n    \n    // Check if the event is for the configured board\n    if (triggerData.boardId !== this.config.boardId) {\n      return false;\n    }\n    \n    // Verify this is an item creation event\n    return triggerData.event === 'create_item';\n  }\n}\n\n// Implement other Monday triggers similarly\n```\n\n3. Implement Monday-specific conditions:\n\n```typescript\nclass MondayColumnValueCondition implements Condition {\n  type = 'column_value';\n  \n  constructor(private config: { \n    columnId: string;\n    operator: 'equals' | 'contains' | 'greater_than' | 'less_than';\n    value: any;\n  }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData } = context;\n    const itemId = triggerData.itemId;\n    const columnValue = await getMondayColumnValue(itemId, this.config.columnId);\n    \n    switch (this.config.operator) {\n      case 'equals':\n        return columnValue === this.config.value;\n      case 'contains':\n        return String(columnValue).includes(String(this.config.value));\n      // Other operators\n    }\n  }\n}\n```\n\n4. Implement Monday-specific actions:\n\n```typescript\nclass MondayUpdateColumnAction implements Action {\n  type = 'update_column';\n  \n  constructor(private config: {\n    columnId: string;\n    value: any;\n  }) {}\n  \n  async execute(context: RuleExecutionContext): Promise<ActionResult> {\n    try {\n      const { triggerData } = context;\n      const itemId = triggerData.itemId;\n      \n      await updateMondayColumnValue(itemId, this.config.columnId, this.config.value);\n      \n      return {\n        success: true,\n        message: `Updated column ${this.config.columnId} to ${this.config.value}`,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: `Failed to update column: ${error.message}`,\n      };\n    }\n  }\n}\n```\n\n5. Create a migration function to convert existing Monday rules to the new format:\n\n```typescript\nasync function migrateMondayRule(oldRule: OldMondayRule): Promise<Rule> {\n  // Map old trigger to new format\n  const triggerType = mapOldTriggerType(oldRule.triggerType);\n  const triggerConfig = mapOldTriggerConfig(oldRule.triggerConfig);\n  \n  // Map old conditions to new format\n  const conditions = oldRule.conditions.map(oldCondition => ({\n    type: mapOldConditionType(oldCondition.type),\n    config: mapOldConditionConfig(oldCondition),\n  }));\n  \n  // Map old actions to new format\n  const actions = oldRule.actions.map(oldAction => ({\n    type: mapOldActionType(oldAction.type),\n    config: mapOldActionConfig(oldAction),\n  }));\n  \n  return {\n    id: oldRule.id,\n    name: oldRule.name,\n    description: oldRule.description,\n    enabled: oldRule.enabled,\n    integrationId: 'monday',\n    triggerType,\n    triggerConfig,\n    conditions,\n    actions,\n    metadata: {\n      originalMondayRuleId: oldRule.id,\n      // Any other Monday-specific metadata\n    },\n  };\n}\n```\n\n6. Implement a Monday-specific rule execution context factory:\n\n```typescript\nclass MondayRuleContextFactory {\n  createContext(rule: Rule, triggerData: any): RuleExecutionContext {\n    // Fetch any additional Monday-specific data needed for rule execution\n    const mondayIntegrationData = {\n      // Monday API client, authentication, etc.\n    };\n    \n    return {\n      rule,\n      triggerData,\n      integrationData: mondayIntegrationData,\n      timestamp: new Date(),\n      logger: new RuleExecutionLogger(rule.id),\n    };\n  }\n}\n```",
      "testStrategy": "1. Create unit tests for each Monday-specific trigger, condition, and action\n2. Test the migration function with various existing rule configurations\n3. Verify that refactored rules produce the same results as the original rules\n4. Create integration tests that simulate Monday webhooks and verify rule execution\n5. Test error handling and edge cases specific to Monday integration\n6. Verify performance is maintained or improved compared to the original implementation\n7. Create regression tests to ensure no functionality is lost during refactoring",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Create Generic Rule Management UI Components",
      "description": "Develop reusable React components for rule management that can work with any integration type, providing a consistent user experience.",
      "details": "1. Create a generic rule editor component:\n\n```tsx\ninterface RuleEditorProps {\n  rule?: Rule; // Existing rule for editing, undefined for new rule\n  integrationId: string;\n  onSave: (rule: Rule) => Promise<void>;\n  onCancel: () => void;\n}\n\nconst RuleEditor: React.FC<RuleEditorProps> = ({ rule, integrationId, onSave, onCancel }) => {\n  const [name, setName] = useState(rule?.name || '');\n  const [description, setDescription] = useState(rule?.description || '');\n  const [triggerType, setTriggerType] = useState(rule?.triggerType || '');\n  const [triggerConfig, setTriggerConfig] = useState(rule?.triggerConfig || {});\n  const [conditions, setConditions] = useState(rule?.conditions || []);\n  const [actions, setActions] = useState(rule?.actions || []);\n  \n  // Fetch available triggers, conditions, and actions for the integration\n  const { data: availableTriggers } = useQuery(api.rules.getAvailableTriggers, { integrationId });\n  const { data: availableConditions } = useQuery(api.rules.getAvailableConditions, { integrationId });\n  const { data: availableActions } = useQuery(api.rules.getAvailableActions, { integrationId });\n  \n  const handleSave = async () => {\n    const newRule: Rule = {\n      id: rule?.id || '', // ID will be assigned by the backend for new rules\n      name,\n      description,\n      enabled: rule?.enabled ?? true,\n      integrationId,\n      triggerType,\n      triggerConfig,\n      conditions,\n      actions,\n      metadata: rule?.metadata || {},\n    };\n    \n    await onSave(newRule);\n  };\n  \n  return (\n    <div className=\"rule-editor\">\n      <h2>{rule ? 'Edit Rule' : 'Create Rule'}</h2>\n      \n      <div className=\"form-group\">\n        <label>Name</label>\n        <input \n          type=\"text\" \n          value={name} \n          onChange={(e) => setName(e.target.value)} \n          required \n        />\n      </div>\n      \n      <div className=\"form-group\">\n        <label>Description</label>\n        <textarea \n          value={description} \n          onChange={(e) => setDescription(e.target.value)} \n        />\n      </div>\n      \n      <TriggerSelector \n        availableTriggers={availableTriggers || []} \n        selectedType={triggerType}\n        config={triggerConfig}\n        onSelectTrigger={setTriggerType}\n        onConfigChange={setTriggerConfig}\n      />\n      \n      <ConditionBuilder \n        availableConditions={availableConditions || []} \n        conditions={conditions}\n        onChange={setConditions}\n      />\n      \n      <ActionBuilder \n        availableActions={availableActions || []} \n        actions={actions}\n        onChange={setActions}\n      />\n      \n      <div className=\"button-group\">\n        <button onClick={onCancel}>Cancel</button>\n        <button onClick={handleSave} disabled={!name || !triggerType || actions.length === 0}>\n          Save Rule\n        </button>\n      </div>\n    </div>\n  );\n};\n```\n\n2. Create a dynamic configuration form component that adapts to different schemas:\n\n```tsx\ninterface ConfigFormProps {\n  schema: JSONSchema7; // JSON Schema for the configuration\n  value: any;\n  onChange: (value: any) => void;\n}\n\nconst ConfigForm: React.FC<ConfigFormProps> = ({ schema, value, onChange }) => {\n  // Use a library like @rjsf/core for dynamic form generation based on JSON Schema\n  return (\n    <Form\n      schema={schema}\n      formData={value}\n      onChange={({ formData }) => onChange(formData)}\n      uiSchema={{\n        // Custom UI configuration\n      }}\n    />\n  );\n};\n```\n\n3. Create a rule list component:\n\n```tsx\ninterface RuleListProps {\n  integrationId: string;\n  onEditRule: (rule: Rule) => void;\n  onDeleteRule: (ruleId: string) => Promise<void>;\n  onToggleRule: (ruleId: string, enabled: boolean) => Promise<void>;\n}\n\nconst RuleList: React.FC<RuleListProps> = ({ \n  integrationId, \n  onEditRule, \n  onDeleteRule, \n  onToggleRule \n}) => {\n  const { data: rules, isLoading } = useQuery(api.rules.getRulesByIntegration, { integrationId });\n  \n  if (isLoading) {\n    return <div>Loading rules...</div>;\n  }\n  \n  return (\n    <div className=\"rule-list\">\n      {rules?.map(rule => (\n        <div key={rule.id} className=\"rule-item\">\n          <div className=\"rule-header\">\n            <h3>{rule.name}</h3>\n            <div className=\"rule-controls\">\n              <Switch \n                checked={rule.enabled} \n                onChange={(checked) => onToggleRule(rule.id, checked)} \n              />\n              <button onClick={() => onEditRule(rule)}>Edit</button>\n              <button \n                onClick={() => onDeleteRule(rule.id)}\n                className=\"delete-button\"\n              >\n                Delete\n              </button>\n            </div>\n          </div>\n          <p>{rule.description}</p>\n          <div className=\"rule-summary\">\n            <div className=\"trigger-summary\">\n              <strong>When:</strong> {getTriggerSummary(rule.triggerType, rule.triggerConfig)}\n            </div>\n            {rule.conditions.length > 0 && (\n              <div className=\"conditions-summary\">\n                <strong>If:</strong> {getConditionsSummary(rule.conditions)}\n              </div>\n            )}\n            <div className=\"actions-summary\">\n              <strong>Then:</strong> {getActionsSummary(rule.actions)}\n            </div>\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n4. Create an integration selector component:\n\n```tsx\ninterface IntegrationSelectorProps {\n  onSelectIntegration: (integrationId: string) => void;\n  selectedIntegrationId?: string;\n}\n\nconst IntegrationSelector: React.FC<IntegrationSelectorProps> = ({ \n  onSelectIntegration, \n  selectedIntegrationId \n}) => {\n  const { data: integrations, isLoading } = useQuery(api.integrations.getAllIntegrations);\n  \n  if (isLoading) {\n    return <div>Loading integrations...</div>;\n  }\n  \n  return (\n    <div className=\"integration-selector\">\n      <h2>Select Integration</h2>\n      <div className=\"integration-list\">\n        {integrations?.map(integration => (\n          <div \n            key={integration.id} \n            className={`integration-item ${selectedIntegrationId === integration.id ? 'selected' : ''}`}\n            onClick={() => onSelectIntegration(integration.id)}\n          >\n            <h3>{integration.name}</h3>\n            <p>{integration.description}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n5. Create a rule execution history component:\n\n```tsx\ninterface RuleExecutionHistoryProps {\n  ruleId: string;\n}\n\nconst RuleExecutionHistory: React.FC<RuleExecutionHistoryProps> = ({ ruleId }) => {\n  const { data: executions, isLoading } = useQuery(api.rules.getRuleExecutions, { \n    ruleId, \n    limit: 10 \n  });\n  \n  if (isLoading) {\n    return <div>Loading execution history...</div>;\n  }\n  \n  return (\n    <div className=\"execution-history\">\n      <h3>Recent Executions</h3>\n      <table>\n        <thead>\n          <tr>\n            <th>Time</th>\n            <th>Triggered</th>\n            <th>Conditions Met</th>\n            <th>Actions Successful</th>\n            <th>Duration</th>\n            <th>Details</th>\n          </tr>\n        </thead>\n        <tbody>\n          {executions?.map(execution => (\n            <tr key={execution._id}>\n              <td>{new Date(execution.startTime).toLocaleString()}</td>\n              <td>{execution.triggered ? '✅' : '❌'}</td>\n              <td>{execution.conditionsMet ? '✅' : '❌'}</td>\n              <td>{execution.successful ? '✅' : '❌'}</td>\n              <td>{((execution.endTime - execution.startTime) / 1000).toFixed(2)}s</td>\n              <td>\n                <button onClick={() => /* Show details modal */}>View Details</button>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n```",
      "testStrategy": "1. Create unit tests for each UI component using React Testing Library\n2. Test form validation for rule configuration\n3. Test dynamic rendering of different integration-specific forms\n4. Create mock API responses for testing UI components\n5. Test UI state management and user interactions\n6. Verify accessibility compliance\n7. Test responsive design for different screen sizes\n8. Create integration tests for the complete rule management flow",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Update Monday Rule UI",
      "description": "Adapt the existing Monday rule management UI to use the new generic components while maintaining the same user experience and functionality.",
      "details": "1. Create a Monday-specific rule management page that uses the generic components:\n\n```tsx\nconst MondayRulesPage: React.FC = () => {\n  const [editingRule, setEditingRule] = useState<Rule | undefined>();\n  const [isCreating, setIsCreating] = useState(false);\n  \n  const { mutate: saveRule } = useMutation(api.rules.saveRule);\n  const { mutate: deleteRule } = useMutation(api.rules.deleteRule);\n  const { mutate: toggleRule } = useMutation(api.rules.toggleRule);\n  \n  const handleSaveRule = async (rule: Rule) => {\n    await saveRule({ rule });\n    setEditingRule(undefined);\n    setIsCreating(false);\n  };\n  \n  const handleDeleteRule = async (ruleId: string) => {\n    if (confirm('Are you sure you want to delete this rule?')) {\n      await deleteRule({ ruleId });\n    }\n  };\n  \n  const handleToggleRule = async (ruleId: string, enabled: boolean) => {\n    await toggleRule({ ruleId, enabled });\n  };\n  \n  return (\n    <div className=\"monday-rules-page\">\n      <header>\n        <h1>Monday.com Automation Rules</h1>\n        <button onClick={() => setIsCreating(true)}>Create New Rule</button>\n      </header>\n      \n      {(isCreating || editingRule) ? (\n        <RuleEditor\n          rule={editingRule}\n          integrationId=\"monday\"\n          onSave={handleSaveRule}\n          onCancel={() => {\n            setEditingRule(undefined);\n            setIsCreating(false);\n          }}\n        />\n      ) : (\n        <RuleList\n          integrationId=\"monday\"\n          onEditRule={setEditingRule}\n          onDeleteRule={handleDeleteRule}\n          onToggleRule={handleToggleRule}\n        />\n      )}\n      \n      {/* Monday-specific help content */}\n      <div className=\"monday-help-section\">\n        <h2>Monday.com Automation Help</h2>\n        <p>Rules allow you to automate actions in your Monday.com boards based on triggers and conditions.</p>\n        <h3>Available Triggers</h3>\n        <ul>\n          <li><strong>Item Created</strong> - Triggered when a new item is added to a board</li>\n          <li><strong>Status Changed</strong> - Triggered when an item's status column changes</li>\n          {/* Other Monday-specific triggers */}\n        </ul>\n        {/* More help content */}\n      </div>\n    </div>\n  );\n};\n```\n\n2. Create Monday-specific rule templates:\n\n```tsx\nconst MondayRuleTemplates: React.FC<{ onSelectTemplate: (template: Rule) => void }> = ({ \n  onSelectTemplate \n}) => {\n  const templates = [\n    {\n      name: 'Status Update Notification',\n      description: 'Send a notification when an item status changes to a specific value',\n      template: {\n        name: 'Status Update Notification',\n        description: 'Send a notification when an item status changes',\n        integrationId: 'monday',\n        triggerType: 'status_changed',\n        triggerConfig: {\n          boardId: '', // To be filled by user\n        },\n        conditions: [\n          {\n            type: 'status_equals',\n            config: {\n              value: 'Done',\n            },\n          },\n        ],\n        actions: [\n          {\n            type: 'send_notification',\n            config: {\n              message: 'Item {{item.name}} is now Done',\n              userIds: [],\n            },\n          },\n        ],\n      },\n    },\n    // Other templates\n  ];\n  \n  return (\n    <div className=\"rule-templates\">\n      <h2>Rule Templates</h2>\n      <div className=\"template-list\">\n        {templates.map((template, index) => (\n          <div key={index} className=\"template-item\" onClick={() => onSelectTemplate(template.template)}>\n            <h3>{template.name}</h3>\n            <p>{template.description}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n3. Create Monday-specific form helpers for rule configuration:\n\n```tsx\nconst MondayBoardSelector: React.FC<{\n  value: string;\n  onChange: (boardId: string) => void;\n}> = ({ value, onChange }) => {\n  const { data: boards, isLoading } = useQuery(api.monday.getBoards);\n  \n  if (isLoading) {\n    return <div>Loading boards...</div>;\n  }\n  \n  return (\n    <select value={value} onChange={(e) => onChange(e.target.value)}>\n      <option value=\"\">Select a board</option>\n      {boards?.map(board => (\n        <option key={board.id} value={board.id}>{board.name}</option>\n      ))}\n    </select>\n  );\n};\n\nconst MondayColumnSelector: React.FC<{\n  boardId: string;\n  value: string;\n  onChange: (columnId: string) => void;\n}> = ({ boardId, value, onChange }) => {\n  const { data: columns, isLoading } = useQuery(api.monday.getBoardColumns, { boardId });\n  \n  if (!boardId) {\n    return <div>Please select a board first</div>;\n  }\n  \n  if (isLoading) {\n    return <div>Loading columns...</div>;\n  }\n  \n  return (\n    <select value={value} onChange={(e) => onChange(e.target.value)}>\n      <option value=\"\">Select a column</option>\n      {columns?.map(column => (\n        <option key={column.id} value={column.id}>{column.title}</option>\n      ))}\n    </select>\n  );\n};\n```\n\n4. Create a Monday-specific rule summary component:\n\n```tsx\nconst MondayRuleSummary: React.FC<{ rule: Rule }> = ({ rule }) => {\n  // Get human-readable descriptions of Monday-specific rule components\n  const triggerDescription = getMondayTriggerDescription(rule.triggerType, rule.triggerConfig);\n  const conditionsDescription = getMondayConditionsDescription(rule.conditions);\n  const actionsDescription = getMondayActionsDescription(rule.actions);\n  \n  return (\n    <div className=\"rule-summary\">\n      <div className=\"trigger-summary\">\n        <strong>When:</strong> {triggerDescription}\n      </div>\n      {rule.conditions.length > 0 && (\n        <div className=\"conditions-summary\">\n          <strong>If:</strong> {conditionsDescription}\n        </div>\n      )}\n      <div className=\"actions-summary\">\n        <strong>Then:</strong> {actionsDescription}\n      </div>\n    </div>\n  );\n};\n\n// Helper functions to generate human-readable descriptions\nfunction getMondayTriggerDescription(type: string, config: any): string {\n  switch (type) {\n    case 'item_created':\n      return `A new item is created in board \"${getBoardName(config.boardId)}\"`;\n    case 'status_changed':\n      return `An item's status changes in board \"${getBoardName(config.boardId)}\"`;\n    // Other trigger types\n    default:\n      return 'Unknown trigger';\n  }\n}\n\n// Similar functions for conditions and actions\n```\n\n5. Create a navigation component that integrates with the existing Monday UI:\n\n```tsx\nconst MondayNavigation: React.FC<{ currentPage: string }> = ({ currentPage }) => {\n  return (\n    <nav className=\"monday-navigation\">\n      <ul>\n        <li className={currentPage === 'dashboard' ? 'active' : ''}>\n          <Link href=\"/monday/dashboard\">Dashboard</Link>\n        </li>\n        <li className={currentPage === 'boards' ? 'active' : ''}>\n          <Link href=\"/monday/boards\">Boards</Link>\n        </li>\n        <li className={currentPage === 'rules' ? 'active' : ''}>\n          <Link href=\"/monday/rules\">Automation Rules</Link>\n        </li>\n        <li className={currentPage === 'settings' ? 'active' : ''}>\n          <Link href=\"/monday/settings\">Settings</Link>\n        </li>\n      </ul>\n    </nav>\n  );\n};\n```",
      "testStrategy": "1. Create unit tests for Monday-specific UI components\n2. Test integration with the generic rule management components\n3. Verify that all existing Monday rule functionality is preserved\n4. Test the rule templates and form helpers\n5. Create user flow tests for common Monday rule management scenarios\n6. Test error handling and edge cases\n7. Verify that the UI matches the existing Monday integration design\n8. Conduct usability testing with existing Monday integration users",
      "priority": "medium",
      "dependencies": [
        4,
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Rule Execution Engine",
      "description": "Create the core rule execution engine that processes rules based on triggers, evaluates conditions, and executes actions across different integration types.",
      "details": "1. Implement the core rule execution engine:\n\n```typescript\nclass RuleExecutionEngine {\n  constructor(\n    private registry: RuleEngineRegistry,\n    private db: ConvexClient,\n    private logger: Logger\n  ) {}\n  \n  async processTrigger(integrationId: string, triggerType: string, triggerData: any): Promise<void> {\n    // Find all rules that match this trigger type and integration\n    const rules = await this.db.query('rules')\n      .withIndex('by_integration', q => q.eq('integrationId', integrationId))\n      .filter(q => q.eq(q.field('triggerType'), triggerType) && q.eq(q.field('enabled'), true))\n      .collect();\n    \n    this.logger.info(`Processing ${rules.length} rules for trigger ${triggerType} in integration ${integrationId}`);\n    \n    // Process each matching rule\n    for (const rule of rules) {\n      await this.executeRule(rule, triggerData);\n    }\n  }\n  \n  async executeRule(rule: Rule, triggerData: any): Promise<RuleExecutionResult> {\n    const executionId = await this.db.insert('ruleExecutions', {\n      ruleId: rule.id,\n      integrationId: rule.integrationId,\n      triggered: false, // Will update this later\n      conditionsMet: false, // Will update this later\n      successful: false, // Will update this later\n      startTime: Date.now(),\n      endTime: 0, // Will update this later\n      triggerData,\n    });\n    \n    const logger = new RuleExecutionLogger(executionId, this.db);\n    \n    try {\n      // Create execution context\n      const context = await this.createExecutionContext(rule, triggerData, logger);\n      \n      // Evaluate trigger\n      logger.info('Evaluating trigger', { triggerType: rule.triggerType });\n      const triggerFactory = this.registry.getTrigger(rule.integrationId, rule.triggerType);\n      if (!triggerFactory) {\n        throw new Error(`Trigger type ${rule.triggerType} not found for integration ${rule.integrationId}`);\n      }\n      \n      const trigger = triggerFactory(rule.triggerConfig);\n      const triggered = await trigger.evaluate(context);\n      \n      await this.db.patch(executionId, { triggered });\n      \n      if (!triggered) {\n        logger.info('Trigger conditions not met, skipping rule execution');\n        await this.db.patch(executionId, { \n          endTime: Date.now(),\n        });\n        return { success: true, triggered: false };\n      }\n      \n      // Evaluate conditions\n      logger.info('Evaluating conditions', { conditionCount: rule.conditions.length });\n      let conditionsMet = true;\n      \n      for (const condition of rule.conditions) {\n        const conditionFactory = this.registry.getCondition(rule.integrationId, condition.type);\n        if (!conditionFactory) {\n          throw new Error(`Condition type ${condition.type} not found for integration ${rule.integrationId}`);\n        }\n        \n        const conditionInstance = conditionFactory(condition.config);\n        const result = await conditionInstance.evaluate(context);\n        \n        logger.info('Condition evaluation result', { \n          conditionType: condition.type, \n          result \n        });\n        \n        if (!result) {\n          conditionsMet = false;\n          break;\n        }\n      }\n      \n      await this.db.patch(executionId, { conditionsMet });\n      \n      if (!conditionsMet) {\n        logger.info('Conditions not met, skipping actions');\n        await this.db.patch(executionId, { \n          endTime: Date.now(),\n        });\n        return { success: true, triggered: true, conditionsMet: false };\n      }\n      \n      // Execute actions\n      logger.info('Executing actions', { actionCount: rule.actions.length });\n      const actionResults = [];\n      let allActionsSuccessful = true;\n      \n      for (const action of rule.actions) {\n        const actionFactory = this.registry.getAction(rule.integrationId, action.type);\n        if (!actionFactory) {\n          throw new Error(`Action type ${action.type} not found for integration ${rule.integrationId}`);\n        }\n        \n        const actionInstance = actionFactory(action.config);\n        \n        try {\n          logger.info('Executing action', { actionType: action.type });\n          const result = await actionInstance.execute(context);\n          actionResults.push(result);\n          \n          if (!result.success) {\n            allActionsSuccessful = false;\n            logger.error('Action execution failed', { \n              actionType: action.type, \n              error: result.message \n            });\n          }\n        } catch (error) {\n          allActionsSuccessful = false;\n          logger.error('Action execution threw an exception', { \n            actionType: action.type, \n            error: error.message \n          });\n          actionResults.push({\n            success: false,\n            message: error.message,\n          });\n        }\n      }\n      \n      // Update execution record\n      await this.db.patch(executionId, {\n        successful: allActionsSuccessful,\n        endTime: Date.now(),\n        resultData: { actionResults },\n      });\n      \n      return {\n        success: true,\n        triggered: true,\n        conditionsMet: true,\n        actionsExecuted: true,\n        allActionsSuccessful,\n        actionResults,\n      };\n    } catch (error) {\n      logger.error('Rule execution failed', { error: error.message });\n      \n      // Update execution record with error\n      await this.db.patch(executionId, {\n        successful: false,\n        endTime: Date.now(),\n        error: error.message,\n      });\n      \n      return {\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n  \n  private async createExecutionContext(rule: Rule, triggerData: any, logger: RuleExecutionLogger): Promise<RuleExecutionContext> {\n    // Get integration-specific data needed for rule execution\n    const integrationData = await this.getIntegrationData(rule.integrationId);\n    \n    return {\n      rule,\n      triggerData,\n      integrationData,\n      timestamp: new Date(),\n      logger,\n    };\n  }\n  \n  private async getIntegrationData(integrationId: string): Promise<any> {\n    // Fetch integration-specific configuration and clients\n    const integration = await this.db.query('integrations')\n      .filter(q => q.eq(q.field('id'), integrationId))\n      .first();\n    \n    if (!integration) {\n      throw new Error(`Integration ${integrationId} not found`);\n    }\n    \n    // Create integration-specific clients and data\n    switch (integrationId) {\n      case 'monday':\n        return {\n          // Monday-specific data and clients\n        };\n      // Other integration types\n      default:\n        return {};\n    }\n  }\n}\n```\n\n2. Create a rule execution logger:\n\n```typescript\nclass RuleExecutionLogger implements RuleLogger {\n  private timers: Map<string, number> = new Map();\n  \n  constructor(\n    private executionId: string,\n    private db: ConvexClient\n  ) {}\n  \n  async info(message: string, data?: any): Promise<void> {\n    await this.log('info', message, data);\n  }\n  \n  async warn(message: string, data?: any): Promise<void> {\n    await this.log('warn', message, data);\n  }\n  \n  async error(message: string, error: Error | string, data?: any): Promise<void> {\n    const errorMessage = typeof error === 'string' ? error : error.message;\n    const errorStack = typeof error === 'string' ? undefined : error.stack;\n    \n    await this.log('error', message, {\n      ...data,\n      error: errorMessage,\n      stack: errorStack,\n    });\n  }\n  \n  startTimer(label: string): void {\n    this.timers.set(label, Date.now());\n  }\n  \n  endTimer(label: string): number {\n    const startTime = this.timers.get(label);\n    if (!startTime) {\n      return 0;\n    }\n    \n    const duration = Date.now() - startTime;\n    this.timers.delete(label);\n    return duration;\n  }\n  \n  private async log(level: string, message: string, data?: any): Promise<void> {\n    await this.db.insert('ruleExecutionLogs', {\n      executionId: this.executionId,\n      timestamp: Date.now(),\n      level,\n      message,\n      data,\n      component: data?.component || 'engine',\n      componentId: data?.componentId,\n    });\n  }\n}\n```\n\n3. Create Convex API endpoints for rule execution:\n\n```typescript\n// Convex function to process a trigger event\nexport const processTrigger = mutation({\n  args: {\n    integrationId: v.string(),\n    triggerType: v.string(),\n    triggerData: v.any(),\n  },\n  handler: async (ctx, args) => {\n    const { integrationId, triggerType, triggerData } = args;\n    \n    // Create rule engine instance\n    const registry = await getRuleEngineRegistry(ctx);\n    const engine = new RuleExecutionEngine(registry, ctx.db, ctx.logger);\n    \n    // Process the trigger\n    await engine.processTrigger(integrationId, triggerType, triggerData);\n    \n    return { success: true };\n  },\n});\n\n// Convex function to manually execute a rule\nexport const executeRule = mutation({\n  args: {\n    ruleId: v.string(),\n    triggerData: v.optional(v.any()),\n  },\n  handler: async (ctx, args) => {\n    const { ruleId, triggerData = {} } = args;\n    \n    // Get the rule\n    const rule = await ctx.db.get(ruleId);\n    if (!rule) {\n      throw new Error(`Rule ${ruleId} not found`);\n    }\n    \n    // Create rule engine instance\n    const registry = await getRuleEngineRegistry(ctx);\n    const engine = new RuleExecutionEngine(registry, ctx.db, ctx.logger);\n    \n    // Execute the rule\n    return await engine.executeRule(rule, triggerData);\n  },\n});\n\n// Helper function to get the rule engine registry\nasync function getRuleEngineRegistry(ctx: any): Promise<RuleEngineRegistry> {\n  // Create and initialize the registry\n  const registry = new RuleEngineRegistry();\n  \n  // Get all registered integrations\n  const integrations = await ctx.db.query('integrations')\n    .filter(q => q.eq(q.field('enabled'), true))\n    .collect();\n  \n  // Register each integration's components\n  for (const integration of integrations) {\n    await registerIntegrationComponents(registry, integration);\n  }\n  \n  return registry;\n}\n\n// Helper function to register an integration's components\nasync function registerIntegrationComponents(registry: RuleEngineRegistry, integration: any): Promise<void> {\n  registry.registerIntegration(integration.id);\n  \n  // Register integration-specific components based on integration type\n  switch (integration.id) {\n    case 'monday':\n      registerMondayComponents(registry);\n      break;\n    // Other integration types\n  }\n}\n```\n\n4. Create a webhook handler for receiving integration events:\n\n```typescript\n// Convex HTTP action to handle webhooks\nexport const handleWebhook = httpAction(async (ctx, request) => {\n  const url = new URL(request.url);\n  const integrationId = url.pathname.split('/').pop(); // Extract integration ID from URL\n  \n  if (!integrationId) {\n    return new Response('Missing integration ID', { status: 400 });\n  }\n  \n  try {\n    // Parse webhook payload\n    const payload = await request.json();\n    \n    // Determine trigger type based on integration and payload\n    const triggerType = determineTriggerType(integrationId, payload);\n    if (!triggerType) {\n      return new Response('Unknown event type', { status: 400 });\n    }\n    \n    // Process the trigger asynchronously\n    await ctx.runMutation(api.rules.processTrigger, {\n      integrationId,\n      triggerType,\n      triggerData: payload,\n    });\n    \n    return new Response('Webhook processed successfully', { status: 200 });\n  } catch (error) {\n    ctx.logger.error('Error processing webhook', { error, integrationId });\n    return new Response(`Error: ${error.message}`, { status: 500 });\n  }\n});\n\n// Helper function to determine trigger type from webhook payload\nfunction determineTriggerType(integrationId: string, payload: any): string | null {\n  switch (integrationId) {\n    case 'monday':\n      return determineMondayTriggerType(payload);\n    // Other integration types\n    default:\n      return null;\n  }\n}\n\n// Helper function for Monday-specific trigger type determination\nfunction determineMondayTriggerType(payload: any): string | null {\n  const event = payload.event;\n  const type = payload.type;\n  \n  if (type === 'create_item') {\n    return 'item_created';\n  } else if (type === 'change_column_value' && payload.columnId === 'status') {\n    return 'status_changed';\n  } else if (type === 'change_column_value') {\n    return 'column_changed';\n  }\n  \n  return null;\n}\n```\n\n5. Create a scheduled job for rule cleanup and maintenance:\n\n```typescript\n// Convex scheduled function to clean up old rule execution logs\nexport const cleanupExecutionLogs = internalAction({\n  handler: async (ctx) => {\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    \n    // Find old execution logs\n    const oldLogs = await ctx.runQuery(api.internal.getOldExecutionLogs, {\n      olderThan: thirtyDaysAgo,\n      limit: 1000, // Process in batches\n    });\n    \n    if (oldLogs.length === 0) {\n      return { deleted: 0 };\n    }\n    \n    // Delete old logs\n    for (const log of oldLogs) {\n      await ctx.runMutation(api.internal.deleteExecutionLog, {\n        id: log._id,\n      });\n    }\n    \n    return { deleted: oldLogs.length };\n  },\n  schedule: 'daily',\n});\n```",
      "testStrategy": "1. Create unit tests for the rule execution engine\n2. Test rule evaluation with various trigger, condition, and action combinations\n3. Test error handling during rule execution\n4. Create integration tests for webhook handling\n5. Test logging and monitoring functionality\n6. Verify performance under load with concurrent rule executions\n7. Test scheduled maintenance jobs\n8. Create end-to-end tests that simulate real integration events",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Create Proof of Concept for Additional Integration",
      "description": "Implement a simple WordPress integration as a proof of concept to demonstrate the modularity and extensibility of the new rules engine framework.",
      "details": "1. Create a WordPress integration plugin:\n\n```typescript\nclass WordPressIntegrationPlugin implements IntegrationPlugin {\n  getDefinition(): IntegrationDefinition {\n    return {\n      id: 'wordpress',\n      name: 'WordPress',\n      description: 'Integration with WordPress sites for post and user management',\n      version: '1.0.0',\n      triggers: this.getTriggerDefinitions(),\n      conditions: this.getConditionDefinitions(),\n      actions: this.getActionDefinitions(),\n    };\n  }\n  \n  private getTriggerDefinitions(): TriggerDefinition[] {\n    return [\n      {\n        type: 'post_published',\n        name: 'Post Published',\n        description: 'Triggered when a new post is published',\n        configSchema: {\n          type: 'object',\n          properties: {\n            postType: { \n              type: 'string', \n              title: 'Post Type',\n              enum: ['post', 'page', 'product', 'any'],\n              default: 'any'\n            },\n          },\n        },\n        factory: (config) => new WordPressPostPublishedTrigger(config),\n      },\n      {\n        type: 'user_registered',\n        name: 'User Registered',\n        description: 'Triggered when a new user registers on the site',\n        configSchema: {\n          type: 'object',\n          properties: {\n            role: { \n              type: 'string', \n              title: 'User Role',\n              enum: ['subscriber', 'contributor', 'author', 'editor', 'administrator', 'any'],\n              default: 'any'\n            },\n          },\n        },\n        factory: (config) => new WordPressUserRegisteredTrigger(config),\n      },\n    ];\n  }\n  \n  private getConditionDefinitions(): ConditionDefinition[] {\n    return [\n      {\n        type: 'post_category',\n        name: 'Post Category',\n        description: 'Check if the post belongs to a specific category',\n        configSchema: {\n          type: 'object',\n          properties: {\n            categoryId: { type: 'string', title: 'Category ID' },\n          },\n          required: ['categoryId'],\n        },\n        factory: (config) => new WordPressPostCategoryCondition(config),\n      },\n      {\n        type: 'post_has_tag',\n        name: 'Post Has Tag',\n        description: 'Check if the post has a specific tag',\n        configSchema: {\n          type: 'object',\n          properties: {\n            tagId: { type: 'string', title: 'Tag ID' },\n          },\n          required: ['tagId'],\n        },\n        factory: (config) => new WordPressPostHasTagCondition(config),\n      },\n    ];\n  }\n  \n  private getActionDefinitions(): ActionDefinition[] {\n    return [\n      {\n        type: 'create_post',\n        name: 'Create Post',\n        description: 'Create a new post in WordPress',\n        configSchema: {\n          type: 'object',\n          properties: {\n            title: { type: 'string', title: 'Post Title' },\n            content: { type: 'string', title: 'Post Content' },\n            postType: { \n              type: 'string', \n              title: 'Post Type',\n              enum: ['post', 'page', 'product'],\n              default: 'post'\n            },\n            status: { \n              type: 'string', \n              title: 'Post Status',\n              enum: ['publish', 'draft', 'pending'],\n              default: 'publish'\n            },\n          },\n          required: ['title', 'content'],\n        },\n        factory: (config) => new WordPressCreatePostAction(config),\n      },\n      {\n        type: 'send_email',\n        name: 'Send Email',\n        description: 'Send an email to specified recipients',\n        configSchema: {\n          type: 'object',\n          properties: {\n            to: { type: 'string', title: 'Recipient Email' },\n            subject: { type: 'string', title: 'Email Subject' },\n            body: { type: 'string', title: 'Email Body' },\n          },\n          required: ['to', 'subject', 'body'],\n        },\n        factory: (config) => new WordPressSendEmailAction(config),\n      },\n    ];\n  }\n  \n  async initialize(): Promise<void> {\n    // Set up WordPress API client and authentication\n  }\n}\n```\n\n2. Implement WordPress-specific triggers:\n\n```typescript\nclass WordPressPostPublishedTrigger implements Trigger {\n  type = 'post_published';\n  \n  constructor(private config: { postType: string }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData } = context;\n    \n    // Check if this is a post publish event\n    if (triggerData.action !== 'publish_post' && triggerData.action !== 'publish_page') {\n      return false;\n    }\n    \n    // If a specific post type is configured, check if it matches\n    if (this.config.postType !== 'any' && triggerData.post_type !== this.config.postType) {\n      return false;\n    }\n    \n    return true;\n  }\n}\n\nclass WordPressUserRegisteredTrigger implements Trigger {\n  type = 'user_registered';\n  \n  constructor(private config: { role: string }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData } = context;\n    \n    // Check if this is a user registration event\n    if (triggerData.action !== 'user_register') {\n      return false;\n    }\n    \n    // If a specific role is configured, check if it matches\n    if (this.config.role !== 'any' && triggerData.user_role !== this.config.role) {\n      return false;\n    }\n    \n    return true;\n  }\n}\n```\n\n3. Implement WordPress-specific conditions:\n\n```typescript\nclass WordPressPostCategoryCondition implements Condition {\n  type = 'post_category';\n  \n  constructor(private config: { categoryId: string }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData, integrationData } = context;\n    const postId = triggerData.post_id;\n    \n    // Get post categories using WordPress API\n    const wpClient = integrationData.wpClient;\n    const categories = await wpClient.getPostCategories(postId);\n    \n    // Check if the specified category is in the list\n    return categories.includes(this.config.categoryId);\n  }\n}\n\nclass WordPressPostHasTagCondition implements Condition {\n  type = 'post_has_tag';\n  \n  constructor(private config: { tagId: string }) {}\n  \n  async evaluate(context: RuleExecutionContext): Promise<boolean> {\n    const { triggerData, integrationData } = context;\n    const postId = triggerData.post_id;\n    \n    // Get post tags using WordPress API\n    const wpClient = integrationData.wpClient;\n    const tags = await wpClient.getPostTags(postId);\n    \n    // Check if the specified tag is in the list\n    return tags.includes(this.config.tagId);\n  }\n}\n```\n\n4. Implement WordPress-specific actions:\n\n```typescript\nclass WordPressCreatePostAction implements Action {\n  type = 'create_post';\n  \n  constructor(private config: {\n    title: string;\n    content: string;\n    postType: string;\n    status: string;\n  }) {}\n  \n  async execute(context: RuleExecutionContext): Promise<ActionResult> {\n    try {\n      const { integrationData } = context;\n      const wpClient = integrationData.wpClient;\n      \n      // Create post using WordPress API\n      const postData = {\n        title: this.config.title,\n        content: this.config.content,\n        status: this.config.status,\n        type: this.config.postType,\n      };\n      \n      const result = await wpClient.createPost(postData);\n      \n      return {\n        success: true,\n        message: `Created ${this.config.postType} with ID ${result.id}`,\n        data: { postId: result.id },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: `Failed to create post: ${error.message}`,\n      };\n    }\n  }\n}\n\nclass WordPressSendEmailAction implements Action {\n  type = 'send_email';\n  \n  constructor(private config: {\n    to: string;\n    subject: string;\n    body: string;\n  }) {}\n  \n  async execute(context: RuleExecutionContext): Promise<ActionResult> {\n    try {\n      const { integrationData } = context;\n      const wpClient = integrationData.wpClient;\n      \n      // Send email using WordPress API\n      await wpClient.sendEmail({\n        to: this.config.to,\n        subject: this.config.subject,\n        body: this.config.body,\n      });\n      \n      return {\n        success: true,\n        message: `Sent email to ${this.config.to}`,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        message: `Failed to send email: ${error.message}`,\n      };\n    }\n  }\n}\n```\n\n5. Create a WordPress API client:\n\n```typescript\nclass WordPressApiClient {\n  constructor(private config: {\n    siteUrl: string;\n    username: string;\n    password: string;\n  }) {}\n  \n  async getPostCategories(postId: string): Promise<string[]> {\n    // Implementation using WordPress REST API\n    const response = await fetch(`${this.config.siteUrl}/wp-json/wp/v2/posts/${postId}?_embed`);\n    const post = await response.json();\n    return post.categories.map(category => category.toString());\n  }\n  \n  async getPostTags(postId: string): Promise<string[]> {\n    // Implementation using WordPress REST API\n    const response = await fetch(`${this.config.siteUrl}/wp-json/wp/v2/posts/${postId}?_embed`);\n    const post = await response.json();\n    return post.tags.map(tag => tag.toString());\n  }\n  \n  async createPost(postData: {\n    title: string;\n    content: string;\n    status: string;\n    type: string;\n  }): Promise<{ id: string }> {\n    // Implementation using WordPress REST API\n    const response = await fetch(`${this.config.siteUrl}/wp-json/wp/v2/posts`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Basic ' + btoa(`${this.config.username}:${this.config.password}`),\n      },\n      body: JSON.stringify({\n        title: postData.title,\n        content: postData.content,\n        status: postData.status,\n      }),\n    });\n    \n    const result = await response.json();\n    return { id: result.id.toString() };\n  }\n  \n  async sendEmail(emailData: {\n    to: string;\n    subject: string;\n    body: string;\n  }): Promise<void> {\n    // Implementation using WordPress API or a plugin like WP Mail SMTP\n    const response = await fetch(`${this.config.siteUrl}/wp-json/custom/v1/send-email`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Basic ' + btoa(`${this.config.username}:${this.config.password}`),\n      },\n      body: JSON.stringify(emailData),\n    });\n    \n    const result = await response.json();\n    if (!result.success) {\n      throw new Error(result.message);\n    }\n  }\n}\n```\n\n6. Create a WordPress webhook handler:\n\n```typescript\n// Convex HTTP action to handle WordPress webhooks\nexport const handleWordPressWebhook = httpAction(async (ctx, request) => {\n  try {\n    // Parse webhook payload\n    const payload = await request.json();\n    \n    // Verify webhook signature if available\n    // ...\n    \n    // Determine trigger type based on WordPress event\n    let triggerType = null;\n    if (payload.action === 'publish_post' || payload.action === 'publish_page') {\n      triggerType = 'post_published';\n    } else if (payload.action === 'user_register') {\n      triggerType = 'user_registered';\n    }\n    \n    if (!triggerType) {\n      return new Response('Unknown event type', { status: 400 });\n    }\n    \n    // Process the trigger\n    await ctx.runMutation(api.rules.processTrigger, {\n      integrationId: 'wordpress',\n      triggerType,\n      triggerData: payload,\n    });\n    \n    return new Response('Webhook processed successfully', { status: 200 });\n  } catch (error) {\n    ctx.logger.error('Error processing WordPress webhook', { error });\n    return new Response(`Error: ${error.message}`, { status: 500 });\n  }\n});\n```\n\n7. Create a WordPress integration configuration UI:\n\n```tsx\nconst WordPressConfigForm: React.FC<{\n  config: any;\n  onSave: (config: any) => Promise<void>;\n}> = ({ config, onSave }) => {\n  const [siteUrl, setSiteUrl] = useState(config?.siteUrl || '');\n  const [username, setUsername] = useState(config?.username || '');\n  const [password, setPassword] = useState('');\n  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null);\n  \n  const handleTestConnection = async () => {\n    try {\n      const result = await testWordPressConnection({\n        siteUrl,\n        username,\n        password,\n      });\n      \n      setTestResult({\n        success: true,\n        message: 'Connection successful!',\n      });\n    } catch (error) {\n      setTestResult({\n        success: false,\n        message: `Connection failed: ${error.message}`,\n      });\n    }\n  };\n  \n  const handleSave = async () => {\n    await onSave({\n      siteUrl,\n      username,\n      password: password ? password : undefined, // Only update password if changed\n    });\n  };\n  \n  return (\n    <div className=\"wordpress-config-form\">\n      <h2>WordPress Configuration</h2>\n      \n      <div className=\"form-group\">\n        <label>Site URL</label>\n        <input \n          type=\"url\" \n          value={siteUrl} \n          onChange={(e) => setSiteUrl(e.target.value)} \n          placeholder=\"https://example.com\"\n          required \n        />\n      </div>\n      \n      <div className=\"form-group\">\n        <label>Username</label>\n        <input \n          type=\"text\" \n          value={username} \n          onChange={(e) => setUsername(e.target.value)} \n          required \n        />\n      </div>\n      \n      <div className=\"form-group\">\n        <label>Password</label>\n        <input \n          type=\"password\" \n          value={password} \n          onChange={(e) => setPassword(e.target.value)} \n          placeholder=\"Leave blank to keep current password\"\n        />\n      </div>\n      \n      <div className=\"button-group\">\n        <button onClick={handleTestConnection}>Test Connection</button>\n        <button onClick={handleSave} disabled={!siteUrl || !username}>Save Configuration</button>\n      </div>\n      \n      {testResult && (\n        <div className={`test-result ${testResult.success ? 'success' : 'error'}`}>\n          {testResult.message}\n        </div>\n      )}\n      \n      <div className=\"webhook-info\">\n        <h3>Webhook Setup</h3>\n        <p>To enable WordPress triggers, add the following webhook URL to your WordPress site:</p>\n        <code>{`${window.location.origin}/api/wordpress/webhook`}</code>\n        <p>You can use a plugin like WP Webhooks to configure these webhooks in WordPress.</p>\n      </div>\n    </div>\n  );\n};\n```",
      "testStrategy": "1. Create unit tests for WordPress-specific triggers, conditions, and actions\n2. Test the WordPress API client with mock responses\n3. Create integration tests with a test WordPress instance\n4. Test webhook handling with sample WordPress events\n5. Verify that WordPress rules can be created and executed through the UI\n6. Test error handling for WordPress API failures\n7. Verify that WordPress integration can coexist with the Monday integration\n8. Create end-to-end tests that simulate WordPress events and verify rule execution",
      "priority": "low",
      "dependencies": [
        1,
        2,
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}