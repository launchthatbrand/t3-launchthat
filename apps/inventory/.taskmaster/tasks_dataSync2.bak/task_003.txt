# Task ID: 3
# Title: Design Generic Rules Schema
# Status: done
# Dependencies: 1, 2
# Priority: high
# Description: Design and implement a new database schema with generic tables for rules, rule executions, and rule logs that can support multiple integration types.
# Details:
1. Define Convex schema for the generic rules system:

```typescript
// Rules table - generic structure for all integration types
export const rules = defineTable({
  id: v.string(),
  name: v.string(),
  description: v.optional(v.string()),
  enabled: v.boolean(),
  integrationId: v.string(), // References the integration type
  triggerType: v.string(),
  triggerConfig: v.any(), // JSON configuration for the trigger
  conditions: v.array(v.object({
    id: v.string(),
    type: v.string(),
    config: v.any(), // JSON configuration for the condition
  })),
  actions: v.array(v.object({
    id: v.string(),
    type: v.string(),
    config: v.any(), // JSON configuration for the action
  })),
  metadata: v.optional(v.any()), // Integration-specific metadata
  createdAt: v.number(),
  updatedAt: v.number(),
});

// Rule executions table - tracks each execution of a rule
export const ruleExecutions = defineTable({
  ruleId: v.string(),
  integrationId: v.string(),
  triggered: v.boolean(), // Whether the trigger condition was met
  conditionsMet: v.boolean(), // Whether all conditions were satisfied
  successful: v.boolean(), // Whether all actions executed successfully
  startTime: v.number(),
  endTime: v.number(),
  triggerData: v.any(), // Data that triggered the rule
  resultData: v.optional(v.any()), // Results of the rule execution
  error: v.optional(v.string()), // Error message if execution failed
});

// Rule execution logs - detailed logs for debugging
export const ruleExecutionLogs = defineTable({
  executionId: v.string(),
  timestamp: v.number(),
  level: v.string(), // 'info', 'warn', 'error'
  message: v.string(),
  data: v.optional(v.any()), // Additional context data
  component: v.string(), // 'trigger', 'condition', 'action'
  componentId: v.optional(v.string()), // ID of the specific component
});
```

2. Create indexes for efficient querying:

```typescript
rules.index('by_integration', ['integrationId']);
ruleExecutions.index('by_rule', ['ruleId']);
ruleExecutions.index('by_integration', ['integrationId']);
ruleExecutionLogs.index('by_execution', ['executionId']);
```

3. Implement Convex functions for rule management:

```typescript
// Create a new rule
export const createRule = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
    integrationId: v.string(),
    triggerType: v.string(),
    triggerConfig: v.any(),
    conditions: v.array(v.object({
      type: v.string(),
      config: v.any(),
    })),
    actions: v.array(v.object({
      type: v.string(),
      config: v.any(),
    })),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    // Implementation
  },
});

// Similar functions for updateRule, deleteRule, enableRule, disableRule
```

4. Create query functions for retrieving rules:

```typescript
// Get rules for a specific integration
export const getRulesByIntegration = query({
  args: { integrationId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query('rules')
      .withIndex('by_integration', q => q.eq('integrationId', args.integrationId))
      .collect();
  },
});

// Get rule execution history
export const getRuleExecutions = query({
  args: { ruleId: v.string(), limit: v.optional(v.number()) },
  handler: async (ctx, args) => {
    // Implementation
  },
});
```

5. Design migration utilities to transition from the existing Monday-specific schema to the new generic schema:

```typescript
export const migrateMondayRules = mutation({
  handler: async (ctx) => {
    // Fetch existing Monday rules
    const mondayRules = await ctx.db.query('mondayRules').collect();
    
    // Convert each rule to the new format and insert
    for (const rule of mondayRules) {
      // Conversion logic
      await ctx.db.insert('rules', {
        // Mapped fields
      });
    }
    
    // Mark migration as complete
    await ctx.db.insert('migrations', {
      name: 'monday-rules-to-generic',
      completedAt: Date.now(),
    });
  },
});
```

# Test Strategy:
1. Create unit tests for schema validation
2. Test CRUD operations on the new schema
3. Verify indexes are working correctly with performance tests
4. Test migration utilities with sample data
5. Ensure backward compatibility with existing data
6. Verify that integration-specific metadata is properly stored and retrieved
7. Test query performance for common rule management operations
